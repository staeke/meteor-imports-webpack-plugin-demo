/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./wp-meteor-client/entry.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build/pkg-only/bundle/programs/web.browser/app/global-imports.js":
/*!**************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/app/global-imports.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/* Imports for global scope */\nMongo = Package.mongo.Mongo;\nReactiveVar = Package['reactive-var'].ReactiveVar;\nTracker = Package.tracker.Tracker;\nDeps = Package.tracker.Deps;\nMeteor = Package.meteor.Meteor;\nglobal = Package.meteor.global;\nmeteorEnv = Package.meteor.meteorEnv;\nWebApp = Package.webapp.WebApp;\nDDP = Package['ddp-client'].DDP;\nLaunchScreen = Package['launch-screen'].LaunchScreen;\nmeteorInstall = Package.modules.meteorInstall;\nmeteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nPromise = Package.promise.Promise;\nAutoupdate = Package.autoupdate.Autoupdate;\nReload = Package.reload.Reload;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/app/global-imports.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/merged-stylesheets.css":
/*!***************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/merged-stylesheets.css ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../../../node_modules/css-loader!./merged-stylesheets.css */ \"./node_modules/css-loader/index.js!./build/pkg-only/bundle/programs/web.browser/merged-stylesheets.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/merged-stylesheets.css?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/allow-deny.js":
/*!***************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/allow-deny.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var LocalCollection = Package.minimongo.LocalCollection;\n  var Minimongo = Package.minimongo.Minimongo;\n  var check = Package.check.check;\n  var Match = Package.check.Match;\n  var EJSON = Package.ejson.EJSON;\n  var DDP = Package['ddp-client'].DDP;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var AllowDeny;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"allow-deny\": {\n          \"allow-deny.js\": function allowDenyJs() {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/allow-deny/allow-deny.js                                                                                  //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            ///\n            /// Remote methods and access control.\n            ///\n            var hasOwn = Object.prototype.hasOwnProperty; // Restrict default mutators on collection. allow() and deny() take the\n            // same options:\n            //\n            // options.insert {Function(userId, doc)}\n            //   return true to allow/deny adding this document\n            //\n            // options.update {Function(userId, docs, fields, modifier)}\n            //   return true to allow/deny updating these documents.\n            //   `fields` is passed as an array of fields that are to be modified\n            //\n            // options.remove {Function(userId, docs)}\n            //   return true to allow/deny removing these documents\n            //\n            // options.fetch {Array}\n            //   Fields to fetch for these validators. If any call to allow or deny\n            //   does not have this option then all fields are loaded.\n            //\n            // allow and deny can be called multiple times. The validators are\n            // evaluated as follows:\n            // - If neither deny() nor allow() has been called on the collection,\n            //   then the request is allowed if and only if the \"insecure\" smart\n            //   package is in use.\n            // - Otherwise, if any deny() function returns true, the request is denied.\n            // - Otherwise, if any allow() function returns true, the request is allowed.\n            // - Otherwise, the request is denied.\n            //\n            // Meteor may call your deny() and allow() functions in any order, and may not\n            // call all of them if it is able to make a decision without calling them all\n            // (so don't include side effects).\n\n            AllowDeny = {\n              CollectionPrototype: {}\n            }; // In the `mongo` package, we will extend Mongo.Collection.prototype with these\n            // methods\n\n            var CollectionPrototype = AllowDeny.CollectionPrototype;\n            /**\n             * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n             * @locus Server\n             * @method allow\n             * @memberOf Mongo.Collection\n             * @instance\n             * @param {Object} options\n             * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n             * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n             * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n             */\n\n            CollectionPrototype.allow = function (options) {\n              addValidator(this, 'allow', options);\n            };\n            /**\n             * @summary Override `allow` rules.\n             * @locus Server\n             * @method deny\n             * @memberOf Mongo.Collection\n             * @instance\n             * @param {Object} options\n             * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n             * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n             * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n             */\n\n\n            CollectionPrototype.deny = function (options) {\n              addValidator(this, 'deny', options);\n            };\n\n            CollectionPrototype._defineMutationMethods = function (options) {\n              var self = this;\n              options = options || {}; // set to true once we call any allow or deny methods. If true, use\n              // allow/deny semantics. If false, use insecure mode semantics.\n\n              self._restricted = false; // Insecure mode (default to allowing writes). Defaults to 'undefined' which\n              // means insecure iff the insecure package is loaded. This property can be\n              // overriden by tests or packages wishing to change insecure mode behavior of\n              // their collections.\n\n              self._insecure = undefined;\n              self._validators = {\n                insert: {\n                  allow: [],\n                  deny: []\n                },\n                update: {\n                  allow: [],\n                  deny: []\n                },\n                remove: {\n                  allow: [],\n                  deny: []\n                },\n                upsert: {\n                  allow: [],\n                  deny: []\n                },\n                // dummy arrays; can't set these!\n                fetch: [],\n                fetchAllFields: false\n              };\n              if (!self._name) return; // anonymous collection\n              // XXX Think about method namespacing. Maybe methods should be\n              // \"Meteor:Mongo:insert/NAME\"?\n\n              self._prefix = '/' + self._name + '/'; // Mutation Methods\n              // Minimongo on the server gets no stubs; instead, by default\n              // it wait()s until its result is ready, yielding.\n              // This matches the behavior of macromongo on the server better.\n              // XXX see #MeteorServerNull\n\n              if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\n                var m = {};\n                ['insert', 'update', 'remove'].forEach(function (method) {\n                  var methodName = self._prefix + method;\n\n                  if (options.useExisting) {\n                    var handlerPropName = Meteor.isClient ? '_methodHandlers' : 'method_handlers'; // Do not try to create additional methods if this has already been called.\n                    // (Otherwise the .methods() call below will throw an error.)\n\n                    if (self._connection[handlerPropName] && typeof self._connection[handlerPropName][methodName] === 'function') return;\n                  }\n\n                  m[methodName] = function ()\n                  /* ... */\n                  {\n                    // All the methods do their own validation, instead of using check().\n                    check(arguments, [Match.Any]);\n                    var args = Array.from(arguments);\n\n                    try {\n                      // For an insert, if the client didn't specify an _id, generate one\n                      // now; because this uses DDP.randomStream, it will be consistent with\n                      // what the client generated. We generate it now rather than later so\n                      // that if (eg) an allow/deny rule does an insert to the same\n                      // collection (not that it really should), the generated _id will\n                      // still be the first use of the stream and will be consistent.\n                      //\n                      // However, we don't actually stick the _id onto the document yet,\n                      // because we want allow/deny rules to be able to differentiate\n                      // between arbitrary client-specified _id fields and merely\n                      // client-controlled-via-randomSeed fields.\n                      var generatedId = null;\n\n                      if (method === \"insert\" && !hasOwn.call(args[0], '_id')) {\n                        generatedId = self._makeNewID();\n                      }\n\n                      if (this.isSimulation) {\n                        // In a client simulation, you can do any mutation (even with a\n                        // complex selector).\n                        if (generatedId !== null) args[0]._id = generatedId;\n                        return self._collection[method].apply(self._collection, args);\n                      } // This is the server receiving a method call from the client.\n                      // We don't allow arbitrary selectors in mutations from the client: only\n                      // single-ID selectors.\n\n\n                      if (method !== 'insert') throwIfSelectorIsNotId(args[0], method);\n\n                      if (self._restricted) {\n                        // short circuit if there is no way it will pass.\n                        if (self._validators[method].allow.length === 0) {\n                          throw new Meteor.Error(403, \"Access denied. No allow validators set on restricted \" + \"collection for method '\" + method + \"'.\");\n                        }\n\n                        var validatedMethodName = '_validated' + method.charAt(0).toUpperCase() + method.slice(1);\n                        args.unshift(this.userId);\n                        method === 'insert' && args.push(generatedId);\n                        return self[validatedMethodName].apply(self, args);\n                      } else if (self._isInsecure()) {\n                        if (generatedId !== null) args[0]._id = generatedId; // In insecure mode, allow any mutation (with a simple selector).\n                        // XXX This is kind of bogus.  Instead of blindly passing whatever\n                        //     we get from the network to this function, we should actually\n                        //     know the correct arguments for the function and pass just\n                        //     them.  For example, if you have an extraneous extra null\n                        //     argument and this is Mongo on the server, the .wrapAsync'd\n                        //     functions like update will get confused and pass the\n                        //     \"fut.resolver()\" in the wrong slot, where _update will never\n                        //     invoke it. Bam, broken DDP connection.  Probably should just\n                        //     take this whole method and write it three times, invoking\n                        //     helpers for the common code.\n\n                        return self._collection[method].apply(self._collection, args);\n                      } else {\n                        // In secure mode, if we haven't called allow or deny, then nothing\n                        // is permitted.\n                        throw new Meteor.Error(403, \"Access denied\");\n                      }\n                    } catch (e) {\n                      if (e.name === 'MongoError' || e.name === 'MinimongoError') {\n                        throw new Meteor.Error(409, e.toString());\n                      } else {\n                        throw e;\n                      }\n                    }\n                  };\n                });\n\n                self._connection.methods(m);\n              }\n            };\n\n            CollectionPrototype._updateFetch = function (fields) {\n              var self = this;\n\n              if (!self._validators.fetchAllFields) {\n                if (fields) {\n                  var union = Object.create(null);\n\n                  var add = function add(names) {\n                    return names && names.forEach(function (name) {\n                      return union[name] = 1;\n                    });\n                  };\n\n                  add(self._validators.fetch);\n                  add(fields);\n                  self._validators.fetch = Object.keys(union);\n                } else {\n                  self._validators.fetchAllFields = true; // clear fetch just to make sure we don't accidentally read it\n\n                  self._validators.fetch = null;\n                }\n              }\n            };\n\n            CollectionPrototype._isInsecure = function () {\n              var self = this;\n              if (self._insecure === undefined) return !!Package.insecure;\n              return self._insecure;\n            };\n\n            CollectionPrototype._validatedInsert = function (userId, doc, generatedId) {\n              var self = this; // call user validators.\n              // Any deny returns true means denied.\n\n              if (self._validators.insert.deny.some(function (validator) {\n                return validator(userId, docToValidate(validator, doc, generatedId));\n              })) {\n                throw new Meteor.Error(403, \"Access denied\");\n              } // Any allow returns true means proceed. Throw error if they all fail.\n\n\n              if (self._validators.insert.allow.every(function (validator) {\n                return !validator(userId, docToValidate(validator, doc, generatedId));\n              })) {\n                throw new Meteor.Error(403, \"Access denied\");\n              } // If we generated an ID above, insert it now: after the validation, but\n              // before actually inserting.\n\n\n              if (generatedId !== null) doc._id = generatedId;\n\n              self._collection.insert.call(self._collection, doc);\n            }; // Simulate a mongo `update` operation while validating that the access\n            // control rules set by calls to `allow/deny` are satisfied. If all\n            // pass, rewrite the mongo operation to use $in to set the list of\n            // document ids to change ##ValidatedChange\n\n\n            CollectionPrototype._validatedUpdate = function (userId, selector, mutator, options) {\n              var self = this;\n              check(mutator, Object);\n              options = Object.assign(Object.create(null), options);\n              if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) throw new Error(\"validated update should be of a single ID\"); // We don't support upserts because they don't fit nicely into allow/deny\n              // rules.\n\n              if (options.upsert) throw new Meteor.Error(403, \"Access denied. Upserts not \" + \"allowed in a restricted collection.\");\n              var noReplaceError = \"Access denied. In a restricted collection you can only\" + \" update documents, not replace them. Use a Mongo update operator, such \" + \"as '$set'.\";\n              var mutatorKeys = Object.keys(mutator); // compute modified fields\n\n              var modifiedFields = {};\n\n              if (mutatorKeys.length === 0) {\n                throw new Meteor.Error(403, noReplaceError);\n              }\n\n              mutatorKeys.forEach(function (op) {\n                var params = mutator[op];\n\n                if (op.charAt(0) !== '$') {\n                  throw new Meteor.Error(403, noReplaceError);\n                } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\n                  throw new Meteor.Error(403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");\n                } else {\n                  Object.keys(params).forEach(function (field) {\n                    // treat dotted fields as if they are replacing their\n                    // top-level part\n                    if (field.indexOf('.') !== -1) field = field.substring(0, field.indexOf('.')); // record the field we are trying to change\n\n                    modifiedFields[field] = true;\n                  });\n                }\n              });\n              var fields = Object.keys(modifiedFields);\n              var findOptions = {\n                transform: null\n              };\n\n              if (!self._validators.fetchAllFields) {\n                findOptions.fields = {};\n\n                self._validators.fetch.forEach(function (fieldName) {\n                  findOptions.fields[fieldName] = 1;\n                });\n              }\n\n              var doc = self._collection.findOne(selector, findOptions);\n\n              if (!doc) // none satisfied!\n                return 0; // call user validators.\n              // Any deny returns true means denied.\n\n              if (self._validators.update.deny.some(function (validator) {\n                var factoriedDoc = transformDoc(validator, doc);\n                return validator(userId, factoriedDoc, fields, mutator);\n              })) {\n                throw new Meteor.Error(403, \"Access denied\");\n              } // Any allow returns true means proceed. Throw error if they all fail.\n\n\n              if (self._validators.update.allow.every(function (validator) {\n                var factoriedDoc = transformDoc(validator, doc);\n                return !validator(userId, factoriedDoc, fields, mutator);\n              })) {\n                throw new Meteor.Error(403, \"Access denied\");\n              }\n\n              options._forbidReplace = true; // Back when we supported arbitrary client-provided selectors, we actually\n              // rewrote the selector to include an _id clause before passing to Mongo to\n              // avoid races, but since selector is guaranteed to already just be an ID, we\n              // don't have to any more.\n\n              return self._collection.update.call(self._collection, selector, mutator, options);\n            }; // Only allow these operations in validated updates. Specifically\n            // whitelist operations, rather than blacklist, so new complex\n            // operations that are added aren't automatically allowed. A complex\n            // operation is one that does more than just modify its target\n            // field. For now this contains all update operations except '$rename'.\n            // http://docs.mongodb.org/manual/reference/operators/#update\n\n\n            var ALLOWED_UPDATE_OPERATIONS = {\n              $inc: 1,\n              $set: 1,\n              $unset: 1,\n              $addToSet: 1,\n              $pop: 1,\n              $pullAll: 1,\n              $pull: 1,\n              $pushAll: 1,\n              $push: 1,\n              $bit: 1\n            }; // Simulate a mongo `remove` operation while validating access control\n            // rules. See #ValidatedChange\n\n            CollectionPrototype._validatedRemove = function (userId, selector) {\n              var self = this;\n              var findOptions = {\n                transform: null\n              };\n\n              if (!self._validators.fetchAllFields) {\n                findOptions.fields = {};\n\n                self._validators.fetch.forEach(function (fieldName) {\n                  findOptions.fields[fieldName] = 1;\n                });\n              }\n\n              var doc = self._collection.findOne(selector, findOptions);\n\n              if (!doc) return 0; // call user validators.\n              // Any deny returns true means denied.\n\n              if (self._validators.remove.deny.some(function (validator) {\n                return validator(userId, transformDoc(validator, doc));\n              })) {\n                throw new Meteor.Error(403, \"Access denied\");\n              } // Any allow returns true means proceed. Throw error if they all fail.\n\n\n              if (self._validators.remove.allow.every(function (validator) {\n                return !validator(userId, transformDoc(validator, doc));\n              })) {\n                throw new Meteor.Error(403, \"Access denied\");\n              } // Back when we supported arbitrary client-provided selectors, we actually\n              // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\n              // Mongo to avoid races, but since selector is guaranteed to already just be\n              // an ID, we don't have to any more.\n\n\n              return self._collection.remove.call(self._collection, selector);\n            };\n\n            CollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\n              if (Meteor.isClient && !callback && !alreadyInSimulation()) {\n                // Client can't block, so it can't report errors by exception,\n                // only by callback. If they forget the callback, give them a\n                // default one that logs the error, so they aren't totally\n                // baffled if their writes don't work because their database is\n                // down.\n                // Don't give a default callback in simulation, because inside stubs we\n                // want to return the results from the local collection immediately and\n                // not force a callback.\n                callback = function callback(err) {\n                  if (err) Meteor._debug(name + \" failed: \" + (err.reason || err.stack));\n                };\n              } // For two out of three mutator methods, the first argument is a selector\n\n\n              var firstArgIsSelector = name === \"update\" || name === \"remove\";\n\n              if (firstArgIsSelector && !alreadyInSimulation()) {\n                // If we're about to actually send an RPC, we should throw an error if\n                // this is a non-ID selector, because the mutation methods only allow\n                // single-ID selectors. (If we don't throw here, we'll see flicker.)\n                throwIfSelectorIsNotId(args[0], name);\n              }\n\n              var mutatorMethodName = this._prefix + name;\n              return this._connection.apply(mutatorMethodName, args, {\n                returnStubValue: true\n              }, callback);\n            };\n\n            function transformDoc(validator, doc) {\n              if (validator.transform) return validator.transform(doc);\n              return doc;\n            }\n\n            function docToValidate(validator, doc, generatedId) {\n              var ret = doc;\n\n              if (validator.transform) {\n                ret = EJSON.clone(doc); // If you set a server-side transform on your collection, then you don't get\n                // to tell the difference between \"client specified the ID\" and \"server\n                // generated the ID\", because transforms expect to get _id.  If you want to\n                // do that check, you can do it with a specific\n                // `C.allow({insert: f, transform: null})` validator.\n\n                if (generatedId !== null) {\n                  ret._id = generatedId;\n                }\n\n                ret = validator.transform(ret);\n              }\n\n              return ret;\n            }\n\n            function addValidator(collection, allowOrDeny, options) {\n              // validate keys\n              var validKeysRegEx = /^(?:insert|update|remove|fetch|transform)$/;\n              Object.keys(options).forEach(function (key) {\n                if (!validKeysRegEx.test(key)) throw new Error(allowOrDeny + \": Invalid key: \" + key);\n              });\n              collection._restricted = true;\n              ['insert', 'update', 'remove'].forEach(function (name) {\n                if (hasOwn.call(options, name)) {\n                  if (!(options[name] instanceof Function)) {\n                    throw new Error(allowOrDeny + \": Value for `\" + name + \"` must be a function\");\n                  } // If the transform is specified at all (including as 'null') in this\n                  // call, then take that; otherwise, take the transform from the\n                  // collection.\n\n\n                  if (options.transform === undefined) {\n                    options[name].transform = collection._transform; // already wrapped\n                  } else {\n                    options[name].transform = LocalCollection.wrapTransform(options.transform);\n                  }\n\n                  collection._validators[name][allowOrDeny].push(options[name]);\n                }\n              }); // Only update the fetch fields if we're passed things that affect\n              // fetching. This way allow({}) and allow({insert: f}) don't result in\n              // setting fetchAllFields\n\n              if (options.update || options.remove || options.fetch) {\n                if (options.fetch && !(options.fetch instanceof Array)) {\n                  throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");\n                }\n\n                collection._updateFetch(options.fetch);\n              }\n            }\n\n            function throwIfSelectorIsNotId(selector, methodName) {\n              if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n                throw new Meteor.Error(403, \"Not permitted. Untrusted code may only \" + methodName + \" documents by ID.\");\n              }\n            }\n\n            ; // Determine if we are in a DDP method simulation\n\n            function alreadyInSimulation() {\n              var CurrentInvocation = DDP._CurrentMethodInvocation || // For backwards compatibility, as explained in this issue:\n              // https://github.com/meteor/meteor/issues/8947\n              DDP._CurrentInvocation;\n              var enclosing = CurrentInvocation.get();\n              return enclosing && enclosing.isSimulation;\n            } ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  require(\"/node_modules/meteor/allow-deny/allow-deny.js\");\n  /* Exports */\n\n\n  Package._define(\"allow-deny\", {\n    AllowDeny: AllowDeny\n  });\n})();\n\nmodule.exports = window.Package[\"allow-deny\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/allow-deny.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/autopublish.js":
/*!****************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/autopublish.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/autopublish.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/autoupdate.js":
/*!***************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/autoupdate.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n  var Retry = Package.retry.Retry;\n  var DDP = Package['ddp-client'].DDP;\n  var Mongo = Package.mongo.Mongo;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var ClientVersions, Autoupdate;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"autoupdate\": {\n          \"autoupdate_client.js\": function autoupdate_clientJs() {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                 //\n            // packages/autoupdate/autoupdate_client.js                                                        //\n            //                                                                                                 //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // Subscribe to the `meteor_autoupdate_clientVersions` collection,\n            // which contains the set of acceptable client versions.\n            //\n            // A \"hard code push\" occurs when the running client version is not in\n            // the set of acceptable client versions (or the server updates the\n            // collection, there is a published client version marked `current` and\n            // the running client version is no longer in the set).\n            //\n            // When the `reload` package is loaded, a hard code push causes\n            // the browser to reload, so that it will load the latest client\n            // version from the server.\n            //\n            // A \"soft code push\" represents the situation when the running client\n            // version is in the set of acceptable versions, but there is a newer\n            // version available on the server.\n            //\n            // `Autoupdate.newClientAvailable` is a reactive data source which\n            // becomes `true` if there is a new version of the client is available on\n            // the server.\n            //\n            // This package doesn't implement a soft code reload process itself,\n            // but `newClientAvailable` could be used for example to display a\n            // \"click to reload\" link to the user.\n            // The client version of the client code currently running in the\n            // browser.\n            var autoupdateVersion = __meteor_runtime_config__.autoupdateVersion || \"unknown\";\n            var autoupdateVersionRefreshable = __meteor_runtime_config__.autoupdateVersionRefreshable || \"unknown\"; // The collection of acceptable client versions.\n\n            ClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\");\n            Autoupdate = {};\n\n            Autoupdate.newClientAvailable = function () {\n              return !!ClientVersions.findOne({\n                _id: \"version\",\n                version: {\n                  $ne: autoupdateVersion\n                }\n              }) || !!ClientVersions.findOne({\n                _id: \"version-refreshable\",\n                version: {\n                  $ne: autoupdateVersionRefreshable\n                }\n              });\n            };\n\n            Autoupdate._ClientVersions = ClientVersions; // Used by a self-test\n\n            var knownToSupportCssOnLoad = false;\n            var retry = new Retry({\n              // Unlike the stream reconnect use of Retry, which we want to be instant\n              // in normal operation, this is a wacky failure. We don't want to retry\n              // right away, we can start slowly.\n              //\n              // A better way than timeconstants here might be to use the knowledge\n              // of when we reconnect to help trigger these retries. Typically, the\n              // server fixing code will result in a restart and reconnect, but\n              // potentially the subscription could have a transient error.\n              minCount: 0,\n              // don't do any immediate retries\n              baseTimeout: 30 * 1000 // start with 30s\n\n            });\n            var failures = 0;\n\n            function after(times, func) {\n              return function () {\n                if (--times < 1) {\n                  return func.apply(this, arguments);\n                }\n              };\n            }\n\n            ;\n\n            Autoupdate._retrySubscription = function () {\n              Meteor.subscribe(\"meteor_autoupdate_clientVersions\", {\n                onError: function onError(error) {\n                  Meteor._debug(\"autoupdate subscription failed\", error);\n\n                  failures++;\n                  retry.retryLater(failures, function () {\n                    // Just retry making the subscription, don't reload the whole\n                    // page. While reloading would catch more cases (for example,\n                    // the server went back a version and is now doing old-style hot\n                    // code push), it would also be more prone to reload loops,\n                    // which look really bad to the user. Just retrying the\n                    // subscription over DDP means it is at least possible to fix by\n                    // updating the server.\n                    Autoupdate._retrySubscription();\n                  });\n                },\n                onReady: function onReady() {\n                  if (Package.reload) {\n                    var checkNewVersionDocument = function checkNewVersionDocument(doc) {\n                      var self = this;\n\n                      if (doc._id === 'version-refreshable' && doc.version !== autoupdateVersionRefreshable) {\n                        var waitUntilCssLoads = function waitUntilCssLoads(link, callback) {\n                          var called;\n\n                          function executeCallback() {\n                            if (!called) {\n                              called = true;\n                              return callback.apply(void 0, arguments);\n                            }\n                          }\n\n                          link.onload = function () {\n                            knownToSupportCssOnLoad = true;\n                            executeCallback();\n                          };\n\n                          if (!knownToSupportCssOnLoad) {\n                            var id = Meteor.setInterval(function () {\n                              if (link.sheet) {\n                                executeCallback();\n                                Meteor.clearInterval(id);\n                              }\n                            }, 50);\n                          }\n                        };\n\n                        autoupdateVersionRefreshable = doc.version; // Switch out old css links for the new css links. Inspired by:\n                        // https://github.com/guard/guard-livereload/blob/master/js/livereload.js#L710\n\n                        var newCss = doc.assets && doc.assets.allCss || [];\n                        var oldLinks = [];\n                        Array.prototype.forEach.call(document.getElementsByTagName('link'), function (link) {\n                          if (link.className === '__meteor-css__') {\n                            oldLinks.push(link);\n                          }\n                        });\n                        var removeOldLinks = after(newCss.length, function () {\n                          oldLinks.forEach(function (link) {\n                            link.parentNode.removeChild(link);\n                          });\n                        });\n\n                        var attachStylesheetLink = function attachStylesheetLink(newLink) {\n                          document.getElementsByTagName(\"head\").item(0).appendChild(newLink);\n                          waitUntilCssLoads(newLink, function () {\n                            Meteor.setTimeout(removeOldLinks, 200);\n                          });\n                        };\n\n                        if (newCss.length !== 0) {\n                          newCss.forEach(function (css) {\n                            var newLink = document.createElement(\"link\");\n                            newLink.setAttribute(\"rel\", \"stylesheet\");\n                            newLink.setAttribute(\"type\", \"text/css\");\n                            newLink.setAttribute(\"class\", \"__meteor-css__\");\n                            newLink.setAttribute(\"href\", css.url);\n                            attachStylesheetLink(newLink);\n                          });\n                        } else {\n                          removeOldLinks();\n                        }\n                      } else if (doc._id === 'version' && doc.version !== autoupdateVersion) {\n                        handle && handle.stop();\n\n                        if (Package.reload) {\n                          Package.reload.Reload._reload();\n                        }\n                      }\n                    };\n\n                    var handle = ClientVersions.find().observe({\n                      added: checkNewVersionDocument,\n                      changed: checkNewVersionDocument\n                    });\n                  }\n                }\n              });\n            };\n\n            Autoupdate._retrySubscription(); /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  require(\"/node_modules/meteor/autoupdate/autoupdate_client.js\");\n  /* Exports */\n\n\n  Package._define(\"autoupdate\", {\n    Autoupdate: Autoupdate\n  });\n})();\n\nmodule.exports = window.Package[\"autoupdate\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/autoupdate.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/babel-compiler.js":
/*!*******************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/babel-compiler.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/babel-compiler.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/babel-runtime.js":
/*!******************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/babel-runtime.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  /* Package-scope variables */\n\n  var meteorBabelHelpers;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"babel-runtime\": {\n          \"babel-runtime.js\": function babelRuntimeJs(require, exports) {\n            /////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                         //\n            // packages/babel-runtime/babel-runtime.js                                                 //\n            //                                                                                         //\n            /////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            exports.meteorBabelHelpers = require(\"meteor-babel-helpers\");\n\n            try {\n              var babelRuntimeVersion = require(\"@babel/runtime/package.json\").version;\n            } catch (e) {\n              throw new Error([\"\", \"The @babel/runtime npm package could not be found in your node_modules \", \"directory. Please run the following command to install it:\", \"\", \"  meteor npm install --save @babel/runtime\", \"\"].join(\"\\n\"));\n            }\n\n            if (parseInt(babelRuntimeVersion, 10) < 6) {\n              throw new Error([\"\", \"The version of @babel/runtime installed in your node_modules directory \", \"(\" + babelRuntimeVersion + \") is out of date. Please upgrade it by running \", \"\", \"  meteor npm install --save @babel/runtime\", \"\", \"in your application directory.\", \"\"].join(\"\\n\"));\n            } else if (parseInt(babelRuntimeVersion.split(\".\").shift()) >= 7) {\n              // If Babel 7, only allow -beta.55 and earlier.  The final release, all RCs\n              // and -beta.56 all suffere from the removal of the \"builtins\" helpers.\n              var acceptableBabelRuntimeVersion = /^7\\.0\\.0-beta/.test(babelRuntimeVersion) && parseInt(babelRuntimeVersion.split(\".\").pop(), 10) <= 55;\n\n              if (!acceptableBabelRuntimeVersion) {\n                console.warn([\"The version of @babel/runtime installed in your node_modules directory \", \"(\" + babelRuntimeVersion + \") contains a breaking change which was introduced by \", \"https://github.com/babel/babel/pull/8266. Please either downgrade by \", \"running the following command:\", \"\", \"  meteor npm install --save-exact @babel/runtime@7.0.0-beta.55\", \"\", \"or update to the latest beta version of Meteor 1.7.1, as explained in \", \"this pull request: https://github.com/meteor/meteor/pull/9942.\", \"\"].join(\"\\n\"));\n              }\n            } /////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"node_modules\": {\n            \"meteor-babel-helpers\": {\n              \"package.json\": function packageJson(require, exports) {\n                /////////////////////////////////////////////////////////////////////////////////////////////\n                //                                                                                         //\n                // node_modules/meteor/babel-runtime/node_modules/meteor-babel-helpers/package.json        //\n                //                                                                                         //\n                /////////////////////////////////////////////////////////////////////////////////////////////\n                //\n                exports.name = \"meteor-babel-helpers\";\n                exports.version = \"0.0.3\";\n                exports.main = \"index.js\"; /////////////////////////////////////////////////////////////////////////////////////////////\n              },\n              \"index.js\": function indexJs(require, exports, module) {\n                /////////////////////////////////////////////////////////////////////////////////////////////\n                //                                                                                         //\n                // node_modules/meteor/babel-runtime/node_modules/meteor-babel-helpers/index.js            //\n                //                                                                                         //\n                /////////////////////////////////////////////////////////////////////////////////////////////\n                //\n                function canDefineNonEnumerableProperties() {\n                  var testObj = {};\n                  var testPropName = \"t\";\n\n                  try {\n                    Object.defineProperty(testObj, testPropName, {\n                      enumerable: false,\n                      value: testObj\n                    });\n\n                    for (var k in testObj) {\n                      if (k === testPropName) {\n                        return false;\n                      }\n                    }\n                  } catch (e) {\n                    return false;\n                  }\n\n                  return testObj[testPropName] === testObj;\n                }\n\n                function sanitizeEasy(value) {\n                  return value;\n                }\n\n                function sanitizeHard(obj) {\n                  if (Array.isArray(obj)) {\n                    var newObj = {};\n                    var keys = Object.keys(obj);\n                    var keyCount = keys.length;\n\n                    for (var i = 0; i < keyCount; ++i) {\n                      var key = keys[i];\n                      newObj[key] = obj[key];\n                    }\n\n                    return newObj;\n                  }\n\n                  return obj;\n                }\n\n                meteorBabelHelpers = module.exports = {\n                  // Meteor-specific runtime helper for wrapping the object of for-in\n                  // loops, so that inherited Array methods defined by es5-shim can be\n                  // ignored in browsers where they cannot be defined as non-enumerable.\n                  sanitizeForInObject: canDefineNonEnumerableProperties() ? sanitizeEasy : sanitizeHard,\n                  // Exposed so that we can test sanitizeForInObject in environments that\n                  // support defining non-enumerable properties.\n                  _sanitizeForInObjectHard: sanitizeHard\n                }; /////////////////////////////////////////////////////////////////////////////////////////////\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/babel-runtime/babel-runtime.js\");\n  /* Exports */\n\n\n  Package._define(\"babel-runtime\", exports, {\n    meteorBabelHelpers: meteorBabelHelpers\n  });\n})();\n\nmodule.exports = window.Package[\"babel-runtime\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/babel-runtime.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/base64.js":
/*!***********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/base64.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var Base64;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"base64\": {\n          \"base64.js\": function base64Js(require, exports, module) {\n            ////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                        //\n            // packages/base64/base64.js                                                              //\n            //                                                                                        //\n            ////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              Base64: function Base64() {\n                return _Base;\n              }\n            }); // Base 64 encoding\n\n            var BASE_64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            var BASE_64_VALS = Object.create(null);\n\n            var getChar = function getChar(val) {\n              return BASE_64_CHARS.charAt(val);\n            };\n\n            var getVal = function getVal(ch) {\n              return ch === '=' ? -1 : BASE_64_VALS[ch];\n            };\n\n            for (var i = 0; i < BASE_64_CHARS.length; i++) {\n              BASE_64_VALS[getChar(i)] = i;\n            }\n\n            ;\n\n            var encode = function encode(array) {\n              if (typeof array === \"string\") {\n                var str = array;\n                array = newBinary(str.length);\n\n                for (var _i = 0; _i < str.length; _i++) {\n                  var ch = str.charCodeAt(_i);\n\n                  if (ch > 0xFF) {\n                    throw new Error(\"Not ascii. Base64.encode can only take ascii strings.\");\n                  }\n\n                  array[_i] = ch;\n                }\n              }\n\n              var answer = [];\n              var a = null;\n              var b = null;\n              var c = null;\n              var d = null;\n              array.forEach(function (elm, i) {\n                switch (i % 3) {\n                  case 0:\n                    a = elm >> 2 & 0x3F;\n                    b = (elm & 0x03) << 4;\n                    break;\n\n                  case 1:\n                    b = b | elm >> 4 & 0xF;\n                    c = (elm & 0xF) << 2;\n                    break;\n\n                  case 2:\n                    c = c | elm >> 6 & 0x03;\n                    d = elm & 0x3F;\n                    answer.push(getChar(a));\n                    answer.push(getChar(b));\n                    answer.push(getChar(c));\n                    answer.push(getChar(d));\n                    a = null;\n                    b = null;\n                    c = null;\n                    d = null;\n                    break;\n                }\n              });\n\n              if (a != null) {\n                answer.push(getChar(a));\n                answer.push(getChar(b));\n\n                if (c == null) {\n                  answer.push('=');\n                } else {\n                  answer.push(getChar(c));\n                }\n\n                if (d == null) {\n                  answer.push('=');\n                }\n              }\n\n              return answer.join(\"\");\n            }; // XXX This is a weird place for this to live, but it's used both by\n            // this package and 'ejson', and we can't put it in 'ejson' without\n            // introducing a circular dependency. It should probably be in its own\n            // package or as a helper in a package that both 'base64' and 'ejson'\n            // use.\n\n\n            var newBinary = function newBinary(len) {\n              if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {\n                var ret = [];\n\n                for (var _i2 = 0; _i2 < len; _i2++) {\n                  ret.push(0);\n                }\n\n                ret.$Uint8ArrayPolyfill = true;\n                return ret;\n              }\n\n              return new Uint8Array(new ArrayBuffer(len));\n            };\n\n            var decode = function decode(str) {\n              var len = Math.floor(str.length * 3 / 4);\n\n              if (str.charAt(str.length - 1) == '=') {\n                len--;\n\n                if (str.charAt(str.length - 2) == '=') {\n                  len--;\n                }\n              }\n\n              var arr = newBinary(len);\n              var one = null;\n              var two = null;\n              var three = null;\n              var j = 0;\n\n              for (var _i3 = 0; _i3 < str.length; _i3++) {\n                var c = str.charAt(_i3);\n                var v = getVal(c);\n\n                switch (_i3 % 4) {\n                  case 0:\n                    if (v < 0) {\n                      throw new Error('invalid base64 string');\n                    }\n\n                    one = v << 2;\n                    break;\n\n                  case 1:\n                    if (v < 0) {\n                      throw new Error('invalid base64 string');\n                    }\n\n                    one = one | v >> 4;\n                    arr[j++] = one;\n                    two = (v & 0x0F) << 4;\n                    break;\n\n                  case 2:\n                    if (v >= 0) {\n                      two = two | v >> 2;\n                      arr[j++] = two;\n                      three = (v & 0x03) << 6;\n                    }\n\n                    break;\n\n                  case 3:\n                    if (v >= 0) {\n                      arr[j++] = three | v;\n                    }\n\n                    break;\n                }\n              }\n\n              return arr;\n            };\n\n            var _Base = {\n              encode: encode,\n              decode: decode,\n              newBinary: newBinary\n            }; ////////////////////////////////////////////////////////////////////////////////////////////\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/base64/base64.js\");\n  /* Exports */\n\n\n  Package._define(\"base64\", exports, {\n    Base64: Base64\n  });\n})();\n\nmodule.exports = window.Package[\"base64\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/base64.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/callback-hook.js":
/*!******************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/callback-hook.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var options, Hook;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"callback-hook\": {\n          \"hook.js\": function hookJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                 //\n            // packages/callback-hook/hook.js                                                                  //\n            //                                                                                                 //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              Hook: function Hook() {\n                return _Hook;\n              }\n            }); // XXX This pattern is under development. Do not add more callsites\n            // using this package for now. See:\n            // https://meteor.hackpad.com/Design-proposal-Hooks-YxvgEW06q6f\n            //\n            // Encapsulates the pattern of registering callbacks on a hook.\n            //\n            // The `each` method of the hook calls its iterator function argument\n            // with each registered callback.  This allows the hook to\n            // conditionally decide not to call the callback (if, for example, the\n            // observed object has been closed or terminated).\n            //\n            // By default, callbacks are bound with `Meteor.bindEnvironment`, so they will be\n            // called with the Meteor environment of the calling code that\n            // registered the callback. Override by passing { bindEnvironment: false }\n            // to the constructor.\n            //\n            // Registering a callback returns an object with a single `stop`\n            // method which unregisters the callback.\n            //\n            // The code is careful to allow a callback to be safely unregistered\n            // while the callbacks are being iterated over.\n            //\n            // If the hook is configured with the `exceptionHandler` option, the\n            // handler will be called if a called callback throws an exception.\n            // By default (if the exception handler doesn't itself throw an\n            // exception, or if the iterator function doesn't return a falsy value\n            // to terminate the calling of callbacks), the remaining callbacks\n            // will still be called.\n            //\n            // Alternatively, the `debugPrintExceptions` option can be specified\n            // as string describing the callback.  On an exception the string and\n            // the exception will be printed to the console log with\n            // `Meteor._debug`, and the exception otherwise ignored.\n            //\n            // If an exception handler isn't specified, exceptions thrown in the\n            // callback will propagate up to the iterator function, and will\n            // terminate calling the remaining callbacks if not caught.\n\n            var hasOwn = Object.prototype.hasOwnProperty;\n\n            var _Hook =\n            /*#__PURE__*/\n            function () {\n              function _Hook(options) {\n                _classCallCheck(this, _Hook);\n\n                options = options || {};\n                this.nextCallbackId = 0;\n                this.callbacks = Object.create(null); // Whether to wrap callbacks with Meteor.bindEnvironment\n\n                this.bindEnvironment = true;\n\n                if (options.bindEnvironment === false) {\n                  this.bindEnvironment = false;\n                }\n\n                if (options.exceptionHandler) {\n                  this.exceptionHandler = options.exceptionHandler;\n                } else if (options.debugPrintExceptions) {\n                  if (typeof options.debugPrintExceptions !== \"string\") {\n                    throw new Error(\"Hook option debugPrintExceptions should be a string\");\n                  }\n\n                  this.exceptionHandler = options.debugPrintExceptions;\n                }\n              }\n\n              _createClass(_Hook, [{\n                key: \"register\",\n                value: function register(callback) {\n                  var _this2 = this;\n\n                  var exceptionHandler = this.exceptionHandler || function (exception) {\n                    // Note: this relies on the undocumented fact that if bindEnvironment's\n                    // onException throws, and you are invoking the callback either in the\n                    // browser or from within a Fiber in Node, the exception is propagated.\n                    throw exception;\n                  };\n\n                  if (this.bindEnvironment) {\n                    callback = Meteor.bindEnvironment(callback, exceptionHandler);\n                  } else {\n                    callback = dontBindEnvironment(callback, exceptionHandler);\n                  }\n\n                  var id = this.nextCallbackId++;\n                  this.callbacks[id] = callback;\n                  return {\n                    stop: function stop() {\n                      delete _this2.callbacks[id];\n                    }\n                  };\n                } // For each registered callback, call the passed iterator function\n                // with the callback.\n                //\n                // The iterator function can choose whether or not to call the\n                // callback.  (For example, it might not call the callback if the\n                // observed object has been closed or terminated).\n                //\n                // The iteration is stopped if the iterator function returns a falsy\n                // value or throws an exception.\n                //\n\n              }, {\n                key: \"each\",\n                value: function each(iterator) {\n                  // Invoking bindEnvironment'd callbacks outside of a Fiber in Node doesn't\n                  // run them to completion (and exceptions thrown from onException are not\n                  // propagated), so we need to be in a Fiber.\n                  Meteor._nodeCodeMustBeInFiber();\n\n                  var ids = Object.keys(this.callbacks);\n\n                  for (var i = 0; i < ids.length; ++i) {\n                    var id = ids[i]; // check to see if the callback was removed during iteration\n\n                    if (hasOwn.call(this.callbacks, id)) {\n                      var callback = this.callbacks[id];\n\n                      if (!iterator(callback)) {\n                        break;\n                      }\n                    }\n                  }\n                }\n              }]);\n\n              return _Hook;\n            }(); // Copied from Meteor.bindEnvironment and removed all the env stuff.\n\n\n            function dontBindEnvironment(func, onException, _this) {\n              if (!onException || typeof onException === 'string') {\n                var description = onException || \"callback of async function\";\n\n                onException = function onException(error) {\n                  Meteor._debug(\"Exception in \" + description + \":\", error && error.stack || error);\n                };\n              }\n\n              return function () {\n                try {\n                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                    args[_key] = arguments[_key];\n                  }\n\n                  var ret = func.apply(_this, args);\n                } catch (e) {\n                  onException(e);\n                }\n\n                return ret;\n              };\n            } /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/callback-hook/hook.js\");\n  /* Exports */\n\n\n  Package._define(\"callback-hook\", exports, {\n    Hook: Hook\n  });\n})();\n\nmodule.exports = window.Package[\"callback-hook\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/callback-hook.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/check.js":
/*!**********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/check.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var EJSON = Package.ejson.EJSON;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var check, Match;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"check\": {\n          \"match.js\": function matchJs(require, exports, module) {\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                               //\n            // packages/check/match.js                                                                                       //\n            //                                                                                                               //\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              check: function check() {\n                return _check;\n              },\n              Match: function Match() {\n                return _Match;\n              }\n            });\n\n            var _isPlainObject;\n\n            module.watch(require(\"./isPlainObject\"), {\n              isPlainObject: function isPlainObject(v) {\n                _isPlainObject = v;\n              }\n            }, 0); // Things we explicitly do NOT support:\n            //    - heterogenous arrays\n\n            var currentArgumentChecker = new Meteor.EnvironmentVariable();\n            var hasOwn = Object.prototype.hasOwnProperty;\n            /**\n             * @summary Check that a value matches a [pattern](#matchpatterns).\n             * If the value does not match the pattern, throw a `Match.Error`.\n             *\n             * Particularly useful to assert that arguments to a function have the right\n             * types and structure.\n             * @locus Anywhere\n             * @param {Any} value The value to check\n             * @param {MatchPattern} pattern The pattern to match `value` against\n             */\n\n            function _check(value, pattern) {\n              // Record that check got called, if somebody cared.\n              //\n              // We use getOrNullIfOutsideFiber so that it's OK to call check()\n              // from non-Fiber server contexts; the downside is that if you forget to\n              // bindEnvironment on some random callback in your method/publisher,\n              // it might not find the argumentChecker and you'll get an error about\n              // not checking an argument that it looks like you're checking (instead\n              // of just getting a \"Node code must run in a Fiber\" error).\n              var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\n\n              if (argChecker) {\n                argChecker.checking(value);\n              }\n\n              var result = testSubtree(value, pattern);\n\n              if (result) {\n                var err = new _Match.Error(result.message);\n\n                if (result.path) {\n                  err.message += \" in field \".concat(result.path);\n                  err.path = result.path;\n                }\n\n                throw err;\n              }\n            }\n\n            ;\n            /**\n             * @namespace Match\n             * @summary The namespace for all Match types and methods.\n             */\n\n            var _Match = {\n              Optional: function Optional(pattern) {\n                return new _Optional(pattern);\n              },\n              Maybe: function Maybe(pattern) {\n                return new _Maybe(pattern);\n              },\n              OneOf: function OneOf() {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n\n                return new _OneOf(args);\n              },\n              Any: ['__any__'],\n              Where: function Where(condition) {\n                return new _Where(condition);\n              },\n              ObjectIncluding: function ObjectIncluding(pattern) {\n                return new _ObjectIncluding(pattern);\n              },\n              ObjectWithValues: function ObjectWithValues(pattern) {\n                return new _ObjectWithValues(pattern);\n              },\n              // Matches only signed 32-bit integers\n              Integer: ['__integer__'],\n              // XXX matchers should know how to describe themselves for errors\n              Error: Meteor.makeErrorType('Match.Error', function (msg) {\n                this.message = \"Match error: \".concat(msg); // The path of the value that failed to match. Initially empty, this gets\n                // populated by catching and rethrowing the exception as it goes back up the\n                // stack.\n                // E.g.: \"vals[3].entity.created\"\n\n                this.path = ''; // If this gets sent over DDP, don't give full internal details but at least\n                // provide something better than 500 Internal server error.\n\n                this.sanitizedError = new Meteor.Error(400, 'Match failed');\n              }),\n              // Tests to see if value matches pattern. Unlike check, it merely returns true\n              // or false (unless an error other than Match.Error was thrown). It does not\n              // interact with _failIfArgumentsAreNotAllChecked.\n              // XXX maybe also implement a Match.match which returns more information about\n              //     failures but without using exception handling or doing what check()\n              //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\n\n              /**\n               * @summary Returns true if the value matches the pattern.\n               * @locus Anywhere\n               * @param {Any} value The value to check\n               * @param {MatchPattern} pattern The pattern to match `value` against\n               */\n              test: function test(value, pattern) {\n                return !testSubtree(value, pattern);\n              },\n              // Runs `f.apply(context, args)`. If check() is not called on every element of\n              // `args` (either directly or in the first level of an array), throws an error\n              // (using `description` in the message).\n              _failIfArgumentsAreNotAllChecked: function _failIfArgumentsAreNotAllChecked(f, context, args, description) {\n                var argChecker = new ArgumentChecker(args, description);\n                var result = currentArgumentChecker.withValue(argChecker, function () {\n                  return f.apply(context, args);\n                }); // If f didn't itself throw, make sure it checked all of its arguments.\n\n                argChecker.throwUnlessAllArgumentsHaveBeenChecked();\n                return result;\n              }\n            };\n\n            var _Optional = function _Optional(pattern) {\n              _classCallCheck(this, _Optional);\n\n              this.pattern = pattern;\n            };\n\n            var _Maybe = function _Maybe(pattern) {\n              _classCallCheck(this, _Maybe);\n\n              this.pattern = pattern;\n            };\n\n            var _OneOf = function _OneOf(choices) {\n              _classCallCheck(this, _OneOf);\n\n              if (!choices || choices.length === 0) {\n                throw new Error('Must provide at least one choice to Match.OneOf');\n              }\n\n              this.choices = choices;\n            };\n\n            var _Where = function _Where(condition) {\n              _classCallCheck(this, _Where);\n\n              this.condition = condition;\n            };\n\n            var _ObjectIncluding = function _ObjectIncluding(pattern) {\n              _classCallCheck(this, _ObjectIncluding);\n\n              this.pattern = pattern;\n            };\n\n            var _ObjectWithValues = function _ObjectWithValues(pattern) {\n              _classCallCheck(this, _ObjectWithValues);\n\n              this.pattern = pattern;\n            };\n\n            var stringForErrorMessage = function stringForErrorMessage(value) {\n              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n              if (value === null) {\n                return 'null';\n              }\n\n              if (options.onlyShowType) {\n                return _typeof(value);\n              } // Your average non-object things.  Saves from doing the try/catch below for.\n\n\n              if (_typeof(value) !== 'object') {\n                return EJSON.stringify(value);\n              }\n\n              try {\n                // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\n                // If the native stringify is going to choke, EJSON.stringify is going to choke too.\n                JSON.stringify(value);\n              } catch (stringifyError) {\n                if (stringifyError.name === 'TypeError') {\n                  return _typeof(value);\n                }\n              }\n\n              return EJSON.stringify(value);\n            };\n\n            var typeofChecks = [[String, 'string'], [Number, 'number'], [Boolean, 'boolean'], // While we don't allow undefined/function in EJSON, this is good for optional\n            // arguments with OneOf.\n            [Function, 'function'], [undefined, 'undefined']]; // Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.\n\n            var testSubtree = function testSubtree(value, pattern) {\n              // Match anything!\n              if (pattern === _Match.Any) {\n                return false;\n              } // Basic atomic types.\n              // Do not match boxed objects (e.g. String, Boolean)\n\n\n              for (var i = 0; i < typeofChecks.length; ++i) {\n                if (pattern === typeofChecks[i][0]) {\n                  if (_typeof(value) === typeofChecks[i][1]) {\n                    return false;\n                  }\n\n                  return {\n                    message: \"Expected \".concat(typeofChecks[i][1], \", got \").concat(stringForErrorMessage(value, {\n                      onlyShowType: true\n                    })),\n                    path: ''\n                  };\n                }\n              }\n\n              if (pattern === null) {\n                if (value === null) {\n                  return false;\n                }\n\n                return {\n                  message: \"Expected null, got \".concat(stringForErrorMessage(value)),\n                  path: ''\n                };\n              } // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\n\n\n              if (typeof pattern === 'string' || typeof pattern === 'number' || typeof pattern === 'boolean') {\n                if (value === pattern) {\n                  return false;\n                }\n\n                return {\n                  message: \"Expected \".concat(pattern, \", got \").concat(stringForErrorMessage(value)),\n                  path: ''\n                };\n              } // Match.Integer is special type encoded with array\n\n\n              if (pattern === _Match.Integer) {\n                // There is no consistent and reliable way to check if variable is a 64-bit\n                // integer. One of the popular solutions is to get reminder of division by 1\n                // but this method fails on really large floats with big precision.\n                // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n                // Bitwise operators work consistantly but always cast variable to 32-bit\n                // signed integer according to JavaScript specs.\n                if (typeof value === 'number' && (value | 0) === value) {\n                  return false;\n                }\n\n                return {\n                  message: \"Expected Integer, got \".concat(stringForErrorMessage(value)),\n                  path: ''\n                };\n              } // 'Object' is shorthand for Match.ObjectIncluding({});\n\n\n              if (pattern === Object) {\n                pattern = _Match.ObjectIncluding({});\n              } // Array (checked AFTER Any, which is implemented as an Array).\n\n\n              if (pattern instanceof Array) {\n                if (pattern.length !== 1) {\n                  return {\n                    message: \"Bad pattern: arrays must have one type element \".concat(stringForErrorMessage(pattern)),\n                    path: ''\n                  };\n                }\n\n                if (!Array.isArray(value) && !isArguments(value)) {\n                  return {\n                    message: \"Expected array, got \".concat(stringForErrorMessage(value)),\n                    path: ''\n                  };\n                }\n\n                for (var _i = 0, length = value.length; _i < length; _i++) {\n                  var result = testSubtree(value[_i], pattern[0]);\n\n                  if (result) {\n                    result.path = _prependPath(_i, result.path);\n                    return result;\n                  }\n                }\n\n                return false;\n              } // Arbitrary validation checks. The condition can return false or throw a\n              // Match.Error (ie, it can internally use check()) to fail.\n\n\n              if (pattern instanceof _Where) {\n                var _result;\n\n                try {\n                  _result = pattern.condition(value);\n                } catch (err) {\n                  if (!(err instanceof _Match.Error)) {\n                    throw err;\n                  }\n\n                  return {\n                    message: err.message,\n                    path: err.path\n                  };\n                }\n\n                if (_result) {\n                  return false;\n                } // XXX this error is terrible\n\n\n                return {\n                  message: 'Failed Match.Where validation',\n                  path: ''\n                };\n              }\n\n              if (pattern instanceof _Maybe) {\n                pattern = _Match.OneOf(undefined, null, pattern.pattern);\n              } else if (pattern instanceof _Optional) {\n                pattern = _Match.OneOf(undefined, pattern.pattern);\n              }\n\n              if (pattern instanceof _OneOf) {\n                for (var _i2 = 0; _i2 < pattern.choices.length; ++_i2) {\n                  var _result2 = testSubtree(value, pattern.choices[_i2]);\n\n                  if (!_result2) {\n                    // No error? Yay, return.\n                    return false;\n                  } // Match errors just mean try another choice.\n\n                } // XXX this error is terrible\n\n\n                return {\n                  message: 'Failed Match.OneOf, Match.Maybe or Match.Optional validation',\n                  path: ''\n                };\n              } // A function that isn't something we special-case is assumed to be a\n              // constructor.\n\n\n              if (pattern instanceof Function) {\n                if (value instanceof pattern) {\n                  return false;\n                }\n\n                return {\n                  message: \"Expected \".concat(pattern.name || 'particular constructor'),\n                  path: ''\n                };\n              }\n\n              var unknownKeysAllowed = false;\n              var unknownKeyPattern;\n\n              if (pattern instanceof _ObjectIncluding) {\n                unknownKeysAllowed = true;\n                pattern = pattern.pattern;\n              }\n\n              if (pattern instanceof _ObjectWithValues) {\n                unknownKeysAllowed = true;\n                unknownKeyPattern = [pattern.pattern];\n                pattern = {}; // no required keys\n              }\n\n              if (_typeof(pattern) !== 'object') {\n                return {\n                  message: 'Bad pattern: unknown pattern type',\n                  path: ''\n                };\n              } // An object, with required and optional keys. Note that this does NOT do\n              // structural matches against objects of special types that happen to match\n              // the pattern: this really needs to be a plain old {Object}!\n\n\n              if (_typeof(value) !== 'object') {\n                return {\n                  message: \"Expected object, got \".concat(_typeof(value)),\n                  path: ''\n                };\n              }\n\n              if (value === null) {\n                return {\n                  message: \"Expected object, got null\",\n                  path: ''\n                };\n              }\n\n              if (!_isPlainObject(value)) {\n                return {\n                  message: \"Expected plain object\",\n                  path: ''\n                };\n              }\n\n              var requiredPatterns = Object.create(null);\n              var optionalPatterns = Object.create(null);\n              Object.keys(pattern).forEach(function (key) {\n                var subPattern = pattern[key];\n\n                if (subPattern instanceof _Optional || subPattern instanceof _Maybe) {\n                  optionalPatterns[key] = subPattern.pattern;\n                } else {\n                  requiredPatterns[key] = subPattern;\n                }\n              });\n\n              for (var key in Object(value)) {\n                var subValue = value[key];\n\n                if (hasOwn.call(requiredPatterns, key)) {\n                  var _result3 = testSubtree(subValue, requiredPatterns[key]);\n\n                  if (_result3) {\n                    _result3.path = _prependPath(key, _result3.path);\n                    return _result3;\n                  }\n\n                  delete requiredPatterns[key];\n                } else if (hasOwn.call(optionalPatterns, key)) {\n                  var _result4 = testSubtree(subValue, optionalPatterns[key]);\n\n                  if (_result4) {\n                    _result4.path = _prependPath(key, _result4.path);\n                    return _result4;\n                  }\n                } else {\n                  if (!unknownKeysAllowed) {\n                    return {\n                      message: 'Unknown key',\n                      path: key\n                    };\n                  }\n\n                  if (unknownKeyPattern) {\n                    var _result5 = testSubtree(subValue, unknownKeyPattern[0]);\n\n                    if (_result5) {\n                      _result5.path = _prependPath(key, _result5.path);\n                      return _result5;\n                    }\n                  }\n                }\n              }\n\n              var keys = Object.keys(requiredPatterns);\n\n              if (keys.length) {\n                return {\n                  message: \"Missing key '\".concat(keys[0], \"'\"),\n                  path: ''\n                };\n              }\n            };\n\n            var ArgumentChecker =\n            /*#__PURE__*/\n            function () {\n              function ArgumentChecker(args, description) {\n                _classCallCheck(this, ArgumentChecker);\n\n                // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\n                // against its contents.)\n                this.args = _toConsumableArray(args); // Since the common case will be to check arguments in order, and we splice\n                // out arguments when we check them, make it so we splice out from the end\n                // rather than the beginning.\n\n                this.args.reverse();\n                this.description = description;\n              }\n\n              _createClass(ArgumentChecker, [{\n                key: \"checking\",\n                value: function checking(value) {\n                  if (this._checkingOneValue(value)) {\n                    return;\n                  } // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\n                  // or check([foo, bar], [String]) to count... but only if value wasn't\n                  // itself an argument.\n\n\n                  if (Array.isArray(value) || isArguments(value)) {\n                    Array.prototype.forEach.call(value, this._checkingOneValue.bind(this));\n                  }\n                }\n              }, {\n                key: \"_checkingOneValue\",\n                value: function _checkingOneValue(value) {\n                  for (var i = 0; i < this.args.length; ++i) {\n                    // Is this value one of the arguments? (This can have a false positive if\n                    // the argument is an interned primitive, but it's still a good enough\n                    // check.)\n                    // (NaN is not === to itself, so we have to check specially.)\n                    if (value === this.args[i] || Number.isNaN(value) && Number.isNaN(this.args[i])) {\n                      this.args.splice(i, 1);\n                      return true;\n                    }\n                  }\n\n                  return false;\n                }\n              }, {\n                key: \"throwUnlessAllArgumentsHaveBeenChecked\",\n                value: function throwUnlessAllArgumentsHaveBeenChecked() {\n                  if (this.args.length > 0) throw new Error(\"Did not check() all arguments during \".concat(this.description));\n                }\n              }]);\n\n              return ArgumentChecker;\n            }();\n\n            var _jsKeywords = ['do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case', 'else', 'enum', 'eval', 'false', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'super', 'throw', 'while', 'yield', 'delete', 'export', 'import', 'public', 'return', 'static', 'switch', 'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue', 'debugger', 'function', 'arguments', 'interface', 'protected', 'implements', 'instanceof']; // Assumes the base of path is already escaped properly\n            // returns key + base\n\n            var _prependPath = function _prependPath(key, base) {\n              if (typeof key === 'number' || key.match(/^[0-9]+$/)) {\n                key = \"[\".concat(key, \"]\");\n              } else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _jsKeywords.indexOf(key) >= 0) {\n                key = JSON.stringify([key]);\n              }\n\n              if (base && base[0] !== '[') {\n                return \"\".concat(key, \".\").concat(base);\n              }\n\n              return key + base;\n            };\n\n            var isObject = function isObject(value) {\n              return _typeof(value) === 'object' && value !== null;\n            };\n\n            var baseIsArguments = function baseIsArguments(item) {\n              return isObject(item) && Object.prototype.toString.call(item) === '[object Arguments]';\n            };\n\n            var isArguments = baseIsArguments(function () {\n              return arguments;\n            }()) ? baseIsArguments : function (value) {\n              return isObject(value) && typeof value.callee === 'function';\n            }; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          },\n          \"isPlainObject.js\": function isPlainObjectJs(require, exports, module) {\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                               //\n            // packages/check/isPlainObject.js                                                                               //\n            //                                                                                                               //\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              isPlainObject: function isPlainObject() {\n                return _isPlainObject2;\n              }\n            }); // Copy of jQuery.isPlainObject for the server side from jQuery v3.1.1.\n\n            var class2type = {};\n            var toString = class2type.toString;\n            var hasOwn = Object.prototype.hasOwnProperty;\n            var fnToString = hasOwn.toString;\n            var ObjectFunctionString = fnToString.call(Object);\n            var getProto = Object.getPrototypeOf;\n\n            var _isPlainObject2 = function _isPlainObject2(obj) {\n              var proto;\n              var Ctor; // Detect obvious negatives\n              // Use toString instead of jQuery.type to catch host objects\n\n              if (!obj || toString.call(obj) !== '[object Object]') {\n                return false;\n              }\n\n              proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain\n\n              if (!proto) {\n                return true;\n              } // Objects with prototype are plain iff they were constructed by a global Object function\n\n\n              Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\n              return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;\n            }; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/check/match.js\");\n  /* Exports */\n\n\n  Package._define(\"check\", exports, {\n    check: check,\n    Match: Match\n  });\n})();\n\nmodule.exports = window.Package[\"check\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/check.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/ddp-client.js":
/*!***************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/ddp-client.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var check = Package.check.check;\n  var Match = Package.check.Match;\n  var Random = Package.random.Random;\n  var EJSON = Package.ejson.EJSON;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n  var Retry = Package.retry.Retry;\n  var IdMap = Package['id-map'].IdMap;\n  var Hook = Package['callback-hook'].Hook;\n  var DDPCommon = Package['ddp-common'].DDPCommon;\n  var Reload = Package.reload.Reload;\n  var DiffSequence = Package['diff-sequence'].DiffSequence;\n  var MongoID = Package['mongo-id'].MongoID;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var options, DDP;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"ddp-client\": {\n          \"client\": {\n            \"client.js\": function clientJs(require, exports, module) {\n              /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              //                                                                                                                     //\n              // packages/ddp-client/client/client.js                                                                                //\n              //                                                                                                                     //\n              /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              //\n              module.watch(require(\"../common/namespace.js\"), {\n                DDP: function DDP(v) {\n                  exports.DDP = v;\n                }\n              }, 0);\n              module.watch(require(\"../common/livedata_connection\"));\n              module.watch(require(\"./client_convenience\")); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            },\n            \"client_convenience.js\": function client_convenienceJs(require, exports, module) {\n              /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              //                                                                                                                     //\n              // packages/ddp-client/client/client_convenience.js                                                                    //\n              //                                                                                                                     //\n              /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              //\n              var _DDP;\n\n              module.watch(require(\"../common/namespace.js\"), {\n                DDP: function DDP(v) {\n                  _DDP = v;\n                }\n              }, 0);\n\n              var _Meteor;\n\n              module.watch(require(\"meteor/meteor\"), {\n                Meteor: function Meteor(v) {\n                  _Meteor = v;\n                }\n              }, 1); // Meteor.refresh can be called on the client (if you're in common code) but it\n              // only has an effect on the server.\n\n              _Meteor.refresh = function () {}; // By default, try to connect back to the same endpoint as the page\n              // was served from.\n              //\n              // XXX We should be doing this a different way. Right now we don't\n              // include ROOT_URL_PATH_PREFIX when computing ddpUrl. (We don't\n              // include it on the server when computing\n              // DDP_DEFAULT_CONNECTION_URL, and we don't include it in our\n              // default, '/'.) We get by with this because DDP.connect then\n              // forces the URL passed to it to be interpreted relative to the\n              // app's deploy path, even if it is absolute. Instead, we should\n              // make DDP_DEFAULT_CONNECTION_URL, if set, include the path prefix;\n              // make the default ddpUrl be '' rather that '/'; and make\n              // _translateUrl in stream_client_common.js not force absolute paths\n              // to be treated like relative paths. See also\n              // stream_client_common.js #RationalizingRelativeDDPURLs\n\n\n              var ddpUrl = '/';\n\n              if (typeof __meteor_runtime_config__ !== 'undefined') {\n                if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL) ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;\n              }\n\n              var retry = new Retry();\n\n              function onDDPVersionNegotiationFailure(description) {\n                _Meteor._debug(description);\n\n                if (Package.reload) {\n                  var migrationData = Package.reload.Reload._migrationData('livedata') || Object.create(null);\n                  var failures = migrationData.DDPVersionNegotiationFailures || 0;\n                  ++failures;\n\n                  Package.reload.Reload._onMigrate('livedata', function () {\n                    return [true, {\n                      DDPVersionNegotiationFailures: failures\n                    }];\n                  });\n\n                  retry.retryLater(failures, function () {\n                    Package.reload.Reload._reload();\n                  });\n                }\n              }\n\n              _Meteor.connection = _DDP.connect(ddpUrl, {\n                onDDPVersionNegotiationFailure: onDDPVersionNegotiationFailure\n              }); // Proxy the public methods of Meteor.connection so they can\n              // be called directly on Meteor.\n\n              ['subscribe', 'methods', 'call', 'apply', 'status', 'reconnect', 'disconnect'].forEach(function (name) {\n                _Meteor[name] = _Meteor.connection[name].bind(_Meteor.connection);\n              }); // Meteor.connection used to be called\n              // Meteor.default_connection. Provide backcompat as a courtesy even\n              // though it was never documented.\n              // XXX COMPAT WITH 0.6.4\n\n              _Meteor.default_connection = _Meteor.connection; // We should transition from Meteor.connect to DDP.connect.\n              // XXX COMPAT WITH 0.6.4\n\n              _Meteor.connect = _DDP.connect; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            }\n          },\n          \"common\": {\n            \"MethodInvoker.js\": function MethodInvokerJs(require, exports, module) {\n              /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              //                                                                                                                     //\n              // packages/ddp-client/common/MethodInvoker.js                                                                         //\n              //                                                                                                                     //\n              /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              //\n              module.export({\n                default: function _default() {\n                  return MethodInvoker;\n                }\n              });\n\n              var MethodInvoker =\n              /*#__PURE__*/\n              function () {\n                function MethodInvoker(options) {\n                  _classCallCheck(this, MethodInvoker);\n\n                  // Public (within this file) fields.\n                  this.methodId = options.methodId;\n                  this.sentMessage = false;\n                  this._callback = options.callback;\n                  this._connection = options.connection;\n                  this._message = options.message;\n\n                  this._onResultReceived = options.onResultReceived || function () {};\n\n                  this._wait = options.wait;\n                  this.noRetry = options.noRetry;\n                  this._methodResult = null;\n                  this._dataVisible = false; // Register with the connection.\n\n                  this._connection._methodInvokers[this.methodId] = this;\n                } // Sends the method message to the server. May be called additional times if\n                // we lose the connection and reconnect before receiving a result.\n\n\n                _createClass(MethodInvoker, [{\n                  key: \"sendMessage\",\n                  value: function sendMessage() {\n                    // This function is called before sending a method (including resending on\n                    // reconnect). We should only (re)send methods where we don't already have a\n                    // result!\n                    if (this.gotResult()) throw new Error('sendingMethod is called on method with result'); // If we're re-sending it, it doesn't matter if data was written the first\n                    // time.\n\n                    this._dataVisible = false;\n                    this.sentMessage = true; // If this is a wait method, make all data messages be buffered until it is\n                    // done.\n\n                    if (this._wait) this._connection._methodsBlockingQuiescence[this.methodId] = true; // Actually send the message.\n\n                    this._connection._send(this._message);\n                  } // Invoke the callback, if we have both a result and know that all data has\n                  // been written to the local cache.\n\n                }, {\n                  key: \"_maybeInvokeCallback\",\n                  value: function _maybeInvokeCallback() {\n                    if (this._methodResult && this._dataVisible) {\n                      // Call the callback. (This won't throw: the callback was wrapped with\n                      // bindEnvironment.)\n                      this._callback(this._methodResult[0], this._methodResult[1]); // Forget about this method.\n\n\n                      delete this._connection._methodInvokers[this.methodId]; // Let the connection know that this method is finished, so it can try to\n                      // move on to the next block of methods.\n\n                      this._connection._outstandingMethodFinished();\n                    }\n                  } // Call with the result of the method from the server. Only may be called\n                  // once; once it is called, you should not call sendMessage again.\n                  // If the user provided an onResultReceived callback, call it immediately.\n                  // Then invoke the main callback if data is also visible.\n\n                }, {\n                  key: \"receiveResult\",\n                  value: function receiveResult(err, result) {\n                    if (this.gotResult()) throw new Error('Methods should only receive results once');\n                    this._methodResult = [err, result];\n\n                    this._onResultReceived(err, result);\n\n                    this._maybeInvokeCallback();\n                  } // Call this when all data written by the method is visible. This means that\n                  // the method has returns its \"data is done\" message *AND* all server\n                  // documents that are buffered at that time have been written to the local\n                  // cache. Invokes the main callback if the result has been received.\n\n                }, {\n                  key: \"dataVisible\",\n                  value: function dataVisible() {\n                    this._dataVisible = true;\n\n                    this._maybeInvokeCallback();\n                  } // True if receiveResult has been called.\n\n                }, {\n                  key: \"gotResult\",\n                  value: function gotResult() {\n                    return !!this._methodResult;\n                  }\n                }]);\n\n                return MethodInvoker;\n              }(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n            },\n            \"livedata_connection.js\": function livedata_connectionJs(require, exports, module) {\n              /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              //                                                                                                                     //\n              // packages/ddp-client/common/livedata_connection.js                                                                   //\n              //                                                                                                                     //\n              /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              //\n              var _interopRequireDefault = require(\"@babel/runtime/helpers/builtin/interopRequireDefault\");\n\n              var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\n              module.export({\n                Connection: function Connection() {\n                  return _Connection;\n                }\n              });\n\n              var _Meteor2;\n\n              module.watch(require(\"meteor/meteor\"), {\n                Meteor: function Meteor(v) {\n                  _Meteor2 = v;\n                }\n              }, 0);\n\n              var _DDPCommon;\n\n              module.watch(require(\"meteor/ddp-common\"), {\n                DDPCommon: function DDPCommon(v) {\n                  _DDPCommon = v;\n                }\n              }, 1);\n\n              var _Tracker;\n\n              module.watch(require(\"meteor/tracker\"), {\n                Tracker: function Tracker(v) {\n                  _Tracker = v;\n                }\n              }, 2);\n\n              var _EJSON;\n\n              module.watch(require(\"meteor/ejson\"), {\n                EJSON: function EJSON(v) {\n                  _EJSON = v;\n                }\n              }, 3);\n\n              var _Random;\n\n              module.watch(require(\"meteor/random\"), {\n                Random: function Random(v) {\n                  _Random = v;\n                }\n              }, 4);\n\n              var _Hook;\n\n              module.watch(require(\"meteor/callback-hook\"), {\n                Hook: function Hook(v) {\n                  _Hook = v;\n                }\n              }, 5);\n\n              var _MongoID;\n\n              module.watch(require(\"meteor/mongo-id\"), {\n                MongoID: function MongoID(v) {\n                  _MongoID = v;\n                }\n              }, 6);\n\n              var _DDP2;\n\n              module.watch(require(\"./namespace.js\"), {\n                DDP: function DDP(v) {\n                  _DDP2 = v;\n                }\n              }, 7);\n              var MethodInvoker;\n              module.watch(require(\"./MethodInvoker.js\"), {\n                default: function _default(v) {\n                  MethodInvoker = v;\n                }\n              }, 8);\n\n              var _hasOwn, _slice, _keys, _isEmpty, _last;\n\n              module.watch(require(\"meteor/ddp-common/utils.js\"), {\n                hasOwn: function hasOwn(v) {\n                  _hasOwn = v;\n                },\n                slice: function slice(v) {\n                  _slice = v;\n                },\n                keys: function keys(v) {\n                  _keys = v;\n                },\n                isEmpty: function isEmpty(v) {\n                  _isEmpty = v;\n                },\n                last: function last(v) {\n                  _last = v;\n                }\n              }, 9);\n\n              if (_Meteor2.isServer) {\n                var Fiber = Npm.require('fibers');\n\n                var Future = Npm.require('fibers/future');\n              }\n\n              var MongoIDMap =\n              /*#__PURE__*/\n              function (_IdMap) {\n                _inherits(MongoIDMap, _IdMap);\n\n                function MongoIDMap() {\n                  _classCallCheck(this, MongoIDMap);\n\n                  return _possibleConstructorReturn(this, _getPrototypeOf(MongoIDMap).call(this, _MongoID.idStringify, _MongoID.idParse));\n                }\n\n                return MongoIDMap;\n              }(IdMap); // @param url {String|Object} URL to Meteor app,\n              //   or an object as a test hook (see code)\n              // Options:\n              //   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\n              //   headers: extra headers to send on the websockets connection, for\n              //     server-to-server DDP only\n              //   _sockjsOptions: Specifies options to pass through to the sockjs client\n              //   onDDPNegotiationVersionFailure: callback when version negotiation fails.\n              //\n              // XXX There should be a way to destroy a DDP connection, causing all\n              // outstanding method calls to fail.\n              //\n              // XXX Our current way of handling failure and reconnection is great\n              // for an app (where we want to tolerate being disconnected as an\n              // expect state, and keep trying forever to reconnect) but cumbersome\n              // for something like a command line tool that wants to make a\n              // connection, call a method, and print an error if connection\n              // fails. We should have better usability in the latter case (while\n              // still transparently reconnecting if it's just a transient failure\n              // or the server migrating us).\n\n\n              var _Connection =\n              /*#__PURE__*/\n              function () {\n                function _Connection(url, options) {\n                  _classCallCheck(this, _Connection);\n\n                  var self = this;\n                  this.options = options = (0, _objectSpread2.default)({\n                    onConnected: function onConnected() {},\n                    onDDPVersionNegotiationFailure: function onDDPVersionNegotiationFailure(description) {\n                      _Meteor2._debug(description);\n                    },\n                    heartbeatInterval: 17500,\n                    heartbeatTimeout: 15000,\n                    npmFayeOptions: Object.create(null),\n                    // These options are only for testing.\n                    reloadWithOutstanding: false,\n                    supportedDDPVersions: _DDPCommon.SUPPORTED_DDP_VERSIONS,\n                    retry: true,\n                    respondToPings: true,\n                    // When updates are coming within this ms interval, batch them together.\n                    bufferedWritesInterval: 5,\n                    // Flush buffers immediately if writes are happening continuously for more than this many ms.\n                    bufferedWritesMaxAge: 500\n                  }, options); // If set, called when we reconnect, queuing method calls _before_ the\n                  // existing outstanding ones.\n                  // NOTE: This feature has been preserved for backwards compatibility. The\n                  // preferred method of setting a callback on reconnect is to use\n                  // DDP.onReconnect.\n\n                  self.onReconnect = null; // as a test hook, allow passing a stream instead of a url.\n\n                  if (_typeof(url) === 'object') {\n                    self._stream = url;\n                  } else {\n                    var _require = require(\"meteor/socket-stream-client\"),\n                        ClientStream = _require.ClientStream;\n\n                    self._stream = new ClientStream(url, {\n                      retry: options.retry,\n                      ConnectionError: _DDP2.ConnectionError,\n                      headers: options.headers,\n                      _sockjsOptions: options._sockjsOptions,\n                      // Used to keep some tests quiet, or for other cases in which\n                      // the right thing to do with connection errors is to silently\n                      // fail (e.g. sending package usage stats). At some point we\n                      // should have a real API for handling client-stream-level\n                      // errors.\n                      _dontPrintErrors: options._dontPrintErrors,\n                      connectTimeoutMs: options.connectTimeoutMs,\n                      npmFayeOptions: options.npmFayeOptions\n                    });\n                  }\n\n                  self._lastSessionId = null;\n                  self._versionSuggestion = null; // The last proposed DDP version.\n\n                  self._version = null; // The DDP version agreed on by client and server.\n\n                  self._stores = Object.create(null); // name -> object with methods\n\n                  self._methodHandlers = Object.create(null); // name -> func\n\n                  self._nextMethodId = 1;\n                  self._supportedDDPVersions = options.supportedDDPVersions;\n                  self._heartbeatInterval = options.heartbeatInterval;\n                  self._heartbeatTimeout = options.heartbeatTimeout; // Tracks methods which the user has tried to call but which have not yet\n                  // called their user callback (ie, they are waiting on their result or for all\n                  // of their writes to be written to the local cache). Map from method ID to\n                  // MethodInvoker object.\n\n                  self._methodInvokers = Object.create(null); // Tracks methods which the user has called but whose result messages have not\n                  // arrived yet.\n                  //\n                  // _outstandingMethodBlocks is an array of blocks of methods. Each block\n                  // represents a set of methods that can run at the same time. The first block\n                  // represents the methods which are currently in flight; subsequent blocks\n                  // must wait for previous blocks to be fully finished before they can be sent\n                  // to the server.\n                  //\n                  // Each block is an object with the following fields:\n                  // - methods: a list of MethodInvoker objects\n                  // - wait: a boolean; if true, this block had a single method invoked with\n                  //         the \"wait\" option\n                  //\n                  // There will never be adjacent blocks with wait=false, because the only thing\n                  // that makes methods need to be serialized is a wait method.\n                  //\n                  // Methods are removed from the first block when their \"result\" is\n                  // received. The entire first block is only removed when all of the in-flight\n                  // methods have received their results (so the \"methods\" list is empty) *AND*\n                  // all of the data written by those methods are visible in the local cache. So\n                  // it is possible for the first block's methods list to be empty, if we are\n                  // still waiting for some objects to quiesce.\n                  //\n                  // Example:\n                  //  _outstandingMethodBlocks = [\n                  //    {wait: false, methods: []},\n                  //    {wait: true, methods: [<MethodInvoker for 'login'>]},\n                  //    {wait: false, methods: [<MethodInvoker for 'foo'>,\n                  //                            <MethodInvoker for 'bar'>]}]\n                  // This means that there were some methods which were sent to the server and\n                  // which have returned their results, but some of the data written by\n                  // the methods may not be visible in the local cache. Once all that data is\n                  // visible, we will send a 'login' method. Once the login method has returned\n                  // and all the data is visible (including re-running subs if userId changes),\n                  // we will send the 'foo' and 'bar' methods in parallel.\n\n                  self._outstandingMethodBlocks = []; // method ID -> array of objects with keys 'collection' and 'id', listing\n                  // documents written by a given method's stub. keys are associated with\n                  // methods whose stub wrote at least one document, and whose data-done message\n                  // has not yet been received.\n\n                  self._documentsWrittenByStub = Object.create(null); // collection -> IdMap of \"server document\" object. A \"server document\" has:\n                  // - \"document\": the version of the document according the\n                  //   server (ie, the snapshot before a stub wrote it, amended by any changes\n                  //   received from the server)\n                  //   It is undefined if we think the document does not exist\n                  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document\n                  //   whose \"data done\" messages have not yet been processed\n\n                  self._serverDocuments = Object.create(null); // Array of callbacks to be called after the next update of the local\n                  // cache. Used for:\n                  //  - Calling methodInvoker.dataVisible and sub ready callbacks after\n                  //    the relevant data is flushed.\n                  //  - Invoking the callbacks of \"half-finished\" methods after reconnect\n                  //    quiescence. Specifically, methods whose result was received over the old\n                  //    connection (so we don't re-send it) but whose data had not been made\n                  //    visible.\n\n                  self._afterUpdateCallbacks = []; // In two contexts, we buffer all incoming data messages and then process them\n                  // all at once in a single update:\n                  //   - During reconnect, we buffer all data messages until all subs that had\n                  //     been ready before reconnect are ready again, and all methods that are\n                  //     active have returned their \"data done message\"; then\n                  //   - During the execution of a \"wait\" method, we buffer all data messages\n                  //     until the wait method gets its \"data done\" message. (If the wait method\n                  //     occurs during reconnect, it doesn't get any special handling.)\n                  // all data messages are processed in one update.\n                  //\n                  // The following fields are used for this \"quiescence\" process.\n                  // This buffers the messages that aren't being processed yet.\n\n                  self._messagesBufferedUntilQuiescence = []; // Map from method ID -> true. Methods are removed from this when their\n                  // \"data done\" message is received, and we will not quiesce until it is\n                  // empty.\n\n                  self._methodsBlockingQuiescence = Object.create(null); // map from sub ID -> true for subs that were ready (ie, called the sub\n                  // ready callback) before reconnect but haven't become ready again yet\n\n                  self._subsBeingRevived = Object.create(null); // map from sub._id -> true\n                  // if true, the next data update should reset all stores. (set during\n                  // reconnect.)\n\n                  self._resetStores = false; // name -> array of updates for (yet to be created) collections\n\n                  self._updatesForUnknownStores = Object.create(null); // if we're blocking a migration, the retry func\n\n                  self._retryMigrate = null;\n                  self.__flushBufferedWrites = _Meteor2.bindEnvironment(self._flushBufferedWrites, 'flushing DDP buffered writes', self); // Collection name -> array of messages.\n\n                  self._bufferedWrites = Object.create(null); // When current buffer of updates must be flushed at, in ms timestamp.\n\n                  self._bufferedWritesFlushAt = null; // Timeout handle for the next processing of all pending writes\n\n                  self._bufferedWritesFlushHandle = null;\n                  self._bufferedWritesInterval = options.bufferedWritesInterval;\n                  self._bufferedWritesMaxAge = options.bufferedWritesMaxAge; // metadata for subscriptions.  Map from sub ID to object with keys:\n                  //   - id\n                  //   - name\n                  //   - params\n                  //   - inactive (if true, will be cleaned up if not reused in re-run)\n                  //   - ready (has the 'ready' message been received?)\n                  //   - readyCallback (an optional callback to call when ready)\n                  //   - errorCallback (an optional callback to call if the sub terminates with\n                  //                    an error, XXX COMPAT WITH 1.0.3.1)\n                  //   - stopCallback (an optional callback to call when the sub terminates\n                  //     for any reason, with an error argument if an error triggered the stop)\n\n                  self._subscriptions = Object.create(null); // Reactive userId.\n\n                  self._userId = null;\n                  self._userIdDeps = new _Tracker.Dependency(); // Block auto-reload while we're waiting for method responses.\n\n                  if (_Meteor2.isClient && Package.reload && !options.reloadWithOutstanding) {\n                    Package.reload.Reload._onMigrate(function (retry) {\n                      if (!self._readyToMigrate()) {\n                        if (self._retryMigrate) throw new Error('Two migrations in progress?');\n                        self._retryMigrate = retry;\n                        return false;\n                      } else {\n                        return [true];\n                      }\n                    });\n                  }\n\n                  var onDisconnect = function onDisconnect() {\n                    if (self._heartbeat) {\n                      self._heartbeat.stop();\n\n                      self._heartbeat = null;\n                    }\n                  };\n\n                  if (_Meteor2.isServer) {\n                    self._stream.on('message', _Meteor2.bindEnvironment(this.onMessage.bind(this), 'handling DDP message'));\n\n                    self._stream.on('reset', _Meteor2.bindEnvironment(this.onReset.bind(this), 'handling DDP reset'));\n\n                    self._stream.on('disconnect', _Meteor2.bindEnvironment(onDisconnect, 'handling DDP disconnect'));\n                  } else {\n                    self._stream.on('message', this.onMessage.bind(this));\n\n                    self._stream.on('reset', this.onReset.bind(this));\n\n                    self._stream.on('disconnect', onDisconnect);\n                  }\n                } // 'name' is the name of the data on the wire that should go in the\n                // store. 'wrappedStore' should be an object with methods beginUpdate, update,\n                // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\n\n\n                _createClass(_Connection, [{\n                  key: \"registerStore\",\n                  value: function registerStore(name, wrappedStore) {\n                    var self = this;\n                    if (name in self._stores) return false; // Wrap the input object in an object which makes any store method not\n                    // implemented by 'store' into a no-op.\n\n                    var store = Object.create(null);\n                    ['update', 'beginUpdate', 'endUpdate', 'saveOriginals', 'retrieveOriginals', 'getDoc', '_getCollection'].forEach(function (method) {\n                      store[method] = function () {\n                        if (wrappedStore[method]) {\n                          return wrappedStore[method].apply(wrappedStore, arguments);\n                        }\n                      };\n                    });\n                    self._stores[name] = store;\n                    var queued = self._updatesForUnknownStores[name];\n\n                    if (queued) {\n                      store.beginUpdate(queued.length, false);\n                      queued.forEach(function (msg) {\n                        store.update(msg);\n                      });\n                      store.endUpdate();\n                      delete self._updatesForUnknownStores[name];\n                    }\n\n                    return true;\n                  }\n                  /**\n                   * @memberOf Meteor\n                   * @importFromPackage meteor\n                   * @alias Meteor.subscribe\n                   * @summary Subscribe to a record set.  Returns a handle that provides\n                   * `stop()` and `ready()` methods.\n                   * @locus Client\n                   * @param {String} name Name of the subscription.  Matches the name of the\n                   * server's `publish()` call.\n                   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher\n                   * function on server.\n                   * @param {Function|Object} [callbacks] Optional. May include `onStop`\n                   * and `onReady` callbacks. If there is an error, it is passed as an\n                   * argument to `onStop`. If a function is passed instead of an object, it\n                   * is interpreted as an `onReady` callback.\n                   */\n\n                }, {\n                  key: \"subscribe\",\n                  value: function subscribe(name\n                  /* .. [arguments] .. (callback|callbacks) */\n                  ) {\n                    var self = this;\n\n                    var params = _slice.call(arguments, 1);\n\n                    var callbacks = Object.create(null);\n\n                    if (params.length) {\n                      var lastParam = params[params.length - 1];\n\n                      if (typeof lastParam === 'function') {\n                        callbacks.onReady = params.pop();\n                      } else if (lastParam && [lastParam.onReady, // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n                      // onStop with an error callback instead.\n                      lastParam.onError, lastParam.onStop].some(function (f) {\n                        return typeof f === \"function\";\n                      })) {\n                        callbacks = params.pop();\n                      }\n                    } // Is there an existing sub with the same name and param, run in an\n                    // invalidated Computation? This will happen if we are rerunning an\n                    // existing computation.\n                    //\n                    // For example, consider a rerun of:\n                    //\n                    //     Tracker.autorun(function () {\n                    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));\n                    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));\n                    //     });\n                    //\n                    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"\n                    // subcribe to an existing inactive subscription in order to not\n                    // unsub and resub the subscription unnecessarily.\n                    //\n                    // We only look for one such sub; if there are N apparently-identical subs\n                    // being invalidated, we will require N matching subscribe calls to keep\n                    // them all active.\n\n\n                    var existing;\n\n                    _keys(self._subscriptions).some(function (id) {\n                      var sub = self._subscriptions[id];\n\n                      if (sub.inactive && sub.name === name && _EJSON.equals(sub.params, params)) {\n                        return existing = sub;\n                      }\n                    });\n\n                    var id;\n\n                    if (existing) {\n                      id = existing.id;\n                      existing.inactive = false; // reactivate\n\n                      if (callbacks.onReady) {\n                        // If the sub is not already ready, replace any ready callback with the\n                        // one provided now. (It's not really clear what users would expect for\n                        // an onReady callback inside an autorun; the semantics we provide is\n                        // that at the time the sub first becomes ready, we call the last\n                        // onReady callback provided, if any.)\n                        // If the sub is already ready, run the ready callback right away.\n                        // It seems that users would expect an onReady callback inside an\n                        // autorun to trigger once the the sub first becomes ready and also\n                        // when re-subs happens.\n                        if (existing.ready) {\n                          callbacks.onReady();\n                        } else {\n                          existing.readyCallback = callbacks.onReady;\n                        }\n                      } // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call\n                      // onStop with an optional error argument\n\n\n                      if (callbacks.onError) {\n                        // Replace existing callback if any, so that errors aren't\n                        // double-reported.\n                        existing.errorCallback = callbacks.onError;\n                      }\n\n                      if (callbacks.onStop) {\n                        existing.stopCallback = callbacks.onStop;\n                      }\n                    } else {\n                      // New sub! Generate an id, save it locally, and send message.\n                      id = _Random.id();\n                      self._subscriptions[id] = {\n                        id: id,\n                        name: name,\n                        params: _EJSON.clone(params),\n                        inactive: false,\n                        ready: false,\n                        readyDeps: new _Tracker.Dependency(),\n                        readyCallback: callbacks.onReady,\n                        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n                        errorCallback: callbacks.onError,\n                        stopCallback: callbacks.onStop,\n                        connection: self,\n                        remove: function remove() {\n                          delete this.connection._subscriptions[this.id];\n                          this.ready && this.readyDeps.changed();\n                        },\n                        stop: function stop() {\n                          this.connection._send({\n                            msg: 'unsub',\n                            id: id\n                          });\n\n                          this.remove();\n\n                          if (callbacks.onStop) {\n                            callbacks.onStop();\n                          }\n                        }\n                      };\n\n                      self._send({\n                        msg: 'sub',\n                        id: id,\n                        name: name,\n                        params: params\n                      });\n                    } // return a handle to the application.\n\n\n                    var handle = {\n                      stop: function stop() {\n                        if (!_hasOwn.call(self._subscriptions, id)) {\n                          return;\n                        }\n\n                        self._subscriptions[id].stop();\n                      },\n                      ready: function ready() {\n                        // return false if we've unsubscribed.\n                        if (!_hasOwn.call(self._subscriptions, id)) {\n                          return false;\n                        }\n\n                        var record = self._subscriptions[id];\n                        record.readyDeps.depend();\n                        return record.ready;\n                      },\n                      subscriptionId: id\n                    };\n\n                    if (_Tracker.active) {\n                      // We're in a reactive computation, so we'd like to unsubscribe when the\n                      // computation is invalidated... but not if the rerun just re-subscribes\n                      // to the same subscription!  When a rerun happens, we use onInvalidate\n                      // as a change to mark the subscription \"inactive\" so that it can\n                      // be reused from the rerun.  If it isn't reused, it's killed from\n                      // an afterFlush.\n                      _Tracker.onInvalidate(function (c) {\n                        if (_hasOwn.call(self._subscriptions, id)) {\n                          self._subscriptions[id].inactive = true;\n                        }\n\n                        _Tracker.afterFlush(function () {\n                          if (_hasOwn.call(self._subscriptions, id) && self._subscriptions[id].inactive) {\n                            handle.stop();\n                          }\n                        });\n                      });\n                    }\n\n                    return handle;\n                  } // options:\n                  // - onLateError {Function(error)} called if an error was received after the ready event.\n                  //     (errors received before ready cause an error to be thrown)\n\n                }, {\n                  key: \"_subscribeAndWait\",\n                  value: function _subscribeAndWait(name, args, options) {\n                    var self = this;\n                    var f = new Future();\n                    var ready = false;\n                    var handle;\n                    args = args || [];\n                    args.push({\n                      onReady: function onReady() {\n                        ready = true;\n                        f['return']();\n                      },\n                      onError: function onError(e) {\n                        if (!ready) f['throw'](e);else options && options.onLateError && options.onLateError(e);\n                      }\n                    });\n                    handle = self.subscribe.apply(self, [name].concat(args));\n                    f.wait();\n                    return handle;\n                  }\n                }, {\n                  key: \"methods\",\n                  value: function methods(_methods) {\n                    var _this = this;\n\n                    _keys(_methods).forEach(function (name) {\n                      var func = _methods[name];\n\n                      if (typeof func !== 'function') {\n                        throw new Error(\"Method '\" + name + \"' must be a function\");\n                      }\n\n                      if (_this._methodHandlers[name]) {\n                        throw new Error(\"A method named '\" + name + \"' is already defined\");\n                      }\n\n                      _this._methodHandlers[name] = func;\n                    });\n                  }\n                  /**\n                   * @memberOf Meteor\n                   * @importFromPackage meteor\n                   * @alias Meteor.call\n                   * @summary Invokes a method passing any number of arguments.\n                   * @locus Anywhere\n                   * @param {String} name Name of method to invoke\n                   * @param {EJSONable} [arg1,arg2...] Optional method arguments\n                   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n                   */\n\n                }, {\n                  key: \"call\",\n                  value: function call(name\n                  /* .. [arguments] .. callback */\n                  ) {\n                    // if it's a function, the last argument is the result callback,\n                    // not a parameter to the remote method.\n                    var args = _slice.call(arguments, 1);\n\n                    if (args.length && typeof args[args.length - 1] === 'function') var callback = args.pop();\n                    return this.apply(name, args, callback);\n                  }\n                  /**\n                   * @memberOf Meteor\n                   * @importFromPackage meteor\n                   * @alias Meteor.apply\n                   * @summary Invoke a method passing an array of arguments.\n                   * @locus Anywhere\n                   * @param {String} name Name of method to invoke\n                   * @param {EJSONable[]} args Method arguments\n                   * @param {Object} [options]\n                   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n                   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n                   * @param {Boolean} options.noRetry (Client only) if true, don't send this method again on reload, simply call the callback an error with the error code 'invocation-failed'.\n                   * @param {Boolean} options.throwStubExceptions (Client only) If true, exceptions thrown by method stubs will be thrown instead of logged, and the method will not be invoked on the server.\n                   * @param {Boolean} options.returnStubValue (Client only) If true then in cases where we would have otherwise discarded the stub's return value and returned undefined, instead we go ahead and return it. Specifically, this is any time other than when (a) we are already inside a stub or (b) we are in Node and no callback was provided. Currently we require this flag to be explicitly passed to reduce the likelihood that stub return values will be confused with server return values; we may improve this in future.\n                   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).\n                   */\n\n                }, {\n                  key: \"apply\",\n                  value: function apply(name, args, options, callback) {\n                    var self = this; // We were passed 3 arguments. They may be either (name, args, options)\n                    // or (name, args, callback)\n\n                    if (!callback && typeof options === 'function') {\n                      callback = options;\n                      options = Object.create(null);\n                    }\n\n                    options = options || Object.create(null);\n\n                    if (callback) {\n                      // XXX would it be better form to do the binding in stream.on,\n                      // or caller, instead of here?\n                      // XXX improve error message (and how we report it)\n                      callback = _Meteor2.bindEnvironment(callback, \"delivering result of invoking '\" + name + \"'\");\n                    } // Keep our args safe from mutation (eg if we don't send the message for a\n                    // while because of a wait method).\n\n\n                    args = _EJSON.clone(args);\n\n                    var enclosing = _DDP2._CurrentMethodInvocation.get();\n\n                    var alreadyInSimulation = enclosing && enclosing.isSimulation; // Lazily generate a randomSeed, only if it is requested by the stub.\n                    // The random streams only have utility if they're used on both the client\n                    // and the server; if the client doesn't generate any 'random' values\n                    // then we don't expect the server to generate any either.\n                    // Less commonly, the server may perform different actions from the client,\n                    // and may in fact generate values where the client did not, but we don't\n                    // have any client-side values to match, so even here we may as well just\n                    // use a random seed on the server.  In that case, we don't pass the\n                    // randomSeed to save bandwidth, and we don't even generate it to save a\n                    // bit of CPU and to avoid consuming entropy.\n\n                    var randomSeed = null;\n\n                    var randomSeedGenerator = function randomSeedGenerator() {\n                      if (randomSeed === null) {\n                        randomSeed = _DDPCommon.makeRpcSeed(enclosing, name);\n                      }\n\n                      return randomSeed;\n                    }; // Run the stub, if we have one. The stub is supposed to make some\n                    // temporary writes to the database to give the user a smooth experience\n                    // until the actual result of executing the method comes back from the\n                    // server (whereupon the temporary writes to the database will be reversed\n                    // during the beginUpdate/endUpdate process.)\n                    //\n                    // Normally, we ignore the return value of the stub (even if it is an\n                    // exception), in favor of the real return value from the server. The\n                    // exception is if the *caller* is a stub. In that case, we're not going\n                    // to do a RPC, so we use the return value of the stub as our return\n                    // value.\n\n\n                    var stub = self._methodHandlers[name];\n\n                    if (stub) {\n                      var setUserId = function setUserId(userId) {\n                        self.setUserId(userId);\n                      };\n\n                      var invocation = new _DDPCommon.MethodInvocation({\n                        isSimulation: true,\n                        userId: self.userId(),\n                        setUserId: setUserId,\n                        randomSeed: function randomSeed() {\n                          return randomSeedGenerator();\n                        }\n                      });\n                      if (!alreadyInSimulation) self._saveOriginals();\n\n                      try {\n                        // Note that unlike in the corresponding server code, we never audit\n                        // that stubs check() their arguments.\n                        var stubReturnValue = _DDP2._CurrentMethodInvocation.withValue(invocation, function () {\n                          if (_Meteor2.isServer) {\n                            // Because saveOriginals and retrieveOriginals aren't reentrant,\n                            // don't allow stubs to yield.\n                            return _Meteor2._noYieldsAllowed(function () {\n                              // re-clone, so that the stub can't affect our caller's values\n                              return stub.apply(invocation, _EJSON.clone(args));\n                            });\n                          } else {\n                            return stub.apply(invocation, _EJSON.clone(args));\n                          }\n                        });\n                      } catch (e) {\n                        var exception = e;\n                      }\n                    } // If we're in a simulation, stop and return the result we have,\n                    // rather than going on to do an RPC. If there was no stub,\n                    // we'll end up returning undefined.\n\n\n                    if (alreadyInSimulation) {\n                      if (callback) {\n                        callback(exception, stubReturnValue);\n                        return undefined;\n                      }\n\n                      if (exception) throw exception;\n                      return stubReturnValue;\n                    } // We only create the methodId here because we don't actually need one if\n                    // we're already in a simulation\n\n\n                    var methodId = '' + self._nextMethodId++;\n\n                    if (stub) {\n                      self._retrieveAndStoreOriginals(methodId);\n                    } // Generate the DDP message for the method call. Note that on the client,\n                    // it is important that the stub have finished before we send the RPC, so\n                    // that we know we have a complete list of which local documents the stub\n                    // wrote.\n\n\n                    var message = {\n                      msg: 'method',\n                      method: name,\n                      params: args,\n                      id: methodId\n                    }; // If an exception occurred in a stub, and we're ignoring it\n                    // because we're doing an RPC and want to use what the server\n                    // returns instead, log it so the developer knows\n                    // (unless they explicitly ask to see the error).\n                    //\n                    // Tests can set the '_expectedByTest' flag on an exception so it won't\n                    // go to log.\n\n                    if (exception) {\n                      if (options.throwStubExceptions) {\n                        throw exception;\n                      } else if (!exception._expectedByTest) {\n                        _Meteor2._debug(\"Exception while simulating the effect of invoking '\" + name + \"'\", exception);\n                      }\n                    } // At this point we're definitely doing an RPC, and we're going to\n                    // return the value of the RPC to the caller.\n                    // If the caller didn't give a callback, decide what to do.\n\n\n                    if (!callback) {\n                      if (_Meteor2.isClient) {\n                        // On the client, we don't have fibers, so we can't block. The\n                        // only thing we can do is to return undefined and discard the\n                        // result of the RPC. If an error occurred then print the error\n                        // to the console.\n                        callback = function callback(err) {\n                          err && _Meteor2._debug(\"Error invoking Method '\" + name + \"'\", err);\n                        };\n                      } else {\n                        // On the server, make the function synchronous. Throw on\n                        // errors, return on success.\n                        var future = new Future();\n                        callback = future.resolver();\n                      }\n                    } // Send the randomSeed only if we used it\n\n\n                    if (randomSeed !== null) {\n                      message.randomSeed = randomSeed;\n                    }\n\n                    var methodInvoker = new MethodInvoker({\n                      methodId: methodId,\n                      callback: callback,\n                      connection: self,\n                      onResultReceived: options.onResultReceived,\n                      wait: !!options.wait,\n                      message: message,\n                      noRetry: !!options.noRetry\n                    });\n\n                    if (options.wait) {\n                      // It's a wait method! Wait methods go in their own block.\n                      self._outstandingMethodBlocks.push({\n                        wait: true,\n                        methods: [methodInvoker]\n                      });\n                    } else {\n                      // Not a wait method. Start a new block if the previous block was a wait\n                      // block, and add it to the last block of methods.\n                      if (_isEmpty(self._outstandingMethodBlocks) || _last(self._outstandingMethodBlocks).wait) {\n                        self._outstandingMethodBlocks.push({\n                          wait: false,\n                          methods: []\n                        });\n                      }\n\n                      _last(self._outstandingMethodBlocks).methods.push(methodInvoker);\n                    } // If we added it to the first block, send it out now.\n\n\n                    if (self._outstandingMethodBlocks.length === 1) methodInvoker.sendMessage(); // If we're using the default callback on the server,\n                    // block waiting for the result.\n\n                    if (future) {\n                      return future.wait();\n                    }\n\n                    return options.returnStubValue ? stubReturnValue : undefined;\n                  } // Before calling a method stub, prepare all stores to track changes and allow\n                  // _retrieveAndStoreOriginals to get the original versions of changed\n                  // documents.\n\n                }, {\n                  key: \"_saveOriginals\",\n                  value: function _saveOriginals() {\n                    var _this2 = this;\n\n                    if (!this._waitingForQuiescence()) {\n                      this._flushBufferedWrites();\n                    }\n\n                    _keys(this._stores).forEach(function (storeName) {\n                      _this2._stores[storeName].saveOriginals();\n                    });\n                  } // Retrieves the original versions of all documents modified by the stub for\n                  // method 'methodId' from all stores and saves them to _serverDocuments (keyed\n                  // by document) and _documentsWrittenByStub (keyed by method ID).\n\n                }, {\n                  key: \"_retrieveAndStoreOriginals\",\n                  value: function _retrieveAndStoreOriginals(methodId) {\n                    var self = this;\n                    if (self._documentsWrittenByStub[methodId]) throw new Error('Duplicate methodId in _retrieveAndStoreOriginals');\n                    var docsWritten = [];\n\n                    _keys(self._stores).forEach(function (collection) {\n                      var originals = self._stores[collection].retrieveOriginals(); // not all stores define retrieveOriginals\n\n\n                      if (!originals) return;\n                      originals.forEach(function (doc, id) {\n                        docsWritten.push({\n                          collection: collection,\n                          id: id\n                        });\n\n                        if (!_hasOwn.call(self._serverDocuments, collection)) {\n                          self._serverDocuments[collection] = new MongoIDMap();\n                        }\n\n                        var serverDoc = self._serverDocuments[collection].setDefault(id, Object.create(null));\n\n                        if (serverDoc.writtenByStubs) {\n                          // We're not the first stub to write this doc. Just add our method ID\n                          // to the record.\n                          serverDoc.writtenByStubs[methodId] = true;\n                        } else {\n                          // First stub! Save the original value and our method ID.\n                          serverDoc.document = doc;\n                          serverDoc.flushCallbacks = [];\n                          serverDoc.writtenByStubs = Object.create(null);\n                          serverDoc.writtenByStubs[methodId] = true;\n                        }\n                      });\n                    });\n\n                    if (!_isEmpty(docsWritten)) {\n                      self._documentsWrittenByStub[methodId] = docsWritten;\n                    }\n                  } // This is very much a private function we use to make the tests\n                  // take up fewer server resources after they complete.\n\n                }, {\n                  key: \"_unsubscribeAll\",\n                  value: function _unsubscribeAll() {\n                    var _this3 = this;\n\n                    _keys(this._subscriptions).forEach(function (id) {\n                      var sub = _this3._subscriptions[id]; // Avoid killing the autoupdate subscription so that developers\n                      // still get hot code pushes when writing tests.\n                      //\n                      // XXX it's a hack to encode knowledge about autoupdate here,\n                      // but it doesn't seem worth it yet to have a special API for\n                      // subscriptions to preserve after unit tests.\n\n                      if (sub.name !== 'meteor_autoupdate_clientVersions') {\n                        sub.stop();\n                      }\n                    });\n                  } // Sends the DDP stringification of the given message object\n\n                }, {\n                  key: \"_send\",\n                  value: function _send(obj) {\n                    this._stream.send(_DDPCommon.stringifyDDP(obj));\n                  } // We detected via DDP-level heartbeats that we've lost the\n                  // connection.  Unlike `disconnect` or `close`, a lost connection\n                  // will be automatically retried.\n\n                }, {\n                  key: \"_lostConnection\",\n                  value: function _lostConnection(error) {\n                    this._stream._lostConnection(error);\n                  }\n                  /**\n                   * @memberOf Meteor\n                   * @importFromPackage meteor\n                   * @alias Meteor.status\n                   * @summary Get the current connection status. A reactive data source.\n                   * @locus Client\n                   */\n\n                }, {\n                  key: \"status\",\n                  value: function status() {\n                    var _this$_stream;\n\n                    return (_this$_stream = this._stream).status.apply(_this$_stream, arguments);\n                  }\n                  /**\n                   * @summary Force an immediate reconnection attempt if the client is not connected to the server.\n                   This method does nothing if the client is already connected.\n                   * @memberOf Meteor\n                   * @importFromPackage meteor\n                   * @alias Meteor.reconnect\n                   * @locus Client\n                   */\n\n                }, {\n                  key: \"reconnect\",\n                  value: function reconnect() {\n                    var _this$_stream2;\n\n                    return (_this$_stream2 = this._stream).reconnect.apply(_this$_stream2, arguments);\n                  }\n                  /**\n                   * @memberOf Meteor\n                   * @importFromPackage meteor\n                   * @alias Meteor.disconnect\n                   * @summary Disconnect the client from the server.\n                   * @locus Client\n                   */\n\n                }, {\n                  key: \"disconnect\",\n                  value: function disconnect() {\n                    var _this$_stream3;\n\n                    return (_this$_stream3 = this._stream).disconnect.apply(_this$_stream3, arguments);\n                  }\n                }, {\n                  key: \"close\",\n                  value: function close() {\n                    return this._stream.disconnect({\n                      _permanent: true\n                    });\n                  } ///\n                  /// Reactive user system\n                  ///\n\n                }, {\n                  key: \"userId\",\n                  value: function userId() {\n                    if (this._userIdDeps) this._userIdDeps.depend();\n                    return this._userId;\n                  }\n                }, {\n                  key: \"setUserId\",\n                  value: function setUserId(userId) {\n                    // Avoid invalidating dependents if setUserId is called with current value.\n                    if (this._userId === userId) return;\n                    this._userId = userId;\n                    if (this._userIdDeps) this._userIdDeps.changed();\n                  } // Returns true if we are in a state after reconnect of waiting for subs to be\n                  // revived or early methods to finish their data, or we are waiting for a\n                  // \"wait\" method to finish.\n\n                }, {\n                  key: \"_waitingForQuiescence\",\n                  value: function _waitingForQuiescence() {\n                    return !_isEmpty(this._subsBeingRevived) || !_isEmpty(this._methodsBlockingQuiescence);\n                  } // Returns true if any method whose message has been sent to the server has\n                  // not yet invoked its user callback.\n\n                }, {\n                  key: \"_anyMethodsAreOutstanding\",\n                  value: function _anyMethodsAreOutstanding() {\n                    var invokers = this._methodInvokers;\n                    return _keys(invokers).some(function (id) {\n                      return invokers[id].sentMessage;\n                    });\n                  }\n                }, {\n                  key: \"_livedata_connected\",\n                  value: function _livedata_connected(msg) {\n                    var self = this;\n\n                    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n                      self._heartbeat = new _DDPCommon.Heartbeat({\n                        heartbeatInterval: self._heartbeatInterval,\n                        heartbeatTimeout: self._heartbeatTimeout,\n                        onTimeout: function onTimeout() {\n                          self._lostConnection(new _DDP2.ConnectionError('DDP heartbeat timed out'));\n                        },\n                        sendPing: function sendPing() {\n                          self._send({\n                            msg: 'ping'\n                          });\n                        }\n                      });\n\n                      self._heartbeat.start();\n                    } // If this is a reconnect, we'll have to reset all stores.\n\n\n                    if (self._lastSessionId) self._resetStores = true;\n\n                    if (typeof msg.session === 'string') {\n                      var reconnectedToPreviousSession = self._lastSessionId === msg.session;\n                      self._lastSessionId = msg.session;\n                    }\n\n                    if (reconnectedToPreviousSession) {\n                      // Successful reconnection -- pick up where we left off.  Note that right\n                      // now, this never happens: the server never connects us to a previous\n                      // session, because DDP doesn't provide enough data for the server to know\n                      // what messages the client has processed. We need to improve DDP to make\n                      // this possible, at which point we'll probably need more code here.\n                      return;\n                    } // Server doesn't have our data any more. Re-sync a new session.\n                    // Forget about messages we were buffering for unknown collections. They'll\n                    // be resent if still relevant.\n\n\n                    self._updatesForUnknownStores = Object.create(null);\n\n                    if (self._resetStores) {\n                      // Forget about the effects of stubs. We'll be resetting all collections\n                      // anyway.\n                      self._documentsWrittenByStub = Object.create(null);\n                      self._serverDocuments = Object.create(null);\n                    } // Clear _afterUpdateCallbacks.\n\n\n                    self._afterUpdateCallbacks = []; // Mark all named subscriptions which are ready (ie, we already called the\n                    // ready callback) as needing to be revived.\n                    // XXX We should also block reconnect quiescence until unnamed subscriptions\n                    //     (eg, autopublish) are done re-publishing to avoid flicker!\n\n                    self._subsBeingRevived = Object.create(null);\n\n                    _keys(self._subscriptions).forEach(function (id) {\n                      if (self._subscriptions[id].ready) {\n                        self._subsBeingRevived[id] = true;\n                      }\n                    }); // Arrange for \"half-finished\" methods to have their callbacks run, and\n                    // track methods that were sent on this connection so that we don't\n                    // quiesce until they are all done.\n                    //\n                    // Start by clearing _methodsBlockingQuiescence: methods sent before\n                    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n                    // that we drop here will be restored by the loop below.\n\n\n                    self._methodsBlockingQuiescence = Object.create(null);\n\n                    if (self._resetStores) {\n                      var invokers = self._methodInvokers;\n\n                      _keys(invokers).forEach(function (id) {\n                        var invoker = invokers[id];\n\n                        if (invoker.gotResult()) {\n                          // This method already got its result, but it didn't call its callback\n                          // because its data didn't become visible. We did not resend the\n                          // method RPC. We'll call its callback when we get a full quiesce,\n                          // since that's as close as we'll get to \"data must be visible\".\n                          self._afterUpdateCallbacks.push(function () {\n                            return invoker.dataVisible.apply(invoker, arguments);\n                          });\n                        } else if (invoker.sentMessage) {\n                          // This method has been sent on this connection (maybe as a resend\n                          // from the last connection, maybe from onReconnect, maybe just very\n                          // quickly before processing the connected message).\n                          //\n                          // We don't need to do anything special to ensure its callbacks get\n                          // called, but we'll count it as a method which is preventing\n                          // reconnect quiescence. (eg, it might be a login method that was run\n                          // from onReconnect, and we don't want to see flicker by seeing a\n                          // logged-out state.)\n                          self._methodsBlockingQuiescence[invoker.methodId] = true;\n                        }\n                      });\n                    }\n\n                    self._messagesBufferedUntilQuiescence = []; // If we're not waiting on any methods or subs, we can reset the stores and\n                    // call the callbacks immediately.\n\n                    if (!self._waitingForQuiescence()) {\n                      if (self._resetStores) {\n                        _keys(self._stores).forEach(function (storeName) {\n                          var s = self._stores[storeName];\n                          s.beginUpdate(0, true);\n                          s.endUpdate();\n                        });\n\n                        self._resetStores = false;\n                      }\n\n                      self._runAfterUpdateCallbacks();\n                    }\n                  }\n                }, {\n                  key: \"_processOneDataMessage\",\n                  value: function _processOneDataMessage(msg, updates) {\n                    var messageType = msg.msg; // msg is one of ['added', 'changed', 'removed', 'ready', 'updated']\n\n                    if (messageType === 'added') {\n                      this._process_added(msg, updates);\n                    } else if (messageType === 'changed') {\n                      this._process_changed(msg, updates);\n                    } else if (messageType === 'removed') {\n                      this._process_removed(msg, updates);\n                    } else if (messageType === 'ready') {\n                      this._process_ready(msg, updates);\n                    } else if (messageType === 'updated') {\n                      this._process_updated(msg, updates);\n                    } else if (messageType === 'nosub') {// ignore this\n                    } else {\n                      _Meteor2._debug('discarding unknown livedata data message type', msg);\n                    }\n                  }\n                }, {\n                  key: \"_livedata_data\",\n                  value: function _livedata_data(msg) {\n                    var self = this;\n\n                    if (self._waitingForQuiescence()) {\n                      self._messagesBufferedUntilQuiescence.push(msg);\n\n                      if (msg.msg === 'nosub') {\n                        delete self._subsBeingRevived[msg.id];\n                      }\n\n                      if (msg.subs) {\n                        msg.subs.forEach(function (subId) {\n                          delete self._subsBeingRevived[subId];\n                        });\n                      }\n\n                      if (msg.methods) {\n                        msg.methods.forEach(function (methodId) {\n                          delete self._methodsBlockingQuiescence[methodId];\n                        });\n                      }\n\n                      if (self._waitingForQuiescence()) {\n                        return;\n                      } // No methods or subs are blocking quiescence!\n                      // We'll now process and all of our buffered messages, reset all stores,\n                      // and apply them all at once.\n\n\n                      var bufferedMessages = self._messagesBufferedUntilQuiescence;\n\n                      _keys(bufferedMessages).forEach(function (id) {\n                        self._processOneDataMessage(bufferedMessages[id], self._bufferedWrites);\n                      });\n\n                      self._messagesBufferedUntilQuiescence = [];\n                    } else {\n                      self._processOneDataMessage(msg, self._bufferedWrites);\n                    } // Immediately flush writes when:\n                    //  1. Buffering is disabled. Or;\n                    //  2. any non-(added/changed/removed) message arrives.\n\n\n                    var standardWrite = msg.msg === \"added\" || msg.msg === \"changed\" || msg.msg === \"removed\";\n\n                    if (self._bufferedWritesInterval === 0 || !standardWrite) {\n                      self._flushBufferedWrites();\n\n                      return;\n                    }\n\n                    if (self._bufferedWritesFlushAt === null) {\n                      self._bufferedWritesFlushAt = new Date().valueOf() + self._bufferedWritesMaxAge;\n                    } else if (self._bufferedWritesFlushAt < new Date().valueOf()) {\n                      self._flushBufferedWrites();\n\n                      return;\n                    }\n\n                    if (self._bufferedWritesFlushHandle) {\n                      clearTimeout(self._bufferedWritesFlushHandle);\n                    }\n\n                    self._bufferedWritesFlushHandle = setTimeout(self.__flushBufferedWrites, self._bufferedWritesInterval);\n                  }\n                }, {\n                  key: \"_flushBufferedWrites\",\n                  value: function _flushBufferedWrites() {\n                    var self = this;\n\n                    if (self._bufferedWritesFlushHandle) {\n                      clearTimeout(self._bufferedWritesFlushHandle);\n                      self._bufferedWritesFlushHandle = null;\n                    }\n\n                    self._bufferedWritesFlushAt = null; // We need to clear the buffer before passing it to\n                    //  performWrites. As there's no guarantee that it\n                    //  will exit cleanly.\n\n                    var writes = self._bufferedWrites;\n                    self._bufferedWrites = Object.create(null);\n\n                    self._performWrites(writes);\n                  }\n                }, {\n                  key: \"_performWrites\",\n                  value: function _performWrites(updates) {\n                    var self = this;\n\n                    if (self._resetStores || !_isEmpty(updates)) {\n                      // Begin a transactional update of each store.\n                      _keys(self._stores).forEach(function (storeName) {\n                        self._stores[storeName].beginUpdate(_hasOwn.call(updates, storeName) ? updates[storeName].length : 0, self._resetStores);\n                      });\n\n                      self._resetStores = false;\n\n                      _keys(updates).forEach(function (storeName) {\n                        var updateMessages = updates[storeName];\n                        var store = self._stores[storeName];\n\n                        if (store) {\n                          updateMessages.forEach(function (updateMessage) {\n                            store.update(updateMessage);\n                          });\n                        } else {\n                          var _updates$storeName;\n\n                          // Nobody's listening for this data. Queue it up until\n                          // someone wants it.\n                          // XXX memory use will grow without bound if you forget to\n                          // create a collection or just don't care about it... going\n                          // to have to do something about that.\n                          var _updates = self._updatesForUnknownStores;\n\n                          if (!_hasOwn.call(_updates, storeName)) {\n                            _updates[storeName] = [];\n                          }\n\n                          (_updates$storeName = _updates[storeName]).push.apply(_updates$storeName, _toConsumableArray(updateMessages));\n                        }\n                      }); // End update transaction.\n\n\n                      _keys(self._stores).forEach(function (storeName) {\n                        self._stores[storeName].endUpdate();\n                      });\n                    }\n\n                    self._runAfterUpdateCallbacks();\n                  } // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\n                  // relevant docs have been flushed, as well as dataVisible callbacks at\n                  // reconnect-quiescence time.\n\n                }, {\n                  key: \"_runAfterUpdateCallbacks\",\n                  value: function _runAfterUpdateCallbacks() {\n                    var self = this;\n                    var callbacks = self._afterUpdateCallbacks;\n                    self._afterUpdateCallbacks = [];\n                    callbacks.forEach(function (c) {\n                      c();\n                    });\n                  }\n                }, {\n                  key: \"_pushUpdate\",\n                  value: function _pushUpdate(updates, collection, msg) {\n                    if (!_hasOwn.call(updates, collection)) {\n                      updates[collection] = [];\n                    }\n\n                    updates[collection].push(msg);\n                  }\n                }, {\n                  key: \"_getServerDoc\",\n                  value: function _getServerDoc(collection, id) {\n                    var self = this;\n\n                    if (!_hasOwn.call(self._serverDocuments, collection)) {\n                      return null;\n                    }\n\n                    var serverDocsForCollection = self._serverDocuments[collection];\n                    return serverDocsForCollection.get(id) || null;\n                  }\n                }, {\n                  key: \"_process_added\",\n                  value: function _process_added(msg, updates) {\n                    var self = this;\n\n                    var id = _MongoID.idParse(msg.id);\n\n                    var serverDoc = self._getServerDoc(msg.collection, id);\n\n                    if (serverDoc) {\n                      // Some outstanding stub wrote here.\n                      var isExisting = serverDoc.document !== undefined;\n                      serverDoc.document = msg.fields || Object.create(null);\n                      serverDoc.document._id = id;\n\n                      if (self._resetStores) {\n                        // During reconnect the server is sending adds for existing ids.\n                        // Always push an update so that document stays in the store after\n                        // reset. Use current version of the document for this update, so\n                        // that stub-written values are preserved.\n                        var currentDoc = self._stores[msg.collection].getDoc(msg.id);\n\n                        if (currentDoc !== undefined) msg.fields = currentDoc;\n\n                        self._pushUpdate(updates, msg.collection, msg);\n                      } else if (isExisting) {\n                        throw new Error('Server sent add for existing id: ' + msg.id);\n                      }\n                    } else {\n                      self._pushUpdate(updates, msg.collection, msg);\n                    }\n                  }\n                }, {\n                  key: \"_process_changed\",\n                  value: function _process_changed(msg, updates) {\n                    var self = this;\n\n                    var serverDoc = self._getServerDoc(msg.collection, _MongoID.idParse(msg.id));\n\n                    if (serverDoc) {\n                      if (serverDoc.document === undefined) throw new Error('Server sent changed for nonexisting id: ' + msg.id);\n                      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n                    } else {\n                      self._pushUpdate(updates, msg.collection, msg);\n                    }\n                  }\n                }, {\n                  key: \"_process_removed\",\n                  value: function _process_removed(msg, updates) {\n                    var self = this;\n\n                    var serverDoc = self._getServerDoc(msg.collection, _MongoID.idParse(msg.id));\n\n                    if (serverDoc) {\n                      // Some outstanding stub wrote here.\n                      if (serverDoc.document === undefined) throw new Error('Server sent removed for nonexisting id:' + msg.id);\n                      serverDoc.document = undefined;\n                    } else {\n                      self._pushUpdate(updates, msg.collection, {\n                        msg: 'removed',\n                        collection: msg.collection,\n                        id: msg.id\n                      });\n                    }\n                  }\n                }, {\n                  key: \"_process_updated\",\n                  value: function _process_updated(msg, updates) {\n                    var self = this; // Process \"method done\" messages.\n\n                    msg.methods.forEach(function (methodId) {\n                      var docs = self._documentsWrittenByStub[methodId];\n\n                      _keys(docs).forEach(function (id) {\n                        var written = docs[id];\n\n                        var serverDoc = self._getServerDoc(written.collection, written.id);\n\n                        if (!serverDoc) {\n                          throw new Error('Lost serverDoc for ' + JSON.stringify(written));\n                        }\n\n                        if (!serverDoc.writtenByStubs[methodId]) {\n                          throw new Error('Doc ' + JSON.stringify(written) + ' not written by  method ' + methodId);\n                        }\n\n                        delete serverDoc.writtenByStubs[methodId];\n\n                        if (_isEmpty(serverDoc.writtenByStubs)) {\n                          // All methods whose stubs wrote this method have completed! We can\n                          // now copy the saved document to the database (reverting the stub's\n                          // change if the server did not write to this object, or applying the\n                          // server's writes if it did).\n                          // This is a fake ddp 'replace' message.  It's just for talking\n                          // between livedata connections and minimongo.  (We have to stringify\n                          // the ID because it's supposed to look like a wire message.)\n                          self._pushUpdate(updates, written.collection, {\n                            msg: 'replace',\n                            id: _MongoID.idStringify(written.id),\n                            replace: serverDoc.document\n                          }); // Call all flush callbacks.\n\n\n                          serverDoc.flushCallbacks.forEach(function (c) {\n                            c();\n                          }); // Delete this completed serverDocument. Don't bother to GC empty\n                          // IdMaps inside self._serverDocuments, since there probably aren't\n                          // many collections and they'll be written repeatedly.\n\n                          self._serverDocuments[written.collection].remove(written.id);\n                        }\n                      });\n\n                      delete self._documentsWrittenByStub[methodId]; // We want to call the data-written callback, but we can't do so until all\n                      // currently buffered messages are flushed.\n\n                      var callbackInvoker = self._methodInvokers[methodId];\n\n                      if (!callbackInvoker) {\n                        throw new Error('No callback invoker for method ' + methodId);\n                      }\n\n                      self._runWhenAllServerDocsAreFlushed(function () {\n                        return callbackInvoker.dataVisible.apply(callbackInvoker, arguments);\n                      });\n                    });\n                  }\n                }, {\n                  key: \"_process_ready\",\n                  value: function _process_ready(msg, updates) {\n                    var self = this; // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n                    // until all current server documents have been flushed to the local\n                    // database. We can use a write fence to implement this.\n\n                    msg.subs.forEach(function (subId) {\n                      self._runWhenAllServerDocsAreFlushed(function () {\n                        var subRecord = self._subscriptions[subId]; // Did we already unsubscribe?\n\n                        if (!subRecord) return; // Did we already receive a ready message? (Oops!)\n\n                        if (subRecord.ready) return;\n                        subRecord.ready = true;\n                        subRecord.readyCallback && subRecord.readyCallback();\n                        subRecord.readyDeps.changed();\n                      });\n                    });\n                  } // Ensures that \"f\" will be called after all documents currently in\n                  // _serverDocuments have been written to the local cache. f will not be called\n                  // if the connection is lost before then!\n\n                }, {\n                  key: \"_runWhenAllServerDocsAreFlushed\",\n                  value: function _runWhenAllServerDocsAreFlushed(f) {\n                    var self = this;\n\n                    var runFAfterUpdates = function runFAfterUpdates() {\n                      self._afterUpdateCallbacks.push(f);\n                    };\n\n                    var unflushedServerDocCount = 0;\n\n                    var onServerDocFlush = function onServerDocFlush() {\n                      --unflushedServerDocCount;\n\n                      if (unflushedServerDocCount === 0) {\n                        // This was the last doc to flush! Arrange to run f after the updates\n                        // have been applied.\n                        runFAfterUpdates();\n                      }\n                    };\n\n                    _keys(self._serverDocuments).forEach(function (collection) {\n                      self._serverDocuments[collection].forEach(function (serverDoc) {\n                        var writtenByStubForAMethodWithSentMessage = _keys(serverDoc.writtenByStubs).some(function (methodId) {\n                          var invoker = self._methodInvokers[methodId];\n                          return invoker && invoker.sentMessage;\n                        });\n\n                        if (writtenByStubForAMethodWithSentMessage) {\n                          ++unflushedServerDocCount;\n                          serverDoc.flushCallbacks.push(onServerDocFlush);\n                        }\n                      });\n                    });\n\n                    if (unflushedServerDocCount === 0) {\n                      // There aren't any buffered docs --- we can call f as soon as the current\n                      // round of updates is applied!\n                      runFAfterUpdates();\n                    }\n                  }\n                }, {\n                  key: \"_livedata_nosub\",\n                  value: function _livedata_nosub(msg) {\n                    var self = this; // First pass it through _livedata_data, which only uses it to help get\n                    // towards quiescence.\n\n                    self._livedata_data(msg); // Do the rest of our processing immediately, with no\n                    // buffering-until-quiescence.\n                    // we weren't subbed anyway, or we initiated the unsub.\n\n\n                    if (!_hasOwn.call(self._subscriptions, msg.id)) {\n                      return;\n                    } // XXX COMPAT WITH 1.0.3.1 #errorCallback\n\n\n                    var errorCallback = self._subscriptions[msg.id].errorCallback;\n                    var stopCallback = self._subscriptions[msg.id].stopCallback;\n\n                    self._subscriptions[msg.id].remove();\n\n                    var meteorErrorFromMsg = function meteorErrorFromMsg(msgArg) {\n                      return msgArg && msgArg.error && new _Meteor2.Error(msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n                    }; // XXX COMPAT WITH 1.0.3.1 #errorCallback\n\n\n                    if (errorCallback && msg.error) {\n                      errorCallback(meteorErrorFromMsg(msg));\n                    }\n\n                    if (stopCallback) {\n                      stopCallback(meteorErrorFromMsg(msg));\n                    }\n                  }\n                }, {\n                  key: \"_livedata_result\",\n                  value: function _livedata_result(msg) {\n                    // id, result or error. error has error (code), reason, details\n                    var self = this; // Lets make sure there are no buffered writes before returning result.\n\n                    if (!_isEmpty(self._bufferedWrites)) {\n                      self._flushBufferedWrites();\n                    } // find the outstanding request\n                    // should be O(1) in nearly all realistic use cases\n\n\n                    if (_isEmpty(self._outstandingMethodBlocks)) {\n                      _Meteor2._debug('Received method result but no methods outstanding');\n\n                      return;\n                    }\n\n                    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n                    var m;\n\n                    for (var i = 0; i < currentMethodBlock.length; i++) {\n                      m = currentMethodBlock[i];\n                      if (m.methodId === msg.id) break;\n                    }\n\n                    if (!m) {\n                      _Meteor2._debug(\"Can't match method response to original method call\", msg);\n\n                      return;\n                    } // Remove from current method block. This may leave the block empty, but we\n                    // don't move on to the next block until the callback has been delivered, in\n                    // _outstandingMethodFinished.\n\n\n                    currentMethodBlock.splice(i, 1);\n\n                    if (_hasOwn.call(msg, 'error')) {\n                      m.receiveResult(new _Meteor2.Error(msg.error.error, msg.error.reason, msg.error.details));\n                    } else {\n                      // msg.result may be undefined if the method didn't return a\n                      // value\n                      m.receiveResult(undefined, msg.result);\n                    }\n                  } // Called by MethodInvoker after a method's callback is invoked.  If this was\n                  // the last outstanding method in the current block, runs the next block. If\n                  // there are no more methods, consider accepting a hot code push.\n\n                }, {\n                  key: \"_outstandingMethodFinished\",\n                  value: function _outstandingMethodFinished() {\n                    var self = this;\n                    if (self._anyMethodsAreOutstanding()) return; // No methods are outstanding. This should mean that the first block of\n                    // methods is empty. (Or it might not exist, if this was a method that\n                    // half-finished before disconnect/reconnect.)\n\n                    if (!_isEmpty(self._outstandingMethodBlocks)) {\n                      var firstBlock = self._outstandingMethodBlocks.shift();\n\n                      if (!_isEmpty(firstBlock.methods)) throw new Error('No methods outstanding but nonempty block: ' + JSON.stringify(firstBlock)); // Send the outstanding methods now in the first block.\n\n                      if (!_isEmpty(self._outstandingMethodBlocks)) self._sendOutstandingMethods();\n                    } // Maybe accept a hot code push.\n\n\n                    self._maybeMigrate();\n                  } // Sends messages for all the methods in the first block in\n                  // _outstandingMethodBlocks.\n\n                }, {\n                  key: \"_sendOutstandingMethods\",\n                  value: function _sendOutstandingMethods() {\n                    var self = this;\n\n                    if (_isEmpty(self._outstandingMethodBlocks)) {\n                      return;\n                    }\n\n                    self._outstandingMethodBlocks[0].methods.forEach(function (m) {\n                      m.sendMessage();\n                    });\n                  }\n                }, {\n                  key: \"_livedata_error\",\n                  value: function _livedata_error(msg) {\n                    _Meteor2._debug('Received error from server: ', msg.reason);\n\n                    if (msg.offendingMessage) _Meteor2._debug('For: ', msg.offendingMessage);\n                  }\n                }, {\n                  key: \"_callOnReconnectAndSendAppropriateOutstandingMethods\",\n                  value: function _callOnReconnectAndSendAppropriateOutstandingMethods() {\n                    var self = this;\n                    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\n                    self._outstandingMethodBlocks = [];\n                    self.onReconnect && self.onReconnect();\n\n                    _DDP2._reconnectHook.each(function (callback) {\n                      callback(self);\n                      return true;\n                    });\n\n                    if (_isEmpty(oldOutstandingMethodBlocks)) return; // We have at least one block worth of old outstanding methods to try\n                    // again. First: did onReconnect actually send anything? If not, we just\n                    // restore all outstanding methods and run the first block.\n\n                    if (_isEmpty(self._outstandingMethodBlocks)) {\n                      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\n\n                      self._sendOutstandingMethods();\n\n                      return;\n                    } // OK, there are blocks on both sides. Special case: merge the last block of\n                    // the reconnect methods with the first block of the original methods, if\n                    // neither of them are \"wait\" blocks.\n\n\n                    if (!_last(self._outstandingMethodBlocks).wait && !oldOutstandingMethodBlocks[0].wait) {\n                      oldOutstandingMethodBlocks[0].methods.forEach(function (m) {\n                        _last(self._outstandingMethodBlocks).methods.push(m); // If this \"last block\" is also the first block, send the message.\n\n\n                        if (self._outstandingMethodBlocks.length === 1) {\n                          m.sendMessage();\n                        }\n                      });\n                      oldOutstandingMethodBlocks.shift();\n                    } // Now add the rest of the original blocks on.\n\n\n                    oldOutstandingMethodBlocks.forEach(function (block) {\n                      self._outstandingMethodBlocks.push(block);\n                    });\n                  } // We can accept a hot code push if there are no methods in flight.\n\n                }, {\n                  key: \"_readyToMigrate\",\n                  value: function _readyToMigrate() {\n                    return _isEmpty(this._methodInvokers);\n                  } // If we were blocking a migration, see if it's now possible to continue.\n                  // Call whenever the set of outstanding/blocked methods shrinks.\n\n                }, {\n                  key: \"_maybeMigrate\",\n                  value: function _maybeMigrate() {\n                    var self = this;\n\n                    if (self._retryMigrate && self._readyToMigrate()) {\n                      self._retryMigrate();\n\n                      self._retryMigrate = null;\n                    }\n                  }\n                }, {\n                  key: \"onMessage\",\n                  value: function onMessage(raw_msg) {\n                    try {\n                      var msg = _DDPCommon.parseDDP(raw_msg);\n                    } catch (e) {\n                      _Meteor2._debug('Exception while parsing DDP', e);\n\n                      return;\n                    } // Any message counts as receiving a pong, as it demonstrates that\n                    // the server is still alive.\n\n\n                    if (this._heartbeat) {\n                      this._heartbeat.messageReceived();\n                    }\n\n                    if (msg === null || !msg.msg) {\n                      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\n                      // compat.  Remove this 'if' once the server stops sending welcome\n                      // messages (stream_server.js).\n                      if (!(msg && msg.server_id)) _Meteor2._debug('discarding invalid livedata message', msg);\n                      return;\n                    }\n\n                    if (msg.msg === 'connected') {\n                      this._version = this._versionSuggestion;\n\n                      this._livedata_connected(msg);\n\n                      this.options.onConnected();\n                    } else if (msg.msg === 'failed') {\n                      if (this._supportedDDPVersions.indexOf(msg.version) >= 0) {\n                        this._versionSuggestion = msg.version;\n\n                        this._stream.reconnect({\n                          _force: true\n                        });\n                      } else {\n                        var description = 'DDP version negotiation failed; server requested version ' + msg.version;\n\n                        this._stream.disconnect({\n                          _permanent: true,\n                          _error: description\n                        });\n\n                        this.options.onDDPVersionNegotiationFailure(description);\n                      }\n                    } else if (msg.msg === 'ping' && this.options.respondToPings) {\n                      this._send({\n                        msg: 'pong',\n                        id: msg.id\n                      });\n                    } else if (msg.msg === 'pong') {// noop, as we assume everything's a pong\n                    } else if (['added', 'changed', 'removed', 'ready', 'updated'].includes(msg.msg)) {\n                      this._livedata_data(msg);\n                    } else if (msg.msg === 'nosub') {\n                      this._livedata_nosub(msg);\n                    } else if (msg.msg === 'result') {\n                      this._livedata_result(msg);\n                    } else if (msg.msg === 'error') {\n                      this._livedata_error(msg);\n                    } else {\n                      _Meteor2._debug('discarding unknown livedata message type', msg);\n                    }\n                  }\n                }, {\n                  key: \"onReset\",\n                  value: function onReset() {\n                    var _this4 = this;\n\n                    // Send a connect message at the beginning of the stream.\n                    // NOTE: reset is called even on the first connection, so this is\n                    // the only place we send this message.\n                    var msg = {\n                      msg: 'connect'\n                    };\n                    if (this._lastSessionId) msg.session = this._lastSessionId;\n                    msg.version = this._versionSuggestion || this._supportedDDPVersions[0];\n                    this._versionSuggestion = msg.version;\n                    msg.support = this._supportedDDPVersions;\n\n                    this._send(msg); // Mark non-retry calls as failed. This has to be done early as getting these methods out of the\n                    // current block is pretty important to making sure that quiescence is properly calculated, as\n                    // well as possibly moving on to another useful block.\n                    // Only bother testing if there is an outstandingMethodBlock (there might not be, especially if\n                    // we are connecting for the first time.\n\n\n                    if (this._outstandingMethodBlocks.length > 0) {\n                      // If there is an outstanding method block, we only care about the first one as that is the\n                      // one that could have already sent messages with no response, that are not allowed to retry.\n                      var currentMethodBlock = this._outstandingMethodBlocks[0].methods;\n                      this._outstandingMethodBlocks[0].methods = currentMethodBlock.filter(function (methodInvoker) {\n                        // Methods with 'noRetry' option set are not allowed to re-send after\n                        // recovering dropped connection.\n                        if (methodInvoker.sentMessage && methodInvoker.noRetry) {\n                          // Make sure that the method is told that it failed.\n                          methodInvoker.receiveResult(new _Meteor2.Error('invocation-failed', 'Method invocation might have failed due to dropped connection. ' + 'Failing because `noRetry` option was passed to Meteor.apply.'));\n                        } // Only keep a method if it wasn't sent or it's allowed to retry.\n                        // This may leave the block empty, but we don't move on to the next\n                        // block until the callback has been delivered, in _outstandingMethodFinished.\n\n\n                        return !(methodInvoker.sentMessage && methodInvoker.noRetry);\n                      });\n                    } // Now, to minimize setup latency, go ahead and blast out all of\n                    // our pending methods ands subscriptions before we've even taken\n                    // the necessary RTT to know if we successfully reconnected. (1)\n                    // They're supposed to be idempotent, and where they are not,\n                    // they can block retry in apply; (2) even if we did reconnect,\n                    // we're not sure what messages might have gotten lost\n                    // (in either direction) since we were disconnected (TCP being\n                    // sloppy about that.)\n                    // If the current block of methods all got their results (but didn't all get\n                    // their data visible), discard the empty block now.\n\n\n                    if (this._outstandingMethodBlocks.length > 0 && this._outstandingMethodBlocks[0].methods.length === 0) {\n                      this._outstandingMethodBlocks.shift();\n                    } // Mark all messages as unsent, they have not yet been sent on this\n                    // connection.\n\n\n                    _keys(this._methodInvokers).forEach(function (id) {\n                      _this4._methodInvokers[id].sentMessage = false;\n                    }); // If an `onReconnect` handler is set, call it first. Go through\n                    // some hoops to ensure that methods that are called from within\n                    // `onReconnect` get executed _before_ ones that were originally\n                    // outstanding (since `onReconnect` is used to re-establish auth\n                    // certificates)\n\n\n                    this._callOnReconnectAndSendAppropriateOutstandingMethods(); // add new subscriptions at the end. this way they take effect after\n                    // the handlers and we don't see flicker.\n\n\n                    _keys(this._subscriptions).forEach(function (id) {\n                      var sub = _this4._subscriptions[id];\n\n                      _this4._send({\n                        msg: 'sub',\n                        id: id,\n                        name: sub.name,\n                        params: sub.params\n                      });\n                    });\n                  }\n                }]);\n\n                return _Connection;\n              }(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n            },\n            \"namespace.js\": function namespaceJs(require, exports, module) {\n              /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              //                                                                                                                     //\n              // packages/ddp-client/common/namespace.js                                                                             //\n              //                                                                                                                     //\n              /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n              //\n              module.export({\n                DDP: function DDP() {\n                  return _DDP3;\n                }\n              });\n\n              var _DDPCommon2;\n\n              module.watch(require(\"meteor/ddp-common\"), {\n                DDPCommon: function DDPCommon(v) {\n                  _DDPCommon2 = v;\n                }\n              }, 0);\n\n              var _Meteor3;\n\n              module.watch(require(\"meteor/meteor\"), {\n                Meteor: function Meteor(v) {\n                  _Meteor3 = v;\n                }\n              }, 1);\n\n              var _keys2;\n\n              module.watch(require(\"meteor/ddp-common/utils.js\"), {\n                keys: function keys(v) {\n                  _keys2 = v;\n                }\n              }, 2);\n\n              var _Connection2;\n\n              module.watch(require(\"./livedata_connection.js\"), {\n                Connection: function Connection(v) {\n                  _Connection2 = v;\n                }\n              }, 3); // This array allows the `_allSubscriptionsReady` method below, which\n              // is used by the `spiderable` package, to keep track of whether all\n              // data is ready.\n\n              var allConnections = [];\n              /**\n               * @namespace DDP\n               * @summary Namespace for DDP-related methods/classes.\n               */\n\n              var _DDP3 = {}; // This is private but it's used in a few places. accounts-base uses\n              // it to get the current user. Meteor.setTimeout and friends clear\n              // it. We can probably find a better way to factor this.\n\n              _DDP3._CurrentMethodInvocation = new _Meteor3.EnvironmentVariable();\n              _DDP3._CurrentPublicationInvocation = new _Meteor3.EnvironmentVariable(); // XXX: Keep DDP._CurrentInvocation for backwards-compatibility.\n\n              _DDP3._CurrentInvocation = _DDP3._CurrentMethodInvocation; // This is passed into a weird `makeErrorType` function that expects its thing\n              // to be a constructor\n\n              function connectionErrorConstructor(message) {\n                this.message = message;\n              }\n\n              _DDP3.ConnectionError = _Meteor3.makeErrorType('DDP.ConnectionError', connectionErrorConstructor);\n              _DDP3.ForcedReconnectError = _Meteor3.makeErrorType('DDP.ForcedReconnectError', function () {}); // Returns the named sequence of pseudo-random values.\n              // The scope will be DDP._CurrentMethodInvocation.get(), so the stream will produce\n              // consistent values for method calls on the client and server.\n\n              _DDP3.randomStream = function (name) {\n                var scope = _DDP3._CurrentMethodInvocation.get();\n\n                return _DDPCommon2.RandomStream.get(scope, name);\n              }; // @param url {String} URL to Meteor app,\n              //     e.g.:\n              //     \"subdomain.meteor.com\",\n              //     \"http://subdomain.meteor.com\",\n              //     \"/\",\n              //     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n\n              /**\n               * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n               * @locus Anywhere\n               * @param {String} url The URL of another Meteor application.\n               */\n\n\n              _DDP3.connect = function (url, options) {\n                var ret = new _Connection2(url, options);\n                allConnections.push(ret); // hack. see below.\n\n                return ret;\n              };\n\n              _DDP3._reconnectHook = new Hook({\n                bindEnvironment: false\n              });\n              /**\n               * @summary Register a function to call as the first step of\n               * reconnecting. This function can call methods which will be executed before\n               * any other outstanding methods. For example, this can be used to re-establish\n               * the appropriate authentication context on the connection.\n               * @locus Anywhere\n               * @param {Function} callback The function to call. It will be called with a\n               * single argument, the [connection object](#ddp_connect) that is reconnecting.\n               */\n\n              _DDP3.onReconnect = function (callback) {\n                return _DDP3._reconnectHook.register(callback);\n              }; // Hack for `spiderable` package: a way to see if the page is done\n              // loading all the data it needs.\n              //\n\n\n              _DDP3._allSubscriptionsReady = function () {\n                return allConnections.every(function (conn) {\n                  return _keys2(conn._subscriptions).every(function (id) {\n                    return conn._subscriptions[id].ready;\n                  });\n                });\n              }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n            }\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/ddp-client/client/client.js\");\n  /* Exports */\n\n\n  Package._define(\"ddp-client\", exports, {\n    DDP: DDP\n  });\n})();\n\nmodule.exports = window.Package[\"ddp-client\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/ddp-client.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/ddp-common.js":
/*!***************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/ddp-common.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var check = Package.check.check;\n  var Match = Package.check.Match;\n  var Random = Package.random.Random;\n  var EJSON = Package.ejson.EJSON;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n  var Retry = Package.retry.Retry;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var DDPCommon;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"ddp-common\": {\n          \"namespace.js\": function namespaceJs() {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/ddp-common/namespace.js                                                                                   //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n\n            /**\n             * @namespace DDPCommon\n             * @summary Namespace for DDPCommon-related methods/classes. Shared between \n             * `ddp-client` and `ddp-server`, where the ddp-client is the implementation\n             * of a ddp client for both client AND server; and the ddp server is the\n             * implementation of the livedata server and stream server. Common \n             * functionality shared between both can be shared under this namespace\n             */\n            DDPCommon = {}; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          },\n          \"heartbeat.js\": function heartbeatJs() {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/ddp-common/heartbeat.js                                                                                   //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // Heartbeat options:\n            //   heartbeatInterval: interval to send pings, in milliseconds.\n            //   heartbeatTimeout: timeout to close the connection if a reply isn't\n            //     received, in milliseconds.\n            //   sendPing: function to call to send a ping on the connection.\n            //   onTimeout: function to call to close the connection.\n            DDPCommon.Heartbeat =\n            /*#__PURE__*/\n            function () {\n              function Heartbeat(options) {\n                _classCallCheck(this, Heartbeat);\n\n                this.heartbeatInterval = options.heartbeatInterval;\n                this.heartbeatTimeout = options.heartbeatTimeout;\n                this._sendPing = options.sendPing;\n                this._onTimeout = options.onTimeout;\n                this._seenPacket = false;\n                this._heartbeatIntervalHandle = null;\n                this._heartbeatTimeoutHandle = null;\n              }\n\n              _createClass(Heartbeat, [{\n                key: \"stop\",\n                value: function stop() {\n                  this._clearHeartbeatIntervalTimer();\n\n                  this._clearHeartbeatTimeoutTimer();\n                }\n              }, {\n                key: \"start\",\n                value: function start() {\n                  this.stop();\n\n                  this._startHeartbeatIntervalTimer();\n                }\n              }, {\n                key: \"_startHeartbeatIntervalTimer\",\n                value: function _startHeartbeatIntervalTimer() {\n                  var _this = this;\n\n                  this._heartbeatIntervalHandle = Meteor.setInterval(function () {\n                    return _this._heartbeatIntervalFired();\n                  }, this.heartbeatInterval);\n                }\n              }, {\n                key: \"_startHeartbeatTimeoutTimer\",\n                value: function _startHeartbeatTimeoutTimer() {\n                  var _this2 = this;\n\n                  this._heartbeatTimeoutHandle = Meteor.setTimeout(function () {\n                    return _this2._heartbeatTimeoutFired();\n                  }, this.heartbeatTimeout);\n                }\n              }, {\n                key: \"_clearHeartbeatIntervalTimer\",\n                value: function _clearHeartbeatIntervalTimer() {\n                  if (this._heartbeatIntervalHandle) {\n                    Meteor.clearInterval(this._heartbeatIntervalHandle);\n                    this._heartbeatIntervalHandle = null;\n                  }\n                }\n              }, {\n                key: \"_clearHeartbeatTimeoutTimer\",\n                value: function _clearHeartbeatTimeoutTimer() {\n                  if (this._heartbeatTimeoutHandle) {\n                    Meteor.clearTimeout(this._heartbeatTimeoutHandle);\n                    this._heartbeatTimeoutHandle = null;\n                  }\n                } // The heartbeat interval timer is fired when we should send a ping.\n\n              }, {\n                key: \"_heartbeatIntervalFired\",\n                value: function _heartbeatIntervalFired() {\n                  // don't send ping if we've seen a packet since we last checked,\n                  // *or* if we have already sent a ping and are awaiting a timeout.\n                  // That shouldn't happen, but it's possible if\n                  // `this.heartbeatInterval` is smaller than\n                  // `this.heartbeatTimeout`.\n                  if (!this._seenPacket && !this._heartbeatTimeoutHandle) {\n                    this._sendPing(); // Set up timeout, in case a pong doesn't arrive in time.\n\n\n                    this._startHeartbeatTimeoutTimer();\n                  }\n\n                  this._seenPacket = false;\n                } // The heartbeat timeout timer is fired when we sent a ping, but we\n                // timed out waiting for the pong.\n\n              }, {\n                key: \"_heartbeatTimeoutFired\",\n                value: function _heartbeatTimeoutFired() {\n                  this._heartbeatTimeoutHandle = null;\n\n                  this._onTimeout();\n                }\n              }, {\n                key: \"messageReceived\",\n                value: function messageReceived() {\n                  // Tell periodic checkin that we have seen a packet, and thus it\n                  // does not need to send a ping this cycle.\n                  this._seenPacket = true; // If we were waiting for a pong, we got it.\n\n                  if (this._heartbeatTimeoutHandle) {\n                    this._clearHeartbeatTimeoutTimer();\n                  }\n                }\n              }]);\n\n              return Heartbeat;\n            }(); ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"utils.js\": function utilsJs(require, exports, module) {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/ddp-common/utils.js                                                                                       //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            \"use strict\";\n\n            module.export({\n              hasOwn: function hasOwn() {\n                return _hasOwn;\n              },\n              slice: function slice() {\n                return _slice;\n              },\n              keys: function keys() {\n                return _keys;\n              },\n              isEmpty: function isEmpty() {\n                return _isEmpty;\n              },\n              last: function last() {\n                return _last;\n              }\n            });\n            var _hasOwn = Object.prototype.hasOwnProperty;\n            var _slice = Array.prototype.slice;\n\n            function _keys(obj) {\n              return Object.keys(Object(obj));\n            }\n\n            function _isEmpty(obj) {\n              if (obj == null) {\n                return true;\n              }\n\n              if (Array.isArray(obj) || typeof obj === \"string\") {\n                return obj.length === 0;\n              }\n\n              for (var key in obj) {\n                if (_hasOwn.call(obj, key)) {\n                  return false;\n                }\n              }\n\n              return true;\n            }\n\n            function _last(array, n, guard) {\n              if (array == null) {\n                return;\n              }\n\n              if (n == null || guard) {\n                return array[array.length - 1];\n              }\n\n              return _slice.call(array, Math.max(array.length - n, 0));\n            }\n\n            DDPCommon.SUPPORTED_DDP_VERSIONS = ['1', 'pre2', 'pre1'];\n\n            DDPCommon.parseDDP = function (stringMessage) {\n              try {\n                var msg = JSON.parse(stringMessage);\n              } catch (e) {\n                Meteor._debug(\"Discarding message with invalid JSON\", stringMessage);\n\n                return null;\n              } // DDP messages must be objects.\n\n\n              if (msg === null || _typeof(msg) !== 'object') {\n                Meteor._debug(\"Discarding non-object DDP message\", stringMessage);\n\n                return null;\n              } // massage msg to get it into \"abstract ddp\" rather than \"wire ddp\" format.\n              // switch between \"cleared\" rep of unsetting fields and \"undefined\"\n              // rep of same\n\n\n              if (_hasOwn.call(msg, 'cleared')) {\n                if (!_hasOwn.call(msg, 'fields')) {\n                  msg.fields = {};\n                }\n\n                msg.cleared.forEach(function (clearKey) {\n                  msg.fields[clearKey] = undefined;\n                });\n                delete msg.cleared;\n              }\n\n              ['fields', 'params', 'result'].forEach(function (field) {\n                if (_hasOwn.call(msg, field)) {\n                  msg[field] = EJSON._adjustTypesFromJSONValue(msg[field]);\n                }\n              });\n              return msg;\n            };\n\n            DDPCommon.stringifyDDP = function (msg) {\n              var copy = EJSON.clone(msg); // swizzle 'changed' messages from 'fields undefined' rep to 'fields\n              // and cleared' rep\n\n              if (_hasOwn.call(msg, 'fields')) {\n                var cleared = [];\n                Object.keys(msg.fields).forEach(function (key) {\n                  var value = msg.fields[key];\n\n                  if (typeof value === \"undefined\") {\n                    cleared.push(key);\n                    delete copy.fields[key];\n                  }\n                });\n\n                if (!_isEmpty(cleared)) {\n                  copy.cleared = cleared;\n                }\n\n                if (_isEmpty(copy.fields)) {\n                  delete copy.fields;\n                }\n              } // adjust types to basic\n\n\n              ['fields', 'params', 'result'].forEach(function (field) {\n                if (_hasOwn.call(copy, field)) {\n                  copy[field] = EJSON._adjustTypesToJSONValue(copy[field]);\n                }\n              });\n\n              if (msg.id && typeof msg.id !== 'string') {\n                throw new Error(\"Message id is not a string\");\n              }\n\n              return JSON.stringify(copy);\n            }; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"method_invocation.js\": function method_invocationJs() {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/ddp-common/method_invocation.js                                                                           //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // Instance name is this because it is usually referred to as this inside a\n            // method definition\n\n            /**\n             * @summary The state for a single invocation of a method, referenced by this\n             * inside a method definition.\n             * @param {Object} options\n             * @instanceName this\n             * @showInstanceName true\n             */\n            DDPCommon.MethodInvocation =\n            /*#__PURE__*/\n            function () {\n              function MethodInvocation(options) {\n                _classCallCheck(this, MethodInvocation);\n\n                // true if we're running not the actual method, but a stub (that is,\n                // if we're on a client (which may be a browser, or in the future a\n                // server connecting to another server) and presently running a\n                // simulation of a server-side method for latency compensation\n                // purposes). not currently true except in a client such as a browser,\n                // since there's usually no point in running stubs unless you have a\n                // zero-latency connection to the user.\n\n                /**\n                 * @summary Access inside a method invocation.  Boolean value, true if this invocation is a stub.\n                 * @locus Anywhere\n                 * @name  isSimulation\n                 * @memberOf DDPCommon.MethodInvocation\n                 * @instance\n                 * @type {Boolean}\n                 */\n                this.isSimulation = options.isSimulation; // call this function to allow other method invocations (from the\n                // same client) to continue running without waiting for this one to\n                // complete.\n\n                this._unblock = options.unblock || function () {};\n\n                this._calledUnblock = false; // current user id\n\n                /**\n                 * @summary The id of the user that made this method call, or `null` if no user was logged in.\n                 * @locus Anywhere\n                 * @name  userId\n                 * @memberOf DDPCommon.MethodInvocation\n                 * @instance\n                 */\n\n                this.userId = options.userId; // sets current user id in all appropriate server contexts and\n                // reruns subscriptions\n\n                this._setUserId = options.setUserId || function () {}; // On the server, the connection this method call came in on.\n\n                /**\n                 * @summary Access inside a method invocation. The [connection](#meteor_onconnection) that this method was received on. `null` if the method is not associated with a connection, eg. a server initiated method call. Calls to methods made from a server method which was in turn initiated from the client share the same `connection`.\n                 * @locus Server\n                 * @name  connection\n                 * @memberOf DDPCommon.MethodInvocation\n                 * @instance\n                 */\n\n\n                this.connection = options.connection; // The seed for randomStream value generation\n\n                this.randomSeed = options.randomSeed; // This is set by RandomStream.get; and holds the random stream state\n\n                this.randomStream = null;\n              }\n              /**\n               * @summary Call inside a method invocation.  Allow subsequent method from this client to begin running in a new fiber.\n               * @locus Server\n               * @memberOf DDPCommon.MethodInvocation\n               * @instance\n               */\n\n\n              _createClass(MethodInvocation, [{\n                key: \"unblock\",\n                value: function unblock() {\n                  this._calledUnblock = true;\n\n                  this._unblock();\n                }\n                /**\n                 * @summary Set the logged in user.\n                 * @locus Server\n                 * @memberOf DDPCommon.MethodInvocation\n                 * @instance\n                 * @param {String | null} userId The value that should be returned by `userId` on this connection.\n                 */\n\n              }, {\n                key: \"setUserId\",\n                value: function setUserId(userId) {\n                  if (this._calledUnblock) {\n                    throw new Error(\"Can't call setUserId in a method after calling unblock\");\n                  }\n\n                  this.userId = userId;\n\n                  this._setUserId(userId);\n                }\n              }]);\n\n              return MethodInvocation;\n            }(); ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"random_stream.js\": function random_streamJs() {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/ddp-common/random_stream.js                                                                               //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // RandomStream allows for generation of pseudo-random values, from a seed.\n            //\n            // We use this for consistent 'random' numbers across the client and server.\n            // We want to generate probably-unique IDs on the client, and we ideally want\n            // the server to generate the same IDs when it executes the method.\n            //\n            // For generated values to be the same, we must seed ourselves the same way,\n            // and we must keep track of the current state of our pseudo-random generators.\n            // We call this state the scope. By default, we use the current DDP method\n            // invocation as our scope.  DDP now allows the client to specify a randomSeed.\n            // If a randomSeed is provided it will be used to seed our random sequences.\n            // In this way, client and server method calls will generate the same values.\n            //\n            // We expose multiple named streams; each stream is independent\n            // and is seeded differently (but predictably from the name).\n            // By using multiple streams, we support reordering of requests,\n            // as long as they occur on different streams.\n            //\n            // @param options {Optional Object}\n            //   seed: Array or value - Seed value(s) for the generator.\n            //                          If an array, will be used as-is\n            //                          If a value, will be converted to a single-value array\n            //                          If omitted, a random array will be used as the seed.\n            DDPCommon.RandomStream =\n            /*#__PURE__*/\n            function () {\n              function RandomStream(options) {\n                _classCallCheck(this, RandomStream);\n\n                this.seed = [].concat(options.seed || randomToken());\n                this.sequences = Object.create(null);\n              } // Get a random sequence with the specified name, creating it if does not exist.\n              // New sequences are seeded with the seed concatenated with the name.\n              // By passing a seed into Random.create, we use the Alea generator.\n\n\n              _createClass(RandomStream, [{\n                key: \"_sequence\",\n                value: function _sequence(name) {\n                  var self = this;\n                  var sequence = self.sequences[name] || null;\n\n                  if (sequence === null) {\n                    var sequenceSeed = self.seed.concat(name);\n\n                    for (var i = 0; i < sequenceSeed.length; i++) {\n                      if (typeof sequenceSeed[i] === \"function\") {\n                        sequenceSeed[i] = sequenceSeed[i]();\n                      }\n                    }\n\n                    self.sequences[name] = sequence = Random.createWithSeeds.apply(null, sequenceSeed);\n                  }\n\n                  return sequence;\n                }\n              }]);\n\n              return RandomStream;\n            }(); // Returns a random string of sufficient length for a random seed.\n            // This is a placeholder function; a similar function is planned\n            // for Random itself; when that is added we should remove this function,\n            // and call Random's randomToken instead.\n\n\n            function randomToken() {\n              return Random.hexString(20);\n            }\n\n            ; // Returns the random stream with the specified name, in the specified\n            // scope. If a scope is passed, then we use that to seed a (not\n            // cryptographically secure) PRNG using the fast Alea algorithm.  If\n            // scope is null (or otherwise falsey) then we use a generated seed.\n            //\n            // However, scope will normally be the current DDP method invocation,\n            // so we'll use the stream with the specified name, and we should get\n            // consistent values on the client and server sides of a method call.\n\n            DDPCommon.RandomStream.get = function (scope, name) {\n              if (!name) {\n                name = \"default\";\n              }\n\n              if (!scope) {\n                // There was no scope passed in; the sequence won't actually be\n                // reproducible. but make it fast (and not cryptographically\n                // secure) anyways, so that the behavior is similar to what you'd\n                // get by passing in a scope.\n                return Random.insecure;\n              }\n\n              var randomStream = scope.randomStream;\n\n              if (!randomStream) {\n                scope.randomStream = randomStream = new DDPCommon.RandomStream({\n                  seed: scope.randomSeed\n                });\n              }\n\n              return randomStream._sequence(name);\n            }; // Creates a randomSeed for passing to a method call.\n            // Note that we take enclosing as an argument,\n            // though we expect it to be DDP._CurrentMethodInvocation.get()\n            // However, we often evaluate makeRpcSeed lazily, and thus the relevant\n            // invocation may not be the one currently in scope.\n            // If enclosing is null, we'll use Random and values won't be repeatable.\n\n\n            DDPCommon.makeRpcSeed = function (enclosing, methodName) {\n              var stream = DDPCommon.RandomStream.get(enclosing, '/rpc/' + methodName);\n              return stream.hexString(20);\n            }; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  require(\"/node_modules/meteor/ddp-common/namespace.js\");\n\n  require(\"/node_modules/meteor/ddp-common/heartbeat.js\");\n\n  require(\"/node_modules/meteor/ddp-common/utils.js\");\n\n  require(\"/node_modules/meteor/ddp-common/method_invocation.js\");\n\n  require(\"/node_modules/meteor/ddp-common/random_stream.js\");\n  /* Exports */\n\n\n  Package._define(\"ddp-common\", {\n    DDPCommon: DDPCommon\n  });\n})();\n\nmodule.exports = window.Package[\"ddp-common\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/ddp-common.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/ddp-server.js":
/*!***************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/ddp-server.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/ddp-server.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/ddp.js":
/*!********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/ddp.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/ddp.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/demo-pkg.js":
/*!*************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/demo-pkg.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  (function () {\n    ///////////////////////////////////////////////////////////////////////\n    //                                                                   //\n    // packages/demo-pkg/demo-pkg.js                                     //\n    //                                                                   //\n    ///////////////////////////////////////////////////////////////////////\n    //\n    console.log('This is the private demo-pkg.js'); ///////////////////////////////////////////////////////////////////////\n  }).call(this);\n  /* Exports */\n\n  Package._define(\"demo-pkg\");\n})();\n\nmodule.exports = window.Package[\"demo-pkg\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/demo-pkg.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/diff-sequence.js":
/*!******************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/diff-sequence.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var EJSON = Package.ejson.EJSON;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var DiffSequence;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"diff-sequence\": {\n          \"diff.js\": function diffJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                 //\n            // packages/diff-sequence/diff.js                                                                  //\n            //                                                                                                 //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              DiffSequence: function DiffSequence() {\n                return _DiffSequence;\n              }\n            });\n            var _DiffSequence = {};\n            var hasOwn = Object.prototype.hasOwnProperty;\n\n            function isObjEmpty(obj) {\n              for (var key in Object(obj)) {\n                if (hasOwn.call(obj, key)) {\n                  return false;\n                }\n              }\n\n              return true;\n            } // ordered: bool.\n            // old_results and new_results: collections of documents.\n            //    if ordered, they are arrays.\n            //    if unordered, they are IdMaps\n\n\n            _DiffSequence.diffQueryChanges = function (ordered, oldResults, newResults, observer, options) {\n              if (ordered) _DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options);else _DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options);\n            };\n\n            _DiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults, observer, options) {\n              options = options || {};\n              var projectionFn = options.projectionFn || EJSON.clone;\n\n              if (observer.movedBefore) {\n                throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");\n              }\n\n              newResults.forEach(function (newDoc, id) {\n                var oldDoc = oldResults.get(id);\n\n                if (oldDoc) {\n                  if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {\n                    var projectedNew = projectionFn(newDoc);\n                    var projectedOld = projectionFn(oldDoc);\n\n                    var changedFields = _DiffSequence.makeChangedFields(projectedNew, projectedOld);\n\n                    if (!isObjEmpty(changedFields)) {\n                      observer.changed(id, changedFields);\n                    }\n                  }\n                } else if (observer.added) {\n                  var fields = projectionFn(newDoc);\n                  delete fields._id;\n                  observer.added(newDoc._id, fields);\n                }\n              });\n\n              if (observer.removed) {\n                oldResults.forEach(function (oldDoc, id) {\n                  if (!newResults.has(id)) observer.removed(id);\n                });\n              }\n            };\n\n            _DiffSequence.diffQueryOrderedChanges = function (old_results, new_results, observer, options) {\n              options = options || {};\n              var projectionFn = options.projectionFn || EJSON.clone;\n              var new_presence_of_id = {};\n              new_results.forEach(function (doc) {\n                if (new_presence_of_id[doc._id]) Meteor._debug(\"Duplicate _id in new_results\");\n                new_presence_of_id[doc._id] = true;\n              });\n              var old_index_of_id = {};\n              old_results.forEach(function (doc, i) {\n                if (doc._id in old_index_of_id) Meteor._debug(\"Duplicate _id in old_results\");\n                old_index_of_id[doc._id] = i;\n              }); // ALGORITHM:\n              //\n              // To determine which docs should be considered \"moved\" (and which\n              // merely change position because of other docs moving) we run\n              // a \"longest common subsequence\" (LCS) algorithm.  The LCS of the\n              // old doc IDs and the new doc IDs gives the docs that should NOT be\n              // considered moved.\n              // To actually call the appropriate callbacks to get from the old state to the\n              // new state:\n              // First, we call removed() on all the items that only appear in the old\n              // state.\n              // Then, once we have the items that should not move, we walk through the new\n              // results array group-by-group, where a \"group\" is a set of items that have\n              // moved, anchored on the end by an item that should not move.  One by one, we\n              // move each of those elements into place \"before\" the anchoring end-of-group\n              // item, and fire changed events on them if necessary.  Then we fire a changed\n              // event on the anchor, and move on to the next group.  There is always at\n              // least one group; the last group is anchored by a virtual \"null\" id at the\n              // end.\n              // Asymptotically: O(N k) where k is number of ops, or potentially\n              // O(N log N) if inner loop of LCS were made to be binary search.\n              //////// LCS (longest common sequence, with respect to _id)\n              // (see Wikipedia article on Longest Increasing Subsequence,\n              // where the LIS is taken of the sequence of old indices of the\n              // docs in new_results)\n              //\n              // unmoved: the output of the algorithm; members of the LCS,\n              // in the form of indices into new_results\n\n              var unmoved = []; // max_seq_len: length of LCS found so far\n\n              var max_seq_len = 0; // seq_ends[i]: the index into new_results of the last doc in a\n              // common subsequence of length of i+1 <= max_seq_len\n\n              var N = new_results.length;\n              var seq_ends = new Array(N); // ptrs:  the common subsequence ending with new_results[n] extends\n              // a common subsequence ending with new_results[ptr[n]], unless\n              // ptr[n] is -1.\n\n              var ptrs = new Array(N); // virtual sequence of old indices of new results\n\n              var old_idx_seq = function old_idx_seq(i_new) {\n                return old_index_of_id[new_results[i_new]._id];\n              }; // for each item in new_results, use it to extend a common subsequence\n              // of length j <= max_seq_len\n\n\n              for (var i = 0; i < N; i++) {\n                if (old_index_of_id[new_results[i]._id] !== undefined) {\n                  var j = max_seq_len; // this inner loop would traditionally be a binary search,\n                  // but scanning backwards we will likely find a subseq to extend\n                  // pretty soon, bounded for example by the total number of ops.\n                  // If this were to be changed to a binary search, we'd still want\n                  // to scan backwards a bit as an optimization.\n\n                  while (j > 0) {\n                    if (old_idx_seq(seq_ends[j - 1]) < old_idx_seq(i)) break;\n                    j--;\n                  }\n\n                  ptrs[i] = j === 0 ? -1 : seq_ends[j - 1];\n                  seq_ends[j] = i;\n                  if (j + 1 > max_seq_len) max_seq_len = j + 1;\n                }\n              } // pull out the LCS/LIS into unmoved\n\n\n              var idx = max_seq_len === 0 ? -1 : seq_ends[max_seq_len - 1];\n\n              while (idx >= 0) {\n                unmoved.push(idx);\n                idx = ptrs[idx];\n              } // the unmoved item list is built backwards, so fix that\n\n\n              unmoved.reverse(); // the last group is always anchored by the end of the result list, which is\n              // an id of \"null\"\n\n              unmoved.push(new_results.length);\n              old_results.forEach(function (doc) {\n                if (!new_presence_of_id[doc._id]) observer.removed && observer.removed(doc._id);\n              }); // for each group of things in the new_results that is anchored by an unmoved\n              // element, iterate through the things before it.\n\n              var startOfGroup = 0;\n              unmoved.forEach(function (endOfGroup) {\n                var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;\n                var oldDoc, newDoc, fields, projectedNew, projectedOld;\n\n                for (var i = startOfGroup; i < endOfGroup; i++) {\n                  newDoc = new_results[i];\n\n                  if (!hasOwn.call(old_index_of_id, newDoc._id)) {\n                    fields = projectionFn(newDoc);\n                    delete fields._id;\n                    observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);\n                    observer.added && observer.added(newDoc._id, fields);\n                  } else {\n                    // moved\n                    oldDoc = old_results[old_index_of_id[newDoc._id]];\n                    projectedNew = projectionFn(newDoc);\n                    projectedOld = projectionFn(oldDoc);\n                    fields = _DiffSequence.makeChangedFields(projectedNew, projectedOld);\n\n                    if (!isObjEmpty(fields)) {\n                      observer.changed && observer.changed(newDoc._id, fields);\n                    }\n\n                    observer.movedBefore && observer.movedBefore(newDoc._id, groupId);\n                  }\n                }\n\n                if (groupId) {\n                  newDoc = new_results[endOfGroup];\n                  oldDoc = old_results[old_index_of_id[newDoc._id]];\n                  projectedNew = projectionFn(newDoc);\n                  projectedOld = projectionFn(oldDoc);\n                  fields = _DiffSequence.makeChangedFields(projectedNew, projectedOld);\n\n                  if (!isObjEmpty(fields)) {\n                    observer.changed && observer.changed(newDoc._id, fields);\n                  }\n                }\n\n                startOfGroup = endOfGroup + 1;\n              });\n            }; // General helper for diff-ing two objects.\n            // callbacks is an object like so:\n            // { leftOnly: function (key, leftValue) {...},\n            //   rightOnly: function (key, rightValue) {...},\n            //   both: function (key, leftValue, rightValue) {...},\n            // }\n\n\n            _DiffSequence.diffObjects = function (left, right, callbacks) {\n              Object.keys(left).forEach(function (key) {\n                var leftValue = left[key];\n\n                if (hasOwn.call(right, key)) {\n                  callbacks.both && callbacks.both(key, leftValue, right[key]);\n                } else {\n                  callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\n                }\n              });\n\n              if (callbacks.rightOnly) {\n                Object.keys(right).forEach(function (key) {\n                  var rightValue = right[key];\n\n                  if (!hasOwn.call(left, key)) {\n                    callbacks.rightOnly(key, rightValue);\n                  }\n                });\n              }\n            };\n\n            _DiffSequence.makeChangedFields = function (newDoc, oldDoc) {\n              var fields = {};\n\n              _DiffSequence.diffObjects(oldDoc, newDoc, {\n                leftOnly: function leftOnly(key, value) {\n                  fields[key] = undefined;\n                },\n                rightOnly: function rightOnly(key, value) {\n                  fields[key] = value;\n                },\n                both: function both(key, leftValue, rightValue) {\n                  if (!EJSON.equals(leftValue, rightValue)) fields[key] = rightValue;\n                }\n              });\n\n              return fields;\n            };\n\n            _DiffSequence.applyChanges = function (doc, changeFields) {\n              Object.keys(changeFields).forEach(function (key) {\n                var value = changeFields[key];\n\n                if (typeof value === \"undefined\") {\n                  delete doc[key];\n                } else {\n                  doc[key] = value;\n                }\n              });\n            }; /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/diff-sequence/diff.js\");\n  /* Exports */\n\n\n  Package._define(\"diff-sequence\", exports, {\n    DiffSequence: DiffSequence\n  });\n})();\n\nmodule.exports = window.Package[\"diff-sequence\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/diff-sequence.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/dynamic-import.js":
/*!*******************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/dynamic-import.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var Promise = Package.promise.Promise;\n  var HTTP = Package.http.HTTP;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"dynamic-import\": {\n          \"client.js\": function clientJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////\n            //                                                                             //\n            // packages/dynamic-import/client.js                                           //\n            //                                                                             //\n            /////////////////////////////////////////////////////////////////////////////////\n            //\n            var Module = module.constructor;\n\n            var cache = require(\"./cache.js\");\n\n            var HTTP = require(\"meteor/http\").HTTP;\n\n            var meteorInstall = require(\"meteor/modules\").meteorInstall; // Call module.dynamicImport(id) to fetch a module and any/all of its\n            // dependencies that have not already been fetched, and evaluate them as\n            // soon as they arrive. This runtime API makes it very easy to implement\n            // ECMAScript dynamic import(...) syntax.\n\n\n            Module.prototype.dynamicImport = function (id) {\n              var module = this;\n              return module.prefetch(id).then(function () {\n                return getNamespace(module, id);\n              });\n            }; // Called by Module.prototype.prefetch if there are any missing dynamic\n            // modules that need to be fetched.\n\n\n            meteorInstall.fetch = function (ids) {\n              var tree = Object.create(null);\n              var versions = Object.create(null);\n\n              var dynamicVersions = require(\"./dynamic-versions.js\");\n\n              var missing;\n\n              function addSource(id, source) {\n                addToTree(tree, id, makeModuleFunction(id, source, ids[id].options));\n              }\n\n              function addMissing(id) {\n                addToTree(missing = missing || Object.create(null), id, 1);\n              }\n\n              Object.keys(ids).forEach(function (id) {\n                var version = dynamicVersions.get(id);\n\n                if (version) {\n                  versions[id] = version;\n                } else {\n                  addMissing(id);\n                }\n              });\n              return cache.checkMany(versions).then(function (sources) {\n                Object.keys(sources).forEach(function (id) {\n                  var source = sources[id];\n\n                  if (source) {\n                    addSource(id, source);\n                  } else {\n                    addMissing(id);\n                  }\n                });\n                return missing && fetchMissing(missing).then(function (results) {\n                  var versionsAndSourcesById = Object.create(null);\n                  var flatResults = flattenModuleTree(results);\n                  Object.keys(flatResults).forEach(function (id) {\n                    var source = flatResults[id];\n                    addSource(id, source);\n                    var version = dynamicVersions.get(id);\n\n                    if (version) {\n                      versionsAndSourcesById[id] = {\n                        version: version,\n                        source: source\n                      };\n                    }\n                  });\n                  cache.setMany(versionsAndSourcesById);\n                });\n              }).then(function () {\n                return tree;\n              });\n            };\n\n            function flattenModuleTree(tree) {\n              var parts = [\"\"];\n              var result = Object.create(null);\n\n              function walk(t) {\n                if (t && _typeof(t) === \"object\") {\n                  Object.keys(t).forEach(function (key) {\n                    parts.push(key);\n                    walk(t[key]);\n                    parts.pop();\n                  });\n                } else if (typeof t === \"string\") {\n                  result[parts.join(\"/\")] = t;\n                }\n              }\n\n              walk(tree);\n              return result;\n            }\n\n            function makeModuleFunction(id, source, options) {\n              // By calling (options && options.eval || eval) in a wrapper function,\n              // we delay the cost of parsing and evaluating the module code until the\n              // module is first imported.\n              return function () {\n                // If an options.eval function was provided in the second argument to\n                // meteorInstall when this bundle was first installed, use that\n                // function to parse and evaluate the dynamic module code in the scope\n                // of the package. Otherwise fall back to indirect (global) eval.\n                return (options && options.eval || eval)( // Wrap the function(require,exports,module){...} expression in\n                // parentheses to force it to be parsed as an expression.\n                \"(\" + source + \")\\n//# sourceURL=\" + id).apply(this, arguments);\n              };\n            }\n\n            var secretKey = null;\n\n            exports.setSecretKey = function (key) {\n              secretKey = key;\n            };\n\n            var fetchURL = require(\"./common.js\").fetchURL;\n\n            function fetchMissing(missingTree) {\n              return new Promise(function (resolve, reject) {\n                // If the hostname of the URL returned by Meteor.absoluteUrl differs\n                // from location.host, then we'll be making a cross-origin request\n                // here, but that's fine because the dynamic-import server sets\n                // appropriate CORS headers to enable fetching dynamic modules from\n                // any origin. Browsers that check CORS do so by sending an additional\n                // preflight OPTIONS request, which may add latency to the first\n                // dynamic import() request, so it's a good idea for ROOT_URL to match\n                // location.host if possible, though not strictly necessary.\n                HTTP.call(\"POST\", Meteor.absoluteUrl(fetchURL), {\n                  query: secretKey ? \"key=\" + secretKey : void 0,\n                  data: missingTree\n                }, function (error, result) {\n                  error ? reject(error) : resolve(result.data);\n                });\n              });\n            }\n\n            function addToTree(tree, id, value) {\n              var parts = id.split(\"/\");\n              var lastIndex = parts.length - 1;\n              parts.forEach(function (part, i) {\n                if (part) {\n                  tree = tree[part] = tree[part] || (i < lastIndex ? Object.create(null) : value);\n                }\n              });\n            }\n\n            function getNamespace(module, id) {\n              var namespace;\n              module.watch(module.require(id), {\n                \"*\": function _(ns) {\n                  namespace = ns;\n                }\n              }); // This helps with Babel interop, since we're not just returning the\n              // module.exports object.\n\n              Object.defineProperty(namespace, \"__esModule\", {\n                value: true,\n                enumerable: false\n              });\n              return namespace;\n            } /////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"cache.js\": function cacheJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////\n            //                                                                             //\n            // packages/dynamic-import/cache.js                                            //\n            //                                                                             //\n            /////////////////////////////////////////////////////////////////////////////////\n            //\n            var hasOwn = Object.prototype.hasOwnProperty;\n            var dbPromise;\n            var canUseCache = // The server doesn't benefit from dynamic module fetching, and almost\n            // certainly doesn't support IndexedDB.\n            Meteor.isClient && // Cordova bundles all modules into the monolithic initial bundle, so\n            // the dynamic module cache won't be necessary.\n            !Meteor.isCordova && // Caching can be confusing in development, and is designed to be a\n            // transparent optimization for production performance.\n            Meteor.isProduction;\n\n            function getIDB() {\n              if (typeof indexedDB !== \"undefined\") return indexedDB;\n              if (typeof webkitIndexedDB !== \"undefined\") return webkitIndexedDB;\n              if (typeof mozIndexedDB !== \"undefined\") return mozIndexedDB;\n              if (typeof OIndexedDB !== \"undefined\") return OIndexedDB;\n              if (typeof msIndexedDB !== \"undefined\") return msIndexedDB;\n            }\n\n            function withDB(callback) {\n              dbPromise = dbPromise || new Promise(function (resolve, reject) {\n                var idb = getIDB();\n\n                if (!idb) {\n                  throw new Error(\"IndexedDB not available\");\n                } // Incrementing the version number causes all existing object stores\n                // to be deleted and recreates those specified by objectStoreMap.\n\n\n                var request = idb.open(\"MeteorDynamicImportCache\", 2);\n\n                request.onupgradeneeded = function (event) {\n                  var db = event.target.result; // It's fine to delete existing object stores since onupgradeneeded\n                  // is only called when we change the DB version number, and the data\n                  // we're storing is disposable/reconstructible.\n\n                  Array.from(db.objectStoreNames).forEach(db.deleteObjectStore, db);\n                  Object.keys(objectStoreMap).forEach(function (name) {\n                    db.createObjectStore(name, objectStoreMap[name]);\n                  });\n                };\n\n                request.onerror = makeOnError(reject, \"indexedDB.open\");\n\n                request.onsuccess = function (event) {\n                  resolve(event.target.result);\n                };\n              });\n              return dbPromise.then(callback, function (error) {\n                return callback(null);\n              });\n            }\n\n            var objectStoreMap = {\n              sourcesByVersion: {\n                keyPath: \"version\"\n              }\n            };\n\n            function makeOnError(reject, source) {\n              return function (event) {\n                reject(new Error(\"IndexedDB failure in \" + source + \" \" + JSON.stringify(event.target))); // Returning true from an onerror callback function prevents an\n                // InvalidStateError in Firefox during Private Browsing. Silencing\n                // that error is safe because we handle the error more gracefully by\n                // passing it to the Promise reject function above.\n                // https://github.com/meteor/meteor/issues/8697\n\n                return true;\n              };\n            }\n\n            var checkCount = 0;\n\n            exports.checkMany = function (versions) {\n              var ids = Object.keys(versions);\n              var sourcesById = Object.create(null); // Initialize sourcesById with null values to indicate all sources are\n              // missing (unless replaced with actual sources below).\n\n              ids.forEach(function (id) {\n                sourcesById[id] = null;\n              });\n\n              if (!canUseCache) {\n                return Promise.resolve(sourcesById);\n              }\n\n              return withDB(function (db) {\n                if (!db) {\n                  // We thought we could used IndexedDB, but something went wrong\n                  // while opening the database, so err on the side of safety.\n                  return sourcesById;\n                }\n\n                var txn = db.transaction([\"sourcesByVersion\"], \"readonly\");\n                var sourcesByVersion = txn.objectStore(\"sourcesByVersion\");\n                ++checkCount;\n\n                function finish() {\n                  --checkCount;\n                  return sourcesById;\n                }\n\n                return Promise.all(ids.map(function (id) {\n                  return new Promise(function (resolve, reject) {\n                    var version = versions[id];\n\n                    if (version) {\n                      var sourceRequest = sourcesByVersion.get(version);\n                      sourceRequest.onerror = makeOnError(reject, \"sourcesByVersion.get\");\n\n                      sourceRequest.onsuccess = function (event) {\n                        var result = event.target.result;\n\n                        if (result) {\n                          sourcesById[id] = result.source;\n                        }\n\n                        resolve();\n                      };\n                    } else resolve();\n                  });\n                })).then(finish, finish);\n              });\n            };\n\n            var pendingVersionsAndSourcesById = Object.create(null);\n\n            exports.setMany = function (versionsAndSourcesById) {\n              if (canUseCache) {\n                Object.assign(pendingVersionsAndSourcesById, versionsAndSourcesById); // Delay the call to flushSetMany so that it doesn't contribute to the\n                // amount of time it takes to call module.dynamicImport.\n\n                if (!flushSetMany.timer) {\n                  flushSetMany.timer = setTimeout(flushSetMany, 100);\n                }\n              }\n            };\n\n            function flushSetMany() {\n              if (checkCount > 0) {\n                // If checkMany is currently underway, postpone the flush until later,\n                // since updating the cache is less important than reading from it.\n                return flushSetMany.timer = setTimeout(flushSetMany, 100);\n              }\n\n              flushSetMany.timer = null;\n              var versionsAndSourcesById = pendingVersionsAndSourcesById;\n              pendingVersionsAndSourcesById = Object.create(null);\n              return withDB(function (db) {\n                if (!db) {\n                  // We thought we could used IndexedDB, but something went wrong\n                  // while opening the database, so err on the side of safety.\n                  return;\n                }\n\n                var setTxn = db.transaction([\"sourcesByVersion\"], \"readwrite\");\n                var sourcesByVersion = setTxn.objectStore(\"sourcesByVersion\");\n                return Promise.all(Object.keys(versionsAndSourcesById).map(function (id) {\n                  var info = versionsAndSourcesById[id];\n                  return new Promise(function (resolve, reject) {\n                    var request = sourcesByVersion.put({\n                      version: info.version,\n                      source: info.source\n                    });\n                    request.onerror = makeOnError(reject, \"sourcesByVersion.put\");\n                    request.onsuccess = resolve;\n                  });\n                }));\n              });\n            } /////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"common.js\": function commonJs(require, exports) {\n            /////////////////////////////////////////////////////////////////////////////////\n            //                                                                             //\n            // packages/dynamic-import/common.js                                           //\n            //                                                                             //\n            /////////////////////////////////////////////////////////////////////////////////\n            //\n            exports.fetchURL = \"/__meteor__/dynamic-import/fetch\"; /////////////////////////////////////////////////////////////////////////////////\n          },\n          \"dynamic-versions.js\": function dynamicVersionsJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////\n            //                                                                             //\n            // packages/dynamic-import/dynamic-versions.js                                 //\n            //                                                                             //\n            /////////////////////////////////////////////////////////////////////////////////\n            //\n            // This magic double-underscored identifier gets replaced in\n            // tools/isobuild/bundler.js with a tree of hashes of all dynamic\n            // modules, for use in client.js and cache.js.\n            var versions = {};\n\n            exports.get = function (id) {\n              var tree = versions;\n              var version = null;\n              id.split(\"/\").some(function (part) {\n                if (part) {\n                  // If the tree contains identifiers for Meteor packages with colons\n                  // in their names, the colons should not have been replaced by\n                  // underscores, but there's a bug that results in that behavior, so\n                  // for now it seems safest to be tolerant of underscores here.\n                  // https://github.com/meteor/meteor/pull/9103\n                  tree = tree[part] || tree[part.replace(\":\", \"_\")];\n                }\n\n                if (!tree) {\n                  // Terminate the search without reassigning version.\n                  return true;\n                }\n\n                if (typeof tree === \"string\") {\n                  version = tree;\n                  return true;\n                }\n              });\n              return version;\n            };\n\n            function getFlatModuleArray(tree) {\n              var parts = [\"\"];\n              var result = [];\n\n              function walk(t) {\n                if (t && _typeof(t) === \"object\") {\n                  Object.keys(t).forEach(function (key) {\n                    parts.push(key);\n                    walk(t[key]);\n                    parts.pop();\n                  });\n                } else if (typeof t === \"string\") {\n                  result.push(parts.join(\"/\"));\n                }\n              }\n\n              walk(tree);\n              return result;\n            } // If Package.appcache is loaded, preload additional modules after the\n            // core bundle has been loaded.\n\n\n            function precacheOnLoad(event) {\n              // Check inside onload to make sure Package.appcache has had a chance to\n              // become available.\n              if (!Package.appcache) {\n                return;\n              } // Prefetch in chunks to reduce overhead. If we call module.prefetch(id)\n              // multiple times in the same tick of the event loop, all those modules\n              // will be fetched in one HTTP POST request.\n\n\n              function prefetchInChunks(modules, amount) {\n                Promise.all(modules.splice(0, amount).map(function (id) {\n                  return module.prefetch(id);\n                })).then(function () {\n                  if (modules.length > 0) {\n                    prefetchInChunks(modules, amount);\n                  }\n                });\n              } // Get a flat array of modules and start prefetching.\n\n\n              prefetchInChunks(getFlatModuleArray(versions), 50);\n            } // Use window.onload to only prefetch after the main bundle has loaded.\n\n\n            if (global.addEventListener) {\n              global.addEventListener('load', precacheOnLoad, false);\n            } else if (global.attachEvent) {\n              global.attachEvent('onload', precacheOnLoad);\n            } /////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/dynamic-import/client.js\");\n  /* Exports */\n\n\n  Package._define(\"dynamic-import\", exports);\n})();\n\nmodule.exports = window.Package[\"dynamic-import\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/dynamic-import.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/ecmascript-runtime-client.js":
/*!******************************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/ecmascript-runtime-client.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var Promise = Package.promise.Promise;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"ecmascript-runtime-client\": {\n          \"modern.js\": function modernJs(require) {\n            //////////////////////////////////////////////////////////////////////////\n            //                                                                      //\n            // packages/ecmascript-runtime-client/modern.js                         //\n            //                                                                      //\n            //////////////////////////////////////////////////////////////////////////\n            //\n            try {\n              require(\"core-js/modules/es7.object.get-own-property-descriptors\");\n            } catch (e) {\n              throw new Error([\"The core-js npm package could not be found in your node_modules \", \"directory. Please run the following command to install it:\", \"\", \"  meteor npm install --save core-js\", \"\"].join(\"\\n\"));\n            }\n\n            require(\"core-js/modules/es6.object.is\");\n\n            require(\"core-js/modules/es6.function.name\");\n\n            require(\"core-js/modules/es6.number.is-finite\");\n\n            require(\"core-js/modules/es6.number.is-nan\");\n\n            require(\"core-js/modules/es7.array.flatten\");\n\n            require(\"core-js/modules/es7.array.flat-map\");\n\n            require(\"core-js/modules/es7.object.values\");\n\n            require(\"core-js/modules/es7.object.entries\");\n\n            require(\"core-js/modules/es7.string.pad-start\");\n\n            require(\"core-js/modules/es7.string.pad-end\"); //////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/ecmascript-runtime-client/modern.js\");\n  /* Exports */\n\n\n  Package._define(\"ecmascript-runtime-client\", exports);\n})();\n\nmodule.exports = window.Package[\"ecmascript-runtime-client\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/ecmascript-runtime-client.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/ecmascript-runtime.js":
/*!***********************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/ecmascript-runtime.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/ecmascript-runtime.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/ecmascript.js":
/*!***************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/ecmascript.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/ecmascript.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/ejson.js":
/*!**********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/ejson.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var Base64 = Package.base64.Base64;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var v, EJSON;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"ejson\": {\n          \"ejson.js\": function ejsonJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                             //\n            // packages/ejson/ejson.js                                                                                     //\n            //                                                                                                             //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              EJSON: function EJSON() {\n                return _EJSON;\n              }\n            });\n            /**\n             * @namespace\n             * @summary Namespace for EJSON functions\n             */\n\n            var _EJSON = {}; // Custom type interface definition\n\n            /**\n             * @class CustomType\n             * @instanceName customType\n             * @memberOf EJSON\n             * @summary The interface that a class must satisfy to be able to become an\n             * EJSON custom type via EJSON.addType.\n             */\n\n            /**\n             * @function typeName\n             * @memberOf EJSON.CustomType\n             * @summary Return the tag used to identify this type.  This must match the\n             *          tag used to register this type with\n             *          [`EJSON.addType`](#ejson_add_type).\n             * @locus Anywhere\n             * @instance\n             */\n\n            /**\n             * @function toJSONValue\n             * @memberOf EJSON.CustomType\n             * @summary Serialize this instance into a JSON-compatible value.\n             * @locus Anywhere\n             * @instance\n             */\n\n            /**\n             * @function clone\n             * @memberOf EJSON.CustomType\n             * @summary Return a value `r` such that `this.equals(r)` is true, and\n             *          modifications to `r` do not affect `this` and vice versa.\n             * @locus Anywhere\n             * @instance\n             */\n\n            /**\n             * @function equals\n             * @memberOf EJSON.CustomType\n             * @summary Return `true` if `other` has a value equal to `this`; `false`\n             *          otherwise.\n             * @locus Anywhere\n             * @param {Object} other Another object to compare this to.\n             * @instance\n             */\n\n            var customTypes = {};\n\n            var hasOwn = function hasOwn(obj, prop) {\n              return {}.hasOwnProperty.call(obj, prop);\n            };\n\n            var isArguments = function isArguments(obj) {\n              return obj != null && hasOwn(obj, 'callee');\n            };\n\n            var isInfOrNan = function isInfOrNan(obj) {\n              return Number.isNaN(obj) || obj === Infinity || obj === -Infinity;\n            }; // Add a custom type, using a method of your choice to get to and\n            // from a basic JSON-able representation.  The factory argument\n            // is a function of JSON-able --> your object\n            // The type you add must have:\n            // - A toJSONValue() method, so that Meteor can serialize it\n            // - a typeName() method, to show how to look it up in our type table.\n            // It is okay if these methods are monkey-patched on.\n            // EJSON.clone will use toJSONValue and the given factory to produce\n            // a clone, but you may specify a method clone() that will be\n            // used instead.\n            // Similarly, EJSON.equals will use toJSONValue to make comparisons,\n            // but you may provide a method equals() instead.\n\n            /**\n             * @summary Add a custom datatype to EJSON.\n             * @locus Anywhere\n             * @param {String} name A tag for your custom type; must be unique among\n             *                      custom data types defined in your project, and must\n             *                      match the result of your type's `typeName` method.\n             * @param {Function} factory A function that deserializes a JSON-compatible\n             *                           value into an instance of your type.  This should\n             *                           match the serialization performed by your\n             *                           type's `toJSONValue` method.\n             */\n\n\n            _EJSON.addType = function (name, factory) {\n              if (hasOwn(customTypes, name)) {\n                throw new Error(\"Type \".concat(name, \" already present\"));\n              }\n\n              customTypes[name] = factory;\n            };\n\n            var builtinConverters = [{\n              // Date\n              matchJSONValue: function matchJSONValue(obj) {\n                return hasOwn(obj, '$date') && Object.keys(obj).length === 1;\n              },\n              matchObject: function matchObject(obj) {\n                return obj instanceof Date;\n              },\n              toJSONValue: function toJSONValue(obj) {\n                return {\n                  $date: obj.getTime()\n                };\n              },\n              fromJSONValue: function fromJSONValue(obj) {\n                return new Date(obj.$date);\n              }\n            }, {\n              // RegExp\n              matchJSONValue: function matchJSONValue(obj) {\n                return hasOwn(obj, '$regexp') && hasOwn(obj, '$flags') && Object.keys(obj).length === 2;\n              },\n              matchObject: function matchObject(obj) {\n                return obj instanceof RegExp;\n              },\n              toJSONValue: function toJSONValue(regexp) {\n                return {\n                  $regexp: regexp.source,\n                  $flags: regexp.flags\n                };\n              },\n              fromJSONValue: function fromJSONValue(obj) {\n                // Replaces duplicate / invalid flags.\n                return new RegExp(obj.$regexp, obj.$flags // Cut off flags at 50 chars to avoid abusing RegExp for DOS.\n                .slice(0, 50).replace(/[^gimuy]/g, '').replace(/(.)(?=.*\\1)/g, ''));\n              }\n            }, {\n              // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n              // which we match.)\n              matchJSONValue: function matchJSONValue(obj) {\n                return hasOwn(obj, '$InfNaN') && Object.keys(obj).length === 1;\n              },\n              matchObject: isInfOrNan,\n              toJSONValue: function toJSONValue(obj) {\n                var sign;\n\n                if (Number.isNaN(obj)) {\n                  sign = 0;\n                } else if (obj === Infinity) {\n                  sign = 1;\n                } else {\n                  sign = -1;\n                }\n\n                return {\n                  $InfNaN: sign\n                };\n              },\n              fromJSONValue: function fromJSONValue(obj) {\n                return obj.$InfNaN / 0;\n              }\n            }, {\n              // Binary\n              matchJSONValue: function matchJSONValue(obj) {\n                return hasOwn(obj, '$binary') && Object.keys(obj).length === 1;\n              },\n              matchObject: function matchObject(obj) {\n                return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && hasOwn(obj, '$Uint8ArrayPolyfill');\n              },\n              toJSONValue: function toJSONValue(obj) {\n                return {\n                  $binary: Base64.encode(obj)\n                };\n              },\n              fromJSONValue: function fromJSONValue(obj) {\n                return Base64.decode(obj.$binary);\n              }\n            }, {\n              // Escaping one level\n              matchJSONValue: function matchJSONValue(obj) {\n                return hasOwn(obj, '$escape') && Object.keys(obj).length === 1;\n              },\n              matchObject: function matchObject(obj) {\n                var match = false;\n\n                if (obj) {\n                  var keyCount = Object.keys(obj).length;\n\n                  if (keyCount === 1 || keyCount === 2) {\n                    match = builtinConverters.some(function (converter) {\n                      return converter.matchJSONValue(obj);\n                    });\n                  }\n                }\n\n                return match;\n              },\n              toJSONValue: function toJSONValue(obj) {\n                var newObj = {};\n                Object.keys(obj).forEach(function (key) {\n                  newObj[key] = _EJSON.toJSONValue(obj[key]);\n                });\n                return {\n                  $escape: newObj\n                };\n              },\n              fromJSONValue: function fromJSONValue(obj) {\n                var newObj = {};\n                Object.keys(obj.$escape).forEach(function (key) {\n                  newObj[key] = _EJSON.fromJSONValue(obj.$escape[key]);\n                });\n                return newObj;\n              }\n            }, {\n              // Custom\n              matchJSONValue: function matchJSONValue(obj) {\n                return hasOwn(obj, '$type') && hasOwn(obj, '$value') && Object.keys(obj).length === 2;\n              },\n              matchObject: function matchObject(obj) {\n                return _EJSON._isCustomType(obj);\n              },\n              toJSONValue: function toJSONValue(obj) {\n                var jsonValue = Meteor._noYieldsAllowed(function () {\n                  return obj.toJSONValue();\n                });\n\n                return {\n                  $type: obj.typeName(),\n                  $value: jsonValue\n                };\n              },\n              fromJSONValue: function fromJSONValue(obj) {\n                var typeName = obj.$type;\n\n                if (!hasOwn(customTypes, typeName)) {\n                  throw new Error(\"Custom EJSON type \".concat(typeName, \" is not defined\"));\n                }\n\n                var converter = customTypes[typeName];\n                return Meteor._noYieldsAllowed(function () {\n                  return converter(obj.$value);\n                });\n              }\n            }];\n\n            _EJSON._isCustomType = function (obj) {\n              return obj && typeof obj.toJSONValue === 'function' && typeof obj.typeName === 'function' && hasOwn(customTypes, obj.typeName());\n            };\n\n            _EJSON._getTypes = function () {\n              return customTypes;\n            };\n\n            _EJSON._getConverters = function () {\n              return builtinConverters;\n            }; // Either return the JSON-compatible version of the argument, or undefined (if\n            // the item isn't itself replaceable, but maybe some fields in it are)\n\n\n            var toJSONValueHelper = function toJSONValueHelper(item) {\n              for (var i = 0; i < builtinConverters.length; i++) {\n                var converter = builtinConverters[i];\n\n                if (converter.matchObject(item)) {\n                  return converter.toJSONValue(item);\n                }\n              }\n\n              return undefined;\n            }; // for both arrays and objects, in-place modification.\n\n\n            var adjustTypesToJSONValue = function adjustTypesToJSONValue(obj) {\n              // Is it an atom that we need to adjust?\n              if (obj === null) {\n                return null;\n              }\n\n              var maybeChanged = toJSONValueHelper(obj);\n\n              if (maybeChanged !== undefined) {\n                return maybeChanged;\n              } // Other atoms are unchanged.\n\n\n              if (_typeof(obj) !== 'object') {\n                return obj;\n              } // Iterate over array or object structure.\n\n\n              Object.keys(obj).forEach(function (key) {\n                var value = obj[key];\n\n                if (_typeof(value) !== 'object' && value !== undefined && !isInfOrNan(value)) {\n                  return; // continue\n                }\n\n                var changed = toJSONValueHelper(value);\n\n                if (changed) {\n                  obj[key] = changed;\n                  return; // on to the next key\n                } // if we get here, value is an object but not adjustable\n                // at this level.  recurse.\n\n\n                adjustTypesToJSONValue(value);\n              });\n              return obj;\n            };\n\n            _EJSON._adjustTypesToJSONValue = adjustTypesToJSONValue;\n            /**\n             * @summary Serialize an EJSON-compatible value into its plain JSON\n             *          representation.\n             * @locus Anywhere\n             * @param {EJSON} val A value to serialize to plain JSON.\n             */\n\n            _EJSON.toJSONValue = function (item) {\n              var changed = toJSONValueHelper(item);\n\n              if (changed !== undefined) {\n                return changed;\n              }\n\n              var newItem = item;\n\n              if (_typeof(item) === 'object') {\n                newItem = _EJSON.clone(item);\n                adjustTypesToJSONValue(newItem);\n              }\n\n              return newItem;\n            }; // Either return the argument changed to have the non-json\n            // rep of itself (the Object version) or the argument itself.\n            // DOES NOT RECURSE.  For actually getting the fully-changed value, use\n            // EJSON.fromJSONValue\n\n\n            var fromJSONValueHelper = function fromJSONValueHelper(value) {\n              if (_typeof(value) === 'object' && value !== null) {\n                var keys = Object.keys(value);\n\n                if (keys.length <= 2 && keys.every(function (k) {\n                  return typeof k === 'string' && k.substr(0, 1) === '$';\n                })) {\n                  for (var i = 0; i < builtinConverters.length; i++) {\n                    var converter = builtinConverters[i];\n\n                    if (converter.matchJSONValue(value)) {\n                      return converter.fromJSONValue(value);\n                    }\n                  }\n                }\n              }\n\n              return value;\n            }; // for both arrays and objects. Tries its best to just\n            // use the object you hand it, but may return something\n            // different if the object you hand it itself needs changing.\n\n\n            var adjustTypesFromJSONValue = function adjustTypesFromJSONValue(obj) {\n              if (obj === null) {\n                return null;\n              }\n\n              var maybeChanged = fromJSONValueHelper(obj);\n\n              if (maybeChanged !== obj) {\n                return maybeChanged;\n              } // Other atoms are unchanged.\n\n\n              if (_typeof(obj) !== 'object') {\n                return obj;\n              }\n\n              Object.keys(obj).forEach(function (key) {\n                var value = obj[key];\n\n                if (_typeof(value) === 'object') {\n                  var changed = fromJSONValueHelper(value);\n\n                  if (value !== changed) {\n                    obj[key] = changed;\n                    return;\n                  } // if we get here, value is an object but not adjustable\n                  // at this level.  recurse.\n\n\n                  adjustTypesFromJSONValue(value);\n                }\n              });\n              return obj;\n            };\n\n            _EJSON._adjustTypesFromJSONValue = adjustTypesFromJSONValue;\n            /**\n             * @summary Deserialize an EJSON value from its plain JSON representation.\n             * @locus Anywhere\n             * @param {JSONCompatible} val A value to deserialize into EJSON.\n             */\n\n            _EJSON.fromJSONValue = function (item) {\n              var changed = fromJSONValueHelper(item);\n\n              if (changed === item && _typeof(item) === 'object') {\n                changed = _EJSON.clone(item);\n                adjustTypesFromJSONValue(changed);\n              }\n\n              return changed;\n            };\n            /**\n             * @summary Serialize a value to a string. For EJSON values, the serialization\n             *          fully represents the value. For non-EJSON values, serializes the\n             *          same way as `JSON.stringify`.\n             * @locus Anywhere\n             * @param {EJSON} val A value to stringify.\n             * @param {Object} [options]\n             * @param {Boolean | Integer | String} options.indent Indents objects and\n             * arrays for easy readability.  When `true`, indents by 2 spaces; when an\n             * integer, indents by that number of spaces; and when a string, uses the\n             * string as the indentation pattern.\n             * @param {Boolean} options.canonical When `true`, stringifies keys in an\n             *                                    object in sorted order.\n             */\n\n\n            _EJSON.stringify = function (item, options) {\n              var serialized;\n\n              var json = _EJSON.toJSONValue(item);\n\n              if (options && (options.canonical || options.indent)) {\n                var canonicalStringify;\n                module.watch(require(\"./stringify\"), {\n                  default: function _default(v) {\n                    canonicalStringify = v;\n                  }\n                }, 0);\n                serialized = canonicalStringify(json, options);\n              } else {\n                serialized = JSON.stringify(json);\n              }\n\n              return serialized;\n            };\n            /**\n             * @summary Parse a string into an EJSON value. Throws an error if the string\n             *          is not valid EJSON.\n             * @locus Anywhere\n             * @param {String} str A string to parse into an EJSON value.\n             */\n\n\n            _EJSON.parse = function (item) {\n              if (typeof item !== 'string') {\n                throw new Error('EJSON.parse argument should be a string');\n              }\n\n              return _EJSON.fromJSONValue(JSON.parse(item));\n            };\n            /**\n             * @summary Returns true if `x` is a buffer of binary data, as returned from\n             *          [`EJSON.newBinary`](#ejson_new_binary).\n             * @param {Object} x The variable to check.\n             * @locus Anywhere\n             */\n\n\n            _EJSON.isBinary = function (obj) {\n              return !!(typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && obj.$Uint8ArrayPolyfill);\n            };\n            /**\n             * @summary Return true if `a` and `b` are equal to each other.  Return false\n             *          otherwise.  Uses the `equals` method on `a` if present, otherwise\n             *          performs a deep comparison.\n             * @locus Anywhere\n             * @param {EJSON} a\n             * @param {EJSON} b\n             * @param {Object} [options]\n             * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order,\n             * if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}`\n             * is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The\n             * default is `false`.\n             */\n\n\n            _EJSON.equals = function (a, b, options) {\n              var i;\n              var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n\n              if (a === b) {\n                return true;\n              } // This differs from the IEEE spec for NaN equality, b/c we don't want\n              // anything ever with a NaN to be poisoned from becoming equal to anything.\n\n\n              if (Number.isNaN(a) && Number.isNaN(b)) {\n                return true;\n              } // if either one is falsy, they'd have to be === to be equal\n\n\n              if (!a || !b) {\n                return false;\n              }\n\n              if (!(_typeof(a) === 'object' && _typeof(b) === 'object')) {\n                return false;\n              }\n\n              if (a instanceof Date && b instanceof Date) {\n                return a.valueOf() === b.valueOf();\n              }\n\n              if (_EJSON.isBinary(a) && _EJSON.isBinary(b)) {\n                if (a.length !== b.length) {\n                  return false;\n                }\n\n                for (i = 0; i < a.length; i++) {\n                  if (a[i] !== b[i]) {\n                    return false;\n                  }\n                }\n\n                return true;\n              }\n\n              if (typeof a.equals === 'function') {\n                return a.equals(b, options);\n              }\n\n              if (typeof b.equals === 'function') {\n                return b.equals(a, options);\n              }\n\n              if (a instanceof Array) {\n                if (!(b instanceof Array)) {\n                  return false;\n                }\n\n                if (a.length !== b.length) {\n                  return false;\n                }\n\n                for (i = 0; i < a.length; i++) {\n                  if (!_EJSON.equals(a[i], b[i], options)) {\n                    return false;\n                  }\n                }\n\n                return true;\n              } // fallback for custom types that don't implement their own equals\n\n\n              switch (_EJSON._isCustomType(a) + _EJSON._isCustomType(b)) {\n                case 1:\n                  return false;\n\n                case 2:\n                  return _EJSON.equals(_EJSON.toJSONValue(a), _EJSON.toJSONValue(b));\n\n                default: // Do nothing\n\n              } // fall back to structural equality of objects\n\n\n              var ret;\n              var aKeys = Object.keys(a);\n              var bKeys = Object.keys(b);\n\n              if (keyOrderSensitive) {\n                i = 0;\n                ret = aKeys.every(function (key) {\n                  if (i >= bKeys.length) {\n                    return false;\n                  }\n\n                  if (key !== bKeys[i]) {\n                    return false;\n                  }\n\n                  if (!_EJSON.equals(a[key], b[bKeys[i]], options)) {\n                    return false;\n                  }\n\n                  i++;\n                  return true;\n                });\n              } else {\n                i = 0;\n                ret = aKeys.every(function (key) {\n                  if (!hasOwn(b, key)) {\n                    return false;\n                  }\n\n                  if (!_EJSON.equals(a[key], b[key], options)) {\n                    return false;\n                  }\n\n                  i++;\n                  return true;\n                });\n              }\n\n              return ret && i === bKeys.length;\n            };\n            /**\n             * @summary Return a deep copy of `val`.\n             * @locus Anywhere\n             * @param {EJSON} val A value to copy.\n             */\n\n\n            _EJSON.clone = function (v) {\n              var ret;\n\n              if (_typeof(v) !== 'object') {\n                return v;\n              }\n\n              if (v === null) {\n                return null; // null has typeof \"object\"\n              }\n\n              if (v instanceof Date) {\n                return new Date(v.getTime());\n              } // RegExps are not really EJSON elements (eg we don't define a serialization\n              // for them), but they're immutable anyway, so we can support them in clone.\n\n\n              if (v instanceof RegExp) {\n                return v;\n              }\n\n              if (_EJSON.isBinary(v)) {\n                ret = _EJSON.newBinary(v.length);\n\n                for (var i = 0; i < v.length; i++) {\n                  ret[i] = v[i];\n                }\n\n                return ret;\n              }\n\n              if (Array.isArray(v)) {\n                return v.map(function (value) {\n                  return _EJSON.clone(value);\n                });\n              }\n\n              if (isArguments(v)) {\n                return Array.from(v).map(function (value) {\n                  return _EJSON.clone(value);\n                });\n              } // handle general user-defined typed Objects if they have a clone method\n\n\n              if (typeof v.clone === 'function') {\n                return v.clone();\n              } // handle other custom types\n\n\n              if (_EJSON._isCustomType(v)) {\n                return _EJSON.fromJSONValue(_EJSON.clone(_EJSON.toJSONValue(v)), true);\n              } // handle other objects\n\n\n              ret = {};\n              Object.keys(v).forEach(function (key) {\n                ret[key] = _EJSON.clone(v[key]);\n              });\n              return ret;\n            };\n            /**\n             * @summary Allocate a new buffer of binary data that EJSON can serialize.\n             * @locus Anywhere\n             * @param {Number} size The number of bytes of binary data to allocate.\n             */\n            // EJSON.newBinary is the public documented API for this functionality,\n            // but the implementation is in the 'base64' package to avoid\n            // introducing a circular dependency. (If the implementation were here,\n            // then 'base64' would have to use EJSON.newBinary, and 'ejson' would\n            // also have to use 'base64'.)\n\n\n            _EJSON.newBinary = Base64.newBinary; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          },\n          \"stringify.js\": function stringifyJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                             //\n            // packages/ejson/stringify.js                                                                                 //\n            //                                                                                                             //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // Based on json2.js from https://github.com/douglascrockford/JSON-js\n            //\n            //    json2.js\n            //    2012-10-08\n            //\n            //    Public Domain.\n            //\n            //    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n            function quote(string) {\n              return JSON.stringify(string);\n            }\n\n            var str = function str(key, holder, singleIndent, outerIndent, canonical) {\n              var value = holder[key]; // What happens next depends on the value's type.\n\n              switch (_typeof(value)) {\n                case 'string':\n                  return quote(value);\n\n                case 'number':\n                  // JSON numbers must be finite. Encode non-finite numbers as null.\n                  return isFinite(value) ? String(value) : 'null';\n\n                case 'boolean':\n                  return String(value);\n                // If the type is 'object', we might be dealing with an object or an array or\n                // null.\n\n                case 'object':\n                  // Due to a specification blunder in ECMAScript, typeof null is 'object',\n                  // so watch out for that case.\n                  if (!value) {\n                    return 'null';\n                  } // Make an array to hold the partial results of stringifying this object\n                  // value.\n\n\n                  var innerIndent = outerIndent + singleIndent;\n                  var partial = []; // Is the value an array?\n\n                  if (Array.isArray(value) || {}.hasOwnProperty.call(value, 'callee')) {\n                    // The value is an array. Stringify every element. Use null as a\n                    // placeholder for non-JSON values.\n                    var length = value.length;\n\n                    for (var i = 0; i < length; i += 1) {\n                      partial[i] = str(i, value, singleIndent, innerIndent, canonical) || 'null';\n                    } // Join all of the elements together, separated with commas, and wrap\n                    // them in brackets.\n\n\n                    var _v;\n\n                    if (partial.length === 0) {\n                      _v = '[]';\n                    } else if (innerIndent) {\n                      _v = '[\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + ']';\n                    } else {\n                      _v = '[' + partial.join(',') + ']';\n                    }\n\n                    return _v;\n                  } // Iterate through all of the keys in the object.\n\n\n                  var keys = Object.keys(value);\n\n                  if (canonical) {\n                    keys = keys.sort();\n                  }\n\n                  keys.forEach(function (k) {\n                    v = str(k, value, singleIndent, innerIndent, canonical);\n\n                    if (v) {\n                      partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);\n                    }\n                  }); // Join all of the member texts together, separated with commas,\n                  // and wrap them in braces.\n\n                  if (partial.length === 0) {\n                    v = '{}';\n                  } else if (innerIndent) {\n                    v = '{\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + '}';\n                  } else {\n                    v = '{' + partial.join(',') + '}';\n                  }\n\n                  return v;\n\n                default: // Do nothing\n\n              }\n            }; // If the JSON object does not yet have a stringify method, give it one.\n\n\n            var canonicalStringify = function canonicalStringify(value, options) {\n              // Make a fake root object containing our value under the key of ''.\n              // Return the result of stringifying the value.\n              var allOptions = Object.assign({\n                indent: '',\n                canonical: false\n              }, options);\n\n              if (allOptions.indent === true) {\n                allOptions.indent = '  ';\n              } else if (typeof allOptions.indent === 'number') {\n                var newIndent = '';\n\n                for (var i = 0; i < allOptions.indent; i++) {\n                  newIndent += ' ';\n                }\n\n                allOptions.indent = newIndent;\n              }\n\n              return str('', {\n                '': value\n              }, allOptions.indent, '', allOptions.canonical);\n            };\n\n            module.exportDefault(canonicalStringify); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/ejson/ejson.js\");\n  /* Exports */\n\n\n  Package._define(\"ejson\", exports, {\n    EJSON: EJSON\n  });\n})();\n\nmodule.exports = window.Package[\"ejson\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/ejson.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/es5-shim.js":
/*!*************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/es5-shim.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/es5-shim.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/geojson-utils.js":
/*!******************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/geojson-utils.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  /* Package-scope variables */\n\n  var GeoJSON;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"geojson-utils\": {\n          \"main.js\": function mainJs(require, exports) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                         //\n            // packages/geojson-utils/main.js                                                                          //\n            //                                                                                                         //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            exports.GeoJSON = require(\"./geojson-utils.js\"); /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          },\n          \"geojson-utils.js\": function geojsonUtilsJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                         //\n            // packages/geojson-utils/geojson-utils.js                                                                 //\n            //                                                                                                         //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            (function () {\n              var gju = {}; // Export the geojson object for **CommonJS**\n\n              if (typeof module !== 'undefined' && module.exports) {\n                module.exports = gju;\n              } // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js\n\n\n              gju.lineStringsIntersect = function (l1, l2) {\n                var intersects = [];\n\n                for (var i = 0; i <= l1.coordinates.length - 2; ++i) {\n                  for (var j = 0; j <= l2.coordinates.length - 2; ++j) {\n                    var a1 = {\n                      x: l1.coordinates[i][1],\n                      y: l1.coordinates[i][0]\n                    },\n                        a2 = {\n                      x: l1.coordinates[i + 1][1],\n                      y: l1.coordinates[i + 1][0]\n                    },\n                        b1 = {\n                      x: l2.coordinates[j][1],\n                      y: l2.coordinates[j][0]\n                    },\n                        b2 = {\n                      x: l2.coordinates[j + 1][1],\n                      y: l2.coordinates[j + 1][0]\n                    },\n                        ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),\n                        ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),\n                        u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n\n                    if (u_b != 0) {\n                      var ua = ua_t / u_b,\n                          ub = ub_t / u_b;\n\n                      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n                        intersects.push({\n                          'type': 'Point',\n                          'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]\n                        });\n                      }\n                    }\n                  }\n                }\n\n                if (intersects.length == 0) intersects = false;\n                return intersects;\n              }; // Bounding Box\n\n\n              function boundingBoxAroundPolyCoords(coords) {\n                var xAll = [],\n                    yAll = [];\n\n                for (var i = 0; i < coords[0].length; i++) {\n                  xAll.push(coords[0][i][1]);\n                  yAll.push(coords[0][i][0]);\n                }\n\n                xAll = xAll.sort(function (a, b) {\n                  return a - b;\n                });\n                yAll = yAll.sort(function (a, b) {\n                  return a - b;\n                });\n                return [[xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]]];\n              }\n\n              gju.pointInBoundingBox = function (point, bounds) {\n                return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]);\n              }; // Point in Polygon\n              // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices\n\n\n              function pnpoly(x, y, coords) {\n                var vert = [[0, 0]];\n\n                for (var i = 0; i < coords.length; i++) {\n                  for (var j = 0; j < coords[i].length; j++) {\n                    vert.push(coords[i][j]);\n                  }\n\n                  vert.push([0, 0]);\n                }\n\n                var inside = false;\n\n                for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {\n                  if (vert[i][0] > y != vert[j][0] > y && x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1]) inside = !inside;\n                }\n\n                return inside;\n              }\n\n              gju.pointInPolygon = function (p, poly) {\n                var coords = poly.type == \"Polygon\" ? [poly.coordinates] : poly.coordinates;\n                var insideBox = false;\n\n                for (var i = 0; i < coords.length; i++) {\n                  if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true;\n                }\n\n                if (!insideBox) return false;\n                var insidePoly = false;\n\n                for (var i = 0; i < coords.length; i++) {\n                  if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true;\n                }\n\n                return insidePoly;\n              };\n\n              gju.numberToRadius = function (number) {\n                return number * Math.PI / 180;\n              };\n\n              gju.numberToDegree = function (number) {\n                return number * 180 / Math.PI;\n              }; // written with help from @tautologe\n\n\n              gju.drawCircle = function (radiusInMeters, centerPoint, steps) {\n                var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],\n                    dist = radiusInMeters / 1000 / 6371,\n                    // convert meters to radiant\n                radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],\n                    steps = steps || 15,\n                    // 15 sided circle\n                poly = [[center[0], center[1]]];\n\n                for (var i = 0; i < steps; i++) {\n                  var brng = 2 * Math.PI * i / steps;\n                  var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist) + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));\n                  var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]), Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));\n                  poly[i] = [];\n                  poly[i][1] = gju.numberToDegree(lat);\n                  poly[i][0] = gju.numberToDegree(lng);\n                }\n\n                return {\n                  \"type\": \"Polygon\",\n                  \"coordinates\": [poly]\n                };\n              }; // assumes rectangle starts at lower left point\n\n\n              gju.rectangleCentroid = function (rectangle) {\n                var bbox = rectangle.coordinates[0];\n                var xmin = bbox[0][0],\n                    ymin = bbox[0][1],\n                    xmax = bbox[2][0],\n                    ymax = bbox[2][1];\n                var xwidth = xmax - xmin;\n                var ywidth = ymax - ymin;\n                return {\n                  'type': 'Point',\n                  'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]\n                };\n              }; // from http://www.movable-type.co.uk/scripts/latlong.html\n\n\n              gju.pointDistance = function (pt1, pt2) {\n                var lon1 = pt1.coordinates[0],\n                    lat1 = pt1.coordinates[1],\n                    lon2 = pt2.coordinates[0],\n                    lat2 = pt2.coordinates[1],\n                    dLat = gju.numberToRadius(lat2 - lat1),\n                    dLon = gju.numberToRadius(lon2 - lon1),\n                    a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1)) * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),\n                    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); // Earth radius is 6371 km\n\n                return 6371 * c * 1000; // returns meters\n              }, // checks if geometry lies entirely within a circle\n              // works with Point, LineString, Polygon\n              gju.geometryWithinRadius = function (geometry, center, radius) {\n                if (geometry.type == 'Point') {\n                  return gju.pointDistance(geometry, center) <= radius;\n                } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {\n                  var point = {};\n                  var coordinates;\n\n                  if (geometry.type == 'Polygon') {\n                    // it's enough to check the exterior ring of the Polygon\n                    coordinates = geometry.coordinates[0];\n                  } else {\n                    coordinates = geometry.coordinates;\n                  }\n\n                  for (var i in coordinates) {\n                    point.coordinates = coordinates[i];\n\n                    if (gju.pointDistance(point, center) > radius) {\n                      return false;\n                    }\n                  }\n                }\n\n                return true;\n              }; // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt\n\n              gju.area = function (polygon) {\n                var area = 0; // TODO: polygon holes at coordinates[1]\n\n                var points = polygon.coordinates[0];\n                var j = points.length - 1;\n                var p1, p2;\n\n                for (var i = 0; i < points.length; j = i++) {\n                  var p1 = {\n                    x: points[i][1],\n                    y: points[i][0]\n                  };\n                  var p2 = {\n                    x: points[j][1],\n                    y: points[j][0]\n                  };\n                  area += p1.x * p2.y;\n                  area -= p1.y * p2.x;\n                }\n\n                area /= 2;\n                return area;\n              }, // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt\n              gju.centroid = function (polygon) {\n                var f,\n                    x = 0,\n                    y = 0; // TODO: polygon holes at coordinates[1]\n\n                var points = polygon.coordinates[0];\n                var j = points.length - 1;\n                var p1, p2;\n\n                for (var i = 0; i < points.length; j = i++) {\n                  var p1 = {\n                    x: points[i][1],\n                    y: points[i][0]\n                  };\n                  var p2 = {\n                    x: points[j][1],\n                    y: points[j][0]\n                  };\n                  f = p1.x * p2.y - p2.x * p1.y;\n                  x += (p1.x + p2.x) * f;\n                  y += (p1.y + p2.y) * f;\n                }\n\n                f = gju.area(polygon) * 6;\n                return {\n                  'type': 'Point',\n                  'coordinates': [y / f, x / f]\n                };\n              }, gju.simplify = function (source, kink) {\n                /* source[] array of geojson points */\n\n                /* kink\tin metres, kinks above this depth kept  */\n\n                /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */\n                kink = kink || 20;\n                source = source.map(function (o) {\n                  return {\n                    lng: o.coordinates[0],\n                    lat: o.coordinates[1]\n                  };\n                });\n                var n_source, n_stack, n_dest, start, end, i, sig;\n                var dev_sqr, max_dev_sqr, band_sqr;\n                var x12, y12, d12, x13, y13, d13, x23, y23, d23;\n                var F = Math.PI / 180.0 * 0.5;\n                var index = new Array();\n                /* aray of indexes of source points to include in the reduced line */\n\n                var sig_start = new Array();\n                /* indices of start & end of working section */\n\n                var sig_end = new Array();\n                /* check for simple cases */\n\n                if (source.length < 3) return source;\n                /* one or two points */\n\n                /* more complex case. initialize stack */\n\n                n_source = source.length;\n                band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0);\n                /* Now in degrees */\n\n                band_sqr *= band_sqr;\n                n_dest = 0;\n                sig_start[0] = 0;\n                sig_end[0] = n_source - 1;\n                n_stack = 1;\n                /* while the stack is not empty  ... */\n\n                while (n_stack > 0) {\n                  /* ... pop the top-most entries off the stacks */\n                  start = sig_start[n_stack - 1];\n                  end = sig_end[n_stack - 1];\n                  n_stack--;\n\n                  if (end - start > 1) {\n                    /* any intermediate points ? */\n\n                    /* ... yes, so find most deviant intermediate point to\n                    either side of line joining start & end points */\n                    x12 = source[end].lng() - source[start].lng();\n                    y12 = source[end].lat() - source[start].lat();\n                    if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);\n                    x12 *= Math.cos(F * (source[end].lat() + source[start].lat()));\n                    /* use avg lat to reduce lng */\n\n                    d12 = x12 * x12 + y12 * y12;\n\n                    for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {\n                      x13 = source[i].lng() - source[start].lng();\n                      y13 = source[i].lat() - source[start].lat();\n                      if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);\n                      x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));\n                      d13 = x13 * x13 + y13 * y13;\n                      x23 = source[i].lng() - source[end].lng();\n                      y23 = source[i].lat() - source[end].lat();\n                      if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);\n                      x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));\n                      d23 = x23 * x23 + y23 * y23;\n                      if (d13 >= d12 + d23) dev_sqr = d23;else if (d23 >= d12 + d13) dev_sqr = d13;else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle\n\n                      if (dev_sqr > max_dev_sqr) {\n                        sig = i;\n                        max_dev_sqr = dev_sqr;\n                      }\n                    }\n\n                    if (max_dev_sqr < band_sqr) {\n                      /* is there a sig. intermediate point ? */\n\n                      /* ... no, so transfer current start point */\n                      index[n_dest] = start;\n                      n_dest++;\n                    } else {\n                      /* ... yes, so push two sub-sections on stack for further processing */\n                      n_stack++;\n                      sig_start[n_stack - 1] = sig;\n                      sig_end[n_stack - 1] = end;\n                      n_stack++;\n                      sig_start[n_stack - 1] = start;\n                      sig_end[n_stack - 1] = sig;\n                    }\n                  } else {\n                    /* ... no intermediate points, so transfer current start point */\n                    index[n_dest] = start;\n                    n_dest++;\n                  }\n                }\n                /* transfer last point */\n\n\n                index[n_dest] = n_source - 1;\n                n_dest++;\n                /* make return array */\n\n                var r = new Array();\n\n                for (var i = 0; i < n_dest; i++) {\n                  r.push(source[index[i]]);\n                }\n\n                return r.map(function (o) {\n                  return {\n                    type: \"Point\",\n                    coordinates: [o.lng, o.lat]\n                  };\n                });\n              }; // http://www.movable-type.co.uk/scripts/latlong.html#destPoint\n\n              gju.destinationPoint = function (pt, brng, dist) {\n                dist = dist / 6371; // convert dist to angular distance in radians\n\n                brng = gju.numberToRadius(brng);\n                var lat1 = gju.numberToRadius(pt.coordinates[0]);\n                var lon1 = gju.numberToRadius(pt.coordinates[1]);\n                var lat2 = Math.asin(Math.sin(lat1) * Math.cos(dist) + Math.cos(lat1) * Math.sin(dist) * Math.cos(brng));\n                var lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(lat1), Math.cos(dist) - Math.sin(lat1) * Math.sin(lat2));\n                lon2 = (lon2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180\n\n                return {\n                  'type': 'Point',\n                  'coordinates': [gju.numberToDegree(lat2), gju.numberToDegree(lon2)]\n                };\n              };\n            })(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/geojson-utils/main.js\");\n  /* Exports */\n\n\n  Package._define(\"geojson-utils\", exports, {\n    GeoJSON: GeoJSON\n  });\n})();\n\nmodule.exports = window.Package[\"geojson-utils\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/geojson-utils.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/hot-code-push.js":
/*!******************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/hot-code-push.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/hot-code-push.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/http.js":
/*!*********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/http.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var URL = Package.url.URL;\n  var meteorInstall = Package.modules.meteorInstall;\n  /* Package-scope variables */\n\n  var HTTP;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"http\": {\n          \"httpcall_client.js\": function httpcall_clientJs(require, exports, module) {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/http/httpcall_client.js                                                                                   //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var URL = require(\"meteor/url\").URL;\n\n            var common = require(\"./httpcall_common.js\");\n\n            var HTTP = exports.HTTP = common.HTTP;\n            var hasOwn = Object.prototype.hasOwnProperty;\n            /**\n             * @summary Perform an outbound HTTP request.\n             * @locus Anywhere\n             * @param {String} method The [HTTP method](http://en.wikipedia.org/wiki/HTTP_method) to use, such as \"`GET`\", \"`POST`\", or \"`HEAD`\".\n             * @param {String} url The URL to retrieve.\n             * @param {Object} [options]\n             * @param {String} options.content String to use as the HTTP request body.\n             * @param {Object} options.data JSON-able object to stringify and use as the HTTP request body. Overwrites `content`.\n             * @param {String} options.query Query string to go in the URL. Overwrites any query string in `url`.\n             * @param {Object} options.params Dictionary of request parameters to be encoded and placed in the URL (for GETs) or request body (for POSTs).  If `content` or `data` is specified, `params` will always be placed in the URL.\n             * @param {String} options.auth HTTP basic authentication string of the form `\"username:password\"`\n             * @param {Object} options.headers Dictionary of strings, headers to add to the HTTP request.\n             * @param {Number} options.timeout Maximum time in milliseconds to wait for the request before failing.  There is no timeout by default.\n             * @param {Boolean} options.followRedirects If `true`, transparently follow HTTP redirects. Cannot be set to `false` on the client. Default `true`.\n             * @param {Object} options.npmRequestOptions On the server, `HTTP.call` is implemented by using the [npm `request` module](https://www.npmjs.com/package/request). Any options in this object will be passed directly to the `request` invocation.\n             * @param {Function} options.beforeSend On the client, this will be called before the request is sent to allow for more direct manipulation of the underlying XMLHttpRequest object, which will be passed as the first argument. If the callback returns `false`, the request will be not be send.\n             * @param {Function} [asyncCallback] Optional callback.  If passed, the method runs asynchronously, instead of synchronously, and calls asyncCallback.  On the client, this callback is required.\n             */\n\n            HTTP.call = function (method, url, options, callback) {\n              ////////// Process arguments //////////\n              if (!callback && typeof options === \"function\") {\n                // support (method, url, callback) argument list\n                callback = options;\n                options = null;\n              }\n\n              options = options || {};\n              if (typeof callback !== \"function\") throw new Error(\"Can't make a blocking HTTP call from the client; callback required.\");\n              method = (method || \"\").toUpperCase();\n              var headers = {};\n              var content = options.content;\n\n              if (options.data) {\n                content = JSON.stringify(options.data);\n                headers['Content-Type'] = 'application/json';\n              }\n\n              var params_for_url, params_for_body;\n              if (content || method === \"GET\" || method === \"HEAD\") params_for_url = options.params;else params_for_body = options.params;\n              url = URL._constructUrl(url, options.query, params_for_url);\n              if (options.followRedirects === false) throw new Error(\"Option followRedirects:false not supported on client.\");\n\n              if (hasOwn.call(options, 'npmRequestOptions')) {\n                throw new Error(\"Option npmRequestOptions not supported on client.\");\n              }\n\n              var username, password;\n\n              if (options.auth) {\n                var colonLoc = options.auth.indexOf(':');\n                if (colonLoc < 0) throw new Error('Option auth should be of the form \"username:password\"');\n                username = options.auth.substring(0, colonLoc);\n                password = options.auth.substring(colonLoc + 1);\n              }\n\n              if (params_for_body) {\n                content = URL._encodeParams(params_for_body);\n              }\n\n              if (options.headers) {\n                Object.keys(options.headers).forEach(function (key) {\n                  headers[key] = options.headers[key];\n                });\n              } ////////// Callback wrapping //////////\n              // wrap callback to add a 'response' property on an error, in case\n              // we have both (http 4xx/5xx error, which has a response payload)\n\n\n              callback = function (callback) {\n                var called = false;\n                return function (error, response) {\n                  if (!called) {\n                    called = true;\n\n                    if (error && response) {\n                      error.response = response;\n                    }\n\n                    callback(error, response);\n                  }\n                };\n              }(callback); ////////// Kickoff! //////////\n              // from this point on, errors are because of something remote, not\n              // something we should check in advance. Turn exceptions into error\n              // results.\n\n\n              try {\n                // setup XHR object\n                var xhr;\n                if (typeof XMLHttpRequest !== \"undefined\") xhr = new XMLHttpRequest();else if (typeof ActiveXObject !== \"undefined\") xhr = new ActiveXObject(\"Microsoft.XMLHttp\"); // IE6\n                else throw new Error(\"Can't create XMLHttpRequest\"); // ???\n\n                xhr.open(method, url, true, username, password);\n\n                for (var k in headers) {\n                  xhr.setRequestHeader(k, headers[k]);\n                } // setup timeout\n\n\n                var timed_out = false;\n                var timer;\n\n                if (options.timeout) {\n                  timer = Meteor.setTimeout(function () {\n                    timed_out = true;\n                    xhr.abort();\n                  }, options.timeout);\n                }\n\n                ; // callback on complete\n\n                xhr.onreadystatechange = function (evt) {\n                  if (xhr.readyState === 4) {\n                    // COMPLETE\n                    if (timer) Meteor.clearTimeout(timer);\n\n                    if (timed_out) {\n                      callback(new Error(\"Connection timeout\"));\n                    } else if (!xhr.status) {\n                      // no HTTP response\n                      callback(new Error(\"Connection lost\"));\n                    } else {\n                      var response = {};\n                      response.statusCode = xhr.status;\n                      response.content = xhr.responseText;\n                      response.headers = {};\n                      var header_str = xhr.getAllResponseHeaders(); // https://github.com/meteor/meteor/issues/553\n                      //\n                      // In Firefox there is a weird issue, sometimes\n                      // getAllResponseHeaders returns the empty string, but\n                      // getResponseHeader returns correct results. Possibly this\n                      // issue:\n                      // https://bugzilla.mozilla.org/show_bug.cgi?id=608735\n                      //\n                      // If this happens we can't get a full list of headers, but\n                      // at least get content-type so our JSON decoding happens\n                      // correctly. In theory, we could try and rescue more header\n                      // values with a list of common headers, but content-type is\n                      // the only vital one for now.\n\n                      if (\"\" === header_str && xhr.getResponseHeader(\"content-type\")) header_str = \"content-type: \" + xhr.getResponseHeader(\"content-type\");\n                      var headers_raw = header_str.split(/\\r?\\n/);\n                      headers_raw.forEach(function (h) {\n                        var m = /^(.*?):(?:\\s+)(.*)$/.exec(h);\n\n                        if (m && m.length === 3) {\n                          response.headers[m[1].toLowerCase()] = m[2];\n                        }\n                      });\n                      common.populateData(response);\n                      var error = null;\n\n                      if (response.statusCode >= 400) {\n                        error = common.makeErrorByStatus(response.statusCode, response.content);\n                      }\n\n                      callback(error, response);\n                    }\n                  }\n                }; // Allow custom control over XHR and abort early.\n\n\n                if (typeof options.beforeSend === \"function\") {\n                  // Call the callback and check to see if the request was aborted\n                  if (false === options.beforeSend.call(null, xhr, options)) {\n                    return xhr.abort();\n                  }\n                } // send it on its way\n\n\n                xhr.send(content);\n              } catch (err) {\n                callback(err);\n              }\n            }; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"httpcall_common.js\": function httpcall_commonJs(require, exports) {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/http/httpcall_common.js                                                                                   //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var MAX_LENGTH = 500; // if you change this, also change the appropriate test\n\n            var slice = Array.prototype.slice;\n\n            exports.makeErrorByStatus = function (statusCode, content) {\n              var message = \"failed [\" + statusCode + \"]\";\n\n              if (content) {\n                var stringContent = typeof content == \"string\" ? content : content.toString();\n                message += ' ' + truncate(stringContent.replace(/\\n/g, ' '), MAX_LENGTH);\n              }\n\n              return new Error(message);\n            };\n\n            function truncate(str, length) {\n              return str.length > length ? str.slice(0, length) + '...' : str;\n            } // Fill in `response.data` if the content-type is JSON.\n\n\n            exports.populateData = function (response) {\n              // Read Content-Type header, up to a ';' if there is one.\n              // A typical header might be \"application/json; charset=utf-8\"\n              // or just \"application/json\".\n              var contentType = (response.headers['content-type'] || ';').split(';')[0]; // Only try to parse data as JSON if server sets correct content type.\n\n              if (['application/json', 'text/javascript', 'application/javascript', 'application/x-javascript'].indexOf(contentType) >= 0) {\n                try {\n                  response.data = JSON.parse(response.content);\n                } catch (err) {\n                  response.data = null;\n                }\n              } else {\n                response.data = null;\n              }\n            };\n\n            var HTTP = exports.HTTP = {};\n            /**\n             * @summary Send an HTTP `GET` request. Equivalent to calling [`HTTP.call`](#http_call) with \"GET\" as the first argument.\n             * @param {String} url The URL to which the request should be sent.\n             * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n             * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n             * @locus Anywhere\n             */\n\n            HTTP.get = function ()\n            /* varargs */\n            {\n              return HTTP.call.apply(this, [\"GET\"].concat(slice.call(arguments)));\n            };\n            /**\n             * @summary Send an HTTP `POST` request. Equivalent to calling [`HTTP.call`](#http_call) with \"POST\" as the first argument.\n             * @param {String} url The URL to which the request should be sent.\n             * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n             * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n             * @locus Anywhere\n             */\n\n\n            HTTP.post = function ()\n            /* varargs */\n            {\n              return HTTP.call.apply(this, [\"POST\"].concat(slice.call(arguments)));\n            };\n            /**\n             * @summary Send an HTTP `PUT` request. Equivalent to calling [`HTTP.call`](#http_call) with \"PUT\" as the first argument.\n             * @param {String} url The URL to which the request should be sent.\n             * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n             * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n             * @locus Anywhere\n             */\n\n\n            HTTP.put = function ()\n            /* varargs */\n            {\n              return HTTP.call.apply(this, [\"PUT\"].concat(slice.call(arguments)));\n            };\n            /**\n             * @summary Send an HTTP `DELETE` request. Equivalent to calling [`HTTP.call`](#http_call) with \"DELETE\" as the first argument. (Named `del` to avoid conflict with the Javascript keyword `delete`)\n             * @param {String} url The URL to which the request should be sent.\n             * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n             * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n             * @locus Anywhere\n             */\n\n\n            HTTP.del = function ()\n            /* varargs */\n            {\n              return HTTP.call.apply(this, [\"DELETE\"].concat(slice.call(arguments)));\n            };\n            /**\n             * @summary Send an HTTP `PATCH` request. Equivalent to calling [`HTTP.call`](#http_call) with \"PATCH\" as the first argument.\n             * @param {String} url The URL to which the request should be sent.\n             * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n             * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n             * @locus Anywhere\n             */\n\n\n            HTTP.patch = function ()\n            /* varargs */\n            {\n              return HTTP.call.apply(this, [\"PATCH\"].concat(slice.call(arguments)));\n            }; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/http/httpcall_client.js\");\n  /* Exports */\n\n\n  Package._define(\"http\", exports, {\n    HTTP: HTTP\n  });\n})();\n\nmodule.exports = window.Package[\"http\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/http.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/id-map.js":
/*!***********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/id-map.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var EJSON = Package.ejson.EJSON;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var IdMap;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"id-map\": {\n          \"id-map.js\": function idMapJs(require, exports, module) {\n            ////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                        //\n            // packages/id-map/id-map.js                                                              //\n            //                                                                                        //\n            ////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              IdMap: function IdMap() {\n                return _IdMap;\n              }\n            });\n            var hasOwn = Object.prototype.hasOwnProperty;\n\n            var _IdMap =\n            /*#__PURE__*/\n            function () {\n              function _IdMap(idStringify, idParse) {\n                _classCallCheck(this, _IdMap);\n\n                this.clear();\n                this._idStringify = idStringify || JSON.stringify;\n                this._idParse = idParse || JSON.parse;\n              } // Some of these methods are designed to match methods on OrderedDict, since\n              // (eg) ObserveMultiplex and _CachingChangeObserver use them interchangeably.\n              // (Conceivably, this should be replaced with \"UnorderedDict\" with a specific\n              // set of methods that overlap between the two.)\n\n\n              _createClass(_IdMap, [{\n                key: \"get\",\n                value: function get(id) {\n                  var key = this._idStringify(id);\n\n                  return this._map[key];\n                }\n              }, {\n                key: \"set\",\n                value: function set(id, value) {\n                  var key = this._idStringify(id);\n\n                  this._map[key] = value;\n                }\n              }, {\n                key: \"remove\",\n                value: function remove(id) {\n                  var key = this._idStringify(id);\n\n                  delete this._map[key];\n                }\n              }, {\n                key: \"has\",\n                value: function has(id) {\n                  var key = this._idStringify(id);\n\n                  return hasOwn.call(this._map, key);\n                }\n              }, {\n                key: \"empty\",\n                value: function empty() {\n                  for (var key in this._map) {\n                    return false;\n                  }\n\n                  return true;\n                }\n              }, {\n                key: \"clear\",\n                value: function clear() {\n                  this._map = Object.create(null);\n                } // Iterates over the items in the map. Return `false` to break the loop.\n\n              }, {\n                key: \"forEach\",\n                value: function forEach(iterator) {\n                  // don't use _.each, because we can't break out of it.\n                  var keys = Object.keys(this._map);\n\n                  for (var i = 0; i < keys.length; i++) {\n                    var breakIfFalse = iterator.call(null, this._map[keys[i]], this._idParse(keys[i]));\n\n                    if (breakIfFalse === false) {\n                      return;\n                    }\n                  }\n                }\n              }, {\n                key: \"size\",\n                value: function size() {\n                  return Object.keys(this._map).length;\n                }\n              }, {\n                key: \"setDefault\",\n                value: function setDefault(id, def) {\n                  var key = this._idStringify(id);\n\n                  if (hasOwn.call(this._map, key)) {\n                    return this._map[key];\n                  }\n\n                  this._map[key] = def;\n                  return def;\n                } // Assumes that values are EJSON-cloneable, and that we don't need to clone\n                // IDs (ie, that nobody is going to mutate an ObjectId).\n\n              }, {\n                key: \"clone\",\n                value: function clone() {\n                  var clone = new _IdMap(this._idStringify, this._idParse);\n                  this.forEach(function (value, id) {\n                    clone.set(id, EJSON.clone(value));\n                  });\n                  return clone;\n                }\n              }]);\n\n              return _IdMap;\n            }(); ////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/id-map/id-map.js\");\n  /* Exports */\n\n\n  Package._define(\"id-map\", exports, {\n    IdMap: IdMap\n  });\n})();\n\nmodule.exports = window.Package[\"id-map\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/id-map.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/insecure.js":
/*!*************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/insecure.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/insecure.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/launch-screen.js":
/*!******************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/launch-screen.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  /* Package-scope variables */\n\n  var LaunchScreen;\n  (function () {\n    ////////////////////////////////////////////////////////////////////////////\n    //                                                                        //\n    // packages/launch-screen/mobile-launch-screen.js                         //\n    //                                                                        //\n    ////////////////////////////////////////////////////////////////////////////\n    //\n    // XXX This currently implements loading screens for mobile apps only,\n    // but in the future can be expanded to all apps.\n    var holdCount = 0;\n    var alreadyHidden = false;\n    LaunchScreen = {\n      hold: function hold() {\n        if (!Meteor.isCordova) {\n          return {\n            release: function release() {\n              /* noop */\n            }\n          };\n        }\n\n        if (alreadyHidden) {\n          throw new Error(\"Can't show launch screen once it's hidden\");\n        }\n\n        holdCount++;\n        var released = false;\n\n        var release = function release() {\n          if (!Meteor.isCordova) return;\n\n          if (!released) {\n            released = true;\n            holdCount--;\n\n            if (holdCount === 0 && typeof navigator !== 'undefined' && navigator.splashscreen) {\n              alreadyHidden = true;\n              navigator.splashscreen.hide();\n            }\n          }\n        }; // Returns a launch screen handle with a release method\n\n\n        return {\n          release: release\n        };\n      }\n    }; ////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n  (function () {\n    ////////////////////////////////////////////////////////////////////////////\n    //                                                                        //\n    // packages/launch-screen/default-behavior.js                             //\n    //                                                                        //\n    ////////////////////////////////////////////////////////////////////////////\n    //\n    // Hold launch screen on app load. This reflects the fact that Meteor\n    // mobile apps that use this package always start with a launch screen\n    // visible. (see XXX comment at the top of package.js for more\n    // details)\n    var handle = LaunchScreen.hold();\n    var Template = Package.templating && Package.templating.Template;\n    Meteor.startup(function () {\n      if (!Template) {\n        handle.release();\n      } else if (Package['iron:router']) {\n        // XXX Instead of doing this here, this code should be in\n        // iron:router directly. Note that since we're in a\n        // `Meteor.startup` block it's ok that we don't have a\n        // weak dependency on iron:router in package.js.\n        Package['iron:router'].Router.onAfterAction(function () {\n          handle.release();\n        });\n      } else {\n        Template.body.onRendered(function () {\n          handle.release();\n        }); // In case `Template.body` never gets rendered (due to some bug),\n        // hide the launch screen after 6 seconds. This matches the\n        // observed timeout that Cordova apps on Android (but not iOS)\n        // have on hiding the launch screen (even if you don't call\n        // `navigator.splashscreen.hide()`)\n\n        setTimeout(function () {\n          handle.release();\n        }, 6000);\n      }\n    }); ////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n  /* Exports */\n\n  Package._define(\"launch-screen\", {\n    LaunchScreen: LaunchScreen\n  });\n})();\n\nmodule.exports = window.Package[\"launch-screen\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/launch-screen.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/livedata.js":
/*!*************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/livedata.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/livedata.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/meteor-base.js":
/*!****************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/meteor-base.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/meteor-base.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/meteor.js":
/*!***********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/meteor.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Package-scope variables */\n  var global, meteorEnv, Meteor;\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/global.js                                                                            //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Export a reliable global object for all Meteor code.\n    global = this; //////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/client_environment.js                                                                //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    var config = __meteor_runtime_config__;\n    meteorEnv = config.meteorEnv;\n    /**\n     * @summary The Meteor namespace\n     * @namespace Meteor\n     */\n\n    Meteor = {\n      /**\n       * @summary Boolean variable.  True if running in production environment.\n       * @locus Anywhere\n       * @static\n       * @type {Boolean}\n       */\n      isProduction: meteorEnv.NODE_ENV === \"production\",\n\n      /**\n       * @summary Boolean variable.  True if running in development environment.\n       * @locus Anywhere\n       * @static\n       * @type {Boolean}\n       */\n      isDevelopment: meteorEnv.NODE_ENV !== \"production\",\n\n      /**\n       * @summary Boolean variable.  True if running in client environment.\n       * @locus Anywhere\n       * @static\n       * @type {Boolean}\n       */\n      isClient: true,\n\n      /**\n       * @summary Boolean variable.  True if running in server environment.\n       * @locus Anywhere\n       * @static\n       * @type {Boolean}\n       */\n      isServer: false,\n\n      /**\n       * @summary Boolean variable.  True if running in Cordova environment.\n       * @locus Anywhere\n       * @static\n       * @type {Boolean}\n       */\n      isCordova: false,\n\n      /**\n       * @summary Boolean variable. True if running in a \"modern\" JS\n       *          environment, as determined by the `modern` package.\n       * @locus Anywhere\n       * @static\n       * @type {Boolean}\n       */\n      isModern: config.isModern\n    };\n\n    if (config.PUBLIC_SETTINGS) {\n      /**\n       * @summary `Meteor.settings` contains deployment-specific configuration options. You can initialize settings by passing the `--settings` option (which takes the name of a file containing JSON data) to `meteor run` or `meteor deploy`. When running your server directly (e.g. from a bundle), you instead specify settings by putting the JSON directly into the `METEOR_SETTINGS` environment variable. If the settings object contains a key named `public`, then `Meteor.settings.public` will be available on the client as well as the server.  All other properties of `Meteor.settings` are only defined on the server.  You can rely on `Meteor.settings` and `Meteor.settings.public` being defined objects (not undefined) on both client and server even if there are no settings specified.  Changes to `Meteor.settings.public` at runtime will be picked up by new client connections.\n       * @locus Anywhere\n       * @type {Object}\n       */\n      Meteor.settings = {\n        \"public\": config.PUBLIC_SETTINGS\n      };\n    } //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/define-package.js                                                                    //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    function PackageRegistry() {\n      this._promiseInfoMap = Object.create(null);\n    }\n\n    var PRp = PackageRegistry.prototype; // Set global.Package[name] = pkg || {}. If additional arguments are\n    // supplied, their keys will be copied into pkg if not already present.\n    // This method is defined on the prototype of global.Package so that it\n    // will not be included in Object.keys(Package).\n\n    PRp._define = function definePackage(name, pkg) {\n      pkg = pkg || {};\n      var argc = arguments.length;\n\n      for (var i = 2; i < argc; ++i) {\n        var arg = arguments[i];\n\n        for (var s in arg) {\n          if (!(s in pkg)) {\n            pkg[s] = arg[s];\n          }\n        }\n      }\n\n      this[name] = pkg;\n      var info = this._promiseInfoMap[name];\n\n      if (info) {\n        info.resolve(pkg);\n      }\n\n      return pkg;\n    };\n\n    PRp._has = function has(name) {\n      return Object.prototype.hasOwnProperty.call(this, name);\n    }; // Returns a Promise that will resolve to the exports of the named\n    // package, or be rejected if the package is not installed.\n\n\n    PRp._promise = function promise(name) {\n      var self = this;\n      var info = self._promiseInfoMap[name];\n\n      if (!info) {\n        info = self._promiseInfoMap[name] = {};\n        info.promise = new Promise(function (resolve, reject) {\n          info.resolve = resolve;\n\n          if (self._has(name)) {\n            resolve(self[name]);\n          } else {\n            Meteor.startup(function () {\n              if (!self._has(name)) {\n                reject(new Error(\"Package \" + name + \" not installed\"));\n              }\n            });\n          }\n        });\n      }\n\n      return info.promise;\n    }; // Initialize the Package namespace used by all Meteor packages.\n\n\n    global.Package = new PackageRegistry();\n\n    if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === \"object\") {\n      // This code is also used by meteor/tools/isobuild/bundler.js.\n      exports.PackageRegistry = PackageRegistry;\n    } //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/helpers.js                                                                           //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    if (Meteor.isServer) var Future = Npm.require('fibers/future');\n\n    if ((typeof __meteor_runtime_config__ === \"undefined\" ? \"undefined\" : _typeof(__meteor_runtime_config__)) === 'object' && __meteor_runtime_config__.meteorRelease) {\n      /**\n       * @summary `Meteor.release` is a string containing the name of the [release](#meteorupdate) with which the project was built (for example, `\"1.2.3\"`). It is `undefined` if the project was built using a git checkout of Meteor.\n       * @locus Anywhere\n       * @type {String}\n       */\n      Meteor.release = __meteor_runtime_config__.meteorRelease;\n    } // XXX find a better home for these? Ideally they would be _.get,\n    // _.ensure, _.delete..\n    // _get(a,b,c,d) returns a[b][c][d], or else undefined if a[b] or\n    // a[b][c] doesn't exist.\n    //\n\n\n    Meteor._get = function (obj\n    /*, arguments */\n    ) {\n      for (var i = 1; i < arguments.length; i++) {\n        if (!(arguments[i] in obj)) return undefined;\n        obj = obj[arguments[i]];\n      }\n\n      return obj;\n    }; // _ensure(a,b,c,d) ensures that a[b][c][d] exists. If it does not,\n    // it is created and set to {}. Either way, it is returned.\n    //\n\n\n    Meteor._ensure = function (obj\n    /*, arguments */\n    ) {\n      for (var i = 1; i < arguments.length; i++) {\n        var key = arguments[i];\n        if (!(key in obj)) obj[key] = {};\n        obj = obj[key];\n      }\n\n      return obj;\n    }; // _delete(a, b, c, d) deletes a[b][c][d], then a[b][c] unless it\n    // isn't empty, then a[b] unless it isn't empty.\n    //\n\n\n    Meteor._delete = function (obj\n    /*, arguments */\n    ) {\n      var stack = [obj];\n      var leaf = true;\n\n      for (var i = 1; i < arguments.length - 1; i++) {\n        var key = arguments[i];\n\n        if (!(key in obj)) {\n          leaf = false;\n          break;\n        }\n\n        obj = obj[key];\n        if (_typeof(obj) !== \"object\") break;\n        stack.push(obj);\n      }\n\n      for (var i = stack.length - 1; i >= 0; i--) {\n        var key = arguments[i + 1];\n        if (leaf) leaf = false;else for (var other in stack[i][key]) {\n          return;\n        } // not empty -- we're done\n\n        delete stack[i][key];\n      }\n    }; // wrapAsync can wrap any function that takes some number of arguments that\n    // can't be undefined, followed by some optional arguments, where the callback\n    // is the last optional argument.\n    // e.g. fs.readFile(pathname, [callback]),\n    // fs.open(pathname, flags, [mode], [callback])\n    // For maximum effectiveness and least confusion, wrapAsync should be used on\n    // functions where the callback is the only argument of type Function.\n\n    /**\n     * @memberOf Meteor\n     * @summary Wrap a function that takes a callback function as its final parameter. The signature of the callback of the wrapped function should be `function(error, result){}`. On the server, the wrapped function can be used either synchronously (without passing a callback) or asynchronously (when a callback is passed). On the client, a callback is always required; errors will be logged if there is no callback. If a callback is provided, the environment captured when the original function was called will be restored in the callback.\n     * @locus Anywhere\n     * @param {Function} func A function that takes a callback as its final parameter\n     * @param {Object} [context] Optional `this` object against which the original function will be invoked\n     */\n\n\n    Meteor.wrapAsync = function (fn, context) {\n      return function ()\n      /* arguments */\n      {\n        var self = context || this;\n        var newArgs = Array.prototype.slice.call(arguments);\n        var callback;\n\n        for (var i = newArgs.length - 1; i >= 0; --i) {\n          var arg = newArgs[i];\n\n          var type = _typeof(arg);\n\n          if (type !== \"undefined\") {\n            if (type === \"function\") {\n              callback = arg;\n            }\n\n            break;\n          }\n        }\n\n        if (!callback) {\n          if (Meteor.isClient) {\n            callback = logErr;\n          } else {\n            var fut = new Future();\n            callback = fut.resolver();\n          }\n\n          ++i; // Insert the callback just after arg.\n        }\n\n        newArgs[i] = Meteor.bindEnvironment(callback);\n        var result = fn.apply(self, newArgs);\n        return fut ? fut.wait() : result;\n      };\n    }; // Sets child's prototype to a new object whose prototype is parent's\n    // prototype. Used as:\n    //   Meteor._inherits(ClassB, ClassA).\n    //   _.extend(ClassB.prototype, { ... })\n    // Inspired by CoffeeScript's `extend` and Google Closure's `goog.inherits`.\n\n\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    Meteor._inherits = function (Child, Parent) {\n      // copy Parent static properties\n      for (var key in Parent) {\n        // make sure we only copy hasOwnProperty properties vs. prototype\n        // properties\n        if (hasOwn.call(Parent, key)) {\n          Child[key] = Parent[key];\n        }\n      } // a middle member of prototype chain: takes the prototype from the Parent\n\n\n      var Middle = function Middle() {\n        this.constructor = Child;\n      };\n\n      Middle.prototype = Parent.prototype;\n      Child.prototype = new Middle();\n      Child.__super__ = Parent.prototype;\n      return Child;\n    };\n\n    var warnedAboutWrapAsync = false;\n    /**\n     * @deprecated in 0.9.3\n     */\n\n    Meteor._wrapAsync = function (fn, context) {\n      if (!warnedAboutWrapAsync) {\n        Meteor._debug(\"Meteor._wrapAsync has been renamed to Meteor.wrapAsync\");\n\n        warnedAboutWrapAsync = true;\n      }\n\n      return Meteor.wrapAsync.apply(Meteor, arguments);\n    };\n\n    function logErr(err) {\n      if (err) {\n        return Meteor._debug(\"Exception in callback of async function\", err);\n      }\n    } //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/setimmediate.js                                                                      //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Chooses one of three setImmediate implementations:\n    //\n    // * Native setImmediate (IE 10, Node 0.9+)\n    //\n    // * postMessage (many browsers)\n    //\n    // * setTimeout  (fallback)\n    //\n    // The postMessage implementation is based on\n    // https://github.com/NobleJS/setImmediate/tree/1.0.1\n    //\n    // Don't use `nextTick` for Node since it runs its callbacks before\n    // I/O, which is stricter than we're looking for.\n    //\n    // Not installed as a polyfill, as our public API is `Meteor.defer`.\n    // Since we're not trying to be a polyfill, we have some\n    // simplifications:\n    //\n    // If one invocation of a setImmediate callback pauses itself by a\n    // call to alert/prompt/showModelDialog, the NobleJS polyfill\n    // implementation ensured that no setImmedate callback would run until\n    // the first invocation completed.  While correct per the spec, what it\n    // would mean for us in practice is that any reactive updates relying\n    // on Meteor.defer would be hung in the main window until the modal\n    // dialog was dismissed.  Thus we only ensure that a setImmediate\n    // function is called in a later event loop.\n    //\n    // We don't need to support using a string to be eval'ed for the\n    // callback, arguments to the function, or clearImmediate.\n    \"use strict\";\n\n    var global = this; // IE 10, Node >= 9.1\n\n    function useSetImmediate() {\n      if (!global.setImmediate) return null;else {\n        var setImmediate = function setImmediate(fn) {\n          global.setImmediate(fn);\n        };\n\n        setImmediate.implementation = 'setImmediate';\n        return setImmediate;\n      }\n    } // Android 2.3.6, Chrome 26, Firefox 20, IE 8-9, iOS 5.1.1 Safari\n\n\n    function usePostMessage() {\n      // The test against `importScripts` prevents this implementation\n      // from being installed inside a web worker, where\n      // `global.postMessage` means something completely different and\n      // can't be used for this purpose.\n      if (!global.postMessage || global.importScripts) {\n        return null;\n      } // Avoid synchronous post message implementations.\n\n\n      var postMessageIsAsynchronous = true;\n      var oldOnMessage = global.onmessage;\n\n      global.onmessage = function () {\n        postMessageIsAsynchronous = false;\n      };\n\n      global.postMessage(\"\", \"*\");\n      global.onmessage = oldOnMessage;\n      if (!postMessageIsAsynchronous) return null;\n      var funcIndex = 0;\n      var funcs = {}; // Installs an event handler on `global` for the `message` event: see\n      // * https://developer.mozilla.org/en/DOM/window.postMessage\n      // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n      // XXX use Random.id() here?\n\n      var MESSAGE_PREFIX = \"Meteor._setImmediate.\" + Math.random() + '.';\n\n      function isStringAndStartsWith(string, putativeStart) {\n        return typeof string === \"string\" && string.substring(0, putativeStart.length) === putativeStart;\n      }\n\n      function onGlobalMessage(event) {\n        // This will catch all incoming messages (even from other\n        // windows!), so we need to try reasonably hard to avoid letting\n        // anyone else trick us into firing off. We test the origin is\n        // still this window, and that a (randomly generated)\n        // unpredictable identifying prefix is present.\n        if (event.source === global && isStringAndStartsWith(event.data, MESSAGE_PREFIX)) {\n          var index = event.data.substring(MESSAGE_PREFIX.length);\n\n          try {\n            if (funcs[index]) funcs[index]();\n          } finally {\n            delete funcs[index];\n          }\n        }\n      }\n\n      if (global.addEventListener) {\n        global.addEventListener(\"message\", onGlobalMessage, false);\n      } else {\n        global.attachEvent(\"onmessage\", onGlobalMessage);\n      }\n\n      var setImmediate = function setImmediate(fn) {\n        // Make `global` post a message to itself with the handle and\n        // identifying prefix, thus asynchronously invoking our\n        // onGlobalMessage listener above.\n        ++funcIndex;\n        funcs[funcIndex] = fn;\n        global.postMessage(MESSAGE_PREFIX + funcIndex, \"*\");\n      };\n\n      setImmediate.implementation = 'postMessage';\n      return setImmediate;\n    }\n\n    function useTimeout() {\n      var setImmediate = function setImmediate(fn) {\n        global.setTimeout(fn, 0);\n      };\n\n      setImmediate.implementation = 'setTimeout';\n      return setImmediate;\n    }\n\n    Meteor._setImmediate = useSetImmediate() || usePostMessage() || useTimeout(); //////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/timers.js                                                                            //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    function withoutInvocation(f) {\n      if (Package.ddp) {\n        var DDP = Package.ddp.DDP;\n        var CurrentInvocation = DDP._CurrentMethodInvocation || // For backwards compatibility, as explained in this issue:\n        // https://github.com/meteor/meteor/issues/8947\n        DDP._CurrentInvocation;\n        var invocation = CurrentInvocation.get();\n\n        if (invocation && invocation.isSimulation) {\n          throw new Error(\"Can't set timers inside simulations\");\n        }\n\n        return function () {\n          CurrentInvocation.withValue(null, f);\n        };\n      } else {\n        return f;\n      }\n    }\n\n    function bindAndCatch(context, f) {\n      return Meteor.bindEnvironment(withoutInvocation(f), context);\n    } // Meteor.setTimeout and Meteor.setInterval callbacks scheduled\n    // inside a server method are not part of the method invocation and\n    // should clear out the CurrentMethodInvocation environment variable.\n\n    /**\n     * @memberOf Meteor\n     * @summary Call a function in the future after waiting for a specified delay.\n     * @locus Anywhere\n     * @param {Function} func The function to run\n     * @param {Number} delay Number of milliseconds to wait before calling function\n     */\n\n\n    Meteor.setTimeout = function (f, duration) {\n      return setTimeout(bindAndCatch(\"setTimeout callback\", f), duration);\n    };\n    /**\n     * @memberOf Meteor\n     * @summary Call a function repeatedly, with a time delay between calls.\n     * @locus Anywhere\n     * @param {Function} func The function to run\n     * @param {Number} delay Number of milliseconds to wait between each function call.\n     */\n\n\n    Meteor.setInterval = function (f, duration) {\n      return setInterval(bindAndCatch(\"setInterval callback\", f), duration);\n    };\n    /**\n     * @memberOf Meteor\n     * @summary Cancel a repeating function call scheduled by `Meteor.setInterval`.\n     * @locus Anywhere\n     * @param {Object} id The handle returned by `Meteor.setInterval`\n     */\n\n\n    Meteor.clearInterval = function (x) {\n      return clearInterval(x);\n    };\n    /**\n     * @memberOf Meteor\n     * @summary Cancel a function call scheduled by `Meteor.setTimeout`.\n     * @locus Anywhere\n     * @param {Object} id The handle returned by `Meteor.setTimeout`\n     */\n\n\n    Meteor.clearTimeout = function (x) {\n      return clearTimeout(x);\n    }; // XXX consider making this guarantee ordering of defer'd callbacks, like\n    // Tracker.afterFlush or Node's nextTick (in practice). Then tests can do:\n    //    callSomethingThatDefersSomeWork();\n    //    Meteor.defer(expect(somethingThatValidatesThatTheWorkHappened));\n\n    /**\n     * @memberOf Meteor\n     * @summary Defer execution of a function to run asynchronously in the background (similar to `Meteor.setTimeout(func, 0)`.\n     * @locus Anywhere\n     * @param {Function} func The function to run\n     */\n\n\n    Meteor.defer = function (f) {\n      Meteor._setImmediate(bindAndCatch(\"defer callback\", f));\n    }; //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/errors.js                                                                            //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Makes an error subclass which properly contains a stack trace in most\n    // environments. constructor can set fields on `this` (and should probably set\n    // `message`, which is what gets displayed at the top of a stack trace).\n    //\n    Meteor.makeErrorType = function (name, constructor) {\n      var errorClass = function errorClass()\n      /*arguments*/\n      {\n        // Ensure we get a proper stack trace in most Javascript environments\n        if (Error.captureStackTrace) {\n          // V8 environments (Chrome and Node.js)\n          Error.captureStackTrace(this, errorClass);\n        } else {\n          // Borrow the .stack property of a native Error object.\n          this.stack = new Error().stack;\n        } // Safari magically works.\n\n\n        constructor.apply(this, arguments);\n        this.errorType = name;\n      };\n\n      Meteor._inherits(errorClass, Error);\n\n      return errorClass;\n    }; // This should probably be in the livedata package, but we don't want\n    // to require you to use the livedata package to get it. Eventually we\n    // should probably rename it to DDP.Error and put it back in the\n    // 'livedata' package (which we should rename to 'ddp' also.)\n    //\n    // Note: The DDP server assumes that Meteor.Error EJSON-serializes as an object\n    // containing 'error' and optionally 'reason' and 'details'.\n    // The DDP client manually puts these into Meteor.Error objects. (We don't use\n    // EJSON.addType here because the type is determined by location in the\n    // protocol, not text on the wire.)\n\n    /**\n     * @summary This class represents a symbolic error thrown by a method.\n     * @locus Anywhere\n     * @class\n     * @param {String} error A string code uniquely identifying this kind of error.\n     * This string should be used by callers of the method to determine the\n     * appropriate action to take, instead of attempting to parse the reason\n     * or details fields. For example:\n     *\n     * ```\n     * // on the server, pick a code unique to this error\n     * // the reason field should be a useful debug message\n     * throw new Meteor.Error(\"logged-out\",\n     *   \"The user must be logged in to post a comment.\");\n     *\n     * // on the client\n     * Meteor.call(\"methodName\", function (error) {\n     *   // identify the error\n     *   if (error && error.error === \"logged-out\") {\n     *     // show a nice error message\n     *     Session.set(\"errorMessage\", \"Please log in to post a comment.\");\n     *   }\n     * });\n     * ```\n     *\n     * For legacy reasons, some built-in Meteor functions such as `check` throw\n     * errors with a number in this field.\n     *\n     * @param {String} [reason] Optional.  A short human-readable summary of the\n     * error, like 'Not Found'.\n     * @param {String} [details] Optional.  Additional information about the error,\n     * like a textual stack trace.\n     */\n\n\n    Meteor.Error = Meteor.makeErrorType(\"Meteor.Error\", function (error, reason, details) {\n      var self = this; // Newer versions of DDP use this property to signify that an error\n      // can be sent back and reconstructed on the calling client.\n\n      self.isClientSafe = true; // String code uniquely identifying this kind of error.\n\n      self.error = error; // Optional: A short human-readable summary of the error. Not\n      // intended to be shown to end users, just developers. (\"Not Found\",\n      // \"Internal Server Error\")\n\n      self.reason = reason; // Optional: Additional information about the error, say for\n      // debugging. It might be a (textual) stack trace if the server is\n      // willing to provide one. The corresponding thing in HTTP would be\n      // the body of a 404 or 500 response. (The difference is that we\n      // never expect this to be shown to end users, only developers, so\n      // it doesn't need to be pretty.)\n\n      self.details = details; // This is what gets displayed at the top of a stack trace. Current\n      // format is \"[404]\" (if no reason is set) or \"File not found [404]\"\n\n      if (self.reason) self.message = self.reason + ' [' + self.error + ']';else self.message = '[' + self.error + ']';\n    }); // Meteor.Error is basically data and is sent over DDP, so you should be able to\n    // properly EJSON-clone it. This is especially important because if a\n    // Meteor.Error is thrown through a Future, the error, reason, and details\n    // properties become non-enumerable so a standard Object clone won't preserve\n    // them and they will be lost from DDP.\n\n    Meteor.Error.prototype.clone = function () {\n      var self = this;\n      return new Meteor.Error(self.error, self.reason, self.details);\n    }; //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/fiber_stubs_client.js                                                                //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // This file is a partial analogue to fiber_helpers.js, which allows the client\n    // to use a queue too, and also to call noYieldsAllowed.\n    // The client has no ability to yield, so noYieldsAllowed is a noop.\n    //\n    Meteor._noYieldsAllowed = function (f) {\n      return f();\n    }; // An even simpler queue of tasks than the fiber-enabled one.  This one just\n    // runs all the tasks when you call runTask or flush, synchronously.\n    //\n\n\n    Meteor._SynchronousQueue = function () {\n      var self = this;\n      self._tasks = [];\n      self._running = false;\n      self._runTimeout = null;\n    };\n\n    var SQp = Meteor._SynchronousQueue.prototype;\n\n    SQp.runTask = function (task) {\n      var self = this;\n      if (!self.safeToRunTask()) throw new Error(\"Could not synchronously run a task from a running task\");\n\n      self._tasks.push(task);\n\n      var tasks = self._tasks;\n      self._tasks = [];\n      self._running = true;\n\n      if (self._runTimeout) {\n        // Since we're going to drain the queue, we can forget about the timeout\n        // which tries to run it.  (But if one of our tasks queues something else,\n        // the timeout will be correctly re-created.)\n        clearTimeout(self._runTimeout);\n        self._runTimeout = null;\n      }\n\n      try {\n        while (tasks.length > 0) {\n          var t = tasks.shift();\n\n          try {\n            t();\n          } catch (e) {\n            if (tasks.length === 0) {\n              // this was the last task, that is, the one we're calling runTask\n              // for.\n              throw e;\n            }\n\n            Meteor._debug(\"Exception in queued task\", e);\n          }\n        }\n      } finally {\n        self._running = false;\n      }\n    };\n\n    SQp.queueTask = function (task) {\n      var self = this;\n\n      self._tasks.push(task); // Intentionally not using Meteor.setTimeout, because it doesn't like runing\n      // in stubs for now.\n\n\n      if (!self._runTimeout) {\n        self._runTimeout = setTimeout(function () {\n          return self.flush.apply(self, arguments);\n        }, 0);\n      }\n    };\n\n    SQp.flush = function () {\n      var self = this;\n      self.runTask(function () {});\n    };\n\n    SQp.drain = function () {\n      var self = this;\n\n      if (!self.safeToRunTask()) {\n        return;\n      }\n\n      while (self._tasks.length > 0) {\n        self.flush();\n      }\n    };\n\n    SQp.safeToRunTask = function () {\n      var self = this;\n      return !self._running;\n    }; //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/startup_client.js                                                                    //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    var callbackQueue = [];\n    var isLoadingCompleted = false;\n    var isReady = false; // Keeps track of how many events to wait for in addition to loading completing,\n    // before we're considered ready.\n\n    var readyHoldsCount = 0;\n\n    var holdReady = function holdReady() {\n      readyHoldsCount++;\n    };\n\n    var releaseReadyHold = function releaseReadyHold() {\n      readyHoldsCount--;\n      maybeReady();\n    };\n\n    var maybeReady = function maybeReady() {\n      if (isReady || !isLoadingCompleted || readyHoldsCount > 0) return;\n      isReady = true; // Run startup callbacks\n\n      while (callbackQueue.length) {\n        callbackQueue.shift()();\n      }\n\n      if (Meteor.isCordova) {\n        // Notify the WebAppLocalServer plugin that startup was completed successfully,\n        // so we can roll back faulty versions if this doesn't happen\n        WebAppLocalServer.startupDidComplete();\n      }\n    };\n\n    var loadingCompleted = function loadingCompleted() {\n      if (!isLoadingCompleted) {\n        isLoadingCompleted = true;\n        maybeReady();\n      }\n    };\n\n    if (Meteor.isCordova) {\n      holdReady();\n      document.addEventListener('deviceready', releaseReadyHold, false);\n    }\n\n    if (document.readyState === 'complete' || document.readyState === 'loaded') {\n      // Loading has completed,\n      // but allow other scripts the opportunity to hold ready\n      window.setTimeout(loadingCompleted);\n    } else {\n      // Attach event listeners to wait for loading to complete\n      if (document.addEventListener) {\n        document.addEventListener('DOMContentLoaded', loadingCompleted, false);\n        window.addEventListener('load', loadingCompleted, false);\n      } else {\n        // Use IE event model for < IE9\n        document.attachEvent('onreadystatechange', function () {\n          if (document.readyState === \"complete\") {\n            loadingCompleted();\n          }\n        });\n        window.attachEvent('load', loadingCompleted);\n      }\n    }\n    /**\n     * @summary Run code when a client or a server starts.\n     * @locus Anywhere\n     * @param {Function} func A function to run on startup.\n     */\n\n\n    Meteor.startup = function (callback) {\n      // Fix for < IE9, see http://javascript.nwbox.com/IEContentLoaded/\n      var doScroll = !document.addEventListener && document.documentElement.doScroll;\n\n      if (!doScroll || window !== top) {\n        if (isReady) callback();else callbackQueue.push(callback);\n      } else {\n        try {\n          doScroll('left');\n        } catch (error) {\n          setTimeout(function () {\n            Meteor.startup(callback);\n          }, 50);\n          return;\n        }\n\n        ;\n        callback();\n      }\n    }; //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/debug.js                                                                             //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    var suppress = 0; // replacement for console.log. This is a temporary API. We should\n    // provide a real logging API soon (possibly just a polyfill for\n    // console?)\n    //\n    // NOTE: this is used on the server to print the warning about\n    // having autopublish enabled when you probably meant to turn it\n    // off. it's not really the proper use of something called\n    // _debug. the intent is for this message to go to the terminal and\n    // be very visible. if you change _debug to go someplace else, etc,\n    // please fix the autopublish code to do something reasonable.\n    //\n\n    Meteor._debug = function ()\n    /* arguments */\n    {\n      if (suppress) {\n        suppress--;\n        return;\n      }\n\n      if (typeof console !== 'undefined' && typeof console.log !== 'undefined') {\n        if (arguments.length == 0) {\n          // IE Companion breaks otherwise\n          // IE10 PP4 requires at least one argument\n          console.log('');\n        } else {\n          // IE doesn't have console.log.apply, it's not a real Object.\n          // http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9\n          // http://patik.com/blog/complete-cross-browser-console-log/\n          if (typeof console.log.apply === \"function\") {\n            // Most browsers\n            // Chrome and Safari only hyperlink URLs to source files in first argument of\n            // console.log, so try to call it with one argument if possible.\n            // Approach taken here: If all arguments are strings, join them on space.\n            // See https://github.com/meteor/meteor/pull/732#issuecomment-13975991\n            var allArgumentsOfTypeString = true;\n\n            for (var i = 0; i < arguments.length; i++) {\n              if (typeof arguments[i] !== \"string\") allArgumentsOfTypeString = false;\n            }\n\n            if (allArgumentsOfTypeString) console.log.apply(console, [Array.prototype.join.call(arguments, \" \")]);else console.log.apply(console, arguments);\n          } else if (typeof Function.prototype.bind === \"function\") {\n            // IE9\n            var log = Function.prototype.bind.call(console.log, console);\n            log.apply(console, arguments);\n          } else {\n            // IE8\n            Function.prototype.call.call(console.log, console, Array.prototype.slice.call(arguments));\n          }\n        }\n      }\n    }; // Suppress the next 'count' Meteor._debug messsages. Use this to\n    // stop tests from spamming the console.\n    //\n\n\n    Meteor._suppress_log = function (count) {\n      suppress += count;\n    };\n\n    Meteor._suppressed_log_expected = function () {\n      return suppress !== 0;\n    }; //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/string_utils.js                                                                      //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Like Perl's quotemeta: quotes all regexp metacharacters.\n    // Code taken from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n    Meteor._escapeRegExp = function (string) {\n      return String(string).replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    }; //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/test_environment.js                                                                  //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    var TEST_METADATA_STR;\n\n    if (Meteor.isClient) {\n      TEST_METADATA_STR = meteorEnv.TEST_METADATA;\n    } else {\n      TEST_METADATA_STR = process.env.TEST_METADATA;\n    }\n\n    var TEST_METADATA = JSON.parse(TEST_METADATA_STR || \"{}\");\n    var testDriverPackageName = TEST_METADATA.driverPackage; // Note that if we are in test-packages mode neither of these will be set,\n    // but we will have a test driver package\n\n    Meteor.isTest = !!TEST_METADATA.isTest;\n    Meteor.isAppTest = !!TEST_METADATA.isAppTest;\n    Meteor.isPackageTest = !!testDriverPackageName && !Meteor.isTest && !Meteor.isAppTest;\n\n    if (typeof testDriverPackageName === \"string\") {\n      Meteor.startup(function () {\n        var testDriverPackage = Package[testDriverPackageName];\n\n        if (!testDriverPackage) {\n          throw new Error(\"Can't find test driver package: \" + testDriverPackageName);\n        } // On the client, the test driver *must* define `runTests`\n\n\n        if (Meteor.isClient) {\n          if (typeof testDriverPackage.runTests !== \"function\") {\n            throw new Error(\"Test driver package \" + testDriverPackageName + \" missing `runTests` export\");\n          }\n\n          testDriverPackage.runTests();\n        } else {\n          // The server can optionally define `start`\n          if (typeof testDriverPackage.start === \"function\") {\n            testDriverPackage.start();\n          }\n        }\n      });\n    } //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/dynamics_browser.js                                                                  //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Simple implementation of dynamic scoping, for use in browsers\n    var nextSlot = 0;\n    var currentValues = [];\n\n    Meteor.EnvironmentVariable = function () {\n      this.slot = nextSlot++;\n    };\n\n    var EVp = Meteor.EnvironmentVariable.prototype;\n\n    EVp.get = function () {\n      return currentValues[this.slot];\n    };\n\n    EVp.getOrNullIfOutsideFiber = function () {\n      return this.get();\n    };\n\n    EVp.withValue = function (value, func) {\n      var saved = currentValues[this.slot];\n\n      try {\n        currentValues[this.slot] = value;\n        var ret = func();\n      } finally {\n        currentValues[this.slot] = saved;\n      }\n\n      return ret;\n    };\n\n    Meteor.bindEnvironment = function (func, onException, _this) {\n      // needed in order to be able to create closures inside func and\n      // have the closed variables not change back to their original\n      // values\n      var boundValues = currentValues.slice();\n\n      if (!onException || typeof onException === 'string') {\n        var description = onException || \"callback of async function\";\n\n        onException = function onException(error) {\n          Meteor._debug(\"Exception in \" + description + \":\", error);\n        };\n      }\n\n      return function ()\n      /* arguments */\n      {\n        var savedValues = currentValues;\n\n        try {\n          currentValues = boundValues;\n          var ret = func.apply(_this, arguments);\n        } catch (e) {\n          // note: callback-hook currently relies on the fact that if onException\n          // throws in the browser, the wrapped call throws.\n          onException(e);\n        } finally {\n          currentValues = savedValues;\n        }\n\n        return ret;\n      };\n    };\n\n    Meteor._nodeCodeMustBeInFiber = function () {// no-op on browser\n    }; //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                      //\n    // packages/meteor/url_common.js                                                                        //\n    //                                                                                                      //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n\n    /**\n     * @summary Generate an absolute URL pointing to the application. The server reads from the `ROOT_URL` environment variable to determine where it is running. This is taken care of automatically for apps deployed to Galaxy, but must be provided when using `meteor build`.\n     * @locus Anywhere\n     * @param {String} [path] A path to append to the root URL. Do not include a leading \"`/`\".\n     * @param {Object} [options]\n     * @param {Boolean} options.secure Create an HTTPS URL.\n     * @param {Boolean} options.replaceLocalhost Replace localhost with 127.0.0.1. Useful for services that don't recognize localhost as a domain name.\n     * @param {String} options.rootUrl Override the default ROOT_URL from the server environment. For example: \"`http://foo.example.com`\"\n     */\n    Meteor.absoluteUrl = function (path, options) {\n      // path is optional\n      if (!options && _typeof(path) === 'object') {\n        options = path;\n        path = undefined;\n      } // merge options with defaults\n\n\n      options = Object.assign({}, Meteor.absoluteUrl.defaultOptions, options || {});\n      var url = options.rootUrl;\n      if (!url) throw new Error(\"Must pass options.rootUrl or set ROOT_URL in the server environment\");\n      if (!/^http[s]?:\\/\\//i.test(url)) // url starts with 'http://' or 'https://'\n        url = 'http://' + url; // we will later fix to https if options.secure is set\n\n      if (!url.endsWith(\"/\")) {\n        url += \"/\";\n      }\n\n      if (path) {\n        // join url and path with a / separator\n        while (path.startsWith(\"/\")) {\n          path = path.slice(1);\n        }\n\n        url += path;\n      } // turn http to https if secure option is set, and we're not talking\n      // to localhost.\n\n\n      if (options.secure && /^http:/.test(url) && // url starts with 'http:'\n      !/http:\\/\\/localhost[:\\/]/.test(url) && // doesn't match localhost\n      !/http:\\/\\/127\\.0\\.0\\.1[:\\/]/.test(url)) // or 127.0.0.1\n        url = url.replace(/^http:/, 'https:');\n      if (options.replaceLocalhost) url = url.replace(/^http:\\/\\/localhost([:\\/].*)/, 'http://127.0.0.1$1');\n      return url;\n    }; // allow later packages to override default options\n\n\n    var defaultOptions = Meteor.absoluteUrl.defaultOptions = {}; // available only in a browser environment\n\n    var location = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && window.location;\n\n    if ((typeof __meteor_runtime_config__ === \"undefined\" ? \"undefined\" : _typeof(__meteor_runtime_config__)) === \"object\" && __meteor_runtime_config__.ROOT_URL) {\n      defaultOptions.rootUrl = __meteor_runtime_config__.ROOT_URL;\n    } else if (location && location.protocol && location.host) {\n      defaultOptions.rootUrl = location.protocol + \"//\" + location.host;\n    } // Make absolute URLs use HTTPS by default if the current window.location\n    // uses HTTPS. Since this is just a default, it can be overridden by\n    // passing { secure: false } if necessary.\n\n\n    if (location && location.protocol === \"https:\") {\n      defaultOptions.secure = true;\n    }\n\n    Meteor._relativeToSiteRootUrl = function (link) {\n      if ((typeof __meteor_runtime_config__ === \"undefined\" ? \"undefined\" : _typeof(__meteor_runtime_config__)) === \"object\" && link.substr(0, 1) === \"/\") link = (__meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\") + link;\n      return link;\n    }; //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  /* Exports */\n\n  Package._define(\"meteor\", {\n    Meteor: Meteor,\n    global: global,\n    meteorEnv: meteorEnv\n  });\n})();\n\nmodule.exports = window.Package[\"meteor\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/meteor.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/minimongo.js":
/*!**************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/minimongo.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var DiffSequence = Package['diff-sequence'].DiffSequence;\n  var EJSON = Package.ejson.EJSON;\n  var GeoJSON = Package['geojson-utils'].GeoJSON;\n  var IdMap = Package['id-map'].IdMap;\n  var MongoID = Package['mongo-id'].MongoID;\n  var OrderedDict = Package['ordered-dict'].OrderedDict;\n  var Random = Package.random.Random;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var operand, selectorValue, MinimongoTest, MinimongoError, selector, doc, callback, options, oldResults, a, b, LocalCollection, Minimongo;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"minimongo\": {\n          \"minimongo_client.js\": function minimongo_clientJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/minimongo/minimongo_client.js                                                                              //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.watch(require(\"./minimongo_common.js\")); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          },\n          \"common.js\": function commonJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/minimongo/common.js                                                                                        //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              hasOwn: function hasOwn() {\n                return _hasOwn;\n              },\n              ELEMENT_OPERATORS: function ELEMENT_OPERATORS() {\n                return _ELEMENT_OPERATORS;\n              },\n              compileDocumentSelector: function compileDocumentSelector() {\n                return _compileDocumentSelector;\n              },\n              equalityElementMatcher: function equalityElementMatcher() {\n                return _equalityElementMatcher;\n              },\n              expandArraysInBranches: function expandArraysInBranches() {\n                return _expandArraysInBranches;\n              },\n              isIndexable: function isIndexable() {\n                return _isIndexable;\n              },\n              isNumericKey: function isNumericKey() {\n                return _isNumericKey;\n              },\n              isOperatorObject: function isOperatorObject() {\n                return _isOperatorObject;\n              },\n              makeLookupFunction: function makeLookupFunction() {\n                return _makeLookupFunction;\n              },\n              nothingMatcher: function nothingMatcher() {\n                return _nothingMatcher;\n              },\n              pathsToTree: function pathsToTree() {\n                return _pathsToTree;\n              },\n              populateDocumentWithQueryFields: function populateDocumentWithQueryFields() {\n                return _populateDocumentWithQueryFields;\n              },\n              projectionDetails: function projectionDetails() {\n                return _projectionDetails;\n              },\n              regexpElementMatcher: function regexpElementMatcher() {\n                return _regexpElementMatcher;\n              }\n            });\n            var LocalCollection;\n            module.watch(require(\"./local_collection.js\"), {\n              default: function _default(v) {\n                LocalCollection = v;\n              }\n            }, 0);\n            var _hasOwn = Object.prototype.hasOwnProperty;\n            var _ELEMENT_OPERATORS = {\n              $lt: makeInequality(function (cmpValue) {\n                return cmpValue < 0;\n              }),\n              $gt: makeInequality(function (cmpValue) {\n                return cmpValue > 0;\n              }),\n              $lte: makeInequality(function (cmpValue) {\n                return cmpValue <= 0;\n              }),\n              $gte: makeInequality(function (cmpValue) {\n                return cmpValue >= 0;\n              }),\n              $mod: {\n                compileElementSelector: function compileElementSelector(operand) {\n                  if (!(Array.isArray(operand) && operand.length === 2 && typeof operand[0] === 'number' && typeof operand[1] === 'number')) {\n                    throw Error('argument to $mod must be an array of two numbers');\n                  } // XXX could require to be ints or round or something\n\n\n                  var divisor = operand[0];\n                  var remainder = operand[1];\n                  return function (value) {\n                    return typeof value === 'number' && value % divisor === remainder;\n                  };\n                }\n              },\n              $in: {\n                compileElementSelector: function compileElementSelector(operand) {\n                  if (!Array.isArray(operand)) {\n                    throw Error('$in needs an array');\n                  }\n\n                  var elementMatchers = operand.map(function (option) {\n                    if (option instanceof RegExp) {\n                      return _regexpElementMatcher(option);\n                    }\n\n                    if (_isOperatorObject(option)) {\n                      throw Error('cannot nest $ under $in');\n                    }\n\n                    return _equalityElementMatcher(option);\n                  });\n                  return function (value) {\n                    // Allow {a: {$in: [null]}} to match when 'a' does not exist.\n                    if (value === undefined) {\n                      value = null;\n                    }\n\n                    return elementMatchers.some(function (matcher) {\n                      return matcher(value);\n                    });\n                  };\n                }\n              },\n              $size: {\n                // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we\n                // don't want to consider the element [5,5] in the leaf array [[5,5]] as a\n                // possible value.\n                dontExpandLeafArrays: true,\n                compileElementSelector: function compileElementSelector(operand) {\n                  if (typeof operand === 'string') {\n                    // Don't ask me why, but by experimentation, this seems to be what Mongo\n                    // does.\n                    operand = 0;\n                  } else if (typeof operand !== 'number') {\n                    throw Error('$size needs a number');\n                  }\n\n                  return function (value) {\n                    return Array.isArray(value) && value.length === operand;\n                  };\n                }\n              },\n              $type: {\n                // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should\n                // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:\n                // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but\n                // should *not* include it itself.\n                dontIncludeLeafArrays: true,\n                compileElementSelector: function compileElementSelector(operand) {\n                  if (typeof operand === 'string') {\n                    var operandAliasMap = {\n                      'double': 1,\n                      'string': 2,\n                      'object': 3,\n                      'array': 4,\n                      'binData': 5,\n                      'undefined': 6,\n                      'objectId': 7,\n                      'bool': 8,\n                      'date': 9,\n                      'null': 10,\n                      'regex': 11,\n                      'dbPointer': 12,\n                      'javascript': 13,\n                      'symbol': 14,\n                      'javascriptWithScope': 15,\n                      'int': 16,\n                      'timestamp': 17,\n                      'long': 18,\n                      'decimal': 19,\n                      'minKey': -1,\n                      'maxKey': 127\n                    };\n\n                    if (!_hasOwn.call(operandAliasMap, operand)) {\n                      throw Error(\"unknown string alias for $type: \".concat(operand));\n                    }\n\n                    operand = operandAliasMap[operand];\n                  } else if (typeof operand === 'number') {\n                    if (operand === 0 || operand < -1 || operand > 19 && operand !== 127) {\n                      throw Error(\"Invalid numerical $type code: \".concat(operand));\n                    }\n                  } else {\n                    throw Error('argument to $type is not a number or a string');\n                  }\n\n                  return function (value) {\n                    return value !== undefined && LocalCollection._f._type(value) === operand;\n                  };\n                }\n              },\n              $bitsAllSet: {\n                compileElementSelector: function compileElementSelector(operand) {\n                  var mask = getOperandBitmask(operand, '$bitsAllSet');\n                  return function (value) {\n                    var bitmask = getValueBitmask(value, mask.length);\n                    return bitmask && mask.every(function (byte, i) {\n                      return (bitmask[i] & byte) === byte;\n                    });\n                  };\n                }\n              },\n              $bitsAnySet: {\n                compileElementSelector: function compileElementSelector(operand) {\n                  var mask = getOperandBitmask(operand, '$bitsAnySet');\n                  return function (value) {\n                    var bitmask = getValueBitmask(value, mask.length);\n                    return bitmask && mask.some(function (byte, i) {\n                      return (~bitmask[i] & byte) !== byte;\n                    });\n                  };\n                }\n              },\n              $bitsAllClear: {\n                compileElementSelector: function compileElementSelector(operand) {\n                  var mask = getOperandBitmask(operand, '$bitsAllClear');\n                  return function (value) {\n                    var bitmask = getValueBitmask(value, mask.length);\n                    return bitmask && mask.every(function (byte, i) {\n                      return !(bitmask[i] & byte);\n                    });\n                  };\n                }\n              },\n              $bitsAnyClear: {\n                compileElementSelector: function compileElementSelector(operand) {\n                  var mask = getOperandBitmask(operand, '$bitsAnyClear');\n                  return function (value) {\n                    var bitmask = getValueBitmask(value, mask.length);\n                    return bitmask && mask.some(function (byte, i) {\n                      return (bitmask[i] & byte) !== byte;\n                    });\n                  };\n                }\n              },\n              $regex: {\n                compileElementSelector: function compileElementSelector(operand, valueSelector) {\n                  if (!(typeof operand === 'string' || operand instanceof RegExp)) {\n                    throw Error('$regex has to be a string or RegExp');\n                  }\n\n                  var regexp;\n\n                  if (valueSelector.$options !== undefined) {\n                    // Options passed in $options (even the empty string) always overrides\n                    // options in the RegExp object itself.\n                    // Be clear that we only support the JS-supported options, not extended\n                    // ones (eg, Mongo supports x and s). Ideally we would implement x and s\n                    // by transforming the regexp, but not today...\n                    if (/[^gim]/.test(valueSelector.$options)) {\n                      throw new Error('Only the i, m, and g regexp options are supported');\n                    }\n\n                    var source = operand instanceof RegExp ? operand.source : operand;\n                    regexp = new RegExp(source, valueSelector.$options);\n                  } else if (operand instanceof RegExp) {\n                    regexp = operand;\n                  } else {\n                    regexp = new RegExp(operand);\n                  }\n\n                  return _regexpElementMatcher(regexp);\n                }\n              },\n              $elemMatch: {\n                dontExpandLeafArrays: true,\n                compileElementSelector: function compileElementSelector(operand, valueSelector, matcher) {\n                  if (!LocalCollection._isPlainObject(operand)) {\n                    throw Error('$elemMatch need an object');\n                  }\n\n                  var isDocMatcher = !_isOperatorObject(Object.keys(operand).filter(function (key) {\n                    return !_hasOwn.call(LOGICAL_OPERATORS, key);\n                  }).reduce(function (a, b) {\n                    return Object.assign(a, _defineProperty({}, b, operand[b]));\n                  }, {}), true);\n                  var subMatcher;\n\n                  if (isDocMatcher) {\n                    // This is NOT the same as compileValueSelector(operand), and not just\n                    // because of the slightly different calling convention.\n                    // {$elemMatch: {x: 3}} means \"an element has a field x:3\", not\n                    // \"consists only of a field x:3\". Also, regexps and sub-$ are allowed.\n                    subMatcher = _compileDocumentSelector(operand, matcher, {\n                      inElemMatch: true\n                    });\n                  } else {\n                    subMatcher = compileValueSelector(operand, matcher);\n                  }\n\n                  return function (value) {\n                    if (!Array.isArray(value)) {\n                      return false;\n                    }\n\n                    for (var i = 0; i < value.length; ++i) {\n                      var arrayElement = value[i];\n                      var arg = void 0;\n\n                      if (isDocMatcher) {\n                        // We can only match {$elemMatch: {b: 3}} against objects.\n                        // (We can also match against arrays, if there's numeric indices,\n                        // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)\n                        if (!_isIndexable(arrayElement)) {\n                          return false;\n                        }\n\n                        arg = arrayElement;\n                      } else {\n                        // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches\n                        // {a: [8]} but not {a: [[8]]}\n                        arg = [{\n                          value: arrayElement,\n                          dontIterate: true\n                        }];\n                      } // XXX support $near in $elemMatch by propagating $distance?\n\n\n                      if (subMatcher(arg).result) {\n                        return i; // specially understood to mean \"use as arrayIndices\"\n                      }\n                    }\n\n                    return false;\n                  };\n                }\n              }\n            }; // Operators that appear at the top level of a document selector.\n\n            var LOGICAL_OPERATORS = {\n              $and: function $and(subSelector, matcher, inElemMatch) {\n                return andDocumentMatchers(compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch));\n              },\n              $or: function $or(subSelector, matcher, inElemMatch) {\n                var matchers = compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch); // Special case: if there is only one matcher, use it directly, *preserving*\n                // any arrayIndices it returns.\n\n                if (matchers.length === 1) {\n                  return matchers[0];\n                }\n\n                return function (doc) {\n                  var result = matchers.some(function (fn) {\n                    return fn(doc).result;\n                  }); // $or does NOT set arrayIndices when it has multiple\n                  // sub-expressions. (Tested against MongoDB.)\n\n                  return {\n                    result: result\n                  };\n                };\n              },\n              $nor: function $nor(subSelector, matcher, inElemMatch) {\n                var matchers = compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch);\n                return function (doc) {\n                  var result = matchers.every(function (fn) {\n                    return !fn(doc).result;\n                  }); // Never set arrayIndices, because we only match if nothing in particular\n                  // 'matched' (and because this is consistent with MongoDB).\n\n                  return {\n                    result: result\n                  };\n                };\n              },\n              $where: function $where(selectorValue, matcher) {\n                // Record that *any* path may be used.\n                matcher._recordPathUsed('');\n\n                matcher._hasWhere = true;\n\n                if (!(selectorValue instanceof Function)) {\n                  // XXX MongoDB seems to have more complex logic to decide where or or not\n                  // to add 'return'; not sure exactly what it is.\n                  selectorValue = Function('obj', \"return \".concat(selectorValue));\n                } // We make the document available as both `this` and `obj`.\n                // // XXX not sure what we should do if this throws\n\n\n                return function (doc) {\n                  return {\n                    result: selectorValue.call(doc, doc)\n                  };\n                };\n              },\n              // This is just used as a comment in the query (in MongoDB, it also ends up in\n              // query logs); it has no effect on the actual selection.\n              $comment: function $comment() {\n                return function () {\n                  return {\n                    result: true\n                  };\n                };\n              }\n            }; // Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a\n            // document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as\n            // \"match each branched value independently and combine with\n            // convertElementMatcherToBranchedMatcher\".\n\n            var VALUE_OPERATORS = {\n              $eq: function $eq(operand) {\n                return convertElementMatcherToBranchedMatcher(_equalityElementMatcher(operand));\n              },\n              $not: function $not(operand, valueSelector, matcher) {\n                return invertBranchedMatcher(compileValueSelector(operand, matcher));\n              },\n              $ne: function $ne(operand) {\n                return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(_equalityElementMatcher(operand)));\n              },\n              $nin: function $nin(operand) {\n                return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(_ELEMENT_OPERATORS.$in.compileElementSelector(operand)));\n              },\n              $exists: function $exists(operand) {\n                var exists = convertElementMatcherToBranchedMatcher(function (value) {\n                  return value !== undefined;\n                });\n                return operand ? exists : invertBranchedMatcher(exists);\n              },\n              // $options just provides options for $regex; its logic is inside $regex\n              $options: function $options(operand, valueSelector) {\n                if (!_hasOwn.call(valueSelector, '$regex')) {\n                  throw Error('$options needs a $regex');\n                }\n\n                return everythingMatcher;\n              },\n              // $maxDistance is basically an argument to $near\n              $maxDistance: function $maxDistance(operand, valueSelector) {\n                if (!valueSelector.$near) {\n                  throw Error('$maxDistance needs a $near');\n                }\n\n                return everythingMatcher;\n              },\n              $all: function $all(operand, valueSelector, matcher) {\n                if (!Array.isArray(operand)) {\n                  throw Error('$all requires array');\n                } // Not sure why, but this seems to be what MongoDB does.\n\n\n                if (operand.length === 0) {\n                  return _nothingMatcher;\n                }\n\n                var branchedMatchers = operand.map(function (criterion) {\n                  // XXX handle $all/$elemMatch combination\n                  if (_isOperatorObject(criterion)) {\n                    throw Error('no $ expressions in $all');\n                  } // This is always a regexp or equality selector.\n\n\n                  return compileValueSelector(criterion, matcher);\n                }); // andBranchedMatchers does NOT require all selectors to return true on the\n                // SAME branch.\n\n                return andBranchedMatchers(branchedMatchers);\n              },\n              $near: function $near(operand, valueSelector, matcher, isRoot) {\n                if (!isRoot) {\n                  throw Error('$near can\\'t be inside another $ operator');\n                }\n\n                matcher._hasGeoQuery = true; // There are two kinds of geodata in MongoDB: legacy coordinate pairs and\n                // GeoJSON. They use different distance metrics, too. GeoJSON queries are\n                // marked with a $geometry property, though legacy coordinates can be\n                // matched using $geometry.\n\n                var maxDistance, point, distance;\n\n                if (LocalCollection._isPlainObject(operand) && _hasOwn.call(operand, '$geometry')) {\n                  // GeoJSON \"2dsphere\" mode.\n                  maxDistance = operand.$maxDistance;\n                  point = operand.$geometry;\n\n                  distance = function distance(value) {\n                    // XXX: for now, we don't calculate the actual distance between, say,\n                    // polygon and circle. If people care about this use-case it will get\n                    // a priority.\n                    if (!value) {\n                      return null;\n                    }\n\n                    if (!value.type) {\n                      return GeoJSON.pointDistance(point, {\n                        type: 'Point',\n                        coordinates: pointToArray(value)\n                      });\n                    }\n\n                    if (value.type === 'Point') {\n                      return GeoJSON.pointDistance(point, value);\n                    }\n\n                    return GeoJSON.geometryWithinRadius(value, point, maxDistance) ? 0 : maxDistance + 1;\n                  };\n                } else {\n                  maxDistance = valueSelector.$maxDistance;\n\n                  if (!_isIndexable(operand)) {\n                    throw Error('$near argument must be coordinate pair or GeoJSON');\n                  }\n\n                  point = pointToArray(operand);\n\n                  distance = function distance(value) {\n                    if (!_isIndexable(value)) {\n                      return null;\n                    }\n\n                    return distanceCoordinatePairs(point, value);\n                  };\n                }\n\n                return function (branchedValues) {\n                  // There might be multiple points in the document that match the given\n                  // field. Only one of them needs to be within $maxDistance, but we need to\n                  // evaluate all of them and use the nearest one for the implicit sort\n                  // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)\n                  //\n                  // Note: This differs from MongoDB's implementation, where a document will\n                  // actually show up *multiple times* in the result set, with one entry for\n                  // each within-$maxDistance branching point.\n                  var result = {\n                    result: false\n                  };\n\n                  _expandArraysInBranches(branchedValues).every(function (branch) {\n                    // if operation is an update, don't skip branches, just return the first\n                    // one (#3599)\n                    var curDistance;\n\n                    if (!matcher._isUpdate) {\n                      if (!(_typeof(branch.value) === 'object')) {\n                        return true;\n                      }\n\n                      curDistance = distance(branch.value); // Skip branches that aren't real points or are too far away.\n\n                      if (curDistance === null || curDistance > maxDistance) {\n                        return true;\n                      } // Skip anything that's a tie.\n\n\n                      if (result.distance !== undefined && result.distance <= curDistance) {\n                        return true;\n                      }\n                    }\n\n                    result.result = true;\n                    result.distance = curDistance;\n\n                    if (branch.arrayIndices) {\n                      result.arrayIndices = branch.arrayIndices;\n                    } else {\n                      delete result.arrayIndices;\n                    }\n\n                    return !matcher._isUpdate;\n                  });\n\n                  return result;\n                };\n              }\n            }; // NB: We are cheating and using this function to implement 'AND' for both\n            // 'document matchers' and 'branched matchers'. They both return result objects\n            // but the argument is different: for the former it's a whole doc, whereas for\n            // the latter it's an array of 'branched values'.\n\n            function andSomeMatchers(subMatchers) {\n              if (subMatchers.length === 0) {\n                return everythingMatcher;\n              }\n\n              if (subMatchers.length === 1) {\n                return subMatchers[0];\n              }\n\n              return function (docOrBranches) {\n                var match = {};\n                match.result = subMatchers.every(function (fn) {\n                  var subResult = fn(docOrBranches); // Copy a 'distance' number out of the first sub-matcher that has\n                  // one. Yes, this means that if there are multiple $near fields in a\n                  // query, something arbitrary happens; this appears to be consistent with\n                  // Mongo.\n\n                  if (subResult.result && subResult.distance !== undefined && match.distance === undefined) {\n                    match.distance = subResult.distance;\n                  } // Similarly, propagate arrayIndices from sub-matchers... but to match\n                  // MongoDB behavior, this time the *last* sub-matcher with arrayIndices\n                  // wins.\n\n\n                  if (subResult.result && subResult.arrayIndices) {\n                    match.arrayIndices = subResult.arrayIndices;\n                  }\n\n                  return subResult.result;\n                }); // If we didn't actually match, forget any extra metadata we came up with.\n\n                if (!match.result) {\n                  delete match.distance;\n                  delete match.arrayIndices;\n                }\n\n                return match;\n              };\n            }\n\n            var andDocumentMatchers = andSomeMatchers;\n            var andBranchedMatchers = andSomeMatchers;\n\n            function compileArrayOfDocumentSelectors(selectors, matcher, inElemMatch) {\n              if (!Array.isArray(selectors) || selectors.length === 0) {\n                throw Error('$and/$or/$nor must be nonempty array');\n              }\n\n              return selectors.map(function (subSelector) {\n                if (!LocalCollection._isPlainObject(subSelector)) {\n                  throw Error('$or/$and/$nor entries need to be full objects');\n                }\n\n                return _compileDocumentSelector(subSelector, matcher, {\n                  inElemMatch: inElemMatch\n                });\n              });\n            } // Takes in a selector that could match a full document (eg, the original\n            // selector). Returns a function mapping document->result object.\n            //\n            // matcher is the Matcher object we are compiling.\n            //\n            // If this is the root document selector (ie, not wrapped in $and or the like),\n            // then isRoot is true. (This is used by $near.)\n\n\n            function _compileDocumentSelector(docSelector, matcher) {\n              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n              var docMatchers = Object.keys(docSelector).map(function (key) {\n                var subSelector = docSelector[key];\n\n                if (key.substr(0, 1) === '$') {\n                  // Outer operators are either logical operators (they recurse back into\n                  // this function), or $where.\n                  if (!_hasOwn.call(LOGICAL_OPERATORS, key)) {\n                    throw new Error(\"Unrecognized logical operator: \".concat(key));\n                  }\n\n                  matcher._isSimple = false;\n                  return LOGICAL_OPERATORS[key](subSelector, matcher, options.inElemMatch);\n                } // Record this path, but only if we aren't in an elemMatcher, since in an\n                // elemMatch this is a path inside an object in an array, not in the doc\n                // root.\n\n\n                if (!options.inElemMatch) {\n                  matcher._recordPathUsed(key);\n                } // Don't add a matcher if subSelector is a function -- this is to match\n                // the behavior of Meteor on the server (inherited from the node mongodb\n                // driver), which is to ignore any part of a selector which is a function.\n\n\n                if (typeof subSelector === 'function') {\n                  return undefined;\n                }\n\n                var lookUpByIndex = _makeLookupFunction(key);\n\n                var valueMatcher = compileValueSelector(subSelector, matcher, options.isRoot);\n                return function (doc) {\n                  return valueMatcher(lookUpByIndex(doc));\n                };\n              }).filter(Boolean);\n              return andDocumentMatchers(docMatchers);\n            } // Takes in a selector that could match a key-indexed value in a document; eg,\n            // {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to\n            // indicate equality).  Returns a branched matcher: a function mapping\n            // [branched value]->result object.\n\n\n            function compileValueSelector(valueSelector, matcher, isRoot) {\n              if (valueSelector instanceof RegExp) {\n                matcher._isSimple = false;\n                return convertElementMatcherToBranchedMatcher(_regexpElementMatcher(valueSelector));\n              }\n\n              if (_isOperatorObject(valueSelector)) {\n                return operatorBranchedMatcher(valueSelector, matcher, isRoot);\n              }\n\n              return convertElementMatcherToBranchedMatcher(_equalityElementMatcher(valueSelector));\n            } // Given an element matcher (which evaluates a single value), returns a branched\n            // value (which evaluates the element matcher on all the branches and returns a\n            // more structured return value possibly including arrayIndices).\n\n\n            function convertElementMatcherToBranchedMatcher(elementMatcher) {\n              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n              return function (branches) {\n                var expanded = options.dontExpandLeafArrays ? branches : _expandArraysInBranches(branches, options.dontIncludeLeafArrays);\n                var match = {};\n                match.result = expanded.some(function (element) {\n                  var matched = elementMatcher(element.value); // Special case for $elemMatch: it means \"true, and use this as an array\n                  // index if I didn't already have one\".\n\n                  if (typeof matched === 'number') {\n                    // XXX This code dates from when we only stored a single array index\n                    // (for the outermost array). Should we be also including deeper array\n                    // indices from the $elemMatch match?\n                    if (!element.arrayIndices) {\n                      element.arrayIndices = [matched];\n                    }\n\n                    matched = true;\n                  } // If some element matched, and it's tagged with array indices, include\n                  // those indices in our result object.\n\n\n                  if (matched && element.arrayIndices) {\n                    match.arrayIndices = element.arrayIndices;\n                  }\n\n                  return matched;\n                });\n                return match;\n              };\n            } // Helpers for $near.\n\n\n            function distanceCoordinatePairs(a, b) {\n              var pointA = pointToArray(a);\n              var pointB = pointToArray(b);\n              return Math.hypot(pointA[0] - pointB[0], pointA[1] - pointB[1]);\n            } // Takes something that is not an operator object and returns an element matcher\n            // for equality with that thing.\n\n\n            function _equalityElementMatcher(elementSelector) {\n              if (_isOperatorObject(elementSelector)) {\n                throw Error('Can\\'t create equalityValueSelector for operator object');\n              } // Special-case: null and undefined are equal (if you got undefined in there\n              // somewhere, or if you got it due to some branch being non-existent in the\n              // weird special case), even though they aren't with EJSON.equals.\n              // undefined or null\n\n\n              if (elementSelector == null) {\n                return function (value) {\n                  return value == null;\n                };\n              }\n\n              return function (value) {\n                return LocalCollection._f._equal(elementSelector, value);\n              };\n            }\n\n            function everythingMatcher(docOrBranchedValues) {\n              return {\n                result: true\n              };\n            }\n\n            function _expandArraysInBranches(branches, skipTheArrays) {\n              var branchesOut = [];\n              branches.forEach(function (branch) {\n                var thisIsArray = Array.isArray(branch.value); // We include the branch itself, *UNLESS* we it's an array that we're going\n                // to iterate and we're told to skip arrays.  (That's right, we include some\n                // arrays even skipTheArrays is true: these are arrays that were found via\n                // explicit numerical indices.)\n\n                if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {\n                  branchesOut.push({\n                    arrayIndices: branch.arrayIndices,\n                    value: branch.value\n                  });\n                }\n\n                if (thisIsArray && !branch.dontIterate) {\n                  branch.value.forEach(function (value, i) {\n                    branchesOut.push({\n                      arrayIndices: (branch.arrayIndices || []).concat(i),\n                      value: value\n                    });\n                  });\n                }\n              });\n              return branchesOut;\n            } // Helpers for $bitsAllSet/$bitsAnySet/$bitsAllClear/$bitsAnyClear.\n\n\n            function getOperandBitmask(operand, selector) {\n              // numeric bitmask\n              // You can provide a numeric bitmask to be matched against the operand field.\n              // It must be representable as a non-negative 32-bit signed integer.\n              // Otherwise, $bitsAllSet will return an error.\n              if (Number.isInteger(operand) && operand >= 0) {\n                return new Uint8Array(new Int32Array([operand]).buffer);\n              } // bindata bitmask\n              // You can also use an arbitrarily large BinData instance as a bitmask.\n\n\n              if (EJSON.isBinary(operand)) {\n                return new Uint8Array(operand.buffer);\n              } // position list\n              // If querying a list of bit positions, each <position> must be a non-negative\n              // integer. Bit positions start at 0 from the least significant bit.\n\n\n              if (Array.isArray(operand) && operand.every(function (x) {\n                return Number.isInteger(x) && x >= 0;\n              })) {\n                var buffer = new ArrayBuffer((Math.max.apply(Math, _toConsumableArray(operand)) >> 3) + 1);\n                var view = new Uint8Array(buffer);\n                operand.forEach(function (x) {\n                  view[x >> 3] |= 1 << (x & 0x7);\n                });\n                return view;\n              } // bad operand\n\n\n              throw Error(\"operand to \".concat(selector, \" must be a numeric bitmask (representable as a \") + 'non-negative 32-bit signed integer), a bindata bitmask or an array with ' + 'bit positions (non-negative integers)');\n            }\n\n            function getValueBitmask(value, length) {\n              // The field value must be either numerical or a BinData instance. Otherwise,\n              // $bits... will not match the current document.\n              // numerical\n              if (Number.isSafeInteger(value)) {\n                // $bits... will not match numerical values that cannot be represented as a\n                // signed 64-bit integer. This can be the case if a value is either too\n                // large or small to fit in a signed 64-bit integer, or if it has a\n                // fractional component.\n                var buffer = new ArrayBuffer(Math.max(length, 2 * Uint32Array.BYTES_PER_ELEMENT));\n                var view = new Uint32Array(buffer, 0, 2);\n                view[0] = value % ((1 << 16) * (1 << 16)) | 0;\n                view[1] = value / ((1 << 16) * (1 << 16)) | 0; // sign extension\n\n                if (value < 0) {\n                  view = new Uint8Array(buffer, 2);\n                  view.forEach(function (byte, i) {\n                    view[i] = 0xff;\n                  });\n                }\n\n                return new Uint8Array(buffer);\n              } // bindata\n\n\n              if (EJSON.isBinary(value)) {\n                return new Uint8Array(value.buffer);\n              } // no match\n\n\n              return false;\n            } // Actually inserts a key value into the selector document\n            // However, this checks there is no ambiguity in setting\n            // the value for the given key, throws otherwise\n\n\n            function insertIntoDocument(document, key, value) {\n              Object.keys(document).forEach(function (existingKey) {\n                if (existingKey.length > key.length && existingKey.indexOf(\"\".concat(key, \".\")) === 0 || key.length > existingKey.length && key.indexOf(\"\".concat(existingKey, \".\")) === 0) {\n                  throw new Error(\"cannot infer query fields to set, both paths '\".concat(existingKey, \"' and \") + \"'\".concat(key, \"' are matched\"));\n                } else if (existingKey === key) {\n                  throw new Error(\"cannot infer query fields to set, path '\".concat(key, \"' is matched twice\"));\n                }\n              });\n              document[key] = value;\n            } // Returns a branched matcher that matches iff the given matcher does not.\n            // Note that this implicitly \"deMorganizes\" the wrapped function.  ie, it\n            // means that ALL branch values need to fail to match innerBranchedMatcher.\n\n\n            function invertBranchedMatcher(branchedMatcher) {\n              return function (branchValues) {\n                // We explicitly choose to strip arrayIndices here: it doesn't make sense to\n                // say \"update the array element that does not match something\", at least\n                // in mongo-land.\n                return {\n                  result: !branchedMatcher(branchValues).result\n                };\n              };\n            }\n\n            function _isIndexable(obj) {\n              return Array.isArray(obj) || LocalCollection._isPlainObject(obj);\n            }\n\n            function _isNumericKey(s) {\n              return /^[0-9]+$/.test(s);\n            }\n\n            function _isOperatorObject(valueSelector, inconsistentOK) {\n              if (!LocalCollection._isPlainObject(valueSelector)) {\n                return false;\n              }\n\n              var theseAreOperators = undefined;\n              Object.keys(valueSelector).forEach(function (selKey) {\n                var thisIsOperator = selKey.substr(0, 1) === '$';\n\n                if (theseAreOperators === undefined) {\n                  theseAreOperators = thisIsOperator;\n                } else if (theseAreOperators !== thisIsOperator) {\n                  if (!inconsistentOK) {\n                    throw new Error(\"Inconsistent operator: \".concat(JSON.stringify(valueSelector)));\n                  }\n\n                  theseAreOperators = false;\n                }\n              });\n              return !!theseAreOperators; // {} has no operators\n            } // Helper for $lt/$gt/$lte/$gte.\n\n\n            function makeInequality(cmpValueComparator) {\n              return {\n                compileElementSelector: function compileElementSelector(operand) {\n                  // Arrays never compare false with non-arrays for any inequality.\n                  // XXX This was behavior we observed in pre-release MongoDB 2.5, but\n                  //     it seems to have been reverted.\n                  //     See https://jira.mongodb.org/browse/SERVER-11444\n                  if (Array.isArray(operand)) {\n                    return function () {\n                      return false;\n                    };\n                  } // Special case: consider undefined and null the same (so true with\n                  // $gte/$lte).\n\n\n                  if (operand === undefined) {\n                    operand = null;\n                  }\n\n                  var operandType = LocalCollection._f._type(operand);\n\n                  return function (value) {\n                    if (value === undefined) {\n                      value = null;\n                    } // Comparisons are never true among things of different type (except\n                    // null vs undefined).\n\n\n                    if (LocalCollection._f._type(value) !== operandType) {\n                      return false;\n                    }\n\n                    return cmpValueComparator(LocalCollection._f._cmp(value, operand));\n                  };\n                }\n              };\n            } // makeLookupFunction(key) returns a lookup function.\n            //\n            // A lookup function takes in a document and returns an array of matching\n            // branches.  If no arrays are found while looking up the key, this array will\n            // have exactly one branches (possibly 'undefined', if some segment of the key\n            // was not found).\n            //\n            // If arrays are found in the middle, this can have more than one element, since\n            // we 'branch'. When we 'branch', if there are more key segments to look up,\n            // then we only pursue branches that are plain objects (not arrays or scalars).\n            // This means we can actually end up with no branches!\n            //\n            // We do *NOT* branch on arrays that are found at the end (ie, at the last\n            // dotted member of the key). We just return that array; if you want to\n            // effectively 'branch' over the array's values, post-process the lookup\n            // function with expandArraysInBranches.\n            //\n            // Each branch is an object with keys:\n            //  - value: the value at the branch\n            //  - dontIterate: an optional bool; if true, it means that 'value' is an array\n            //    that expandArraysInBranches should NOT expand. This specifically happens\n            //    when there is a numeric index in the key, and ensures the\n            //    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT\n            //    match {a: [[5]]}.\n            //  - arrayIndices: if any array indexing was done during lookup (either due to\n            //    explicit numeric indices or implicit branching), this will be an array of\n            //    the array indices used, from outermost to innermost; it is falsey or\n            //    absent if no array index is used. If an explicit numeric index is used,\n            //    the index will be followed in arrayIndices by the string 'x'.\n            //\n            //    Note: arrayIndices is used for two purposes. First, it is used to\n            //    implement the '$' modifier feature, which only ever looks at its first\n            //    element.\n            //\n            //    Second, it is used for sort key generation, which needs to be able to tell\n            //    the difference between different paths. Moreover, it needs to\n            //    differentiate between explicit and implicit branching, which is why\n            //    there's the somewhat hacky 'x' entry: this means that explicit and\n            //    implicit array lookups will have different full arrayIndices paths. (That\n            //    code only requires that different paths have different arrayIndices; it\n            //    doesn't actually 'parse' arrayIndices. As an alternative, arrayIndices\n            //    could contain objects with flags like 'implicit', but I think that only\n            //    makes the code surrounding them more complex.)\n            //\n            //    (By the way, this field ends up getting passed around a lot without\n            //    cloning, so never mutate any arrayIndices field/var in this package!)\n            //\n            //\n            // At the top level, you may only pass in a plain object or array.\n            //\n            // See the test 'minimongo - lookup' for some examples of what lookup functions\n            // return.\n\n\n            function _makeLookupFunction(key) {\n              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n              var parts = key.split('.');\n              var firstPart = parts.length ? parts[0] : '';\n\n              var lookupRest = parts.length > 1 && _makeLookupFunction(parts.slice(1).join('.'), options);\n\n              var omitUnnecessaryFields = function omitUnnecessaryFields(result) {\n                if (!result.dontIterate) {\n                  delete result.dontIterate;\n                }\n\n                if (result.arrayIndices && !result.arrayIndices.length) {\n                  delete result.arrayIndices;\n                }\n\n                return result;\n              }; // Doc will always be a plain object or an array.\n              // apply an explicit numeric index, an array.\n\n\n              return function (doc) {\n                var arrayIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n                if (Array.isArray(doc)) {\n                  // If we're being asked to do an invalid lookup into an array (non-integer\n                  // or out-of-bounds), return no results (which is different from returning\n                  // a single undefined result, in that `null` equality checks won't match).\n                  if (!(_isNumericKey(firstPart) && firstPart < doc.length)) {\n                    return [];\n                  } // Remember that we used this array index. Include an 'x' to indicate that\n                  // the previous index came from being considered as an explicit array\n                  // index (not branching).\n\n\n                  arrayIndices = arrayIndices.concat(+firstPart, 'x');\n                } // Do our first lookup.\n\n\n                var firstLevel = doc[firstPart]; // If there is no deeper to dig, return what we found.\n                //\n                // If what we found is an array, most value selectors will choose to treat\n                // the elements of the array as matchable values in their own right, but\n                // that's done outside of the lookup function. (Exceptions to this are $size\n                // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:\n                // [[1, 2]]}.)\n                //\n                // That said, if we just did an *explicit* array lookup (on doc) to find\n                // firstLevel, and firstLevel is an array too, we do NOT want value\n                // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.\n                // So in that case, we mark the return value as 'don't iterate'.\n\n                if (!lookupRest) {\n                  return [omitUnnecessaryFields({\n                    arrayIndices: arrayIndices,\n                    dontIterate: Array.isArray(doc) && Array.isArray(firstLevel),\n                    value: firstLevel\n                  })];\n                } // We need to dig deeper.  But if we can't, because what we've found is not\n                // an array or plain object, we're done. If we just did a numeric index into\n                // an array, we return nothing here (this is a change in Mongo 2.5 from\n                // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,\n                // return a single `undefined` (which can, for example, match via equality\n                // with `null`).\n\n\n                if (!_isIndexable(firstLevel)) {\n                  if (Array.isArray(doc)) {\n                    return [];\n                  }\n\n                  return [omitUnnecessaryFields({\n                    arrayIndices: arrayIndices,\n                    value: undefined\n                  })];\n                }\n\n                var result = [];\n\n                var appendToResult = function appendToResult(more) {\n                  result.push.apply(result, _toConsumableArray(more));\n                }; // Dig deeper: look up the rest of the parts on whatever we've found.\n                // (lookupRest is smart enough to not try to do invalid lookups into\n                // firstLevel if it's an array.)\n\n\n                appendToResult(lookupRest(firstLevel, arrayIndices)); // If we found an array, then in *addition* to potentially treating the next\n                // part as a literal integer lookup, we should also 'branch': try to look up\n                // the rest of the parts on each array element in parallel.\n                //\n                // In this case, we *only* dig deeper into array elements that are plain\n                // objects. (Recall that we only got this far if we have further to dig.)\n                // This makes sense: we certainly don't dig deeper into non-indexable\n                // objects. And it would be weird to dig into an array: it's simpler to have\n                // a rule that explicit integer indexes only apply to an outer array, not to\n                // an array you find after a branching search.\n                //\n                // In the special case of a numeric part in a *sort selector* (not a query\n                // selector), we skip the branching: we ONLY allow the numeric part to mean\n                // 'look up this index' in that case, not 'also look up this index in all\n                // the elements of the array'.\n\n                if (Array.isArray(firstLevel) && !(_isNumericKey(parts[1]) && options.forSort)) {\n                  firstLevel.forEach(function (branch, arrayIndex) {\n                    if (LocalCollection._isPlainObject(branch)) {\n                      appendToResult(lookupRest(branch, arrayIndices.concat(arrayIndex)));\n                    }\n                  });\n                }\n\n                return result;\n              };\n            } // Object exported only for unit testing.\n            // Use it to export private functions to test in Tinytest.\n\n\n            MinimongoTest = {\n              makeLookupFunction: _makeLookupFunction\n            };\n\n            MinimongoError = function MinimongoError(message) {\n              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n              if (typeof message === 'string' && options.field) {\n                message += \" for field '\".concat(options.field, \"'\");\n              }\n\n              var error = new Error(message);\n              error.name = 'MinimongoError';\n              return error;\n            };\n\n            function _nothingMatcher(docOrBranchedValues) {\n              return {\n                result: false\n              };\n            } // Takes an operator object (an object with $ keys) and returns a branched\n            // matcher for it.\n\n\n            function operatorBranchedMatcher(valueSelector, matcher, isRoot) {\n              // Each valueSelector works separately on the various branches.  So one\n              // operator can match one branch and another can match another branch.  This\n              // is OK.\n              var operatorMatchers = Object.keys(valueSelector).map(function (operator) {\n                var operand = valueSelector[operator];\n                var simpleRange = ['$lt', '$lte', '$gt', '$gte'].includes(operator) && typeof operand === 'number';\n                var simpleEquality = ['$ne', '$eq'].includes(operator) && operand !== Object(operand);\n                var simpleInclusion = ['$in', '$nin'].includes(operator) && Array.isArray(operand) && !operand.some(function (x) {\n                  return x === Object(x);\n                });\n\n                if (!(simpleRange || simpleInclusion || simpleEquality)) {\n                  matcher._isSimple = false;\n                }\n\n                if (_hasOwn.call(VALUE_OPERATORS, operator)) {\n                  return VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot);\n                }\n\n                if (_hasOwn.call(_ELEMENT_OPERATORS, operator)) {\n                  var _options = _ELEMENT_OPERATORS[operator];\n                  return convertElementMatcherToBranchedMatcher(_options.compileElementSelector(operand, valueSelector, matcher), _options);\n                }\n\n                throw new Error(\"Unrecognized operator: \".concat(operator));\n              });\n              return andBranchedMatchers(operatorMatchers);\n            } // paths - Array: list of mongo style paths\n            // newLeafFn - Function: of form function(path) should return a scalar value to\n            //                       put into list created for that path\n            // conflictFn - Function: of form function(node, path, fullPath) is called\n            //                        when building a tree path for 'fullPath' node on\n            //                        'path' was already a leaf with a value. Must return a\n            //                        conflict resolution.\n            // initial tree - Optional Object: starting tree.\n            // @returns - Object: tree represented as a set of nested objects\n\n\n            function _pathsToTree(paths, newLeafFn, conflictFn) {\n              var root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n              paths.forEach(function (path) {\n                var pathArray = path.split('.');\n                var tree = root; // use .every just for iteration with break\n\n                var success = pathArray.slice(0, -1).every(function (key, i) {\n                  if (!_hasOwn.call(tree, key)) {\n                    tree[key] = {};\n                  } else if (tree[key] !== Object(tree[key])) {\n                    tree[key] = conflictFn(tree[key], pathArray.slice(0, i + 1).join('.'), path); // break out of loop if we are failing for this path\n\n                    if (tree[key] !== Object(tree[key])) {\n                      return false;\n                    }\n                  }\n\n                  tree = tree[key];\n                  return true;\n                });\n\n                if (success) {\n                  var lastKey = pathArray[pathArray.length - 1];\n\n                  if (_hasOwn.call(tree, lastKey)) {\n                    tree[lastKey] = conflictFn(tree[lastKey], path, path);\n                  } else {\n                    tree[lastKey] = newLeafFn(path);\n                  }\n                }\n              });\n              return root;\n            } // Makes sure we get 2 elements array and assume the first one to be x and\n            // the second one to y no matter what user passes.\n            // In case user passes { lon: x, lat: y } returns [x, y]\n\n\n            function pointToArray(point) {\n              return Array.isArray(point) ? point.slice() : [point.x, point.y];\n            } // Creating a document from an upsert is quite tricky.\n            // E.g. this selector: {\"$or\": [{\"b.foo\": {\"$all\": [\"bar\"]}}]}, should result\n            // in: {\"b.foo\": \"bar\"}\n            // But this selector: {\"$or\": [{\"b\": {\"foo\": {\"$all\": [\"bar\"]}}}]} should throw\n            // an error\n            // Some rules (found mainly with trial & error, so there might be more):\n            // - handle all childs of $and (or implicit $and)\n            // - handle $or nodes with exactly 1 child\n            // - ignore $or nodes with more than 1 child\n            // - ignore $nor and $not nodes\n            // - throw when a value can not be set unambiguously\n            // - every value for $all should be dealt with as separate $eq-s\n            // - threat all children of $all as $eq setters (=> set if $all.length === 1,\n            //   otherwise throw error)\n            // - you can not mix '$'-prefixed keys and non-'$'-prefixed keys\n            // - you can only have dotted keys on a root-level\n            // - you can not have '$'-prefixed keys more than one-level deep in an object\n            // Handles one key/value pair to put in the selector document\n\n\n            function populateDocumentWithKeyValue(document, key, value) {\n              if (value && Object.getPrototypeOf(value) === Object.prototype) {\n                populateDocumentWithObject(document, key, value);\n              } else if (!(value instanceof RegExp)) {\n                insertIntoDocument(document, key, value);\n              }\n            } // Handles a key, value pair to put in the selector document\n            // if the value is an object\n\n\n            function populateDocumentWithObject(document, key, value) {\n              var keys = Object.keys(value);\n              var unprefixedKeys = keys.filter(function (op) {\n                return op[0] !== '$';\n              });\n\n              if (unprefixedKeys.length > 0 || !keys.length) {\n                // Literal (possibly empty) object ( or empty object )\n                // Don't allow mixing '$'-prefixed with non-'$'-prefixed fields\n                if (keys.length !== unprefixedKeys.length) {\n                  throw new Error(\"unknown operator: \".concat(unprefixedKeys[0]));\n                }\n\n                validateObject(value, key);\n                insertIntoDocument(document, key, value);\n              } else {\n                Object.keys(value).forEach(function (op) {\n                  var object = value[op];\n\n                  if (op === '$eq') {\n                    populateDocumentWithKeyValue(document, key, object);\n                  } else if (op === '$all') {\n                    // every value for $all should be dealt with as separate $eq-s\n                    object.forEach(function (element) {\n                      return populateDocumentWithKeyValue(document, key, element);\n                    });\n                  }\n                });\n              }\n            } // Fills a document with certain fields from an upsert selector\n\n\n            function _populateDocumentWithQueryFields(query) {\n              var document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n              if (Object.getPrototypeOf(query) === Object.prototype) {\n                // handle implicit $and\n                Object.keys(query).forEach(function (key) {\n                  var value = query[key];\n\n                  if (key === '$and') {\n                    // handle explicit $and\n                    value.forEach(function (element) {\n                      return _populateDocumentWithQueryFields(element, document);\n                    });\n                  } else if (key === '$or') {\n                    // handle $or nodes with exactly 1 child\n                    if (value.length === 1) {\n                      _populateDocumentWithQueryFields(value[0], document);\n                    }\n                  } else if (key[0] !== '$') {\n                    // Ignore other '$'-prefixed logical selectors\n                    populateDocumentWithKeyValue(document, key, value);\n                  }\n                });\n              } else {\n                // Handle meteor-specific shortcut for selecting _id\n                if (LocalCollection._selectorIsId(query)) {\n                  insertIntoDocument(document, '_id', query);\n                }\n              }\n\n              return document;\n            }\n\n            function _projectionDetails(fields) {\n              // Find the non-_id keys (_id is handled specially because it is included\n              // unless explicitly excluded). Sort the keys, so that our code to detect\n              // overlaps like 'foo' and 'foo.bar' can assume that 'foo' comes first.\n              var fieldsKeys = Object.keys(fields).sort(); // If _id is the only field in the projection, do not remove it, since it is\n              // required to determine if this is an exclusion or exclusion. Also keep an\n              // inclusive _id, since inclusive _id follows the normal rules about mixing\n              // inclusive and exclusive fields. If _id is not the only field in the\n              // projection and is exclusive, remove it so it can be handled later by a\n              // special case, since exclusive _id is always allowed.\n\n              if (!(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') && !(fieldsKeys.includes('_id') && fields._id)) {\n                fieldsKeys = fieldsKeys.filter(function (key) {\n                  return key !== '_id';\n                });\n              }\n\n              var including = null; // Unknown\n\n              fieldsKeys.forEach(function (keyPath) {\n                var rule = !!fields[keyPath];\n\n                if (including === null) {\n                  including = rule;\n                } // This error message is copied from MongoDB shell\n\n\n                if (including !== rule) {\n                  throw MinimongoError('You cannot currently mix including and excluding fields.');\n                }\n              });\n\n              var projectionRulesTree = _pathsToTree(fieldsKeys, function (path) {\n                return including;\n              }, function (node, path, fullPath) {\n                // Check passed projection fields' keys: If you have two rules such as\n                // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\n                // that happens, there is a probability you are doing something wrong,\n                // framework should notify you about such mistake earlier on cursor\n                // compilation step than later during runtime.  Note, that real mongo\n                // doesn't do anything about it and the later rule appears in projection\n                // project, more priority it takes.\n                //\n                // Example, assume following in mongo shell:\n                // > db.coll.insert({ a: { b: 23, c: 44 } })\n                // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\n                // {\"_id\": ObjectId(\"520bfe456024608e8ef24af3\"), \"a\": {\"b\": 23}}\n                // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\n                // {\"_id\": ObjectId(\"520bfe456024608e8ef24af3\"), \"a\": {\"b\": 23, \"c\": 44}}\n                //\n                // Note, how second time the return set of keys is different.\n                var currentPath = fullPath;\n                var anotherPath = path;\n                throw MinimongoError(\"both \".concat(currentPath, \" and \").concat(anotherPath, \" found in fields option, \") + 'using both of them may trigger unexpected behavior. Did you mean to ' + 'use only one of them?');\n              });\n\n              return {\n                including: including,\n                tree: projectionRulesTree\n              };\n            }\n\n            function _regexpElementMatcher(regexp) {\n              return function (value) {\n                if (value instanceof RegExp) {\n                  return value.toString() === regexp.toString();\n                } // Regexps only work against strings.\n\n\n                if (typeof value !== 'string') {\n                  return false;\n                } // Reset regexp's state to avoid inconsistent matching for objects with the\n                // same value on consecutive calls of regexp.test. This happens only if the\n                // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for\n                // which we should *not* change the lastIndex but MongoDB doesn't support\n                // either of these flags.\n\n\n                regexp.lastIndex = 0;\n                return regexp.test(value);\n              };\n            } // Validates the key in a path.\n            // Objects that are nested more then 1 level cannot have dotted fields\n            // or fields starting with '$'\n\n\n            function validateKeyInPath(key, path) {\n              if (key.includes('.')) {\n                throw new Error(\"The dotted field '\".concat(key, \"' in '\").concat(path, \".\").concat(key, \" is not valid for storage.\"));\n              }\n\n              if (key[0] === '$') {\n                throw new Error(\"The dollar ($) prefixed field  '\".concat(path, \".\").concat(key, \" is not valid for storage.\"));\n              }\n            } // Recursively validates an object that is nested more than one level deep\n\n\n            function validateObject(object, path) {\n              if (object && Object.getPrototypeOf(object) === Object.prototype) {\n                Object.keys(object).forEach(function (key) {\n                  validateKeyInPath(key, path);\n                  validateObject(object[key], path + '.' + key);\n                });\n              }\n            } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"cursor.js\": function cursorJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/minimongo/cursor.js                                                                                        //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              default: function _default() {\n                return Cursor;\n              }\n            });\n            var LocalCollection;\n            module.watch(require(\"./local_collection.js\"), {\n              default: function _default(v) {\n                LocalCollection = v;\n              }\n            }, 0);\n\n            var _hasOwn2;\n\n            module.watch(require(\"./common.js\"), {\n              hasOwn: function hasOwn(v) {\n                _hasOwn2 = v;\n              }\n            }, 1);\n\n            var Cursor =\n            /*#__PURE__*/\n            function () {\n              // don't call this ctor directly.  use LocalCollection.find().\n              function Cursor(collection, selector) {\n                _classCallCheck(this, Cursor);\n\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                this.collection = collection;\n                this.sorter = null;\n                this.matcher = new Minimongo.Matcher(selector);\n\n                if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n                  // stash for fast _id and { _id }\n                  this._selectorId = _hasOwn2.call(selector, '_id') ? selector._id : selector;\n                } else {\n                  this._selectorId = undefined;\n\n                  if (this.matcher.hasGeoQuery() || options.sort) {\n                    this.sorter = new Minimongo.Sorter(options.sort || []);\n                  }\n                }\n\n                this.skip = options.skip || 0;\n                this.limit = options.limit;\n                this.fields = options.fields;\n                this._projectionFn = LocalCollection._compileProjection(this.fields || {});\n                this._transform = LocalCollection.wrapTransform(options.transform); // by default, queries register w/ Tracker when it is available.\n\n                if (typeof Tracker !== 'undefined') {\n                  this.reactive = options.reactive === undefined ? true : options.reactive;\n                }\n              }\n              /**\n               * @summary Returns the number of documents that match a query.\n               * @memberOf Mongo.Cursor\n               * @method  count\n               * @param {boolean} [applySkipLimit=true] If set to `false`, the value\n               *                                         returned will reflect the total\n               *                                         number of matching documents,\n               *                                         ignoring any value supplied for\n               *                                         limit\n               * @instance\n               * @locus Anywhere\n               * @returns {Number}\n               */\n\n\n              _createClass(Cursor, [{\n                key: \"count\",\n                value: function count() {\n                  var applySkipLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n                  if (this.reactive) {\n                    // allow the observe to be unordered\n                    this._depend({\n                      added: true,\n                      removed: true\n                    }, true);\n                  }\n\n                  return this._getRawObjects({\n                    ordered: true,\n                    applySkipLimit: applySkipLimit\n                  }).length;\n                }\n                /**\n                 * @summary Return all matching documents as an Array.\n                 * @memberOf Mongo.Cursor\n                 * @method  fetch\n                 * @instance\n                 * @locus Anywhere\n                 * @returns {Object[]}\n                 */\n\n              }, {\n                key: \"fetch\",\n                value: function fetch() {\n                  var result = [];\n                  this.forEach(function (doc) {\n                    result.push(doc);\n                  });\n                  return result;\n                }\n              }, {\n                key: Symbol.iterator,\n                value: function value() {\n                  var _this = this;\n\n                  if (this.reactive) {\n                    this._depend({\n                      addedBefore: true,\n                      removed: true,\n                      changed: true,\n                      movedBefore: true\n                    });\n                  }\n\n                  var index = 0;\n\n                  var objects = this._getRawObjects({\n                    ordered: true\n                  });\n\n                  return {\n                    next: function next() {\n                      if (index < objects.length) {\n                        // This doubles as a clone operation.\n                        var element = _this._projectionFn(objects[index++]);\n\n                        if (_this._transform) element = _this._transform(element);\n                        return {\n                          value: element\n                        };\n                      }\n\n                      return {\n                        done: true\n                      };\n                    }\n                  };\n                }\n                /**\n                 * @callback IterationCallback\n                 * @param {Object} doc\n                 * @param {Number} index\n                 */\n\n                /**\n                 * @summary Call `callback` once for each matching document, sequentially and\n                 *          synchronously.\n                 * @locus Anywhere\n                 * @method  forEach\n                 * @instance\n                 * @memberOf Mongo.Cursor\n                 * @param {IterationCallback} callback Function to call. It will be called\n                 *                                     with three arguments: the document, a\n                 *                                     0-based index, and <em>cursor</em>\n                 *                                     itself.\n                 * @param {Any} [thisArg] An object which will be the value of `this` inside\n                 *                        `callback`.\n                 */\n\n              }, {\n                key: \"forEach\",\n                value: function forEach(callback, thisArg) {\n                  var _this2 = this;\n\n                  if (this.reactive) {\n                    this._depend({\n                      addedBefore: true,\n                      removed: true,\n                      changed: true,\n                      movedBefore: true\n                    });\n                  }\n\n                  this._getRawObjects({\n                    ordered: true\n                  }).forEach(function (element, i) {\n                    // This doubles as a clone operation.\n                    element = _this2._projectionFn(element);\n\n                    if (_this2._transform) {\n                      element = _this2._transform(element);\n                    }\n\n                    callback.call(thisArg, element, i, _this2);\n                  });\n                }\n              }, {\n                key: \"getTransform\",\n                value: function getTransform() {\n                  return this._transform;\n                }\n                /**\n                 * @summary Map callback over all matching documents.  Returns an Array.\n                 * @locus Anywhere\n                 * @method map\n                 * @instance\n                 * @memberOf Mongo.Cursor\n                 * @param {IterationCallback} callback Function to call. It will be called\n                 *                                     with three arguments: the document, a\n                 *                                     0-based index, and <em>cursor</em>\n                 *                                     itself.\n                 * @param {Any} [thisArg] An object which will be the value of `this` inside\n                 *                        `callback`.\n                 */\n\n              }, {\n                key: \"map\",\n                value: function map(callback, thisArg) {\n                  var _this3 = this;\n\n                  var result = [];\n                  this.forEach(function (doc, i) {\n                    result.push(callback.call(thisArg, doc, i, _this3));\n                  });\n                  return result;\n                } // options to contain:\n                //  * callbacks for observe():\n                //    - addedAt (document, atIndex)\n                //    - added (document)\n                //    - changedAt (newDocument, oldDocument, atIndex)\n                //    - changed (newDocument, oldDocument)\n                //    - removedAt (document, atIndex)\n                //    - removed (document)\n                //    - movedTo (document, oldIndex, newIndex)\n                //\n                // attributes available on returned query handle:\n                //  * stop(): end updates\n                //  * collection: the collection this query is querying\n                //\n                // iff x is a returned query handle, (x instanceof\n                // LocalCollection.ObserveHandle) is true\n                //\n                // initial results delivered through added callback\n                // XXX maybe callbacks should take a list of objects, to expose transactions?\n                // XXX maybe support field limiting (to limit what you're notified on)\n\n                /**\n                 * @summary Watch a query.  Receive callbacks as the result set changes.\n                 * @locus Anywhere\n                 * @memberOf Mongo.Cursor\n                 * @instance\n                 * @param {Object} callbacks Functions to call to deliver the result set as it\n                 *                           changes\n                 */\n\n              }, {\n                key: \"observe\",\n                value: function observe(options) {\n                  return LocalCollection._observeFromObserveChanges(this, options);\n                }\n                /**\n                 * @summary Watch a query. Receive callbacks as the result set changes. Only\n                 *          the differences between the old and new documents are passed to\n                 *          the callbacks.\n                 * @locus Anywhere\n                 * @memberOf Mongo.Cursor\n                 * @instance\n                 * @param {Object} callbacks Functions to call to deliver the result set as it\n                 *                           changes\n                 */\n\n              }, {\n                key: \"observeChanges\",\n                value: function observeChanges(options) {\n                  var _this4 = this;\n\n                  var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options); // there are several places that assume you aren't combining skip/limit with\n                  // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n                  // comment in _modifyAndNotify\n                  // XXX allow skip/limit with unordered observe\n\n\n                  if (!options._allow_unordered && !ordered && (this.skip || this.limit)) {\n                    throw new Error(\"Must use an ordered observe with skip or limit (i.e. 'addedBefore' \" + \"for observeChanges or 'addedAt' for observe, instead of 'added').\");\n                  }\n\n                  if (this.fields && (this.fields._id === 0 || this.fields._id === false)) {\n                    throw Error('You may not observe a cursor with {fields: {_id: 0}}');\n                  }\n\n                  var distances = this.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap();\n                  var query = {\n                    cursor: this,\n                    dirty: false,\n                    distances: distances,\n                    matcher: this.matcher,\n                    // not fast pathed\n                    ordered: ordered,\n                    projectionFn: this._projectionFn,\n                    resultsSnapshot: null,\n                    sorter: ordered && this.sorter\n                  };\n                  var qid; // Non-reactive queries call added[Before] and then never call anything\n                  // else.\n\n                  if (this.reactive) {\n                    qid = this.collection.next_qid++;\n                    this.collection.queries[qid] = query;\n                  }\n\n                  query.results = this._getRawObjects({\n                    ordered: ordered,\n                    distances: query.distances\n                  });\n\n                  if (this.collection.paused) {\n                    query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap();\n                  } // wrap callbacks we were passed. callbacks only fire when not paused and\n                  // are never undefined\n                  // Filters out blacklisted fields according to cursor's projection.\n                  // XXX wrong place for this?\n                  // furthermore, callbacks enqueue until the operation we're working on is\n                  // done.\n\n\n                  var wrapCallback = function wrapCallback(fn) {\n                    if (!fn) {\n                      return function () {};\n                    }\n\n                    var self = _this4;\n                    return function ()\n                    /* args*/\n                    {\n                      var _this5 = this;\n\n                      if (self.collection.paused) {\n                        return;\n                      }\n\n                      var args = arguments;\n\n                      self.collection._observeQueue.queueTask(function () {\n                        fn.apply(_this5, args);\n                      });\n                    };\n                  };\n\n                  query.added = wrapCallback(options.added);\n                  query.changed = wrapCallback(options.changed);\n                  query.removed = wrapCallback(options.removed);\n\n                  if (ordered) {\n                    query.addedBefore = wrapCallback(options.addedBefore);\n                    query.movedBefore = wrapCallback(options.movedBefore);\n                  }\n\n                  if (!options._suppress_initial && !this.collection.paused) {\n                    query.results.forEach(function (doc) {\n                      var fields = EJSON.clone(doc);\n                      delete fields._id;\n\n                      if (ordered) {\n                        query.addedBefore(doc._id, _this4._projectionFn(fields), null);\n                      }\n\n                      query.added(doc._id, _this4._projectionFn(fields));\n                    });\n                  }\n\n                  var handle = Object.assign(new LocalCollection.ObserveHandle(), {\n                    collection: this.collection,\n                    stop: function stop() {\n                      if (_this4.reactive) {\n                        delete _this4.collection.queries[qid];\n                      }\n                    }\n                  });\n\n                  if (this.reactive && Tracker.active) {\n                    // XXX in many cases, the same observe will be recreated when\n                    // the current autorun is rerun.  we could save work by\n                    // letting it linger across rerun and potentially get\n                    // repurposed if the same observe is performed, using logic\n                    // similar to that of Meteor.subscribe.\n                    Tracker.onInvalidate(function () {\n                      handle.stop();\n                    });\n                  } // run the observe callbacks resulting from the initial contents\n                  // before we leave the observe.\n\n\n                  this.collection._observeQueue.drain();\n\n                  return handle;\n                } // Since we don't actually have a \"nextObject\" interface, there's really no\n                // reason to have a \"rewind\" interface.  All it did was make multiple calls\n                // to fetch/map/forEach return nothing the second time.\n                // XXX COMPAT WITH 0.8.1\n\n              }, {\n                key: \"rewind\",\n                value: function rewind() {} // XXX Maybe we need a version of observe that just calls a callback if\n                // anything changed.\n\n              }, {\n                key: \"_depend\",\n                value: function _depend(changers, _allow_unordered) {\n                  if (Tracker.active) {\n                    var dependency = new Tracker.Dependency();\n                    var notify = dependency.changed.bind(dependency);\n                    dependency.depend();\n                    var _options2 = {\n                      _allow_unordered: _allow_unordered,\n                      _suppress_initial: true\n                    };\n                    ['added', 'addedBefore', 'changed', 'movedBefore', 'removed'].forEach(function (fn) {\n                      if (changers[fn]) {\n                        _options2[fn] = notify;\n                      }\n                    }); // observeChanges will stop() when this computation is invalidated\n\n                    this.observeChanges(_options2);\n                  }\n                }\n              }, {\n                key: \"_getCollectionName\",\n                value: function _getCollectionName() {\n                  return this.collection.name;\n                } // Returns a collection of matching objects, but doesn't deep copy them.\n                //\n                // If ordered is set, returns a sorted array, respecting sorter, skip, and\n                // limit properties of the query provided that options.applySkipLimit is\n                // not set to false (#1201). If sorter is falsey, no sort -- you get the\n                // natural order.\n                //\n                // If ordered is not set, returns an object mapping from ID to doc (sorter,\n                // skip and limit should not be set).\n                //\n                // If ordered is set and this cursor is a $near geoquery, then this function\n                // will use an _IdMap to track each distance from the $near argument point in\n                // order to use it as a sort key. If an _IdMap is passed in the 'distances'\n                // argument, this function will clear it and use it for this purpose\n                // (otherwise it will just create its own _IdMap). The observeChanges\n                // implementation uses this to remember the distances after this function\n                // returns.\n\n              }, {\n                key: \"_getRawObjects\",\n                value: function _getRawObjects() {\n                  var _this6 = this;\n\n                  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // By default this method will respect skip and limit because .fetch(),\n                  // .forEach() etc... expect this behaviour. It can be forced to ignore\n                  // skip and limit by setting applySkipLimit to false (.count() does this,\n                  // for example)\n\n                  var applySkipLimit = options.applySkipLimit !== false; // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n                  // compatible\n\n                  var results = options.ordered ? [] : new LocalCollection._IdMap(); // fast path for single ID value\n\n                  if (this._selectorId !== undefined) {\n                    // If you have non-zero skip and ask for a single id, you get nothing.\n                    // This is so it matches the behavior of the '{_id: foo}' path.\n                    if (applySkipLimit && this.skip) {\n                      return results;\n                    }\n\n                    var selectedDoc = this.collection._docs.get(this._selectorId);\n\n                    if (selectedDoc) {\n                      if (options.ordered) {\n                        results.push(selectedDoc);\n                      } else {\n                        results.set(this._selectorId, selectedDoc);\n                      }\n                    }\n\n                    return results;\n                  } // slow path for arbitrary selector, sort, skip, limit\n                  // in the observeChanges case, distances is actually part of the \"query\"\n                  // (ie, live results set) object.  in other cases, distances is only used\n                  // inside this function.\n\n\n                  var distances;\n\n                  if (this.matcher.hasGeoQuery() && options.ordered) {\n                    if (options.distances) {\n                      distances = options.distances;\n                      distances.clear();\n                    } else {\n                      distances = new LocalCollection._IdMap();\n                    }\n                  }\n\n                  this.collection._docs.forEach(function (doc, id) {\n                    var matchResult = _this6.matcher.documentMatches(doc);\n\n                    if (matchResult.result) {\n                      if (options.ordered) {\n                        results.push(doc);\n\n                        if (distances && matchResult.distance !== undefined) {\n                          distances.set(id, matchResult.distance);\n                        }\n                      } else {\n                        results.set(id, doc);\n                      }\n                    } // Override to ensure all docs are matched if ignoring skip & limit\n\n\n                    if (!applySkipLimit) {\n                      return true;\n                    } // Fast path for limited unsorted queries.\n                    // XXX 'length' check here seems wrong for ordered\n\n\n                    return !_this6.limit || _this6.skip || _this6.sorter || results.length !== _this6.limit;\n                  });\n\n                  if (!options.ordered) {\n                    return results;\n                  }\n\n                  if (this.sorter) {\n                    results.sort(this.sorter.getComparator({\n                      distances: distances\n                    }));\n                  } // Return the full set of results if there is no skip or limit or if we're\n                  // ignoring them\n\n\n                  if (!applySkipLimit || !this.limit && !this.skip) {\n                    return results;\n                  }\n\n                  return results.slice(this.skip, this.limit ? this.limit + this.skip : results.length);\n                }\n              }, {\n                key: \"_publishCursor\",\n                value: function _publishCursor(subscription) {\n                  // XXX minimongo should not depend on mongo-livedata!\n                  if (!Package.mongo) {\n                    throw new Error('Can\\'t publish from Minimongo without the `mongo` package.');\n                  }\n\n                  if (!this.collection.name) {\n                    throw new Error('Can\\'t publish a cursor from a collection without a name.');\n                  }\n\n                  return Package.mongo.Mongo.Collection._publishCursor(this, subscription, this.collection.name);\n                }\n              }]);\n\n              return Cursor;\n            }(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"local_collection.js\": function local_collectionJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/minimongo/local_collection.js                                                                              //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              default: function _default() {\n                return LocalCollection;\n              }\n            });\n            var Cursor;\n            module.watch(require(\"./cursor.js\"), {\n              default: function _default(v) {\n                Cursor = v;\n              }\n            }, 0);\n            var ObserveHandle;\n            module.watch(require(\"./observe_handle.js\"), {\n              default: function _default(v) {\n                ObserveHandle = v;\n              }\n            }, 1);\n\n            var _hasOwn3, _isIndexable2, _isNumericKey2, _isOperatorObject2, _populateDocumentWithQueryFields2, _projectionDetails2;\n\n            module.watch(require(\"./common.js\"), {\n              hasOwn: function hasOwn(v) {\n                _hasOwn3 = v;\n              },\n              isIndexable: function isIndexable(v) {\n                _isIndexable2 = v;\n              },\n              isNumericKey: function isNumericKey(v) {\n                _isNumericKey2 = v;\n              },\n              isOperatorObject: function isOperatorObject(v) {\n                _isOperatorObject2 = v;\n              },\n              populateDocumentWithQueryFields: function populateDocumentWithQueryFields(v) {\n                _populateDocumentWithQueryFields2 = v;\n              },\n              projectionDetails: function projectionDetails(v) {\n                _projectionDetails2 = v;\n              }\n            }, 2);\n\n            var LocalCollection =\n            /*#__PURE__*/\n            function () {\n              function LocalCollection(name) {\n                _classCallCheck(this, LocalCollection);\n\n                this.name = name; // _id -> document (also containing id)\n\n                this._docs = new LocalCollection._IdMap();\n                this._observeQueue = new Meteor._SynchronousQueue();\n                this.next_qid = 1; // live query id generator\n                // qid -> live query object. keys:\n                //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n                //  results: array (ordered) or object (unordered) of current results\n                //    (aliased with this._docs!)\n                //  resultsSnapshot: snapshot of results. null if not paused.\n                //  cursor: Cursor object for the query.\n                //  selector, sorter, (callbacks): functions\n\n                this.queries = Object.create(null); // null if not saving originals; an IdMap from id to original document value\n                // if saving originals. See comments before saveOriginals().\n\n                this._savedOriginals = null; // True when observers are paused and we should not send callbacks.\n\n                this.paused = false;\n              } // options may include sort, skip, limit, reactive\n              // sort may be any of these forms:\n              //     {a: 1, b: -1}\n              //     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n              //     [\"a\", [\"b\", \"desc\"]]\n              //   (in the first form you're beholden to key enumeration order in\n              //   your javascript VM)\n              //\n              // reactive: if given, and false, don't register with Tracker (default\n              // is true)\n              //\n              // XXX possibly should support retrieving a subset of fields? and\n              // have it be a hint (ignored on the client, when not copying the\n              // doc?)\n              //\n              // XXX sort does not yet support subkeys ('a.b') .. fix that!\n              // XXX add one more sort form: \"key\"\n              // XXX tests\n\n\n              _createClass(LocalCollection, [{\n                key: \"find\",\n                value: function find(selector, options) {\n                  // default syntax for everything is to omit the selector argument.\n                  // but if selector is explicitly passed in as false or undefined, we\n                  // want a selector that matches nothing.\n                  if (arguments.length === 0) {\n                    selector = {};\n                  }\n\n                  return new LocalCollection.Cursor(this, selector, options);\n                }\n              }, {\n                key: \"findOne\",\n                value: function findOne(selector) {\n                  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n                  if (arguments.length === 0) {\n                    selector = {};\n                  } // NOTE: by setting limit 1 here, we end up using very inefficient\n                  // code that recomputes the whole query on each update. The upside is\n                  // that when you reactively depend on a findOne you only get\n                  // invalidated when the found object changes, not any object in the\n                  // collection. Most findOne will be by id, which has a fast path, so\n                  // this might not be a big deal. In most cases, invalidation causes\n                  // the called to re-query anyway, so this should be a net performance\n                  // improvement.\n\n\n                  options.limit = 1;\n                  return this.find(selector, options).fetch()[0];\n                } // XXX possibly enforce that 'undefined' does not appear (we assume\n                // this in our handling of null and $exists)\n\n              }, {\n                key: \"insert\",\n                value: function insert(doc, callback) {\n                  var _this7 = this;\n\n                  doc = EJSON.clone(doc);\n                  assertHasValidFieldNames(doc); // if you really want to use ObjectIDs, set this global.\n                  // Mongo.Collection specifies its own ids and does not use this code.\n\n                  if (!_hasOwn3.call(doc, '_id')) {\n                    doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n                  }\n\n                  var id = doc._id;\n\n                  if (this._docs.has(id)) {\n                    throw MinimongoError(\"Duplicate _id '\".concat(id, \"'\"));\n                  }\n\n                  this._saveOriginal(id, undefined);\n\n                  this._docs.set(id, doc);\n\n                  var queriesToRecompute = []; // trigger live queries that match\n\n                  Object.keys(this.queries).forEach(function (qid) {\n                    var query = _this7.queries[qid];\n\n                    if (query.dirty) {\n                      return;\n                    }\n\n                    var matchResult = query.matcher.documentMatches(doc);\n\n                    if (matchResult.result) {\n                      if (query.distances && matchResult.distance !== undefined) {\n                        query.distances.set(id, matchResult.distance);\n                      }\n\n                      if (query.cursor.skip || query.cursor.limit) {\n                        queriesToRecompute.push(qid);\n                      } else {\n                        LocalCollection._insertInResults(query, doc);\n                      }\n                    }\n                  });\n                  queriesToRecompute.forEach(function (qid) {\n                    if (_this7.queries[qid]) {\n                      _this7._recomputeResults(_this7.queries[qid]);\n                    }\n                  });\n\n                  this._observeQueue.drain(); // Defer because the caller likely doesn't expect the callback to be run\n                  // immediately.\n\n\n                  if (callback) {\n                    Meteor.defer(function () {\n                      callback(null, id);\n                    });\n                  }\n\n                  return id;\n                } // Pause the observers. No callbacks from observers will fire until\n                // 'resumeObservers' is called.\n\n              }, {\n                key: \"pauseObservers\",\n                value: function pauseObservers() {\n                  var _this8 = this;\n\n                  // No-op if already paused.\n                  if (this.paused) {\n                    return;\n                  } // Set the 'paused' flag such that new observer messages don't fire.\n\n\n                  this.paused = true; // Take a snapshot of the query results for each query.\n\n                  Object.keys(this.queries).forEach(function (qid) {\n                    var query = _this8.queries[qid];\n                    query.resultsSnapshot = EJSON.clone(query.results);\n                  });\n                }\n              }, {\n                key: \"remove\",\n                value: function remove(selector, callback) {\n                  var _this9 = this;\n\n                  // Easy special case: if we're not calling observeChanges callbacks and\n                  // we're not saving originals and we got asked to remove everything, then\n                  // just empty everything directly.\n                  if (this.paused && !this._savedOriginals && EJSON.equals(selector, {})) {\n                    var _result = this._docs.size();\n\n                    this._docs.clear();\n\n                    Object.keys(this.queries).forEach(function (qid) {\n                      var query = _this9.queries[qid];\n\n                      if (query.ordered) {\n                        query.results = [];\n                      } else {\n                        query.results.clear();\n                      }\n                    });\n\n                    if (callback) {\n                      Meteor.defer(function () {\n                        callback(null, _result);\n                      });\n                    }\n\n                    return _result;\n                  }\n\n                  var matcher = new Minimongo.Matcher(selector);\n                  var remove = [];\n\n                  this._eachPossiblyMatchingDoc(selector, function (doc, id) {\n                    if (matcher.documentMatches(doc).result) {\n                      remove.push(id);\n                    }\n                  });\n\n                  var queriesToRecompute = [];\n                  var queryRemove = [];\n\n                  var _loop = function _loop(i) {\n                    var removeId = remove[i];\n\n                    var removeDoc = _this9._docs.get(removeId);\n\n                    Object.keys(_this9.queries).forEach(function (qid) {\n                      var query = _this9.queries[qid];\n\n                      if (query.dirty) {\n                        return;\n                      }\n\n                      if (query.matcher.documentMatches(removeDoc).result) {\n                        if (query.cursor.skip || query.cursor.limit) {\n                          queriesToRecompute.push(qid);\n                        } else {\n                          queryRemove.push({\n                            qid: qid,\n                            doc: removeDoc\n                          });\n                        }\n                      }\n                    });\n\n                    _this9._saveOriginal(removeId, removeDoc);\n\n                    _this9._docs.remove(removeId);\n                  };\n\n                  for (var i = 0; i < remove.length; i++) {\n                    _loop(i);\n                  } // run live query callbacks _after_ we've removed the documents.\n\n\n                  queryRemove.forEach(function (remove) {\n                    var query = _this9.queries[remove.qid];\n\n                    if (query) {\n                      query.distances && query.distances.remove(remove.doc._id);\n\n                      LocalCollection._removeFromResults(query, remove.doc);\n                    }\n                  });\n                  queriesToRecompute.forEach(function (qid) {\n                    var query = _this9.queries[qid];\n\n                    if (query) {\n                      _this9._recomputeResults(query);\n                    }\n                  });\n\n                  this._observeQueue.drain();\n\n                  var result = remove.length;\n\n                  if (callback) {\n                    Meteor.defer(function () {\n                      callback(null, result);\n                    });\n                  }\n\n                  return result;\n                } // Resume the observers. Observers immediately receive change\n                // notifications to bring them to the current state of the\n                // database. Note that this is not just replaying all the changes that\n                // happened during the pause, it is a smarter 'coalesced' diff.\n\n              }, {\n                key: \"resumeObservers\",\n                value: function resumeObservers() {\n                  var _this10 = this;\n\n                  // No-op if not paused.\n                  if (!this.paused) {\n                    return;\n                  } // Unset the 'paused' flag. Make sure to do this first, otherwise\n                  // observer methods won't actually fire when we trigger them.\n\n\n                  this.paused = false;\n                  Object.keys(this.queries).forEach(function (qid) {\n                    var query = _this10.queries[qid];\n\n                    if (query.dirty) {\n                      query.dirty = false; // re-compute results will perform `LocalCollection._diffQueryChanges`\n                      // automatically.\n\n                      _this10._recomputeResults(query, query.resultsSnapshot);\n                    } else {\n                      // Diff the current results against the snapshot and send to observers.\n                      // pass the query object for its observer callbacks.\n                      LocalCollection._diffQueryChanges(query.ordered, query.resultsSnapshot, query.results, query, {\n                        projectionFn: query.projectionFn\n                      });\n                    }\n\n                    query.resultsSnapshot = null;\n                  });\n\n                  this._observeQueue.drain();\n                }\n              }, {\n                key: \"retrieveOriginals\",\n                value: function retrieveOriginals() {\n                  if (!this._savedOriginals) {\n                    throw new Error('Called retrieveOriginals without saveOriginals');\n                  }\n\n                  var originals = this._savedOriginals;\n                  this._savedOriginals = null;\n                  return originals;\n                } // To track what documents are affected by a piece of code, call\n                // saveOriginals() before it and retrieveOriginals() after it.\n                // retrieveOriginals returns an object whose keys are the ids of the documents\n                // that were affected since the call to saveOriginals(), and the values are\n                // equal to the document's contents at the time of saveOriginals. (In the case\n                // of an inserted document, undefined is the value.) You must alternate\n                // between calls to saveOriginals() and retrieveOriginals().\n\n              }, {\n                key: \"saveOriginals\",\n                value: function saveOriginals() {\n                  if (this._savedOriginals) {\n                    throw new Error('Called saveOriginals twice without retrieveOriginals');\n                  }\n\n                  this._savedOriginals = new LocalCollection._IdMap();\n                } // XXX atomicity: if multi is true, and one modification fails, do\n                // we rollback the whole operation, or what?\n\n              }, {\n                key: \"update\",\n                value: function update(selector, mod, options, callback) {\n                  var _this11 = this;\n\n                  if (!callback && options instanceof Function) {\n                    callback = options;\n                    options = null;\n                  }\n\n                  if (!options) {\n                    options = {};\n                  }\n\n                  var matcher = new Minimongo.Matcher(selector, true); // Save the original results of any query that we might need to\n                  // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n                  // it. (We don't need to save the original results of paused queries because\n                  // they already have a resultsSnapshot and we won't be diffing in\n                  // _recomputeResults.)\n\n                  var qidToOriginalResults = {}; // We should only clone each document once, even if it appears in multiple\n                  // queries\n\n                  var docMap = new LocalCollection._IdMap();\n\n                  var idsMatched = LocalCollection._idsMatchedBySelector(selector);\n\n                  Object.keys(this.queries).forEach(function (qid) {\n                    var query = _this11.queries[qid];\n\n                    if ((query.cursor.skip || query.cursor.limit) && !_this11.paused) {\n                      // Catch the case of a reactive `count()` on a cursor with skip\n                      // or limit, which registers an unordered observe. This is a\n                      // pretty rare case, so we just clone the entire result set with\n                      // no optimizations for documents that appear in these result\n                      // sets and other queries.\n                      if (query.results instanceof LocalCollection._IdMap) {\n                        qidToOriginalResults[qid] = query.results.clone();\n                        return;\n                      }\n\n                      if (!(query.results instanceof Array)) {\n                        throw new Error('Assertion failed: query.results not an array');\n                      } // Clones a document to be stored in `qidToOriginalResults`\n                      // because it may be modified before the new and old result sets\n                      // are diffed. But if we know exactly which document IDs we're\n                      // going to modify, then we only need to clone those.\n\n\n                      var memoizedCloneIfNeeded = function memoizedCloneIfNeeded(doc) {\n                        if (docMap.has(doc._id)) {\n                          return docMap.get(doc._id);\n                        }\n\n                        var docToMemoize = idsMatched && !idsMatched.some(function (id) {\n                          return EJSON.equals(id, doc._id);\n                        }) ? doc : EJSON.clone(doc);\n                        docMap.set(doc._id, docToMemoize);\n                        return docToMemoize;\n                      };\n\n                      qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n                    }\n                  });\n                  var recomputeQids = {};\n                  var updateCount = 0;\n\n                  this._eachPossiblyMatchingDoc(selector, function (doc, id) {\n                    var queryResult = matcher.documentMatches(doc);\n\n                    if (queryResult.result) {\n                      // XXX Should we save the original even if mod ends up being a no-op?\n                      _this11._saveOriginal(id, doc);\n\n                      _this11._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndices);\n\n                      ++updateCount;\n\n                      if (!options.multi) {\n                        return false; // break\n                      }\n                    }\n\n                    return true;\n                  });\n\n                  Object.keys(recomputeQids).forEach(function (qid) {\n                    var query = _this11.queries[qid];\n\n                    if (query) {\n                      _this11._recomputeResults(query, qidToOriginalResults[qid]);\n                    }\n                  });\n\n                  this._observeQueue.drain(); // If we are doing an upsert, and we didn't modify any documents yet, then\n                  // it's time to do an insert. Figure out what document we are inserting, and\n                  // generate an id for it.\n\n\n                  var insertedId;\n\n                  if (updateCount === 0 && options.upsert) {\n                    var _doc = LocalCollection._createUpsertDocument(selector, mod);\n\n                    if (!_doc._id && options.insertedId) {\n                      _doc._id = options.insertedId;\n                    }\n\n                    insertedId = this.insert(_doc);\n                    updateCount = 1;\n                  } // Return the number of affected documents, or in the upsert case, an object\n                  // containing the number of affected docs and the id of the doc that was\n                  // inserted, if any.\n\n\n                  var result;\n\n                  if (options._returnObject) {\n                    result = {\n                      numberAffected: updateCount\n                    };\n\n                    if (insertedId !== undefined) {\n                      result.insertedId = insertedId;\n                    }\n                  } else {\n                    result = updateCount;\n                  }\n\n                  if (callback) {\n                    Meteor.defer(function () {\n                      callback(null, result);\n                    });\n                  }\n\n                  return result;\n                } // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n                // equivalent to LocalCollection.update(sel, mod, {upsert: true,\n                // _returnObject: true}).\n\n              }, {\n                key: \"upsert\",\n                value: function upsert(selector, mod, options, callback) {\n                  if (!callback && typeof options === 'function') {\n                    callback = options;\n                    options = {};\n                  }\n\n                  return this.update(selector, mod, Object.assign({}, options, {\n                    upsert: true,\n                    _returnObject: true\n                  }), callback);\n                } // Iterates over a subset of documents that could match selector; calls\n                // fn(doc, id) on each of them.  Specifically, if selector specifies\n                // specific _id's, it only looks at those.  doc is *not* cloned: it is the\n                // same object that is in _docs.\n\n              }, {\n                key: \"_eachPossiblyMatchingDoc\",\n                value: function _eachPossiblyMatchingDoc(selector, fn) {\n                  var _this12 = this;\n\n                  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n                  if (specificIds) {\n                    specificIds.some(function (id) {\n                      var doc = _this12._docs.get(id);\n\n                      if (doc) {\n                        return fn(doc, id) === false;\n                      }\n                    });\n                  } else {\n                    this._docs.forEach(fn);\n                  }\n                }\n              }, {\n                key: \"_modifyAndNotify\",\n                value: function _modifyAndNotify(doc, mod, recomputeQids, arrayIndices) {\n                  var _this13 = this;\n\n                  var matched_before = {};\n                  Object.keys(this.queries).forEach(function (qid) {\n                    var query = _this13.queries[qid];\n\n                    if (query.dirty) {\n                      return;\n                    }\n\n                    if (query.ordered) {\n                      matched_before[qid] = query.matcher.documentMatches(doc).result;\n                    } else {\n                      // Because we don't support skip or limit (yet) in unordered queries, we\n                      // can just do a direct lookup.\n                      matched_before[qid] = query.results.has(doc._id);\n                    }\n                  });\n                  var old_doc = EJSON.clone(doc);\n\n                  LocalCollection._modify(doc, mod, {\n                    arrayIndices: arrayIndices\n                  });\n\n                  Object.keys(this.queries).forEach(function (qid) {\n                    var query = _this13.queries[qid];\n\n                    if (query.dirty) {\n                      return;\n                    }\n\n                    var afterMatch = query.matcher.documentMatches(doc);\n                    var after = afterMatch.result;\n                    var before = matched_before[qid];\n\n                    if (after && query.distances && afterMatch.distance !== undefined) {\n                      query.distances.set(doc._id, afterMatch.distance);\n                    }\n\n                    if (query.cursor.skip || query.cursor.limit) {\n                      // We need to recompute any query where the doc may have been in the\n                      // cursor's window either before or after the update. (Note that if skip\n                      // or limit is set, \"before\" and \"after\" being true do not necessarily\n                      // mean that the document is in the cursor's output after skip/limit is\n                      // applied... but if they are false, then the document definitely is NOT\n                      // in the output. So it's safe to skip recompute if neither before or\n                      // after are true.)\n                      if (before || after) {\n                        recomputeQids[qid] = true;\n                      }\n                    } else if (before && !after) {\n                      LocalCollection._removeFromResults(query, doc);\n                    } else if (!before && after) {\n                      LocalCollection._insertInResults(query, doc);\n                    } else if (before && after) {\n                      LocalCollection._updateInResults(query, doc, old_doc);\n                    }\n                  });\n                } // Recomputes the results of a query and runs observe callbacks for the\n                // difference between the previous results and the current results (unless\n                // paused). Used for skip/limit queries.\n                //\n                // When this is used by insert or remove, it can just use query.results for\n                // the old results (and there's no need to pass in oldResults), because these\n                // operations don't mutate the documents in the collection. Update needs to\n                // pass in an oldResults which was deep-copied before the modifier was\n                // applied.\n                //\n                // oldResults is guaranteed to be ignored if the query is not paused.\n\n              }, {\n                key: \"_recomputeResults\",\n                value: function _recomputeResults(query, oldResults) {\n                  if (this.paused) {\n                    // There's no reason to recompute the results now as we're still paused.\n                    // By flagging the query as \"dirty\", the recompute will be performed\n                    // when resumeObservers is called.\n                    query.dirty = true;\n                    return;\n                  }\n\n                  if (!this.paused && !oldResults) {\n                    oldResults = query.results;\n                  }\n\n                  if (query.distances) {\n                    query.distances.clear();\n                  }\n\n                  query.results = query.cursor._getRawObjects({\n                    distances: query.distances,\n                    ordered: query.ordered\n                  });\n\n                  if (!this.paused) {\n                    LocalCollection._diffQueryChanges(query.ordered, oldResults, query.results, query, {\n                      projectionFn: query.projectionFn\n                    });\n                  }\n                }\n              }, {\n                key: \"_saveOriginal\",\n                value: function _saveOriginal(id, doc) {\n                  // Are we even trying to save originals?\n                  if (!this._savedOriginals) {\n                    return;\n                  } // Have we previously mutated the original (and so 'doc' is not actually\n                  // original)?  (Note the 'has' check rather than truth: we store undefined\n                  // here for inserted docs!)\n\n\n                  if (this._savedOriginals.has(id)) {\n                    return;\n                  }\n\n                  this._savedOriginals.set(id, EJSON.clone(doc));\n                }\n              }]);\n\n              return LocalCollection;\n            }();\n\n            LocalCollection.Cursor = Cursor;\n            LocalCollection.ObserveHandle = ObserveHandle; // XXX maybe move these into another ObserveHelpers package or something\n            // _CachingChangeObserver is an object which receives observeChanges callbacks\n            // and keeps a cache of the current cursor state up to date in this.docs. Users\n            // of this class should read the docs field but not modify it. You should pass\n            // the \"applyChange\" field as the callbacks to the underlying observeChanges\n            // call. Optionally, you can specify your own observeChanges callbacks which are\n            // invoked immediately before the docs field is updated; this object is made\n            // available as `this` to those callbacks.\n\n            LocalCollection._CachingChangeObserver = function _CachingChangeObserver() {\n              var _this14 = this;\n\n              _classCallCheck(this, _CachingChangeObserver);\n\n              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n              var orderedFromCallbacks = options.callbacks && LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);\n\n              if (_hasOwn3.call(options, 'ordered')) {\n                this.ordered = options.ordered;\n\n                if (options.callbacks && options.ordered !== orderedFromCallbacks) {\n                  throw Error('ordered option doesn\\'t match callbacks');\n                }\n              } else if (options.callbacks) {\n                this.ordered = orderedFromCallbacks;\n              } else {\n                throw Error('must provide ordered or callbacks');\n              }\n\n              var callbacks = options.callbacks || {};\n\n              if (this.ordered) {\n                this.docs = new OrderedDict(MongoID.idStringify);\n                this.applyChange = {\n                  addedBefore: function addedBefore(id, fields, before) {\n                    var doc = EJSON.clone(fields);\n                    doc._id = id;\n\n                    if (callbacks.addedBefore) {\n                      callbacks.addedBefore.call(_this14, id, fields, before);\n                    } // This line triggers if we provide added with movedBefore.\n\n\n                    if (callbacks.added) {\n                      callbacks.added.call(_this14, id, fields);\n                    } // XXX could `before` be a falsy ID?  Technically\n                    // idStringify seems to allow for them -- though\n                    // OrderedDict won't call stringify on a falsy arg.\n\n\n                    _this14.docs.putBefore(id, doc, before || null);\n                  },\n                  movedBefore: function movedBefore(id, before) {\n                    var doc = _this14.docs.get(id);\n\n                    if (callbacks.movedBefore) {\n                      callbacks.movedBefore.call(_this14, id, before);\n                    }\n\n                    _this14.docs.moveBefore(id, before || null);\n                  }\n                };\n              } else {\n                this.docs = new LocalCollection._IdMap();\n                this.applyChange = {\n                  added: function added(id, fields) {\n                    var doc = EJSON.clone(fields);\n\n                    if (callbacks.added) {\n                      callbacks.added.call(_this14, id, fields);\n                    }\n\n                    doc._id = id;\n\n                    _this14.docs.set(id, doc);\n                  }\n                };\n              } // The methods in _IdMap and OrderedDict used by these callbacks are\n              // identical.\n\n\n              this.applyChange.changed = function (id, fields) {\n                var doc = _this14.docs.get(id);\n\n                if (!doc) {\n                  throw new Error(\"Unknown id for changed: \".concat(id));\n                }\n\n                if (callbacks.changed) {\n                  callbacks.changed.call(_this14, id, EJSON.clone(fields));\n                }\n\n                DiffSequence.applyChanges(doc, fields);\n              };\n\n              this.applyChange.removed = function (id) {\n                if (callbacks.removed) {\n                  callbacks.removed.call(_this14, id);\n                }\n\n                _this14.docs.remove(id);\n              };\n            };\n\n            LocalCollection._IdMap =\n            /*#__PURE__*/\n            function (_IdMap2) {\n              _inherits(_IdMap, _IdMap2);\n\n              function _IdMap() {\n                _classCallCheck(this, _IdMap);\n\n                return _possibleConstructorReturn(this, _getPrototypeOf(_IdMap).call(this, MongoID.idStringify, MongoID.idParse));\n              }\n\n              return _IdMap;\n            }(IdMap); // Wrap a transform function to return objects that have the _id field\n            // of the untransformed document. This ensures that subsystems such as\n            // the observe-sequence package that call `observe` can keep track of\n            // the documents identities.\n            //\n            // - Require that it returns objects\n            // - If the return value has an _id field, verify that it matches the\n            //   original _id field\n            // - If the return value doesn't have an _id field, add it back.\n\n\n            LocalCollection.wrapTransform = function (transform) {\n              if (!transform) {\n                return null;\n              } // No need to doubly-wrap transforms.\n\n\n              if (transform.__wrappedTransform__) {\n                return transform;\n              }\n\n              var wrapped = function wrapped(doc) {\n                if (!_hasOwn3.call(doc, '_id')) {\n                  // XXX do we ever have a transform on the oplog's collection? because that\n                  // collection has no _id.\n                  throw new Error('can only transform documents with _id');\n                }\n\n                var id = doc._id; // XXX consider making tracker a weak dependency and checking\n                // Package.tracker here\n\n                var transformed = Tracker.nonreactive(function () {\n                  return transform(doc);\n                });\n\n                if (!LocalCollection._isPlainObject(transformed)) {\n                  throw new Error('transform must return object');\n                }\n\n                if (_hasOwn3.call(transformed, '_id')) {\n                  if (!EJSON.equals(transformed._id, id)) {\n                    throw new Error('transformed document can\\'t have different _id');\n                  }\n                } else {\n                  transformed._id = id;\n                }\n\n                return transformed;\n              };\n\n              wrapped.__wrappedTransform__ = true;\n              return wrapped;\n            }; // XXX the sorted-query logic below is laughably inefficient. we'll\n            // need to come up with a better datastructure for this.\n            //\n            // XXX the logic for observing with a skip or a limit is even more\n            // laughably inefficient. we recompute the whole results every time!\n            // This binary search puts a value between any equal values, and the first\n            // lesser value.\n\n\n            LocalCollection._binarySearch = function (cmp, array, value) {\n              var first = 0;\n              var range = array.length;\n\n              while (range > 0) {\n                var halfRange = Math.floor(range / 2);\n\n                if (cmp(value, array[first + halfRange]) >= 0) {\n                  first += halfRange + 1;\n                  range -= halfRange + 1;\n                } else {\n                  range = halfRange;\n                }\n              }\n\n              return first;\n            };\n\n            LocalCollection._checkSupportedProjection = function (fields) {\n              if (fields !== Object(fields) || Array.isArray(fields)) {\n                throw MinimongoError('fields option must be an object');\n              }\n\n              Object.keys(fields).forEach(function (keyPath) {\n                if (keyPath.split('.').includes('$')) {\n                  throw MinimongoError('Minimongo doesn\\'t support $ operator in projections yet.');\n                }\n\n                var value = fields[keyPath];\n\n                if (_typeof(value) === 'object' && ['$elemMatch', '$meta', '$slice'].some(function (key) {\n                  return _hasOwn3.call(value, key);\n                })) {\n                  throw MinimongoError('Minimongo doesn\\'t support operators in projections yet.');\n                }\n\n                if (![1, 0, true, false].includes(value)) {\n                  throw MinimongoError('Projection values should be one of 1, 0, true, or false');\n                }\n              });\n            }; // Knows how to compile a fields projection to a predicate function.\n            // @returns - Function: a closure that filters out an object according to the\n            //            fields projection rules:\n            //            @param obj - Object: MongoDB-styled document\n            //            @returns - Object: a document with the fields filtered out\n            //                       according to projection rules. Doesn't retain subfields\n            //                       of passed argument.\n\n\n            LocalCollection._compileProjection = function (fields) {\n              LocalCollection._checkSupportedProjection(fields);\n\n              var _idProjection = fields._id === undefined ? true : fields._id;\n\n              var details = _projectionDetails2(fields); // returns transformed doc according to ruleTree\n\n\n              var transform = function transform(doc, ruleTree) {\n                // Special case for \"sets\"\n                if (Array.isArray(doc)) {\n                  return doc.map(function (subdoc) {\n                    return transform(subdoc, ruleTree);\n                  });\n                }\n\n                var result = details.including ? {} : EJSON.clone(doc);\n                Object.keys(ruleTree).forEach(function (key) {\n                  if (!_hasOwn3.call(doc, key)) {\n                    return;\n                  }\n\n                  var rule = ruleTree[key];\n\n                  if (rule === Object(rule)) {\n                    // For sub-objects/subsets we branch\n                    if (doc[key] === Object(doc[key])) {\n                      result[key] = transform(doc[key], rule);\n                    }\n                  } else if (details.including) {\n                    // Otherwise we don't even touch this subfield\n                    result[key] = EJSON.clone(doc[key]);\n                  } else {\n                    delete result[key];\n                  }\n                });\n                return result;\n              };\n\n              return function (doc) {\n                var result = transform(doc, details.tree);\n\n                if (_idProjection && _hasOwn3.call(doc, '_id')) {\n                  result._id = doc._id;\n                }\n\n                if (!_idProjection && _hasOwn3.call(result, '_id')) {\n                  delete result._id;\n                }\n\n                return result;\n              };\n            }; // Calculates the document to insert in case we're doing an upsert and the\n            // selector does not match any elements\n\n\n            LocalCollection._createUpsertDocument = function (selector, modifier) {\n              var selectorDocument = _populateDocumentWithQueryFields2(selector);\n\n              var isModify = LocalCollection._isModificationMod(modifier);\n\n              var newDoc = {};\n\n              if (selectorDocument._id) {\n                newDoc._id = selectorDocument._id;\n                delete selectorDocument._id;\n              } // This double _modify call is made to help with nested properties (see issue\n              // #8631). We do this even if it's a replacement for validation purposes (e.g.\n              // ambiguous id's)\n\n\n              LocalCollection._modify(newDoc, {\n                $set: selectorDocument\n              });\n\n              LocalCollection._modify(newDoc, modifier, {\n                isInsert: true\n              });\n\n              if (isModify) {\n                return newDoc;\n              } // Replacement can take _id from query document\n\n\n              var replacement = Object.assign({}, modifier);\n\n              if (newDoc._id) {\n                replacement._id = newDoc._id;\n              }\n\n              return replacement;\n            };\n\n            LocalCollection._diffObjects = function (left, right, callbacks) {\n              return DiffSequence.diffObjects(left, right, callbacks);\n            }; // ordered: bool.\n            // old_results and new_results: collections of documents.\n            //    if ordered, they are arrays.\n            //    if unordered, they are IdMaps\n\n\n            LocalCollection._diffQueryChanges = function (ordered, oldResults, newResults, observer, options) {\n              return DiffSequence.diffQueryChanges(ordered, oldResults, newResults, observer, options);\n            };\n\n            LocalCollection._diffQueryOrderedChanges = function (oldResults, newResults, observer, options) {\n              return DiffSequence.diffQueryOrderedChanges(oldResults, newResults, observer, options);\n            };\n\n            LocalCollection._diffQueryUnorderedChanges = function (oldResults, newResults, observer, options) {\n              return DiffSequence.diffQueryUnorderedChanges(oldResults, newResults, observer, options);\n            };\n\n            LocalCollection._findInOrderedResults = function (query, doc) {\n              if (!query.ordered) {\n                throw new Error('Can\\'t call _findInOrderedResults on unordered query');\n              }\n\n              for (var i = 0; i < query.results.length; i++) {\n                if (query.results[i] === doc) {\n                  return i;\n                }\n              }\n\n              throw Error('object missing from query');\n            }; // If this is a selector which explicitly constrains the match by ID to a finite\n            // number of documents, returns a list of their IDs.  Otherwise returns\n            // null. Note that the selector may have other restrictions so it may not even\n            // match those document!  We care about $in and $and since those are generated\n            // access-controlled update and remove.\n\n\n            LocalCollection._idsMatchedBySelector = function (selector) {\n              // Is the selector just an ID?\n              if (LocalCollection._selectorIsId(selector)) {\n                return [selector];\n              }\n\n              if (!selector) {\n                return null;\n              } // Do we have an _id clause?\n\n\n              if (_hasOwn3.call(selector, '_id')) {\n                // Is the _id clause just an ID?\n                if (LocalCollection._selectorIsId(selector._id)) {\n                  return [selector._id];\n                } // Is the _id clause {_id: {$in: [\"x\", \"y\", \"z\"]}}?\n\n\n                if (selector._id && Array.isArray(selector._id.$in) && selector._id.$in.length && selector._id.$in.every(LocalCollection._selectorIsId)) {\n                  return selector._id.$in;\n                }\n\n                return null;\n              } // If this is a top-level $and, and any of the clauses constrain their\n              // documents, then the whole selector is constrained by any one clause's\n              // constraint. (Well, by their intersection, but that seems unlikely.)\n\n\n              if (Array.isArray(selector.$and)) {\n                for (var i = 0; i < selector.$and.length; ++i) {\n                  var subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);\n\n                  if (subIds) {\n                    return subIds;\n                  }\n                }\n              }\n\n              return null;\n            };\n\n            LocalCollection._insertInResults = function (query, doc) {\n              var fields = EJSON.clone(doc);\n              delete fields._id;\n\n              if (query.ordered) {\n                if (!query.sorter) {\n                  query.addedBefore(doc._id, query.projectionFn(fields), null);\n                  query.results.push(doc);\n                } else {\n                  var i = LocalCollection._insertInSortedList(query.sorter.getComparator({\n                    distances: query.distances\n                  }), query.results, doc);\n\n                  var next = query.results[i + 1];\n\n                  if (next) {\n                    next = next._id;\n                  } else {\n                    next = null;\n                  }\n\n                  query.addedBefore(doc._id, query.projectionFn(fields), next);\n                }\n\n                query.added(doc._id, query.projectionFn(fields));\n              } else {\n                query.added(doc._id, query.projectionFn(fields));\n                query.results.set(doc._id, doc);\n              }\n            };\n\n            LocalCollection._insertInSortedList = function (cmp, array, value) {\n              if (array.length === 0) {\n                array.push(value);\n                return 0;\n              }\n\n              var i = LocalCollection._binarySearch(cmp, array, value);\n\n              array.splice(i, 0, value);\n              return i;\n            };\n\n            LocalCollection._isModificationMod = function (mod) {\n              var isModify = false;\n              var isReplace = false;\n              Object.keys(mod).forEach(function (key) {\n                if (key.substr(0, 1) === '$') {\n                  isModify = true;\n                } else {\n                  isReplace = true;\n                }\n              });\n\n              if (isModify && isReplace) {\n                throw new Error('Update parameter cannot have both modifier and non-modifier fields.');\n              }\n\n              return isModify;\n            }; // XXX maybe this should be EJSON.isObject, though EJSON doesn't know about\n            // RegExp\n            // XXX note that _type(undefined) === 3!!!!\n\n\n            LocalCollection._isPlainObject = function (x) {\n              return x && LocalCollection._f._type(x) === 3;\n            }; // XXX need a strategy for passing the binding of $ into this\n            // function, from the compiled selector\n            //\n            // maybe just {key.up.to.just.before.dollarsign: array_index}\n            //\n            // XXX atomicity: if one modification fails, do we roll back the whole\n            // change?\n            //\n            // options:\n            //   - isInsert is set when _modify is being called to compute the document to\n            //     insert as part of an upsert operation. We use this primarily to figure\n            //     out when to set the fields in $setOnInsert, if present.\n\n\n            LocalCollection._modify = function (doc, modifier) {\n              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n              if (!LocalCollection._isPlainObject(modifier)) {\n                throw MinimongoError('Modifier must be an object');\n              } // Make sure the caller can't mutate our data structures.\n\n\n              modifier = EJSON.clone(modifier);\n\n              var isModifier = _isOperatorObject2(modifier);\n\n              var newDoc = isModifier ? EJSON.clone(doc) : modifier;\n\n              if (isModifier) {\n                // apply modifiers to the doc.\n                Object.keys(modifier).forEach(function (operator) {\n                  // Treat $setOnInsert as $set if this is an insert.\n                  var setOnInsert = options.isInsert && operator === '$setOnInsert';\n                  var modFunc = MODIFIERS[setOnInsert ? '$set' : operator];\n                  var operand = modifier[operator];\n\n                  if (!modFunc) {\n                    throw MinimongoError(\"Invalid modifier specified \".concat(operator));\n                  }\n\n                  Object.keys(operand).forEach(function (keypath) {\n                    var arg = operand[keypath];\n\n                    if (keypath === '') {\n                      throw MinimongoError('An empty update path is not valid.');\n                    }\n\n                    var keyparts = keypath.split('.');\n\n                    if (!keyparts.every(Boolean)) {\n                      throw MinimongoError(\"The update path '\".concat(keypath, \"' contains an empty field name, \") + 'which is not allowed.');\n                    }\n\n                    var target = findModTarget(newDoc, keyparts, {\n                      arrayIndices: options.arrayIndices,\n                      forbidArray: operator === '$rename',\n                      noCreate: NO_CREATE_MODIFIERS[operator]\n                    });\n                    modFunc(target, keyparts.pop(), arg, keypath, newDoc);\n                  });\n                });\n\n                if (doc._id && !EJSON.equals(doc._id, newDoc._id)) {\n                  throw MinimongoError(\"After applying the update to the document {_id: \\\"\".concat(doc._id, \"\\\", ...},\") + ' the (immutable) field \\'_id\\' was found to have been altered to ' + \"_id: \\\"\".concat(newDoc._id, \"\\\"\"));\n                }\n              } else {\n                if (doc._id && modifier._id && !EJSON.equals(doc._id, modifier._id)) {\n                  throw MinimongoError(\"The _id field cannot be changed from {_id: \\\"\".concat(doc._id, \"\\\"} to \") + \"{_id: \\\"\".concat(modifier._id, \"\\\"}\"));\n                } // replace the whole document\n\n\n                assertHasValidFieldNames(modifier);\n              } // move new document into place.\n\n\n              Object.keys(doc).forEach(function (key) {\n                // Note: this used to be for (var key in doc) however, this does not\n                // work right in Opera. Deleting from a doc while iterating over it\n                // would sometimes cause opera to skip some keys.\n                if (key !== '_id') {\n                  delete doc[key];\n                }\n              });\n              Object.keys(newDoc).forEach(function (key) {\n                doc[key] = newDoc[key];\n              });\n            };\n\n            LocalCollection._observeFromObserveChanges = function (cursor, observeCallbacks) {\n              var transform = cursor.getTransform() || function (doc) {\n                return doc;\n              };\n\n              var suppressed = !!observeCallbacks._suppress_initial;\n              var observeChangesCallbacks;\n\n              if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n                // The \"_no_indices\" option sets all index arguments to -1 and skips the\n                // linear scans required to generate them.  This lets observers that don't\n                // need absolute indices benefit from the other features of this API --\n                // relative order, transforms, and applyChanges -- without the speed hit.\n                var indices = !observeCallbacks._no_indices;\n                observeChangesCallbacks = {\n                  addedBefore: function addedBefore(id, fields, before) {\n                    if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added)) {\n                      return;\n                    }\n\n                    var doc = transform(Object.assign(fields, {\n                      _id: id\n                    }));\n\n                    if (observeCallbacks.addedAt) {\n                      observeCallbacks.addedAt(doc, indices ? before ? this.docs.indexOf(before) : this.docs.size() : -1, before);\n                    } else {\n                      observeCallbacks.added(doc);\n                    }\n                  },\n                  changed: function changed(id, fields) {\n                    if (!(observeCallbacks.changedAt || observeCallbacks.changed)) {\n                      return;\n                    }\n\n                    var doc = EJSON.clone(this.docs.get(id));\n\n                    if (!doc) {\n                      throw new Error(\"Unknown id for changed: \".concat(id));\n                    }\n\n                    var oldDoc = transform(EJSON.clone(doc));\n                    DiffSequence.applyChanges(doc, fields);\n\n                    if (observeCallbacks.changedAt) {\n                      observeCallbacks.changedAt(transform(doc), oldDoc, indices ? this.docs.indexOf(id) : -1);\n                    } else {\n                      observeCallbacks.changed(transform(doc), oldDoc);\n                    }\n                  },\n                  movedBefore: function movedBefore(id, before) {\n                    if (!observeCallbacks.movedTo) {\n                      return;\n                    }\n\n                    var from = indices ? this.docs.indexOf(id) : -1;\n                    var to = indices ? before ? this.docs.indexOf(before) : this.docs.size() : -1; // When not moving backwards, adjust for the fact that removing the\n                    // document slides everything back one slot.\n\n                    if (to > from) {\n                      --to;\n                    }\n\n                    observeCallbacks.movedTo(transform(EJSON.clone(this.docs.get(id))), from, to, before || null);\n                  },\n                  removed: function removed(id) {\n                    if (!(observeCallbacks.removedAt || observeCallbacks.removed)) {\n                      return;\n                    } // technically maybe there should be an EJSON.clone here, but it's about\n                    // to be removed from this.docs!\n\n\n                    var doc = transform(this.docs.get(id));\n\n                    if (observeCallbacks.removedAt) {\n                      observeCallbacks.removedAt(doc, indices ? this.docs.indexOf(id) : -1);\n                    } else {\n                      observeCallbacks.removed(doc);\n                    }\n                  }\n                };\n              } else {\n                observeChangesCallbacks = {\n                  added: function added(id, fields) {\n                    if (!suppressed && observeCallbacks.added) {\n                      observeCallbacks.added(transform(Object.assign(fields, {\n                        _id: id\n                      })));\n                    }\n                  },\n                  changed: function changed(id, fields) {\n                    if (observeCallbacks.changed) {\n                      var oldDoc = this.docs.get(id);\n\n                      var _doc2 = EJSON.clone(oldDoc);\n\n                      DiffSequence.applyChanges(_doc2, fields);\n                      observeCallbacks.changed(transform(_doc2), transform(EJSON.clone(oldDoc)));\n                    }\n                  },\n                  removed: function removed(id) {\n                    if (observeCallbacks.removed) {\n                      observeCallbacks.removed(transform(this.docs.get(id)));\n                    }\n                  }\n                };\n              }\n\n              var changeObserver = new LocalCollection._CachingChangeObserver({\n                callbacks: observeChangesCallbacks\n              });\n              var handle = cursor.observeChanges(changeObserver.applyChange);\n              suppressed = false;\n              return handle;\n            };\n\n            LocalCollection._observeCallbacksAreOrdered = function (callbacks) {\n              if (callbacks.added && callbacks.addedAt) {\n                throw new Error('Please specify only one of added() and addedAt()');\n              }\n\n              if (callbacks.changed && callbacks.changedAt) {\n                throw new Error('Please specify only one of changed() and changedAt()');\n              }\n\n              if (callbacks.removed && callbacks.removedAt) {\n                throw new Error('Please specify only one of removed() and removedAt()');\n              }\n\n              return !!(callbacks.addedAt || callbacks.changedAt || callbacks.movedTo || callbacks.removedAt);\n            };\n\n            LocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {\n              if (callbacks.added && callbacks.addedBefore) {\n                throw new Error('Please specify only one of added() and addedBefore()');\n              }\n\n              return !!(callbacks.addedBefore || callbacks.movedBefore);\n            };\n\n            LocalCollection._removeFromResults = function (query, doc) {\n              if (query.ordered) {\n                var i = LocalCollection._findInOrderedResults(query, doc);\n\n                query.removed(doc._id);\n                query.results.splice(i, 1);\n              } else {\n                var id = doc._id; // in case callback mutates doc\n\n                query.removed(doc._id);\n                query.results.remove(id);\n              }\n            }; // Is this selector just shorthand for lookup by _id?\n\n\n            LocalCollection._selectorIsId = function (selector) {\n              return typeof selector === 'number' || typeof selector === 'string' || selector instanceof MongoID.ObjectID;\n            }; // Is the selector just lookup by _id (shorthand or not)?\n\n\n            LocalCollection._selectorIsIdPerhapsAsObject = function (selector) {\n              return LocalCollection._selectorIsId(selector) || LocalCollection._selectorIsId(selector && selector._id) && Object.keys(selector).length === 1;\n            };\n\n            LocalCollection._updateInResults = function (query, doc, old_doc) {\n              if (!EJSON.equals(doc._id, old_doc._id)) {\n                throw new Error('Can\\'t change a doc\\'s _id while updating');\n              }\n\n              var projectionFn = query.projectionFn;\n              var changedFields = DiffSequence.makeChangedFields(projectionFn(doc), projectionFn(old_doc));\n\n              if (!query.ordered) {\n                if (Object.keys(changedFields).length) {\n                  query.changed(doc._id, changedFields);\n                  query.results.set(doc._id, doc);\n                }\n\n                return;\n              }\n\n              var old_idx = LocalCollection._findInOrderedResults(query, doc);\n\n              if (Object.keys(changedFields).length) {\n                query.changed(doc._id, changedFields);\n              }\n\n              if (!query.sorter) {\n                return;\n              } // just take it out and put it back in again, and see if the index changes\n\n\n              query.results.splice(old_idx, 1);\n\n              var new_idx = LocalCollection._insertInSortedList(query.sorter.getComparator({\n                distances: query.distances\n              }), query.results, doc);\n\n              if (old_idx !== new_idx) {\n                var next = query.results[new_idx + 1];\n\n                if (next) {\n                  next = next._id;\n                } else {\n                  next = null;\n                }\n\n                query.movedBefore && query.movedBefore(doc._id, next);\n              }\n            };\n\n            var MODIFIERS = {\n              $currentDate: function $currentDate(target, field, arg) {\n                if (_typeof(arg) === 'object' && _hasOwn3.call(arg, '$type')) {\n                  if (arg.$type !== 'date') {\n                    throw MinimongoError('Minimongo does currently only support the date type in ' + '$currentDate modifiers', {\n                      field: field\n                    });\n                  }\n                } else if (arg !== true) {\n                  throw MinimongoError('Invalid $currentDate modifier', {\n                    field: field\n                  });\n                }\n\n                target[field] = new Date();\n              },\n              $min: function $min(target, field, arg) {\n                if (typeof arg !== 'number') {\n                  throw MinimongoError('Modifier $min allowed for numbers only', {\n                    field: field\n                  });\n                }\n\n                if (field in target) {\n                  if (typeof target[field] !== 'number') {\n                    throw MinimongoError('Cannot apply $min modifier to non-number', {\n                      field: field\n                    });\n                  }\n\n                  if (target[field] > arg) {\n                    target[field] = arg;\n                  }\n                } else {\n                  target[field] = arg;\n                }\n              },\n              $max: function $max(target, field, arg) {\n                if (typeof arg !== 'number') {\n                  throw MinimongoError('Modifier $max allowed for numbers only', {\n                    field: field\n                  });\n                }\n\n                if (field in target) {\n                  if (typeof target[field] !== 'number') {\n                    throw MinimongoError('Cannot apply $max modifier to non-number', {\n                      field: field\n                    });\n                  }\n\n                  if (target[field] < arg) {\n                    target[field] = arg;\n                  }\n                } else {\n                  target[field] = arg;\n                }\n              },\n              $inc: function $inc(target, field, arg) {\n                if (typeof arg !== 'number') {\n                  throw MinimongoError('Modifier $inc allowed for numbers only', {\n                    field: field\n                  });\n                }\n\n                if (field in target) {\n                  if (typeof target[field] !== 'number') {\n                    throw MinimongoError('Cannot apply $inc modifier to non-number', {\n                      field: field\n                    });\n                  }\n\n                  target[field] += arg;\n                } else {\n                  target[field] = arg;\n                }\n              },\n              $set: function $set(target, field, arg) {\n                if (target !== Object(target)) {\n                  // not an array or an object\n                  var error = MinimongoError('Cannot set property on non-object field', {\n                    field: field\n                  });\n                  error.setPropertyError = true;\n                  throw error;\n                }\n\n                if (target === null) {\n                  var _error = MinimongoError('Cannot set property on null', {\n                    field: field\n                  });\n\n                  _error.setPropertyError = true;\n                  throw _error;\n                }\n\n                assertHasValidFieldNames(arg);\n                target[field] = arg;\n              },\n              $setOnInsert: function $setOnInsert(target, field, arg) {// converted to `$set` in `_modify`\n              },\n              $unset: function $unset(target, field, arg) {\n                if (target !== undefined) {\n                  if (target instanceof Array) {\n                    if (field in target) {\n                      target[field] = null;\n                    }\n                  } else {\n                    delete target[field];\n                  }\n                }\n              },\n              $push: function $push(target, field, arg) {\n                if (target[field] === undefined) {\n                  target[field] = [];\n                }\n\n                if (!(target[field] instanceof Array)) {\n                  throw MinimongoError('Cannot apply $push modifier to non-array', {\n                    field: field\n                  });\n                }\n\n                if (!(arg && arg.$each)) {\n                  // Simple mode: not $each\n                  assertHasValidFieldNames(arg);\n                  target[field].push(arg);\n                  return;\n                } // Fancy mode: $each (and maybe $slice and $sort and $position)\n\n\n                var toPush = arg.$each;\n\n                if (!(toPush instanceof Array)) {\n                  throw MinimongoError('$each must be an array', {\n                    field: field\n                  });\n                }\n\n                assertHasValidFieldNames(toPush); // Parse $position\n\n                var position = undefined;\n\n                if ('$position' in arg) {\n                  if (typeof arg.$position !== 'number') {\n                    throw MinimongoError('$position must be a numeric value', {\n                      field: field\n                    });\n                  } // XXX should check to make sure integer\n\n\n                  if (arg.$position < 0) {\n                    throw MinimongoError('$position in $push must be zero or positive', {\n                      field: field\n                    });\n                  }\n\n                  position = arg.$position;\n                } // Parse $slice.\n\n\n                var slice = undefined;\n\n                if ('$slice' in arg) {\n                  if (typeof arg.$slice !== 'number') {\n                    throw MinimongoError('$slice must be a numeric value', {\n                      field: field\n                    });\n                  } // XXX should check to make sure integer\n\n\n                  slice = arg.$slice;\n                } // Parse $sort.\n\n\n                var sortFunction = undefined;\n\n                if (arg.$sort) {\n                  if (slice === undefined) {\n                    throw MinimongoError('$sort requires $slice to be present', {\n                      field: field\n                    });\n                  } // XXX this allows us to use a $sort whose value is an array, but that's\n                  // actually an extension of the Node driver, so it won't work\n                  // server-side. Could be confusing!\n                  // XXX is it correct that we don't do geo-stuff here?\n\n\n                  sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n                  toPush.forEach(function (element) {\n                    if (LocalCollection._f._type(element) !== 3) {\n                      throw MinimongoError('$push like modifiers using $sort require all elements to be ' + 'objects', {\n                        field: field\n                      });\n                    }\n                  });\n                } // Actually push.\n\n\n                if (position === undefined) {\n                  toPush.forEach(function (element) {\n                    target[field].push(element);\n                  });\n                } else {\n                  var _target$field;\n\n                  var spliceArguments = [position, 0];\n                  toPush.forEach(function (element) {\n                    spliceArguments.push(element);\n                  });\n\n                  (_target$field = target[field]).splice.apply(_target$field, spliceArguments);\n                } // Actually sort.\n\n\n                if (sortFunction) {\n                  target[field].sort(sortFunction);\n                } // Actually slice.\n\n\n                if (slice !== undefined) {\n                  if (slice === 0) {\n                    target[field] = []; // differs from Array.slice!\n                  } else if (slice < 0) {\n                    target[field] = target[field].slice(slice);\n                  } else {\n                    target[field] = target[field].slice(0, slice);\n                  }\n                }\n              },\n              $pushAll: function $pushAll(target, field, arg) {\n                if (!(_typeof(arg) === 'object' && arg instanceof Array)) {\n                  throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only');\n                }\n\n                assertHasValidFieldNames(arg);\n                var toPush = target[field];\n\n                if (toPush === undefined) {\n                  target[field] = arg;\n                } else if (!(toPush instanceof Array)) {\n                  throw MinimongoError('Cannot apply $pushAll modifier to non-array', {\n                    field: field\n                  });\n                } else {\n                  toPush.push.apply(toPush, _toConsumableArray(arg));\n                }\n              },\n              $addToSet: function $addToSet(target, field, arg) {\n                var isEach = false;\n\n                if (_typeof(arg) === 'object') {\n                  // check if first key is '$each'\n                  var keys = Object.keys(arg);\n\n                  if (keys[0] === '$each') {\n                    isEach = true;\n                  }\n                }\n\n                var values = isEach ? arg.$each : [arg];\n                assertHasValidFieldNames(values);\n                var toAdd = target[field];\n\n                if (toAdd === undefined) {\n                  target[field] = values;\n                } else if (!(toAdd instanceof Array)) {\n                  throw MinimongoError('Cannot apply $addToSet modifier to non-array', {\n                    field: field\n                  });\n                } else {\n                  values.forEach(function (value) {\n                    if (toAdd.some(function (element) {\n                      return LocalCollection._f._equal(value, element);\n                    })) {\n                      return;\n                    }\n\n                    toAdd.push(value);\n                  });\n                }\n              },\n              $pop: function $pop(target, field, arg) {\n                if (target === undefined) {\n                  return;\n                }\n\n                var toPop = target[field];\n\n                if (toPop === undefined) {\n                  return;\n                }\n\n                if (!(toPop instanceof Array)) {\n                  throw MinimongoError('Cannot apply $pop modifier to non-array', {\n                    field: field\n                  });\n                }\n\n                if (typeof arg === 'number' && arg < 0) {\n                  toPop.splice(0, 1);\n                } else {\n                  toPop.pop();\n                }\n              },\n              $pull: function $pull(target, field, arg) {\n                if (target === undefined) {\n                  return;\n                }\n\n                var toPull = target[field];\n\n                if (toPull === undefined) {\n                  return;\n                }\n\n                if (!(toPull instanceof Array)) {\n                  throw MinimongoError('Cannot apply $pull/pullAll modifier to non-array', {\n                    field: field\n                  });\n                }\n\n                var out;\n\n                if (arg != null && _typeof(arg) === 'object' && !(arg instanceof Array)) {\n                  // XXX would be much nicer to compile this once, rather than\n                  // for each document we modify.. but usually we're not\n                  // modifying that many documents, so we'll let it slide for\n                  // now\n                  // XXX Minimongo.Matcher isn't up for the job, because we need\n                  // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n                  // like {$gt: 4} is not normally a complete selector.\n                  // same issue as $elemMatch possibly?\n                  var matcher = new Minimongo.Matcher(arg);\n                  out = toPull.filter(function (element) {\n                    return !matcher.documentMatches(element).result;\n                  });\n                } else {\n                  out = toPull.filter(function (element) {\n                    return !LocalCollection._f._equal(element, arg);\n                  });\n                }\n\n                target[field] = out;\n              },\n              $pullAll: function $pullAll(target, field, arg) {\n                if (!(_typeof(arg) === 'object' && arg instanceof Array)) {\n                  throw MinimongoError('Modifier $pushAll/pullAll allowed for arrays only', {\n                    field: field\n                  });\n                }\n\n                if (target === undefined) {\n                  return;\n                }\n\n                var toPull = target[field];\n\n                if (toPull === undefined) {\n                  return;\n                }\n\n                if (!(toPull instanceof Array)) {\n                  throw MinimongoError('Cannot apply $pull/pullAll modifier to non-array', {\n                    field: field\n                  });\n                }\n\n                target[field] = toPull.filter(function (object) {\n                  return !arg.some(function (element) {\n                    return LocalCollection._f._equal(object, element);\n                  });\n                });\n              },\n              $rename: function $rename(target, field, arg, keypath, doc) {\n                // no idea why mongo has this restriction..\n                if (keypath === arg) {\n                  throw MinimongoError('$rename source must differ from target', {\n                    field: field\n                  });\n                }\n\n                if (target === null) {\n                  throw MinimongoError('$rename source field invalid', {\n                    field: field\n                  });\n                }\n\n                if (typeof arg !== 'string') {\n                  throw MinimongoError('$rename target must be a string', {\n                    field: field\n                  });\n                }\n\n                if (arg.includes('\\0')) {\n                  // Null bytes are not allowed in Mongo field names\n                  // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n                  throw MinimongoError('The \\'to\\' field for $rename cannot contain an embedded null byte', {\n                    field: field\n                  });\n                }\n\n                if (target === undefined) {\n                  return;\n                }\n\n                var object = target[field];\n                delete target[field];\n                var keyparts = arg.split('.');\n                var target2 = findModTarget(doc, keyparts, {\n                  forbidArray: true\n                });\n\n                if (target2 === null) {\n                  throw MinimongoError('$rename target field invalid', {\n                    field: field\n                  });\n                }\n\n                target2[keyparts.pop()] = object;\n              },\n              $bit: function $bit(target, field, arg) {\n                // XXX mongo only supports $bit on integers, and we only support\n                // native javascript numbers (doubles) so far, so we can't support $bit\n                throw MinimongoError('$bit is not supported', {\n                  field: field\n                });\n              },\n              $v: function $v() {// As discussed in https://github.com/meteor/meteor/issues/9623,\n                // the `$v` operator is not needed by Meteor, but problems can occur if\n                // it's not at least callable (as of Mongo >= 3.6). It's defined here as\n                // a no-op to work around these problems.\n              }\n            };\n            var NO_CREATE_MODIFIERS = {\n              $pop: true,\n              $pull: true,\n              $pullAll: true,\n              $rename: true,\n              $unset: true\n            }; // Make sure field names do not contain Mongo restricted\n            // characters ('.', '$', '\\0').\n            // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n\n            var invalidCharMsg = {\n              $: 'start with \\'$\\'',\n              '.': 'contain \\'.\\'',\n              '\\0': 'contain null bytes'\n            }; // checks if all field names in an object are valid\n\n            function assertHasValidFieldNames(doc) {\n              if (doc && _typeof(doc) === 'object') {\n                JSON.stringify(doc, function (key, value) {\n                  assertIsValidFieldName(key);\n                  return value;\n                });\n              }\n            }\n\n            function assertIsValidFieldName(key) {\n              var match;\n\n              if (typeof key === 'string' && (match = key.match(/^\\$|\\.|\\0/))) {\n                throw MinimongoError(\"Key \".concat(key, \" must not \").concat(invalidCharMsg[match[0]]));\n              }\n            } // for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n            // and then you would operate on the 'e' property of the returned\n            // object.\n            //\n            // if options.noCreate is falsey, creates intermediate levels of\n            // structure as necessary, like mkdir -p (and raises an exception if\n            // that would mean giving a non-numeric property to an array.) if\n            // options.noCreate is true, return undefined instead.\n            //\n            // may modify the last element of keyparts to signal to the caller that it needs\n            // to use a different value to index into the returned object (for example,\n            // ['a', '01'] -> ['a', 1]).\n            //\n            // if forbidArray is true, return null if the keypath goes through an array.\n            //\n            // if options.arrayIndices is set, use its first element for the (first) '$' in\n            // the path.\n\n\n            function findModTarget(doc, keyparts) {\n              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n              var usedArrayIndex = false;\n\n              for (var i = 0; i < keyparts.length; i++) {\n                var last = i === keyparts.length - 1;\n                var keypart = keyparts[i];\n\n                if (!_isIndexable2(doc)) {\n                  if (options.noCreate) {\n                    return undefined;\n                  }\n\n                  var error = MinimongoError(\"cannot use the part '\".concat(keypart, \"' to traverse \").concat(doc));\n                  error.setPropertyError = true;\n                  throw error;\n                }\n\n                if (doc instanceof Array) {\n                  if (options.forbidArray) {\n                    return null;\n                  }\n\n                  if (keypart === '$') {\n                    if (usedArrayIndex) {\n                      throw MinimongoError('Too many positional (i.e. \\'$\\') elements');\n                    }\n\n                    if (!options.arrayIndices || !options.arrayIndices.length) {\n                      throw MinimongoError('The positional operator did not find the match needed from the ' + 'query');\n                    }\n\n                    keypart = options.arrayIndices[0];\n                    usedArrayIndex = true;\n                  } else if (_isNumericKey2(keypart)) {\n                    keypart = parseInt(keypart);\n                  } else {\n                    if (options.noCreate) {\n                      return undefined;\n                    }\n\n                    throw MinimongoError(\"can't append to array using string field name [\".concat(keypart, \"]\"));\n                  }\n\n                  if (last) {\n                    keyparts[i] = keypart; // handle 'a.01'\n                  }\n\n                  if (options.noCreate && keypart >= doc.length) {\n                    return undefined;\n                  }\n\n                  while (doc.length < keypart) {\n                    doc.push(null);\n                  }\n\n                  if (!last) {\n                    if (doc.length === keypart) {\n                      doc.push({});\n                    } else if (_typeof(doc[keypart]) !== 'object') {\n                      throw MinimongoError(\"can't modify field '\".concat(keyparts[i + 1], \"' of list value \") + JSON.stringify(doc[keypart]));\n                    }\n                  }\n                } else {\n                  assertIsValidFieldName(keypart);\n\n                  if (!(keypart in doc)) {\n                    if (options.noCreate) {\n                      return undefined;\n                    }\n\n                    if (!last) {\n                      doc[keypart] = {};\n                    }\n                  }\n                }\n\n                if (last) {\n                  return doc;\n                }\n\n                doc = doc[keypart];\n              } // notreached\n\n            } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"matcher.js\": function matcherJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/minimongo/matcher.js                                                                                       //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              default: function _default() {\n                return Matcher;\n              }\n            });\n            var LocalCollection;\n            module.watch(require(\"./local_collection.js\"), {\n              default: function _default(v) {\n                LocalCollection = v;\n              }\n            }, 0);\n\n            var _compileDocumentSelector2, _hasOwn4, _nothingMatcher2;\n\n            module.watch(require(\"./common.js\"), {\n              compileDocumentSelector: function compileDocumentSelector(v) {\n                _compileDocumentSelector2 = v;\n              },\n              hasOwn: function hasOwn(v) {\n                _hasOwn4 = v;\n              },\n              nothingMatcher: function nothingMatcher(v) {\n                _nothingMatcher2 = v;\n              }\n            }, 1);\n\n            var Matcher =\n            /*#__PURE__*/\n            function () {\n              function Matcher(selector, isUpdate) {\n                _classCallCheck(this, Matcher);\n\n                // A set (object mapping string -> *) of all of the document paths looked\n                // at by the selector. Also includes the empty string if it may look at any\n                // path (eg, $where).\n                this._paths = {}; // Set to true if compilation finds a $near.\n\n                this._hasGeoQuery = false; // Set to true if compilation finds a $where.\n\n                this._hasWhere = false; // Set to false if compilation finds anything other than a simple equality\n                // or one or more of '$gt', '$gte', '$lt', '$lte', '$ne', '$in', '$nin' used\n                // with scalars as operands.\n\n                this._isSimple = true; // Set to a dummy document which always matches this Matcher. Or set to null\n                // if such document is too hard to find.\n\n                this._matchingDocument = undefined; // A clone of the original selector. It may just be a function if the user\n                // passed in a function; otherwise is definitely an object (eg, IDs are\n                // translated into {_id: ID} first. Used by canBecomeTrueByModifier and\n                // Sorter._useWithMatcher.\n\n                this._selector = null;\n                this._docMatcher = this._compileSelector(selector); // Set to true if selection is done for an update operation\n                // Default is false\n                // Used for $near array update (issue #3599)\n\n                this._isUpdate = isUpdate;\n              }\n\n              _createClass(Matcher, [{\n                key: \"documentMatches\",\n                value: function documentMatches(doc) {\n                  if (doc !== Object(doc)) {\n                    throw Error('documentMatches needs a document');\n                  }\n\n                  return this._docMatcher(doc);\n                }\n              }, {\n                key: \"hasGeoQuery\",\n                value: function hasGeoQuery() {\n                  return this._hasGeoQuery;\n                }\n              }, {\n                key: \"hasWhere\",\n                value: function hasWhere() {\n                  return this._hasWhere;\n                }\n              }, {\n                key: \"isSimple\",\n                value: function isSimple() {\n                  return this._isSimple;\n                } // Given a selector, return a function that takes one argument, a\n                // document. It returns a result object.\n\n              }, {\n                key: \"_compileSelector\",\n                value: function _compileSelector(selector) {\n                  // you can pass a literal function instead of a selector\n                  if (selector instanceof Function) {\n                    this._isSimple = false;\n                    this._selector = selector;\n\n                    this._recordPathUsed('');\n\n                    return function (doc) {\n                      return {\n                        result: !!selector.call(doc)\n                      };\n                    };\n                  } // shorthand -- scalar _id\n\n\n                  if (LocalCollection._selectorIsId(selector)) {\n                    this._selector = {\n                      _id: selector\n                    };\n\n                    this._recordPathUsed('_id');\n\n                    return function (doc) {\n                      return {\n                        result: EJSON.equals(doc._id, selector)\n                      };\n                    };\n                  } // protect against dangerous selectors.  falsey and {_id: falsey} are both\n                  // likely programmer error, and not what you want, particularly for\n                  // destructive operations.\n\n\n                  if (!selector || _hasOwn4.call(selector, '_id') && !selector._id) {\n                    this._isSimple = false;\n                    return _nothingMatcher2;\n                  } // Top level can't be an array or true or binary.\n\n\n                  if (Array.isArray(selector) || EJSON.isBinary(selector) || typeof selector === 'boolean') {\n                    throw new Error(\"Invalid selector: \".concat(selector));\n                  }\n\n                  this._selector = EJSON.clone(selector);\n                  return _compileDocumentSelector2(selector, this, {\n                    isRoot: true\n                  });\n                } // Returns a list of key paths the given selector is looking for. It includes\n                // the empty string if there is a $where.\n\n              }, {\n                key: \"_getPaths\",\n                value: function _getPaths() {\n                  return Object.keys(this._paths);\n                }\n              }, {\n                key: \"_recordPathUsed\",\n                value: function _recordPathUsed(path) {\n                  this._paths[path] = true;\n                }\n              }]);\n\n              return Matcher;\n            }(); // helpers used by compiled selector code\n\n\n            LocalCollection._f = {\n              // XXX for _all and _in, consider building 'inquery' at compile time..\n              _type: function _type(v) {\n                if (typeof v === 'number') {\n                  return 1;\n                }\n\n                if (typeof v === 'string') {\n                  return 2;\n                }\n\n                if (typeof v === 'boolean') {\n                  return 8;\n                }\n\n                if (Array.isArray(v)) {\n                  return 4;\n                }\n\n                if (v === null) {\n                  return 10;\n                } // note that typeof(/x/) === \"object\"\n\n\n                if (v instanceof RegExp) {\n                  return 11;\n                }\n\n                if (typeof v === 'function') {\n                  return 13;\n                }\n\n                if (v instanceof Date) {\n                  return 9;\n                }\n\n                if (EJSON.isBinary(v)) {\n                  return 5;\n                }\n\n                if (v instanceof MongoID.ObjectID) {\n                  return 7;\n                } // object\n\n\n                return 3; // XXX support some/all of these:\n                // 14, symbol\n                // 15, javascript code with scope\n                // 16, 18: 32-bit/64-bit integer\n                // 17, timestamp\n                // 255, minkey\n                // 127, maxkey\n              },\n              // deep equality test: use for literal document and array matches\n              _equal: function _equal(a, b) {\n                return EJSON.equals(a, b, {\n                  keyOrderSensitive: true\n                });\n              },\n              // maps a type code to a value that can be used to sort values of different\n              // types\n              _typeorder: function _typeorder(t) {\n                // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types\n                // XXX what is the correct sort position for Javascript code?\n                // ('100' in the matrix below)\n                // XXX minkey/maxkey\n                return [-1, // (not a type)\n                1, // number\n                2, // string\n                3, // object\n                4, // array\n                5, // binary\n                -1, // deprecated\n                6, // ObjectID\n                7, // bool\n                8, // Date\n                0, // null\n                9, // RegExp\n                -1, // deprecated\n                100, // JS code\n                2, // deprecated (symbol)\n                100, // JS code\n                1, // 32-bit int\n                8, // Mongo timestamp\n                1 // 64-bit int\n                ][t];\n              },\n              // compare two values of unknown type according to BSON ordering\n              // semantics. (as an extension, consider 'undefined' to be less than\n              // any other value.) return negative if a is less, positive if b is\n              // less, or 0 if equal\n              _cmp: function _cmp(a, b) {\n                if (a === undefined) {\n                  return b === undefined ? 0 : -1;\n                }\n\n                if (b === undefined) {\n                  return 1;\n                }\n\n                var ta = LocalCollection._f._type(a);\n\n                var tb = LocalCollection._f._type(b);\n\n                var oa = LocalCollection._f._typeorder(ta);\n\n                var ob = LocalCollection._f._typeorder(tb);\n\n                if (oa !== ob) {\n                  return oa < ob ? -1 : 1;\n                } // XXX need to implement this if we implement Symbol or integers, or\n                // Timestamp\n\n\n                if (ta !== tb) {\n                  throw Error('Missing type coercion logic in _cmp');\n                }\n\n                if (ta === 7) {\n                  // ObjectID\n                  // Convert to string.\n                  ta = tb = 2;\n                  a = a.toHexString();\n                  b = b.toHexString();\n                }\n\n                if (ta === 9) {\n                  // Date\n                  // Convert to millis.\n                  ta = tb = 1;\n                  a = a.getTime();\n                  b = b.getTime();\n                }\n\n                if (ta === 1) // double\n                  return a - b;\n                if (tb === 2) // string\n                  return a < b ? -1 : a === b ? 0 : 1;\n\n                if (ta === 3) {\n                  // Object\n                  // this could be much more efficient in the expected case ...\n                  var toArray = function toArray(object) {\n                    var result = [];\n                    Object.keys(object).forEach(function (key) {\n                      result.push(key, object[key]);\n                    });\n                    return result;\n                  };\n\n                  return LocalCollection._f._cmp(toArray(a), toArray(b));\n                }\n\n                if (ta === 4) {\n                  // Array\n                  for (var i = 0;; i++) {\n                    if (i === a.length) {\n                      return i === b.length ? 0 : -1;\n                    }\n\n                    if (i === b.length) {\n                      return 1;\n                    }\n\n                    var s = LocalCollection._f._cmp(a[i], b[i]);\n\n                    if (s !== 0) {\n                      return s;\n                    }\n                  }\n                }\n\n                if (ta === 5) {\n                  // binary\n                  // Surprisingly, a small binary blob is always less than a large one in\n                  // Mongo.\n                  if (a.length !== b.length) {\n                    return a.length - b.length;\n                  }\n\n                  for (var _i = 0; _i < a.length; _i++) {\n                    if (a[_i] < b[_i]) {\n                      return -1;\n                    }\n\n                    if (a[_i] > b[_i]) {\n                      return 1;\n                    }\n                  }\n\n                  return 0;\n                }\n\n                if (ta === 8) {\n                  // boolean\n                  if (a) {\n                    return b ? 0 : 1;\n                  }\n\n                  return b ? -1 : 0;\n                }\n\n                if (ta === 10) // null\n                  return 0;\n                if (ta === 11) // regexp\n                  throw Error('Sorting not supported on regular expression'); // XXX\n                // 13: javascript code\n                // 14: symbol\n                // 15: javascript code with scope\n                // 16: 32-bit integer\n                // 17: timestamp\n                // 18: 64-bit integer\n                // 255: minkey\n                // 127: maxkey\n\n                if (ta === 13) // javascript code\n                  throw Error('Sorting not supported on Javascript code'); // XXX\n\n                throw Error('Unknown type to sort');\n              }\n            }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          },\n          \"minimongo_common.js\": function minimongo_commonJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/minimongo/minimongo_common.js                                                                              //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var LocalCollection_;\n            module.watch(require(\"./local_collection.js\"), {\n              default: function _default(v) {\n                LocalCollection_ = v;\n              }\n            }, 0);\n            var Matcher;\n            module.watch(require(\"./matcher.js\"), {\n              default: function _default(v) {\n                Matcher = v;\n              }\n            }, 1);\n            var Sorter;\n            module.watch(require(\"./sorter.js\"), {\n              default: function _default(v) {\n                Sorter = v;\n              }\n            }, 2);\n            LocalCollection = LocalCollection_;\n            Minimongo = {\n              LocalCollection: LocalCollection_,\n              Matcher: Matcher,\n              Sorter: Sorter\n            }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          },\n          \"observe_handle.js\": function observe_handleJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/minimongo/observe_handle.js                                                                                //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              default: function _default() {\n                return ObserveHandle;\n              }\n            });\n\n            var ObserveHandle = function ObserveHandle() {\n              _classCallCheck(this, ObserveHandle);\n            }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"sorter.js\": function sorterJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/minimongo/sorter.js                                                                                        //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              default: function _default() {\n                return Sorter;\n              }\n            });\n\n            var _ELEMENT_OPERATORS2, _equalityElementMatcher2, _expandArraysInBranches2, _hasOwn5, _isOperatorObject3, _makeLookupFunction2, _regexpElementMatcher2;\n\n            module.watch(require(\"./common.js\"), {\n              ELEMENT_OPERATORS: function ELEMENT_OPERATORS(v) {\n                _ELEMENT_OPERATORS2 = v;\n              },\n              equalityElementMatcher: function equalityElementMatcher(v) {\n                _equalityElementMatcher2 = v;\n              },\n              expandArraysInBranches: function expandArraysInBranches(v) {\n                _expandArraysInBranches2 = v;\n              },\n              hasOwn: function hasOwn(v) {\n                _hasOwn5 = v;\n              },\n              isOperatorObject: function isOperatorObject(v) {\n                _isOperatorObject3 = v;\n              },\n              makeLookupFunction: function makeLookupFunction(v) {\n                _makeLookupFunction2 = v;\n              },\n              regexpElementMatcher: function regexpElementMatcher(v) {\n                _regexpElementMatcher2 = v;\n              }\n            }, 0);\n\n            var Sorter =\n            /*#__PURE__*/\n            function () {\n              function Sorter(spec) {\n                var _this15 = this;\n\n                _classCallCheck(this, Sorter);\n\n                this._sortSpecParts = [];\n                this._sortFunction = null;\n\n                var addSpecPart = function addSpecPart(path, ascending) {\n                  if (!path) {\n                    throw Error('sort keys must be non-empty');\n                  }\n\n                  if (path.charAt(0) === '$') {\n                    throw Error(\"unsupported sort key: \".concat(path));\n                  }\n\n                  _this15._sortSpecParts.push({\n                    ascending: ascending,\n                    lookup: _makeLookupFunction2(path, {\n                      forSort: true\n                    }),\n                    path: path\n                  });\n                };\n\n                if (spec instanceof Array) {\n                  spec.forEach(function (element) {\n                    if (typeof element === 'string') {\n                      addSpecPart(element, true);\n                    } else {\n                      addSpecPart(element[0], element[1] !== 'desc');\n                    }\n                  });\n                } else if (_typeof(spec) === 'object') {\n                  Object.keys(spec).forEach(function (key) {\n                    addSpecPart(key, spec[key] >= 0);\n                  });\n                } else if (typeof spec === 'function') {\n                  this._sortFunction = spec;\n                } else {\n                  throw Error(\"Bad sort specification: \".concat(JSON.stringify(spec)));\n                } // If a function is specified for sorting, we skip the rest.\n\n\n                if (this._sortFunction) {\n                  return;\n                } // To implement affectedByModifier, we piggy-back on top of Matcher's\n                // affectedByModifier code; we create a selector that is affected by the\n                // same modifiers as this sort order. This is only implemented on the\n                // server.\n\n\n                if (this.affectedByModifier) {\n                  var _selector = {};\n\n                  this._sortSpecParts.forEach(function (spec) {\n                    _selector[spec.path] = 1;\n                  });\n\n                  this._selectorForAffectedByModifier = new Minimongo.Matcher(_selector);\n                }\n\n                this._keyComparator = composeComparators(this._sortSpecParts.map(function (spec, i) {\n                  return _this15._keyFieldComparator(i);\n                }));\n              }\n\n              _createClass(Sorter, [{\n                key: \"getComparator\",\n                value: function getComparator(options) {\n                  // If sort is specified or have no distances, just use the comparator from\n                  // the source specification (which defaults to \"everything is equal\".\n                  // issue #3599\n                  // https://docs.mongodb.com/manual/reference/operator/query/near/#sort-operation\n                  // sort effectively overrides $near\n                  if (this._sortSpecParts.length || !options || !options.distances) {\n                    return this._getBaseComparator();\n                  }\n\n                  var distances = options.distances; // Return a comparator which compares using $near distances.\n\n                  return function (a, b) {\n                    if (!distances.has(a._id)) {\n                      throw Error(\"Missing distance for \".concat(a._id));\n                    }\n\n                    if (!distances.has(b._id)) {\n                      throw Error(\"Missing distance for \".concat(b._id));\n                    }\n\n                    return distances.get(a._id) - distances.get(b._id);\n                  };\n                } // Takes in two keys: arrays whose lengths match the number of spec\n                // parts. Returns negative, 0, or positive based on using the sort spec to\n                // compare fields.\n\n              }, {\n                key: \"_compareKeys\",\n                value: function _compareKeys(key1, key2) {\n                  if (key1.length !== this._sortSpecParts.length || key2.length !== this._sortSpecParts.length) {\n                    throw Error('Key has wrong length');\n                  }\n\n                  return this._keyComparator(key1, key2);\n                } // Iterates over each possible \"key\" from doc (ie, over each branch), calling\n                // 'cb' with the key.\n\n              }, {\n                key: \"_generateKeysFromDoc\",\n                value: function _generateKeysFromDoc(doc, cb) {\n                  if (this._sortSpecParts.length === 0) {\n                    throw new Error('can\\'t generate keys without a spec');\n                  }\n\n                  var pathFromIndices = function pathFromIndices(indices) {\n                    return \"\".concat(indices.join(','), \",\");\n                  };\n\n                  var knownPaths = null; // maps index -> ({'' -> value} or {path -> value})\n\n                  var valuesByIndexAndPath = this._sortSpecParts.map(function (spec) {\n                    // Expand any leaf arrays that we find, and ignore those arrays\n                    // themselves.  (We never sort based on an array itself.)\n                    var branches = _expandArraysInBranches2(spec.lookup(doc), true); // If there are no values for a key (eg, key goes to an empty array),\n                    // pretend we found one undefined value.\n\n\n                    if (!branches.length) {\n                      branches = [{\n                        value: void 0\n                      }];\n                    }\n\n                    var element = Object.create(null);\n                    var usedPaths = false;\n                    branches.forEach(function (branch) {\n                      if (!branch.arrayIndices) {\n                        // If there are no array indices for a branch, then it must be the\n                        // only branch, because the only thing that produces multiple branches\n                        // is the use of arrays.\n                        if (branches.length > 1) {\n                          throw Error('multiple branches but no array used?');\n                        }\n\n                        element[''] = branch.value;\n                        return;\n                      }\n\n                      usedPaths = true;\n                      var path = pathFromIndices(branch.arrayIndices);\n\n                      if (_hasOwn5.call(element, path)) {\n                        throw Error(\"duplicate path: \".concat(path));\n                      }\n\n                      element[path] = branch.value; // If two sort fields both go into arrays, they have to go into the\n                      // exact same arrays and we have to find the same paths.  This is\n                      // roughly the same condition that makes MongoDB throw this strange\n                      // error message.  eg, the main thing is that if sort spec is {a: 1,\n                      // b:1} then a and b cannot both be arrays.\n                      //\n                      // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n                      // and 'a.x.y' are both arrays, but we don't allow this for now.\n                      // #NestedArraySort\n                      // XXX achieve full compatibility here\n\n                      if (knownPaths && !_hasOwn5.call(knownPaths, path)) {\n                        throw Error('cannot index parallel arrays');\n                      }\n                    });\n\n                    if (knownPaths) {\n                      // Similarly to above, paths must match everywhere, unless this is a\n                      // non-array field.\n                      if (!_hasOwn5.call(element, '') && Object.keys(knownPaths).length !== Object.keys(element).length) {\n                        throw Error('cannot index parallel arrays!');\n                      }\n                    } else if (usedPaths) {\n                      knownPaths = {};\n                      Object.keys(element).forEach(function (path) {\n                        knownPaths[path] = true;\n                      });\n                    }\n\n                    return element;\n                  });\n\n                  if (!knownPaths) {\n                    // Easy case: no use of arrays.\n                    var soleKey = valuesByIndexAndPath.map(function (values) {\n                      if (!_hasOwn5.call(values, '')) {\n                        throw Error('no value in sole key case?');\n                      }\n\n                      return values[''];\n                    });\n                    cb(soleKey);\n                    return;\n                  }\n\n                  Object.keys(knownPaths).forEach(function (path) {\n                    var key = valuesByIndexAndPath.map(function (values) {\n                      if (_hasOwn5.call(values, '')) {\n                        return values[''];\n                      }\n\n                      if (!_hasOwn5.call(values, path)) {\n                        throw Error('missing path?');\n                      }\n\n                      return values[path];\n                    });\n                    cb(key);\n                  });\n                } // Returns a comparator that represents the sort specification (but not\n                // including a possible geoquery distance tie-breaker).\n\n              }, {\n                key: \"_getBaseComparator\",\n                value: function _getBaseComparator() {\n                  var _this16 = this;\n\n                  if (this._sortFunction) {\n                    return this._sortFunction;\n                  } // If we're only sorting on geoquery distance and no specs, just say\n                  // everything is equal.\n\n\n                  if (!this._sortSpecParts.length) {\n                    return function (doc1, doc2) {\n                      return 0;\n                    };\n                  }\n\n                  return function (doc1, doc2) {\n                    var key1 = _this16._getMinKeyFromDoc(doc1);\n\n                    var key2 = _this16._getMinKeyFromDoc(doc2);\n\n                    return _this16._compareKeys(key1, key2);\n                  };\n                } // Finds the minimum key from the doc, according to the sort specs.  (We say\n                // \"minimum\" here but this is with respect to the sort spec, so \"descending\"\n                // sort fields mean we're finding the max for that field.)\n                //\n                // Note that this is NOT \"find the minimum value of the first field, the\n                // minimum value of the second field, etc\"... it's \"choose the\n                // lexicographically minimum value of the key vector, allowing only keys which\n                // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\n                // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n                // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n\n              }, {\n                key: \"_getMinKeyFromDoc\",\n                value: function _getMinKeyFromDoc(doc) {\n                  var _this17 = this;\n\n                  var minKey = null;\n\n                  this._generateKeysFromDoc(doc, function (key) {\n                    if (minKey === null) {\n                      minKey = key;\n                      return;\n                    }\n\n                    if (_this17._compareKeys(key, minKey) < 0) {\n                      minKey = key;\n                    }\n                  });\n\n                  return minKey;\n                }\n              }, {\n                key: \"_getPaths\",\n                value: function _getPaths() {\n                  return this._sortSpecParts.map(function (part) {\n                    return part.path;\n                  });\n                } // Given an index 'i', returns a comparator that compares two key arrays based\n                // on field 'i'.\n\n              }, {\n                key: \"_keyFieldComparator\",\n                value: function _keyFieldComparator(i) {\n                  var invert = !this._sortSpecParts[i].ascending;\n                  return function (key1, key2) {\n                    var compare = LocalCollection._f._cmp(key1[i], key2[i]);\n\n                    return invert ? -compare : compare;\n                  };\n                }\n              }]);\n\n              return Sorter;\n            }(); // Given an array of comparators\n            // (functions (a,b)->(negative or positive or zero)), returns a single\n            // comparator which uses each comparator in order and returns the first\n            // non-zero value.\n\n\n            function composeComparators(comparatorArray) {\n              return function (a, b) {\n                for (var i = 0; i < comparatorArray.length; ++i) {\n                  var compare = comparatorArray[i](a, b);\n\n                  if (compare !== 0) {\n                    return compare;\n                  }\n                }\n\n                return 0;\n              };\n            } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/minimongo/minimongo_client.js\");\n  /* Exports */\n\n\n  Package._define(\"minimongo\", exports, {\n    LocalCollection: LocalCollection,\n    Minimongo: Minimongo,\n    MinimongoTest: MinimongoTest,\n    MinimongoError: MinimongoError\n  });\n})();\n\nmodule.exports = window.Package[\"minimongo\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/minimongo.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/mobile-experience.js":
/*!**********************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/mobile-experience.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/mobile-experience.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/modern-browsers.js":
/*!********************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/modern-browsers.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/modern-browsers.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/modules-runtime.js":
/*!********************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/modules-runtime.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  /* Package-scope variables */\n\n  var makeInstaller, meteorInstall; ///////////////////////////////////////////////////////////////////////////////\n  //                                                                           //\n  // packages/modules-runtime/.npm/package/node_modules/install/install.js     //\n  // This file is in bare mode and is not in its own closure.                  //\n  //                                                                           //\n  ///////////////////////////////////////////////////////////////////////////////\n  //\n\n  makeInstaller = function makeInstaller(options) {\n    \"use strict\";\n\n    options = options || {}; // These file extensions will be appended to required module identifiers\n    // if they do not exactly match an installed module.\n\n    var defaultExtensions = options.extensions || [\".js\", \".json\"]; // If defined, the options.fallback function will be called when no\n    // installed module is found for a required module identifier. Often\n    // options.fallback will be implemented in terms of the native Node\n    // require function, which has the ability to load binary modules.\n\n    var fallback = options.fallback; // List of fields to look for in package.json files to determine the\n    // main entry module of the package. The first field listed here whose\n    // value is a string will be used to resolve the entry module.\n\n    var mainFields = options.mainFields || ( // If options.mainFields is absent and options.browser is truthy,\n    // package resolution will prefer the \"browser\" field of package.json\n    // files to the \"main\" field. Note that this only supports\n    // string-valued \"browser\" fields for now, though in the future it\n    // might make sense to support the object version, a la browserify.\n    options.browser ? [\"browser\", \"main\"] : [\"main\"]);\n    var hasOwn = {}.hasOwnProperty;\n\n    function strictHasOwn(obj, key) {\n      return isObject(obj) && isString(key) && hasOwn.call(obj, key);\n    } // Cache for looking up File objects given absolute module identifiers.\n    // Invariants:\n    //   filesByModuleId[module.id] === fileAppendId(root, module.id)\n    //   filesByModuleId[module.id].module === module\n\n\n    var filesByModuleId = {}; // The file object representing the root directory of the installed\n    // module tree.\n\n    var root = new File(\"/\", new File(\"/..\"));\n    var rootRequire = makeRequire(root); // Merges the given tree of directories and module factory functions\n    // into the tree of installed modules and returns a require function\n    // that behaves as if called from a module in the root directory.\n\n    function install(tree, options) {\n      if (isObject(tree)) {\n        fileMergeContents(root, tree, options);\n      }\n\n      return rootRequire;\n    } // Replace this function to enable Module.prototype.prefetch.\n\n\n    install.fetch = function (ids) {\n      throw new Error(\"fetch not implemented\");\n    }; // This constructor will be used to instantiate the module objects\n    // passed to module factory functions (i.e. the third argument after\n    // require and exports), and is exposed as install.Module in case the\n    // caller of makeInstaller wishes to modify Module.prototype.\n\n\n    function Module(id) {\n      this.id = id; // The Node implementation of module.children unfortunately includes\n      // only those child modules that were imported for the first time by\n      // this parent module (i.e., child.parent === this).\n\n      this.children = []; // This object is an install.js extension that includes all child\n      // modules imported by this module, even if this module is not the\n      // first to import them.\n\n      this.childrenById = {};\n    } // Used to keep module.prefetch promise resolutions well-ordered.\n\n\n    var lastPrefetchPromise; // May be shared by multiple sequential calls to module.prefetch.\n    // Initialized to {} only when necessary.\n\n    var missing;\n\n    Module.prototype.prefetch = function (id) {\n      var module = this;\n      var parentFile = getOwn(filesByModuleId, module.id);\n      lastPrefetchPromise = lastPrefetchPromise || Promise.resolve();\n      var previousPromise = lastPrefetchPromise;\n\n      function walk(module) {\n        var file = getOwn(filesByModuleId, module.id);\n\n        if (fileIsDynamic(file) && !file.pending) {\n          file.pending = true;\n          missing = missing || {}; // These are the data that will be exposed to the install.fetch\n          // callback, so it's worth documenting each item with a comment.\n\n          missing[module.id] = {\n            // The CommonJS module object that will be exposed to this\n            // dynamic module when it is evaluated. Note that install.fetch\n            // could decide to populate module.exports directly, instead of\n            // fetching anything. In that case, install.fetch should omit\n            // this module from the tree that it produces.\n            module: file.module,\n            // List of module identifier strings imported by this module.\n            // Note that the missing object already contains all available\n            // dependencies (including transitive dependencies), so\n            // install.fetch should not need to traverse these dependencies\n            // in most cases; however, they may be useful for other reasons.\n            // Though the strings are unique, note that two different\n            // strings could resolve to the same module.\n            deps: Object.keys(file.deps),\n            // The options (if any) that were passed as the second argument\n            // to the install(tree, options) function when this stub was\n            // first registered. Typically contains options.extensions, but\n            // could contain any information appropriate for the entire tree\n            // as originally installed. These options will be automatically\n            // inherited by the newly fetched modules, so install.fetch\n            // should not need to modify them.\n            options: file.options,\n            // Any stub data included in the array notation from the\n            // original entry for this dynamic module. Typically contains\n            // \"main\" and/or \"browser\" fields for package.json files, and is\n            // otherwise undefined.\n            stub: file.stub\n          };\n          each(file.deps, function (parentId, id) {\n            fileResolve(file, id);\n          });\n          each(module.childrenById, walk);\n        }\n      }\n\n      return lastPrefetchPromise = new Promise(function (resolve) {\n        var absChildId = module.resolve(id);\n        each(module.childrenById, walk);\n        resolve(absChildId);\n      }).then(function (absChildId) {\n        // Grab the current missing object and fetch its contents.\n        var toBeFetched = missing;\n        missing = null;\n        return Promise.resolve( // The install.fetch function takes an object mapping missing\n        // dynamic module identifiers to options objects, and should\n        // return a Promise that resolves to a module tree that can be\n        // installed. As an optimization, if there were no missing dynamic\n        // modules, then we can skip calling install.fetch entirely.\n        toBeFetched && install.fetch(toBeFetched)).then(function (tree) {\n          function both() {\n            install(tree);\n            return absChildId;\n          } // Although we want multiple install.fetch calls to run in\n          // parallel, it is important that the promises returned by\n          // module.prefetch are resolved in the same order as the original\n          // calls to module.prefetch, because previous fetches may include\n          // modules assumed to exist by more recent module.prefetch calls.\n          // Whether previousPromise was resolved or rejected, carry on with\n          // the installation regardless.\n\n\n          return previousPromise.then(both, both);\n        });\n      });\n    };\n\n    install.Module = Module;\n\n    function getOwn(obj, key) {\n      return strictHasOwn(obj, key) && obj[key];\n    }\n\n    function isObject(value) {\n      return value !== null && _typeof(value) === \"object\";\n    }\n\n    function isFunction(value) {\n      return typeof value === \"function\";\n    }\n\n    function isString(value) {\n      return typeof value === \"string\";\n    }\n\n    function makeMissingError(id) {\n      return new Error(\"Cannot find module '\" + id + \"'\");\n    }\n\n    Module.prototype.resolve = function (id) {\n      var file = fileResolve(filesByModuleId[this.id], id);\n      if (file) return file.module.id;\n      var error = makeMissingError(id);\n\n      if (fallback && isFunction(fallback.resolve)) {\n        return fallback.resolve(id, this.id, error);\n      }\n\n      throw error;\n    };\n\n    Module.prototype.require = function require(id) {\n      var result = fileResolve(filesByModuleId[this.id], id);\n\n      if (result) {\n        return fileEvaluate(result, this);\n      }\n\n      var error = makeMissingError(id);\n\n      if (isFunction(fallback)) {\n        return fallback(id, // The missing module identifier.\n        this.id, // ID of the parent module.\n        error // The error we would have thrown.\n        );\n      }\n\n      throw error;\n    };\n\n    function makeRequire(file) {\n      var module = file.module;\n\n      function require(id) {\n        return module.require(id);\n      }\n\n      require.extensions = fileGetExtensions(file).slice(0);\n\n      require.resolve = function resolve(id) {\n        return module.resolve(id);\n      };\n\n      return require;\n    } // File objects represent either directories or modules that have been\n    // installed. When a `File` respresents a directory, its `.contents`\n    // property is an object containing the names of the files (or\n    // directories) that it contains. When a `File` represents a module, its\n    // `.contents` property is a function that can be invoked with the\n    // appropriate `(require, exports, module)` arguments to evaluate the\n    // module. If the `.contents` property is a string, that string will be\n    // resolved as a module identifier, and the exports of the resulting\n    // module will provide the exports of the original file. The `.parent`\n    // property of a File is either a directory `File` or `null`. Note that\n    // a child may claim another `File` as its parent even if the parent\n    // does not have an entry for that child in its `.contents` object.\n    // This is important for implementing anonymous files, and preventing\n    // child modules from using `../relative/identifier` syntax to examine\n    // unrelated modules.\n\n\n    function File(moduleId, parent) {\n      var file = this; // Link to the parent file.\n\n      file.parent = parent = parent || null; // The module object for this File, which will eventually boast an\n      // .exports property when/if the file is evaluated.\n\n      file.module = new Module(moduleId);\n      filesByModuleId[moduleId] = file; // The .contents of the file can be either (1) an object, if the file\n      // represents a directory containing other files; (2) a factory\n      // function, if the file represents a module that can be imported; (3)\n      // a string, if the file is an alias for another file; or (4) null, if\n      // the file's contents are not (yet) available.\n\n      file.contents = null; // Set of module identifiers imported by this module. Note that this\n      // set is not necessarily complete, so don't rely on it unless you\n      // know what you're doing.\n\n      file.deps = {};\n    }\n\n    function fileEvaluate(file, parentModule) {\n      var module = file.module;\n\n      if (!strictHasOwn(module, \"exports\")) {\n        var contents = file.contents;\n\n        if (!contents) {\n          // If this file was installed with array notation, and the array\n          // contained one or more objects but no functions, then the combined\n          // properties of the objects are treated as a temporary stub for\n          // file.module.exports. This is particularly important for partial\n          // package.json modules, so that the resolution logic can know the\n          // value of the \"main\" and/or \"browser\" fields, at least, even if\n          // the rest of the package.json file is not (yet) available.\n          if (file.stub) {\n            return file.stub;\n          }\n\n          throw makeMissingError(module.id);\n        }\n\n        if (parentModule) {\n          module.parent = parentModule;\n          var children = parentModule.children;\n\n          if (Array.isArray(children)) {\n            children.push(module);\n          }\n        }\n\n        contents(makeRequire(file), // If the file had a .stub, reuse the same object for exports.\n        module.exports = file.stub || {}, module, file.module.id, file.parent.module.id);\n        module.loaded = true;\n      } // The module.runModuleSetters method will be deprecated in favor of\n      // just module.runSetters: https://github.com/benjamn/reify/pull/160\n\n\n      var runSetters = module.runSetters || module.runModuleSetters;\n\n      if (isFunction(runSetters)) {\n        runSetters.call(module);\n      }\n\n      return module.exports;\n    }\n\n    function fileIsDirectory(file) {\n      return file && isObject(file.contents);\n    }\n\n    function fileIsDynamic(file) {\n      return file && file.contents === null;\n    }\n\n    function fileMergeContents(file, contents, options) {\n      if (Array.isArray(contents)) {\n        contents.forEach(function (item) {\n          if (isString(item)) {\n            file.deps[item] = file.module.id;\n          } else if (isFunction(item)) {\n            contents = item;\n          } else if (isObject(item)) {\n            file.stub = file.stub || {};\n            each(item, function (value, key) {\n              file.stub[key] = value;\n            });\n          }\n        });\n\n        if (!isFunction(contents)) {\n          // If the array did not contain a function, merge nothing.\n          contents = null;\n        }\n      } else if (!isFunction(contents) && !isString(contents) && !isObject(contents)) {\n        // If contents is neither an array nor a function nor a string nor\n        // an object, just give up and merge nothing.\n        contents = null;\n      }\n\n      if (contents) {\n        file.contents = file.contents || (isObject(contents) ? {} : contents);\n\n        if (isObject(contents) && fileIsDirectory(file)) {\n          each(contents, function (value, key) {\n            if (key === \"..\") {\n              child = file.parent;\n            } else {\n              var child = getOwn(file.contents, key);\n\n              if (!child) {\n                child = file.contents[key] = new File(file.module.id.replace(/\\/*$/, \"/\") + key, file);\n                child.options = options;\n              }\n            }\n\n            fileMergeContents(child, value, options);\n          });\n        }\n      }\n    }\n\n    function each(obj, callback, context) {\n      Object.keys(obj).forEach(function (key) {\n        callback.call(this, obj[key], key);\n      }, context);\n    }\n\n    function fileGetExtensions(file) {\n      return file.options && file.options.extensions || defaultExtensions;\n    }\n\n    function fileAppendIdPart(file, part, extensions) {\n      // Always append relative to a directory.\n      while (file && !fileIsDirectory(file)) {\n        file = file.parent;\n      }\n\n      if (!file || !part || part === \".\") {\n        return file;\n      }\n\n      if (part === \"..\") {\n        return file.parent;\n      }\n\n      var exactChild = getOwn(file.contents, part); // Only consider multiple file extensions if this part is the last\n      // part of a module identifier and not equal to `.` or `..`, and there\n      // was no exact match or the exact match was a directory.\n\n      if (extensions && (!exactChild || fileIsDirectory(exactChild))) {\n        for (var e = 0; e < extensions.length; ++e) {\n          var child = getOwn(file.contents, part + extensions[e]);\n\n          if (child && !fileIsDirectory(child)) {\n            return child;\n          }\n        }\n      }\n\n      return exactChild;\n    }\n\n    function fileAppendId(file, id, extensions) {\n      var parts = id.split(\"/\"); // Use `Array.prototype.every` to terminate iteration early if\n      // `fileAppendIdPart` returns a falsy value.\n\n      parts.every(function (part, i) {\n        return file = i < parts.length - 1 ? fileAppendIdPart(file, part) : fileAppendIdPart(file, part, extensions);\n      });\n      return file;\n    }\n\n    function recordChild(parentModule, childFile) {\n      var childModule = childFile && childFile.module;\n\n      if (parentModule && childModule) {\n        parentModule.childrenById[childModule.id] = childModule;\n      }\n    }\n\n    function fileResolve(file, id, parentModule, seenDirFiles) {\n      var parentModule = parentModule || file.module;\n      var extensions = fileGetExtensions(file);\n      file = // Absolute module identifiers (i.e. those that begin with a `/`\n      // character) are interpreted relative to the root directory, which\n      // is a slight deviation from Node, which has access to the entire\n      // file system.\n      id.charAt(0) === \"/\" ? fileAppendId(root, id, extensions) : // Relative module identifiers are interpreted relative to the\n      // current file, naturally.\n      id.charAt(0) === \".\" ? fileAppendId(file, id, extensions) : // Top-level module identifiers are interpreted as referring to\n      // packages in `node_modules` directories.\n      nodeModulesLookup(file, id, extensions); // If the identifier resolves to a directory, we use the same logic as\n      // Node to find an `index.js` or `package.json` file to evaluate.\n\n      while (fileIsDirectory(file)) {\n        seenDirFiles = seenDirFiles || []; // If the \"main\" field of a `package.json` file resolves to a\n        // directory we've already considered, then we should not attempt to\n        // read the same `package.json` file again. Using an array as a set\n        // is acceptable here because the number of directories to consider\n        // is rarely greater than 1 or 2. Also, using indexOf allows us to\n        // store File objects instead of strings.\n\n        if (seenDirFiles.indexOf(file) < 0) {\n          seenDirFiles.push(file);\n          var pkgJsonFile = fileAppendIdPart(file, \"package.json\"),\n              main;\n          var pkg = pkgJsonFile && fileEvaluate(pkgJsonFile, parentModule);\n\n          if (pkg && mainFields.some(function (name) {\n            return isString(main = pkg[name]);\n          })) {\n            // The \"main\" field of package.json does not have to begin with\n            // ./ to be considered relative, so first we try simply\n            // appending it to the directory path before falling back to a\n            // full fileResolve, which might return a package from a\n            // node_modules directory.\n            var mainFile = fileAppendId(file, main, extensions) || fileResolve(file, main, parentModule, seenDirFiles);\n\n            if (mainFile) {\n              file = mainFile;\n              recordChild(parentModule, pkgJsonFile); // The fileAppendId call above may have returned a directory,\n              // so continue the loop to make sure we resolve it to a\n              // non-directory file.\n\n              continue;\n            }\n          }\n        } // If we didn't find a `package.json` file, or it didn't have a\n        // resolvable `.main` property, the only possibility left to\n        // consider is that this directory contains an `index.js` module.\n        // This assignment almost always terminates the while loop, because\n        // there's very little chance `fileIsDirectory(file)` will be true\n        // for `fileAppendIdPart(file, \"index\", extensions)`. However, in\n        // principle it is remotely possible that a file called `index.js`\n        // could be a directory instead of a file.\n\n\n        file = fileAppendIdPart(file, \"index\", extensions);\n      }\n\n      if (file && isString(file.contents)) {\n        file = fileResolve(file, file.contents, parentModule, seenDirFiles);\n      }\n\n      recordChild(parentModule, file);\n      return file;\n    }\n\n    ;\n\n    function nodeModulesLookup(file, id, extensions) {\n      for (var resolved; file && !resolved; file = file.parent) {\n        resolved = fileIsDirectory(file) && fileAppendId(file, \"node_modules/\" + id, extensions);\n      }\n\n      return resolved;\n    }\n\n    return install;\n  };\n\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === \"object\") {\n    exports.makeInstaller = makeInstaller;\n  } ///////////////////////////////////////////////////////////////////////////////\n\n\n  (function () {\n    ///////////////////////////////////////////////////////////////////////////////\n    //                                                                           //\n    // packages/modules-runtime/client.js                                        //\n    //                                                                           //\n    ///////////////////////////////////////////////////////////////////////////////\n    //\n    meteorInstall = makeInstaller({\n      // On the client, make package resolution prefer the \"browser\" field of\n      // package.json files to the \"main\" field.\n      browser: true,\n      fallback: function fallback(id, parentId, error) {\n        if (id && id.startsWith('meteor/')) {\n          var packageName = id.split('/', 2)[1];\n          throw new Error('Cannot find package \"' + packageName + '\". ' + 'Try \"meteor add ' + packageName + '\".');\n        }\n\n        throw error;\n      }\n    }); ///////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n  (function () {\n    ///////////////////////////////////////////////////////////////////////////////\n    //                                                                           //\n    // packages/modules-runtime/profile.js                                       //\n    //                                                                           //\n    ///////////////////////////////////////////////////////////////////////////////\n    //\n    if (typeof Profile === \"function\" && process.env.METEOR_PROFILE) {\n      var Mp = meteorInstall.Module.prototype;\n      Mp.require = Profile(function (id) {\n        return \"require(\" + JSON.stringify(id) + \")\";\n      }, Mp.require);\n    } ///////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  /* Exports */\n\n  Package._define(\"modules-runtime\", {\n    meteorInstall: meteorInstall\n  });\n})();\n\nmodule.exports = window.Package[\"modules-runtime\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/modules-runtime.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/modules.js":
/*!************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/modules.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package['modules-runtime'].meteorInstall;\n\n  var __meteorReq = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"modules\": {\n          \"client.js\": function clientJs(__meteorReq, exports) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/modules/client.js                                                                                          //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            __meteorReq(\"./install-packages.js\");\n\n            __meteorReq(\"./stubs.js\");\n\n            __meteorReq(\"./process.js\");\n\n            __meteorReq(\"./reify.js\");\n\n            exports.addStyles = __meteorReq(\"./css\").addStyles; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          },\n          \"css.js\": function cssJs(__meteorReq, exports) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/modules/css.js                                                                                             //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var doc = document;\n            var head = doc.getElementsByTagName(\"head\").item(0);\n\n            exports.addStyles = function (css) {\n              var style = doc.createElement(\"style\");\n              style.setAttribute(\"type\", \"text/css\"); // https://msdn.microsoft.com/en-us/library/ms535871(v=vs.85).aspx\n\n              var internetExplorerSheetObject = style.sheet || // Edge/IE11.\n              style.styleSheet; // Older IEs.\n\n              if (internetExplorerSheetObject) {\n                internetExplorerSheetObject.cssText = css;\n              } else {\n                style.appendChild(doc.createTextNode(css));\n              }\n\n              return head.appendChild(style);\n            }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"install-packages.js\": function installPackagesJs(__meteorReq, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/modules/install-packages.js                                                                                //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            function install(name, mainModule) {\n              var meteorDir = {}; // Given a package name <name>, install a stub module in the\n              // /node_modules/meteor directory called <name>.js, so that\n              // __meteorReq.resolve(\"meteor/<name>\") will always return\n              // /node_modules/meteor/<name>.js instead of something like\n              // /node_modules/meteor/<name>/index.js, in the rare but possible event\n              // that the package contains a file called index.js (#6590).\n\n              if (typeof mainModule === \"string\") {\n                // Set up an alias from /node_modules/meteor/<package>.js to the main\n                // module, e.g. meteor/<package>/index.js.\n                meteorDir[name + \".js\"] = mainModule;\n              } else {\n                // back compat with old Meteor packages\n                meteorDir[name + \".js\"] = function (r, e, module) {\n                  module.exports = Package[name];\n                };\n              }\n\n              meteorInstall({\n                node_modules: {\n                  meteor: meteorDir\n                }\n              });\n            } // This file will be modified during computeJsOutputFilesMap to include\n            // install(<name>) calls for every Meteor package.\n\n\n            install(\"meteor\");\n            install(\"meteor-base\");\n            install(\"mobile-experience\");\n            install(\"modules-runtime\");\n            install(\"modules\", \"meteor/modules/client.js\");\n            install(\"modern-browsers\");\n            install(\"babel-compiler\");\n            install(\"ecmascript\");\n            install(\"ecmascript-runtime\");\n            install(\"babel-runtime\", \"meteor/babel-runtime/babel-runtime.js\");\n            install(\"promise\", \"meteor/promise/client.js\");\n            install(\"url\", \"meteor/url/url_client.js\");\n            install(\"http\", \"meteor/http/httpcall_client.js\");\n            install(\"dynamic-import\", \"meteor/dynamic-import/client.js\");\n            install(\"es5-shim\");\n            install(\"ecmascript-runtime-client\", \"meteor/ecmascript-runtime-client/modern.js\");\n            install(\"base64\", \"meteor/base64/base64.js\");\n            install(\"ejson\", \"meteor/ejson/ejson.js\");\n            install(\"diff-sequence\", \"meteor/diff-sequence/diff.js\");\n            install(\"geojson-utils\", \"meteor/geojson-utils/main.js\");\n            install(\"id-map\", \"meteor/id-map/id-map.js\");\n            install(\"random\");\n            install(\"mongo-id\", \"meteor/mongo-id/id.js\");\n            install(\"ordered-dict\", \"meteor/ordered-dict/ordered_dict.js\");\n            install(\"tracker\");\n            install(\"minimongo\", \"meteor/minimongo/minimongo_client.js\");\n            install(\"check\", \"meteor/check/match.js\");\n            install(\"retry\", \"meteor/retry/retry.js\");\n            install(\"callback-hook\", \"meteor/callback-hook/hook.js\");\n            install(\"ddp-common\");\n            install(\"reload\", \"meteor/reload/reload.js\");\n            install(\"socket-stream-client\", \"meteor/socket-stream-client/browser.js\");\n            install(\"ddp-client\", \"meteor/ddp-client/client/client.js\");\n            install(\"ddp\");\n            install(\"ddp-server\");\n            install(\"allow-deny\");\n            install(\"mongo-dev-server\");\n            install(\"insecure\");\n            install(\"mongo\");\n            install(\"reactive-var\");\n            install(\"standard-minifier-css\");\n            install(\"standard-minifier-js\");\n            install(\"shell-server\");\n            install(\"autopublish\");\n            install(\"static-html\");\n            install(\"jquery\");\n            install(\"twbs:bootstrap\");\n            install(\"demo-pkg\", \"meteor/demo-pkg/demo-pkg.js\");\n            install(\"webapp\", \"meteor/webapp/webapp_client.js\");\n            install(\"livedata\");\n            install(\"hot-code-push\");\n            install(\"launch-screen\");\n            install(\"autoupdate\"); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          },\n          \"process.js\": function processJs(__meteorReq, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/modules/process.js                                                                                         //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            if (!global.process) {\n              try {\n                // The application can run `npm install process` to provide its own\n                // process stub; otherwise this module will provide a partial stub.\n                global.process = __meteorReq(\"process\");\n              } catch (missing) {\n                global.process = {};\n              }\n            }\n\n            var proc = global.process;\n\n            if (Meteor.isServer) {\n              // Make __meteorReq(\"process\") work on the server in all versions of Node.\n              meteorInstall({\n                node_modules: {\n                  \"process.js\": function processJs(r, e, module) {\n                    module.exports = proc;\n                  }\n                }\n              });\n            } else {\n              proc.platform = \"browser\";\n              proc.nextTick = proc.nextTick || Meteor._setImmediate;\n            }\n\n            if (_typeof(proc.env) !== \"object\") {\n              proc.env = {};\n            }\n\n            var hasOwn = Object.prototype.hasOwnProperty;\n\n            for (var key in meteorEnv) {\n              if (hasOwn.call(meteorEnv, key)) {\n                proc.env[key] = meteorEnv[key];\n              }\n            } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"reify.js\": function reifyJs(__meteorReq, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/modules/reify.js                                                                                           //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            __meteorReq(\"reify/lib/runtime\").enable(module.constructor.prototype); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"stubs.js\": function stubsJs(__meteorReq) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/modules/stubs.js                                                                                           //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var haveStubs = false;\n\n            try {\n              __meteorReq.resolve(\"meteor-node-stubs\");\n\n              haveStubs = true;\n            } catch (noStubs) {}\n\n            if (haveStubs) {\n              // When meteor-node-stubs is installed in the application's root\n              // node_modules directory, requiring it here installs aliases for stubs\n              // for all Node built-in modules, such as fs, util, and http.\n              __meteorReq(\"meteor-node-stubs\");\n            } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"node_modules\": {\n            \"reify\": {\n              \"lib\": {\n                \"runtime\": {\n                  \"index.js\": function indexJs(__meteorReq, exports, module) {\n                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                    //                                                                                                                     //\n                    // node_modules/meteor/modules/node_modules/reify/lib/runtime/index.js                                                 //\n                    //                                                                                                                     //\n                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                    //\n                    \"use strict\"; // This module should be compatible with PhantomJS v1, just like the other files\n                    // in reify/lib/runtime. Node 4+ features like const/let and arrow functions are\n                    // not acceptable here, and importing any npm packages should be contemplated\n                    // with extreme skepticism.\n\n                    var utils = __meteorReq(\"./utils.js\");\n\n                    var Entry = __meteorReq(\"./entry.js\"); // The exports.enable method can be used to enable the Reify runtime for\n                    // specific module objects, or for Module.prototype (where implemented),\n                    // to make the runtime available throughout the entire module system.\n\n\n                    exports.enable = function (mod) {\n                      if (mod.watch !== moduleWatch) {\n                        mod.watch = moduleWatch;\n                        mod[\"export\"] = moduleExport;\n                        mod.exportDefault = moduleExportDefault;\n                        mod.runSetters = runSetters; // Used for copying the properties of a namespace object to\n                        // mod.exports to implement `export * from \"module\"` syntax.\n\n                        mod.makeNsSetter = moduleMakeNsSetter;\n                        return true;\n                      }\n\n                      return false;\n                    }; // If key is provided, it will be used to identify the given setters so\n                    // that they can be replaced if module.watch is called again with the same\n                    // key. This avoids potential memory leaks from import declarations inside\n                    // loops. The compiler generates these keys automatically (and\n                    // deterministically) when compiling nested import declarations.\n\n\n                    function moduleWatch(exported, setters, key) {\n                      utils.setESModule(this.exports);\n                      Entry.getOrCreate(this.exports, this);\n\n                      if (utils.isObject(setters)) {\n                        Entry.getOrCreate(exported).addSetters(this, setters, key);\n                      }\n                    } // Register getter functions for local variables in the scope of an export\n                    // statement. Pass true as the second argument to indicate that the getter\n                    // functions always return the same values.\n\n\n                    function moduleExport(getters, constant) {\n                      utils.setESModule(this.exports);\n                      var entry = Entry.getOrCreate(this.exports, this);\n                      entry.addGetters(getters, constant);\n\n                      if (this.loaded) {\n                        // If the module has already been evaluated, then we need to trigger\n                        // another round of entry.runSetters calls, which begins by calling\n                        // entry.runModuleGetters(module).\n                        entry.runSetters();\n                      }\n                    } // Register a getter function that always returns the given value.\n\n\n                    function moduleExportDefault(value) {\n                      return this[\"export\"]({\n                        \"default\": function _default() {\n                          return value;\n                        }\n                      }, true);\n                    } // Platform-specific code should find a way to call this method whenever\n                    // the module system is about to return module.exports from __meteorReq. This\n                    // might happen more than once per module, in case of dependency cycles,\n                    // so we want Module.prototype.runSetters to run each time.\n\n\n                    function runSetters(valueToPassThrough) {\n                      var entry = Entry.get(this.exports);\n\n                      if (entry !== null) {\n                        entry.runSetters();\n                      }\n\n                      if (this.loaded) {\n                        // If this module has finished loading, then we must create an Entry\n                        // object here, so that we can add this module to entry.ownerModules\n                        // by passing it as the second argument to Entry.getOrCreate.\n                        Entry.getOrCreate(this.exports, this);\n                      } // Assignments to exported local variables get wrapped with calls to\n                      // module.runSetters, so module.runSetters returns the\n                      // valueToPassThrough parameter to allow the value of the original\n                      // expression to pass through. For example,\n                      //\n                      //   export var a = 1;\n                      //   console.log(a += 3);\n                      //\n                      // becomes\n                      //\n                      //   module.export(\"a\", () => a);\n                      //   var a = 1;\n                      //   console.log(module.runSetters(a += 3));\n                      //\n                      // This ensures module.runSetters runs immediately after the assignment,\n                      // and does not interfere with the larger computation.\n\n\n                      return valueToPassThrough;\n                    } // Returns a function that takes a namespace object and copies the\n                    // properties of the namespace to module.exports, excluding any \"default\"\n                    // property (by default, unless includeDefault is truthy), which is useful\n                    // for implementing `export * from \"module\"`.\n\n\n                    function moduleMakeNsSetter(includeDefault) {\n                      var module = this; // Discussion of why the \"default\" property is skipped:\n                      // https://github.com/tc39/ecma262/issues/948\n\n                      return function (namespace) {\n                        Object.keys(namespace).forEach(function (key) {\n                          if (includeDefault || key !== \"default\") {\n                            utils.copyKey(key, module.exports, namespace);\n                          }\n                        });\n                      };\n                    } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n                  },\n                  \"utils.js\": function utilsJs(__meteorReq, exports, module) {\n                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                    //                                                                                                                     //\n                    // node_modules/meteor/modules/node_modules/reify/lib/runtime/utils.js                                                 //\n                    //                                                                                                                     //\n                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                    //\n                    \"use strict\"; // This module should be compatible with PhantomJS v1, just like the other files\n                    // in reify/lib/runtime. Node 4+ features like const/let and arrow functions are\n                    // not acceptable here, and importing any npm packages should be contemplated\n                    // with extreme skepticism.\n\n                    var useSetPrototypeOf = typeof Object.setPrototypeOf === \"function\";\n                    var useSymbol = typeof Symbol === \"function\";\n                    var esStrKey = \"__esModule\";\n                    var esSymKey = useSymbol ? Symbol.for(esStrKey) : null;\n                    var useToStringTag = useSymbol && _typeof(Symbol.toStringTag) === \"symbol\";\n                    var useGetOwnPropDesc = typeof Object.getOwnPropertyDescriptor === \"function\";\n                    var hasOwn = Object.prototype.hasOwnProperty;\n\n                    function copyKey(key, target, source) {\n                      if (useGetOwnPropDesc) {\n                        var desc = Object.getOwnPropertyDescriptor(source, key);\n                        desc.configurable = true; // Allow redefinition.\n\n                        Object.defineProperty(target, key, desc);\n                      } else {\n                        target[key] = source[key];\n                      }\n                    }\n\n                    exports.copyKey = copyKey; // Returns obj[key] unless that property is defined by a getter function,\n                    // in which case the getter function is returned.\n\n                    exports.valueOrGetter = function (obj, key) {\n                      if (useGetOwnPropDesc && hasOwn.call(obj, key)) {\n                        var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n                        if (typeof desc.get === \"function\") {\n                          return desc.get;\n                        }\n                      }\n\n                      return obj[key];\n                    };\n\n                    function getESModule(exported) {\n                      if (isObjectLike(exported)) {\n                        if (useSymbol && hasOwn.call(exported, esSymKey)) {\n                          return !!exported[esSymKey];\n                        }\n\n                        if (hasOwn.call(exported, esStrKey)) {\n                          return !!exported[esStrKey];\n                        }\n                      }\n\n                      return false;\n                    }\n\n                    exports.getESModule = getESModule;\n\n                    function setESModule(exported) {\n                      if (isObjectLike(exported)) {\n                        if (useSymbol) {\n                          exported[esSymKey] = true;\n                        } else if (!exported[esStrKey]) {\n                          // Other module runtime systems may set exported.__esModule such\n                          // that it can't be redefined, so we call Object.defineProperty only\n                          // when exported.__esModule is not already true.\n                          Object.defineProperty(exported, esStrKey, {\n                            configurable: true,\n                            enumerable: false,\n                            value: true,\n                            writable: false\n                          });\n                        }\n                      }\n                    }\n\n                    exports.setESModule = setESModule;\n\n                    function isObject(value) {\n                      return _typeof(value) === \"object\" && value !== null;\n                    }\n\n                    exports.isObject = isObject;\n\n                    function isObjectLike(value) {\n                      var type = _typeof(value);\n\n                      return type === \"function\" || type === \"object\" && value !== null;\n                    }\n\n                    exports.isObjectLike = isObjectLike;\n\n                    function createNamespace() {\n                      var namespace = Object.create(null);\n\n                      if (useToStringTag) {\n                        Object.defineProperty(namespace, Symbol.toStringTag, {\n                          value: \"Module\",\n                          configurable: false,\n                          enumerable: false,\n                          writable: false\n                        });\n                      }\n\n                      setESModule(namespace);\n                      return namespace;\n                    }\n\n                    exports.createNamespace = createNamespace;\n\n                    function setPrototypeOf(object, proto) {\n                      if (useSetPrototypeOf) {\n                        Object.setPrototypeOf(object, proto);\n                      } else {\n                        object.__proto__ = proto;\n                      }\n\n                      return object;\n                    }\n\n                    exports.setPrototypeOf = setPrototypeOf; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                  },\n                  \"entry.js\": function entryJs(__meteorReq, exports, module) {\n                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                    //                                                                                                                     //\n                    // node_modules/meteor/modules/node_modules/reify/lib/runtime/entry.js                                                 //\n                    //                                                                                                                     //\n                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                    //\n                    \"use strict\"; // This module should be compatible with PhantomJS v1, just like the other files\n                    // in reify/lib/runtime. Node 4+ features like const/let and arrow functions are\n                    // not acceptable here, and importing any npm packages should be contemplated\n                    // with extreme skepticism.\n\n                    var utils = __meteorReq(\"./utils.js\");\n\n                    var GETTER_ERROR = {};\n                    var NAN = {};\n                    var UNDEFINED = {};\n                    var hasOwn = Object.prototype.hasOwnProperty;\n                    var keySalt = 0;\n\n                    function Entry(exported) {\n                      // The module.exports of the module this Entry is managing.\n                      this.exports = exported; // Getters for local variables exported from the managed module.\n\n                      this.getters = Object.create(null); // Setters for assigning to local variables in parent modules.\n\n                      this.setters = Object.create(null); // The normalized namespace object that importers receive when they use\n                      // `import * as namespace from \"...\"` syntax.\n\n                      this.namespace = utils.createNamespace(); // Map from module.id string to module object for each module this Entry\n                      // is managing.\n\n                      this.ownerModules = Object.create(null); // Boolean indicating whether all the modules this Entry is managing\n                      // have finished loading yet. Call entry.hasLoaded() to compute.\n\n                      this._loaded = false;\n                    }\n\n                    var Ep = utils.setPrototypeOf(Entry.prototype, null);\n                    var weakEntryMap = typeof WeakMap === \"function\" ? new WeakMap() : new function FakeWeakMap() {\n                      // A barely functional WeakMap polyfill, just in case. This\n                      // implementation needs to be logically correct only in the specific\n                      // ways that the Entry class uses it. It isn't even \"weak\" in the\n                      // garbage-collection sense of the word, but that's fine.\n                      var keys = [];\n                      var values = [];\n\n                      this.get = function (obj) {\n                        var index = keys.indexOf(obj);\n\n                        if (index >= 0) {\n                          return values[index];\n                        }\n                      };\n\n                      this.set = function (obj, value) {\n                        var index = keys.indexOf(obj);\n\n                        if (index >= 0) {\n                          values[index] = value;\n                        } else {\n                          keys.push(obj);\n                          values.push(value);\n                        }\n                      };\n                    }();\n\n                    Entry.get = function (exported) {\n                      if (utils.isObjectLike(exported)) {\n                        var entry = weakEntryMap.get(exported);\n\n                        if (entry !== void 0) {\n                          return entry;\n                        }\n                      }\n\n                      return null;\n                    };\n\n                    Entry.getOrCreate = function (exported, mod) {\n                      var entry = getOrCreate(exported);\n\n                      if (utils.isObject(mod)) {\n                        entry.ownerModules[mod.id] = mod;\n                      }\n\n                      return entry;\n                    };\n\n                    function getOrCreate(exported) {\n                      if (!utils.isObjectLike(exported)) {\n                        // In case the child module modified module.exports, create a temporary\n                        // Entry object so that we can call the entry.addSetters method once,\n                        // which will trigger entry.runSetters(names), so that module.importSync\n                        // behaves as expected.\n                        return new Entry(exported);\n                      }\n\n                      var entry = weakEntryMap.get(exported);\n\n                      if (entry !== void 0) {\n                        return entry;\n                      }\n\n                      var entry = new Entry(exported);\n                      weakEntryMap.set(exported, entry);\n                      return entry;\n                    }\n\n                    ;\n\n                    function safeKeys(obj) {\n                      var keys = Object.keys(obj);\n                      var esModuleIndex = keys.indexOf(\"__esModule\");\n\n                      if (esModuleIndex >= 0) {\n                        keys.splice(esModuleIndex, 1);\n                      }\n\n                      return keys;\n                    }\n\n                    Ep.addGetters = function (getters, constant) {\n                      var names = safeKeys(getters);\n                      var nameCount = names.length;\n                      constant = !!constant;\n\n                      for (var i = 0; i < nameCount; ++i) {\n                        var name = names[i];\n                        var getter = getters[name];\n\n                        if (typeof getter === \"function\" && // Should this throw if this.getters[name] exists?\n                        !(name in this.getters)) {\n                          this.getters[name] = getter;\n                          getter.constant = constant;\n                          getter.runCount = 0;\n                        }\n                      }\n                    };\n\n                    Ep.addSetters = function (parent, setters, key) {\n                      var names = safeKeys(setters);\n                      var nameCount = names.length;\n\n                      if (!nameCount) {\n                        return;\n                      } // If no key is provided, make a unique key. Otherwise, make sure the key is\n                      // distinct from keys provided by other parent modules.\n\n\n                      key = key === void 0 ? makeUniqueKey() : parent.id + \":\" + key;\n\n                      for (var i = 0; i < nameCount; ++i) {\n                        var name = names[i];\n                        var setter = setters[name];\n\n                        if (typeof setter === \"function\") {\n                          setter.parent = parent;\n\n                          if (!(name in this.setters)) {\n                            this.setters[name] = Object.create(null);\n                          }\n\n                          this.setters[name][key] = setter;\n                        }\n                      }\n\n                      this.runSetters(names);\n                    };\n\n                    Ep.runGetters = function (names) {\n                      // Before running getters, copy anything added to the exports object\n                      // over to the namespace. Values returned by getters take precedence\n                      // over these values, but we don't want to miss anything.\n                      syncExportsToNamespace(this, names);\n\n                      if (names === void 0 || names.indexOf(\"*\") >= 0) {\n                        names = Object.keys(this.getters);\n                      }\n\n                      var nameCount = names.length;\n\n                      for (var i = 0; i < nameCount; ++i) {\n                        var name = names[i];\n                        var value = runGetter(this, name); // If the getter is run without error, update both entry.namespace and\n                        // module.exports with the current value so that CommonJS __meteorReq\n                        // calls remain consistent with module.watch.\n\n                        if (value !== GETTER_ERROR) {\n                          this.namespace[name] = value;\n                          this.exports[name] = value;\n                        }\n                      }\n                    };\n\n                    function syncExportsToNamespace(entry, names) {\n                      var setDefault = false;\n\n                      if (!utils.getESModule(entry.exports)) {\n                        // If the module entry is managing overrides module.exports, that\n                        // value should be exposed as the .default property of the namespace,\n                        // unless module.exports is marked as an ECMASCript module.\n                        entry.namespace.default = entry.exports;\n                        setDefault = true;\n                      }\n\n                      if (!utils.isObjectLike(entry.exports)) {\n                        return;\n                      }\n\n                      if (names === void 0 || names.indexOf(\"*\") >= 0) {\n                        names = Object.keys(entry.exports);\n                      }\n\n                      names.forEach(function (key) {\n                        // Don't set any properties for which a getter function exists in\n                        // entry.getters, don't accidentally override entry.namespace.default,\n                        // and only copy own properties from entry.exports.\n                        if (!hasOwn.call(entry.getters, key) && !(setDefault && key === \"default\") && hasOwn.call(entry.exports, key)) {\n                          utils.copyKey(key, entry.namespace, entry.exports);\n                        }\n                      });\n                    } // Called by module.runSetters once the module this Entry is managing has\n                    // finished loading.\n\n\n                    Ep.hasLoaded = function () {\n                      if (this._loaded) {\n                        return true;\n                      }\n\n                      var ids = Object.keys(this.ownerModules);\n                      var idCount = ids.length;\n\n                      for (var i = 0; i < idCount; ++i) {\n                        var owner = this.ownerModules[ids[i]];\n\n                        if (!owner.loaded && owner.exports === this.exports) {\n                          // At least one owner module whose exports are still ===\n                          // this.exports has not finished loading, so this this Entry cannot\n                          // be marked as loaded yet.\n                          return false;\n                        }\n                      } // Set entry._loaded = true only if all the modules in\n                      // entry.ownerModules that are still associated with entry.exports have\n                      // finished loading.\n\n\n                      return this._loaded = true;\n                    }; // Called whenever module.exports might have changed, to trigger any\n                    // setters associated with the newly exported values. The names parameter\n                    // is optional; without it, all getters and setters will run.\n\n\n                    Ep.runSetters = function (names) {\n                      // Make sure entry.namespace and module.exports are up to date before we\n                      // call getExportByName(entry, name).\n                      this.runGetters(names); // Lazily-initialized object mapping parent module identifiers to parent\n                      // module objects whose setters we might need to run.\n\n                      var parents;\n                      forEachSetter(this, names, function (setter, name, value) {\n                        if (parents === void 0) {\n                          parents = Object.create(null);\n                        }\n\n                        parents[setter.parent.id] = setter.parent; // The param order for setters is `value` then `name` because the `name`\n                        // param is only used by namespace exports.\n\n                        setter(value, name);\n                      });\n\n                      if (!parents) {\n                        return;\n                      } // If any of the setters updated the module.exports of a parent module,\n                      // or updated local variables that are exported by that parent module,\n                      // then we must re-run any setters registered by that parent module.\n\n\n                      var parentIDs = Object.keys(parents);\n                      var parentIDCount = parentIDs.length;\n\n                      for (var i = 0; i < parentIDCount; ++i) {\n                        // What happens if parents[parentIDs[id]] === module, or if\n                        // longer cycles exist in the parent chain? Thanks to our setter.last\n                        // bookkeeping above, the runSetters broadcast will only proceed\n                        // as far as there are any actual changes to report.\n                        var parent = parents[parentIDs[i]];\n                        var parentEntry = Entry.get(parent.exports);\n\n                        if (parentEntry) {\n                          parentEntry.runSetters();\n                        }\n                      }\n                    };\n\n                    function callSetterIfNecessary(setter, name, value, callback) {\n                      if (name === \"__esModule\") {\n                        // Ignore setters asking for module.exports.__esModule.\n                        return;\n                      }\n\n                      var shouldCall = false;\n\n                      if (setter.last === void 0) {\n                        setter.last = Object.create(null); // Always call the setter if it has never been called before.\n\n                        shouldCall = true;\n                      }\n\n                      function changed(name, value) {\n                        var valueToCompare = value;\n\n                        if (valueToCompare !== valueToCompare) {\n                          valueToCompare = NAN;\n                        } else if (valueToCompare === void 0) {\n                          valueToCompare = UNDEFINED;\n                        }\n\n                        if (setter.last[name] === valueToCompare) {\n                          return false;\n                        }\n\n                        setter.last[name] = valueToCompare;\n                        return true;\n                      }\n\n                      if (name === \"*\") {\n                        var keys = safeKeys(value);\n                        var keyCount = keys.length;\n\n                        for (var i = 0; i < keyCount; ++i) {\n                          var key = keys[i]; // Evaluating value[key] is risky because the property might be\n                          // defined by a getter function that logs a deprecation warning (or\n                          // worse) when evaluated. For example, Node uses this trick to\n                          // display a deprecation warning whenever crypto.createCredentials\n                          // is accessed. Fortunately, when value[key] is defined by a getter\n                          // function, it's enough to check whether the getter function itself\n                          // has changed, since we are careful elsewhere to preserve getters\n                          // rather than prematurely evaluating them.\n\n                          if (changed(key, utils.valueOrGetter(value, key))) {\n                            shouldCall = true;\n                          }\n                        }\n                      } else if (changed(name, value)) {\n                        shouldCall = true;\n                      }\n\n                      if (shouldCall) {\n                        // Only invoke the callback if we have not called this setter\n                        // (with a value of this name) before, or the current value is\n                        // different from the last value we passed to this setter.\n                        return callback(setter, name, value);\n                      }\n                    } // Invoke the given callback once for every (setter, name, value) that needs to\n                    // be called. Note that forEachSetter does not call any setters itself, only the\n                    // given callback.\n\n\n                    function forEachSetter(entry, names, callback) {\n                      var needToCheckNames = true;\n\n                      if (names === void 0) {\n                        names = Object.keys(entry.setters);\n                        needToCheckNames = false;\n                      }\n\n                      var nameCount = names.length;\n\n                      for (var i = 0; i < nameCount; ++i) {\n                        var name = names[i];\n\n                        if (needToCheckNames && !hasOwn.call(entry.setters, name)) {\n                          continue;\n                        }\n\n                        var setters = entry.setters[name];\n                        var keys = Object.keys(setters);\n                        var keyCount = keys.length;\n\n                        for (var j = 0; j < keyCount; ++j) {\n                          var key = keys[j];\n                          var value = getExportByName(entry, name);\n                          callSetterIfNecessary(setters[key], name, value, callback);\n                          var getter = entry.getters[name];\n\n                          if (typeof getter === \"function\" && // Sometimes a getter function will throw because it's called\n                          // before the variable it's supposed to return has been\n                          // initialized, so we need to know that the getter function has\n                          // run to completion at least once.\n                          getter.runCount > 0 && getter.constant) {\n                            // If we happen to know that this getter function has run\n                            // successfully, and will never return a different value, then we\n                            // can forget the corresponding setter, because we've already\n                            // reported that constant value. Note that we can't forget the\n                            // getter, because we need to remember the original value in case\n                            // anyone tampers with entry.exports[name].\n                            delete setters[key];\n                          }\n                        }\n                      }\n                    }\n\n                    function getExportByName(entry, name) {\n                      if (name === \"*\") {\n                        return entry.namespace;\n                      }\n\n                      if (hasOwn.call(entry.namespace, name)) {\n                        return entry.namespace[name];\n                      }\n\n                      var exported = entry.exports;\n\n                      if (name === \"default\" && !(utils.getESModule(exported) && \"default\" in exported)) {\n                        return exported;\n                      }\n\n                      if (exported == null) {\n                        return;\n                      }\n\n                      return exported[name];\n                    }\n\n                    function makeUniqueKey() {\n                      return Math.random().toString(36) // Add an incrementing salt to help track key ordering and also\n                      // absolutely guarantee we never return the same key twice.\n                      .replace(\"0.\", ++keySalt + \"$\");\n                    }\n\n                    function runGetter(entry, name) {\n                      var getter = entry.getters[name];\n\n                      try {\n                        var result = getter();\n                        ++getter.runCount;\n                        return result;\n                      } catch (e) {}\n\n                      return GETTER_ERROR;\n                    }\n\n                    module.exports = Entry; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"@babel\": {\n        \"runtime\": {\n          \"package.json\": function packageJson(__meteorReq, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // node_modules/@babel/runtime/package.json                                                                            //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.exports = {\n              \"_from\": \"@babel/runtime@7.0.0-beta.55\",\n              \"_id\": \"@babel/runtime@7.0.0-beta.55\",\n              \"_inBundle\": false,\n              \"_integrity\": \"sha1-C8M6paasCwEvN+JbnmqqLkiakWs=\",\n              \"_location\": \"/@babel/runtime\",\n              \"_phantomChildren\": {},\n              \"_requested\": {\n                \"type\": \"version\",\n                \"registry\": true,\n                \"raw\": \"@babel/runtime@7.0.0-beta.55\",\n                \"name\": \"@babel/runtime\",\n                \"escapedName\": \"@babel%2fruntime\",\n                \"scope\": \"@babel\",\n                \"rawSpec\": \"7.0.0-beta.55\",\n                \"saveSpec\": null,\n                \"fetchSpec\": \"7.0.0-beta.55\"\n              },\n              \"_requiredBy\": [\"#USER\", \"/\"],\n              \"_resolved\": \"https://registry.npmjs.org/@babel/runtime/-/runtime-7.0.0-beta.55.tgz\",\n              \"_shasum\": \"0bc33aa5a6ac0b012f37e25b9e6aaa2e489a916b\",\n              \"_spec\": \"@babel/runtime@7.0.0-beta.55\",\n              \"_where\": \"/Users/staffan/dev/meteor-imports-webpack-plugin/demo/wp-meteor-server\",\n              \"author\": {\n                \"name\": \"Sebastian McKenzie\",\n                \"email\": \"sebmck@gmail.com\"\n              },\n              \"bundleDependencies\": false,\n              \"dependencies\": {\n                \"core-js\": \"^2.5.7\",\n                \"regenerator-runtime\": \"^0.12.0\"\n              },\n              \"deprecated\": false,\n              \"description\": \"babel selfContained runtime\",\n              \"devDependencies\": {\n                \"@babel/core\": \"7.0.0-beta.55\",\n                \"@babel/helpers\": \"7.0.0-beta.55\",\n                \"@babel/plugin-transform-runtime\": \"7.0.0-beta.55\",\n                \"@babel/preset-env\": \"7.0.0-beta.55\",\n                \"@babel/types\": \"7.0.0-beta.55\"\n              },\n              \"license\": \"MIT\",\n              \"name\": \"@babel/runtime\",\n              \"repository\": {\n                \"type\": \"git\",\n                \"url\": \"https://github.com/babel/babel/tree/master/packages/babel-runtime\"\n              },\n              \"version\": \"7.0.0-beta.55\"\n            }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          },\n          \"helpers\": {\n            \"builtin\": {\n              \"interopRequireDefault.js\": function interopRequireDefaultJs(__meteorReq, exports, module) {\n                arguments[2].exports = __webpack_require__(/*! @babel/runtime/helpers/builtin/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/builtin/interopRequireDefault.js\");\n              },\n              \"objectSpread.js\": function objectSpreadJs(__meteorReq, exports, module) {\n                arguments[2].exports = __webpack_require__(/*! @babel/runtime/helpers/builtin/objectSpread */ \"./node_modules/@babel/runtime/helpers/builtin/objectSpread.js\");\n              },\n              \"defineProperty.js\": function definePropertyJs(__meteorReq, exports, module) {\n                arguments[2].exports = __webpack_require__(/*! @babel/runtime/helpers/builtin/defineProperty */ \"./node_modules/@babel/runtime/helpers/builtin/defineProperty.js\");\n              }\n            }\n          }\n        }\n      },\n      \"core-js\": {\n        \"modules\": {\n          \"es7.object.get-own-property-descriptors.js\": function es7ObjectGetOwnPropertyDescriptorsJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es7.object.get-own-property-descriptors */ \"./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js\");\n          },\n          \"_export.js\": function _exportJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_export */ \"./node_modules/core-js/modules/_export.js\");\n          },\n          \"_global.js\": function _globalJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_global */ \"./node_modules/core-js/modules/_global.js\");\n          },\n          \"_core.js\": function _coreJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_core */ \"./node_modules/core-js/modules/_core.js\");\n          },\n          \"_hide.js\": function _hideJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_hide */ \"./node_modules/core-js/modules/_hide.js\");\n          },\n          \"_object-dp.js\": function _objectDpJs(__meteorReq, exports) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\");\n          },\n          \"_an-object.js\": function _anObjectJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\n          },\n          \"_is-object.js\": function _isObjectJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\n          },\n          \"_ie8-dom-define.js\": function _ie8DomDefineJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_ie8-dom-define */ \"./node_modules/core-js/modules/_ie8-dom-define.js\");\n          },\n          \"_descriptors.js\": function _descriptorsJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\");\n          },\n          \"_fails.js\": function _failsJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_fails */ \"./node_modules/core-js/modules/_fails.js\");\n          },\n          \"_dom-create.js\": function _domCreateJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_dom-create */ \"./node_modules/core-js/modules/_dom-create.js\");\n          },\n          \"_to-primitive.js\": function _toPrimitiveJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_to-primitive */ \"./node_modules/core-js/modules/_to-primitive.js\");\n          },\n          \"_property-desc.js\": function _propertyDescJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_property-desc */ \"./node_modules/core-js/modules/_property-desc.js\");\n          },\n          \"_redefine.js\": function _redefineJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_redefine */ \"./node_modules/core-js/modules/_redefine.js\");\n          },\n          \"_has.js\": function _hasJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_has */ \"./node_modules/core-js/modules/_has.js\");\n          },\n          \"_uid.js\": function _uidJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_uid */ \"./node_modules/core-js/modules/_uid.js\");\n          },\n          \"_ctx.js\": function _ctxJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_ctx */ \"./node_modules/core-js/modules/_ctx.js\");\n          },\n          \"_a-function.js\": function _aFunctionJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_a-function */ \"./node_modules/core-js/modules/_a-function.js\");\n          },\n          \"_own-keys.js\": function _ownKeysJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_own-keys */ \"./node_modules/core-js/modules/_own-keys.js\");\n          },\n          \"_object-gopn.js\": function _objectGopnJs(__meteorReq, exports) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_object-gopn */ \"./node_modules/core-js/modules/_object-gopn.js\");\n          },\n          \"_object-keys-internal.js\": function _objectKeysInternalJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_object-keys-internal */ \"./node_modules/core-js/modules/_object-keys-internal.js\");\n          },\n          \"_to-iobject.js\": function _toIobjectJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\n          },\n          \"_iobject.js\": function _iobjectJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_iobject */ \"./node_modules/core-js/modules/_iobject.js\");\n          },\n          \"_cof.js\": function _cofJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_cof */ \"./node_modules/core-js/modules/_cof.js\");\n          },\n          \"_defined.js\": function _definedJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_defined */ \"./node_modules/core-js/modules/_defined.js\");\n          },\n          \"_array-includes.js\": function _arrayIncludesJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_array-includes */ \"./node_modules/core-js/modules/_array-includes.js\");\n          },\n          \"_to-length.js\": function _toLengthJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_to-length */ \"./node_modules/core-js/modules/_to-length.js\");\n          },\n          \"_to-integer.js\": function _toIntegerJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_to-integer */ \"./node_modules/core-js/modules/_to-integer.js\");\n          },\n          \"_to-absolute-index.js\": function _toAbsoluteIndexJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_to-absolute-index */ \"./node_modules/core-js/modules/_to-absolute-index.js\");\n          },\n          \"_shared-key.js\": function _sharedKeyJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_shared-key */ \"./node_modules/core-js/modules/_shared-key.js\");\n          },\n          \"_shared.js\": function _sharedJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_shared */ \"./node_modules/core-js/modules/_shared.js\");\n          },\n          \"_library.js\": function _libraryJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_library */ \"./node_modules/core-js/modules/_library.js\");\n          },\n          \"_enum-bug-keys.js\": function _enumBugKeysJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_enum-bug-keys */ \"./node_modules/core-js/modules/_enum-bug-keys.js\");\n          },\n          \"_object-gops.js\": function _objectGopsJs(__meteorReq, exports) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_object-gops */ \"./node_modules/core-js/modules/_object-gops.js\");\n          },\n          \"_object-gopd.js\": function _objectGopdJs(__meteorReq, exports) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_object-gopd */ \"./node_modules/core-js/modules/_object-gopd.js\");\n          },\n          \"_object-pie.js\": function _objectPieJs(__meteorReq, exports) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_object-pie */ \"./node_modules/core-js/modules/_object-pie.js\");\n          },\n          \"_create-property.js\": function _createPropertyJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_create-property */ \"./node_modules/core-js/modules/_create-property.js\");\n          },\n          \"es6.object.is.js\": function es6ObjectIsJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es6.object.is */ \"./node_modules/core-js/modules/es6.object.is.js\");\n          },\n          \"_same-value.js\": function _sameValueJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_same-value */ \"./node_modules/core-js/modules/_same-value.js\");\n          },\n          \"es6.function.name.js\": function es6FunctionNameJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es6.function.name */ \"./node_modules/core-js/modules/es6.function.name.js\");\n          },\n          \"es6.number.is-finite.js\": function es6NumberIsFiniteJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es6.number.is-finite */ \"./node_modules/core-js/modules/es6.number.is-finite.js\");\n          },\n          \"es6.number.is-nan.js\": function es6NumberIsNanJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es6.number.is-nan */ \"./node_modules/core-js/modules/es6.number.is-nan.js\");\n          },\n          \"es7.array.flatten.js\": function es7ArrayFlattenJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es7.array.flatten */ \"./node_modules/core-js/modules/es7.array.flatten.js\");\n          },\n          \"_flatten-into-array.js\": function _flattenIntoArrayJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_flatten-into-array */ \"./node_modules/core-js/modules/_flatten-into-array.js\");\n          },\n          \"_is-array.js\": function _isArrayJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_is-array */ \"./node_modules/core-js/modules/_is-array.js\");\n          },\n          \"_wks.js\": function _wksJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_wks */ \"./node_modules/core-js/modules/_wks.js\");\n          },\n          \"_to-object.js\": function _toObjectJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_to-object */ \"./node_modules/core-js/modules/_to-object.js\");\n          },\n          \"_array-species-create.js\": function _arraySpeciesCreateJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_array-species-create */ \"./node_modules/core-js/modules/_array-species-create.js\");\n          },\n          \"_array-species-constructor.js\": function _arraySpeciesConstructorJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_array-species-constructor */ \"./node_modules/core-js/modules/_array-species-constructor.js\");\n          },\n          \"_add-to-unscopables.js\": function _addToUnscopablesJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_add-to-unscopables */ \"./node_modules/core-js/modules/_add-to-unscopables.js\");\n          },\n          \"es7.array.flat-map.js\": function es7ArrayFlatMapJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es7.array.flat-map */ \"./node_modules/core-js/modules/es7.array.flat-map.js\");\n          },\n          \"es7.object.values.js\": function es7ObjectValuesJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es7.object.values */ \"./node_modules/core-js/modules/es7.object.values.js\");\n          },\n          \"_object-to-array.js\": function _objectToArrayJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_object-to-array */ \"./node_modules/core-js/modules/_object-to-array.js\");\n          },\n          \"_object-keys.js\": function _objectKeysJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_object-keys */ \"./node_modules/core-js/modules/_object-keys.js\");\n          },\n          \"es7.object.entries.js\": function es7ObjectEntriesJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es7.object.entries */ \"./node_modules/core-js/modules/es7.object.entries.js\");\n          },\n          \"es7.string.pad-start.js\": function es7StringPadStartJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es7.string.pad-start */ \"./node_modules/core-js/modules/es7.string.pad-start.js\");\n          },\n          \"_string-pad.js\": function _stringPadJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_string-pad */ \"./node_modules/core-js/modules/_string-pad.js\");\n          },\n          \"_string-repeat.js\": function _stringRepeatJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_string-repeat */ \"./node_modules/core-js/modules/_string-repeat.js\");\n          },\n          \"_user-agent.js\": function _userAgentJs(__meteorReq, exports, module) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/_user-agent */ \"./node_modules/core-js/modules/_user-agent.js\");\n          },\n          \"es7.string.pad-end.js\": function es7StringPadEndJs(__meteorReq) {\n            arguments[2].exports = __webpack_require__(/*! core-js/modules/es7.string.pad-end */ \"./node_modules/core-js/modules/es7.string.pad-end.js\");\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = __meteorReq(\"/node_modules/meteor/modules/client.js\");\n  /* Exports */\n\n\n  Package._define(\"modules\", exports, {\n    meteorInstall: meteorInstall\n  });\n})();\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/modules.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/mongo-dev-server.js":
/*!*********************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/mongo-dev-server.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/mongo-dev-server.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/mongo-id.js":
/*!*************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/mongo-id.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var EJSON = Package.ejson.EJSON;\n  var IdMap = Package['id-map'].IdMap;\n  var Random = Package.random.Random;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var hexString, MongoID;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"mongo-id\": {\n          \"id.js\": function idJs(require, exports, module) {\n            ///////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                           //\n            // packages/mongo-id/id.js                                                                   //\n            //                                                                                           //\n            ///////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              MongoID: function MongoID() {\n                return _MongoID;\n              }\n            });\n\n            var _EJSON;\n\n            module.watch(require(\"meteor/ejson\"), {\n              EJSON: function EJSON(v) {\n                _EJSON = v;\n              }\n            }, 0);\n\n            var _Random;\n\n            module.watch(require(\"meteor/random\"), {\n              Random: function Random(v) {\n                _Random = v;\n              }\n            }, 1);\n            var _MongoID = {};\n\n            _MongoID._looksLikeObjectID = function (str) {\n              return str.length === 24 && str.match(/^[0-9a-f]*$/);\n            };\n\n            _MongoID.ObjectID =\n            /*#__PURE__*/\n            function () {\n              function ObjectID(hexString) {\n                _classCallCheck(this, ObjectID);\n\n                //random-based impl of Mongo ObjectID\n                if (hexString) {\n                  hexString = hexString.toLowerCase();\n\n                  if (!_MongoID._looksLikeObjectID(hexString)) {\n                    throw new Error('Invalid hexadecimal string for creating an ObjectID');\n                  } // meant to work with _.isEqual(), which relies on structural equality\n\n\n                  this._str = hexString;\n                } else {\n                  this._str = _Random.hexString(24);\n                }\n              }\n\n              _createClass(ObjectID, [{\n                key: \"equals\",\n                value: function equals(other) {\n                  return other instanceof _MongoID.ObjectID && this.valueOf() === other.valueOf();\n                }\n              }, {\n                key: \"toString\",\n                value: function toString() {\n                  return \"ObjectID(\\\"\".concat(this._str, \"\\\")\");\n                }\n              }, {\n                key: \"clone\",\n                value: function clone() {\n                  return new _MongoID.ObjectID(this._str);\n                }\n              }, {\n                key: \"typeName\",\n                value: function typeName() {\n                  return 'oid';\n                }\n              }, {\n                key: \"getTimestamp\",\n                value: function getTimestamp() {\n                  return Number.parseInt(this._str.substr(0, 8), 16);\n                }\n              }, {\n                key: \"valueOf\",\n                value: function valueOf() {\n                  return this._str;\n                }\n              }, {\n                key: \"toJSONValue\",\n                value: function toJSONValue() {\n                  return this.valueOf();\n                }\n              }, {\n                key: \"toHexString\",\n                value: function toHexString() {\n                  return this.valueOf();\n                }\n              }]);\n\n              return ObjectID;\n            }();\n\n            _EJSON.addType('oid', function (str) {\n              return new _MongoID.ObjectID(str);\n            });\n\n            _MongoID.idStringify = function (id) {\n              if (id instanceof _MongoID.ObjectID) {\n                return id.valueOf();\n              } else if (typeof id === 'string') {\n                if (id === '') {\n                  return id;\n                } else if (id.startsWith('-') || // escape previously dashed strings\n                id.startsWith('~') || // escape escaped numbers, true, false\n                _MongoID._looksLikeObjectID(id) || // escape object-id-form strings\n                id.startsWith('{')) {\n                  // escape object-form strings, for maybe implementing later\n                  return \"-\".concat(id);\n                } else {\n                  return id; // other strings go through unchanged.\n                }\n              } else if (id === undefined) {\n                return '-';\n              } else if (_typeof(id) === 'object' && id !== null) {\n                throw new Error('Meteor does not currently support objects other than ObjectID as ids');\n              } else {\n                // Numbers, true, false, null\n                return \"~\".concat(JSON.stringify(id));\n              }\n            };\n\n            _MongoID.idParse = function (id) {\n              if (id === '') {\n                return id;\n              } else if (id === '-') {\n                return undefined;\n              } else if (id.startsWith('-')) {\n                return id.substr(1);\n              } else if (id.startsWith('~')) {\n                return JSON.parse(id.substr(1));\n              } else if (_MongoID._looksLikeObjectID(id)) {\n                return new _MongoID.ObjectID(id);\n              } else {\n                return id;\n              }\n            }; ///////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/mongo-id/id.js\");\n  /* Exports */\n\n\n  Package._define(\"mongo-id\", exports, {\n    MongoID: MongoID\n  });\n})();\n\nmodule.exports = window.Package[\"mongo-id\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/mongo-id.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/mongo.js":
/*!**********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/mongo.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var AllowDeny = Package['allow-deny'].AllowDeny;\n  var Random = Package.random.Random;\n  var EJSON = Package.ejson.EJSON;\n  var LocalCollection = Package.minimongo.LocalCollection;\n  var Minimongo = Package.minimongo.Minimongo;\n  var DDP = Package['ddp-client'].DDP;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n  var DiffSequence = Package['diff-sequence'].DiffSequence;\n  var MongoID = Package['mongo-id'].MongoID;\n  var check = Package.check.check;\n  var Match = Package.check.Match;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var Mongo, selector, callback, options;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"mongo\": {\n          \"local_collection_driver.js\": function local_collection_driverJs(require, exports, module) {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/local_collection_driver.js                                                                          //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              LocalCollectionDriver: function LocalCollectionDriver() {\n                return _LocalCollectionDriver;\n              }\n            });\n\n            var _LocalCollectionDriver = new (\n            /*#__PURE__*/\n            function () {\n              function LocalCollectionDriver() {\n                _classCallCheck(this, LocalCollectionDriver);\n\n                this.noConnCollections = Object.create(null);\n              }\n\n              _createClass(LocalCollectionDriver, [{\n                key: \"open\",\n                value: function open(name, conn) {\n                  if (!name) {\n                    return new LocalCollection();\n                  }\n\n                  if (!conn) {\n                    return ensureCollection(name, this.noConnCollections);\n                  }\n\n                  if (!conn._mongo_livedata_collections) {\n                    conn._mongo_livedata_collections = Object.create(null);\n                  } // XXX is there a way to keep track of a connection's collections without\n                  // dangling it off the connection object?\n\n\n                  return ensureCollection(name, conn._mongo_livedata_collections);\n                }\n              }]);\n\n              return LocalCollectionDriver;\n            }())();\n\n            function ensureCollection(name, collections) {\n              return name in collections ? collections[name] : collections[name] = new LocalCollection(name);\n            } ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"collection.js\": function collectionJs(require, exports, module) {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/mongo/collection.js                                                                                       //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var _interopRequireDefault = require(\"@babel/runtime/helpers/builtin/interopRequireDefault\");\n\n            var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\")); // options.connection, if given, is a LivedataClient or LivedataServer\n            // XXX presently there is no way to destroy/clean up a Collection\n\n            /**\n             * @summary Namespace for MongoDB-related items\n             * @namespace\n             */\n\n\n            Mongo = {};\n            /**\n             * @summary Constructor for a Collection\n             * @locus Anywhere\n             * @instancename collection\n             * @class\n             * @param {String} name The name of the collection.  If null, creates an unmanaged (unsynchronized) local collection.\n             * @param {Object} [options]\n             * @param {Object} options.connection The server connection that will manage this collection. Uses the default connection if not specified.  Pass the return value of calling [`DDP.connect`](#ddp_connect) to specify a different server. Pass `null` to specify no connection. Unmanaged (`name` is null) collections cannot specify a connection.\n             * @param {String} options.idGeneration The method of generating the `_id` fields of new documents in this collection.  Possible values:\n            \n             - **`'STRING'`**: random strings\n             - **`'MONGO'`**:  random [`Mongo.ObjectID`](#mongo_object_id) values\n            \n            The default id generation technique is `'STRING'`.\n             * @param {Function} options.transform An optional transformation function. Documents will be passed through this function before being returned from `fetch` or `findOne`, and before being passed to callbacks of `observe`, `map`, `forEach`, `allow`, and `deny`. Transforms are *not* applied for the callbacks of `observeChanges` or to cursors returned from publish functions.\n             * @param {Boolean} options.defineMutationMethods Set to `false` to skip setting up the mutation methods that enable insert/update/remove from client code. Default `true`.\n             */\n\n            Mongo.Collection = function Collection(name, options) {\n              var _this = this;\n\n              if (!name && name !== null) {\n                Meteor._debug(\"Warning: creating anonymous collection. It will not be \" + \"saved or synchronized over the network. (Pass null for \" + \"the collection name to turn off this warning.)\");\n\n                name = null;\n              }\n\n              if (name !== null && typeof name !== \"string\") {\n                throw new Error(\"First argument to new Mongo.Collection must be a string or null\");\n              }\n\n              if (options && options.methods) {\n                // Backwards compatibility hack with original signature (which passed\n                // \"connection\" directly instead of in options. (Connections must have a \"methods\"\n                // method.)\n                // XXX remove before 1.0\n                options = {\n                  connection: options\n                };\n              } // Backwards compatibility: \"connection\" used to be called \"manager\".\n\n\n              if (options && options.manager && !options.connection) {\n                options.connection = options.manager;\n              }\n\n              options = (0, _objectSpread2.default)({\n                connection: undefined,\n                idGeneration: 'STRING',\n                transform: null,\n                _driver: undefined,\n                _preventAutopublish: false\n              }, options);\n\n              switch (options.idGeneration) {\n                case 'MONGO':\n                  this._makeNewID = function () {\n                    var src = name ? DDP.randomStream('/collection/' + name) : Random.insecure;\n                    return new Mongo.ObjectID(src.hexString(24));\n                  };\n\n                  break;\n\n                case 'STRING':\n                default:\n                  this._makeNewID = function () {\n                    var src = name ? DDP.randomStream('/collection/' + name) : Random.insecure;\n                    return src.id();\n                  };\n\n                  break;\n              }\n\n              this._transform = LocalCollection.wrapTransform(options.transform);\n              if (!name || options.connection === null) // note: nameless collections never have a connection\n                this._connection = null;else if (options.connection) this._connection = options.connection;else if (Meteor.isClient) this._connection = Meteor.connection;else this._connection = Meteor.server;\n\n              if (!options._driver) {\n                // XXX This check assumes that webapp is loaded so that Meteor.server !==\n                // null. We should fully support the case of \"want to use a Mongo-backed\n                // collection from Node code without webapp\", but we don't yet.\n                // #MeteorServerNull\n                if (name && this._connection === Meteor.server && typeof MongoInternals !== \"undefined\" && MongoInternals.defaultRemoteCollectionDriver) {\n                  options._driver = MongoInternals.defaultRemoteCollectionDriver();\n                } else {\n                  var _require = require(\"./local_collection_driver.js\"),\n                      _LocalCollectionDriver2 = _require.LocalCollectionDriver;\n\n                  options._driver = _LocalCollectionDriver2;\n                }\n              }\n\n              this._collection = options._driver.open(name, this._connection);\n              this._name = name;\n              this._driver = options._driver;\n\n              this._maybeSetUpReplication(name, options); // XXX don't define these until allow or deny is actually used for this\n              // collection. Could be hard if the security rules are only defined on the\n              // server.\n\n\n              if (options.defineMutationMethods !== false) {\n                try {\n                  this._defineMutationMethods({\n                    useExisting: options._suppressSameNameError === true\n                  });\n                } catch (error) {\n                  // Throw a more understandable error on the server for same collection name\n                  if (error.message === \"A method named '/\".concat(name, \"/insert' is already defined\")) throw new Error(\"There is already a collection named \\\"\".concat(name, \"\\\"\"));\n                  throw error;\n                }\n              } // autopublish\n\n\n              if (Package.autopublish && !options._preventAutopublish && this._connection && this._connection.publish) {\n                this._connection.publish(null, function () {\n                  return _this.find();\n                }, {\n                  is_auto: true\n                });\n              }\n            };\n\n            Object.assign(Mongo.Collection.prototype, {\n              _maybeSetUpReplication: function _maybeSetUpReplication(name, _ref) {\n                var _ref$_suppressSameNam = _ref._suppressSameNameError,\n                    _suppressSameNameError = _ref$_suppressSameNam === void 0 ? false : _ref$_suppressSameNam;\n\n                var self = this;\n\n                if (!(self._connection && self._connection.registerStore)) {\n                  return;\n                } // OK, we're going to be a slave, replicating some remote\n                // database, except possibly with some temporary divergence while\n                // we have unacknowledged RPC's.\n\n\n                var ok = self._connection.registerStore(name, {\n                  // Called at the beginning of a batch of updates. batchSize is the number\n                  // of update calls to expect.\n                  //\n                  // XXX This interface is pretty janky. reset probably ought to go back to\n                  // being its own function, and callers shouldn't have to calculate\n                  // batchSize. The optimization of not calling pause/remove should be\n                  // delayed until later: the first call to update() should buffer its\n                  // message, and then we can either directly apply it at endUpdate time if\n                  // it was the only update, or do pauseObservers/apply/apply at the next\n                  // update() if there's another one.\n                  beginUpdate: function beginUpdate(batchSize, reset) {\n                    // pause observers so users don't see flicker when updating several\n                    // objects at once (including the post-reconnect reset-and-reapply\n                    // stage), and so that a re-sorting of a query can take advantage of the\n                    // full _diffQuery moved calculation instead of applying change one at a\n                    // time.\n                    if (batchSize > 1 || reset) self._collection.pauseObservers();\n                    if (reset) self._collection.remove({});\n                  },\n                  // Apply an update.\n                  // XXX better specify this interface (not in terms of a wire message)?\n                  update: function update(msg) {\n                    var mongoId = MongoID.idParse(msg.id);\n\n                    var doc = self._collection.findOne(mongoId); // Is this a \"replace the whole doc\" message coming from the quiescence\n                    // of method writes to an object? (Note that 'undefined' is a valid\n                    // value meaning \"remove it\".)\n\n\n                    if (msg.msg === 'replace') {\n                      var replace = msg.replace;\n\n                      if (!replace) {\n                        if (doc) self._collection.remove(mongoId);\n                      } else if (!doc) {\n                        self._collection.insert(replace);\n                      } else {\n                        // XXX check that replace has no $ ops\n                        self._collection.update(mongoId, replace);\n                      }\n\n                      return;\n                    } else if (msg.msg === 'added') {\n                      if (doc) {\n                        throw new Error(\"Expected not to find a document already present for an add\");\n                      }\n\n                      self._collection.insert((0, _objectSpread2.default)({\n                        _id: mongoId\n                      }, msg.fields));\n                    } else if (msg.msg === 'removed') {\n                      if (!doc) throw new Error(\"Expected to find a document already present for removed\");\n\n                      self._collection.remove(mongoId);\n                    } else if (msg.msg === 'changed') {\n                      if (!doc) throw new Error(\"Expected to find a document to change\");\n                      var keys = Object.keys(msg.fields);\n\n                      if (keys.length > 0) {\n                        var modifier = {};\n                        keys.forEach(function (key) {\n                          var value = msg.fields[key];\n\n                          if (EJSON.equals(doc[key], value)) {\n                            return;\n                          }\n\n                          if (typeof value === \"undefined\") {\n                            if (!modifier.$unset) {\n                              modifier.$unset = {};\n                            }\n\n                            modifier.$unset[key] = 1;\n                          } else {\n                            if (!modifier.$set) {\n                              modifier.$set = {};\n                            }\n\n                            modifier.$set[key] = value;\n                          }\n                        });\n\n                        if (Object.keys(modifier).length > 0) {\n                          self._collection.update(mongoId, modifier);\n                        }\n                      }\n                    } else {\n                      throw new Error(\"I don't know how to deal with this message\");\n                    }\n                  },\n                  // Called at the end of a batch of updates.\n                  endUpdate: function endUpdate() {\n                    self._collection.resumeObservers();\n                  },\n                  // Called around method stub invocations to capture the original versions\n                  // of modified documents.\n                  saveOriginals: function saveOriginals() {\n                    self._collection.saveOriginals();\n                  },\n                  retrieveOriginals: function retrieveOriginals() {\n                    return self._collection.retrieveOriginals();\n                  },\n                  // Used to preserve current versions of documents across a store reset.\n                  getDoc: function getDoc(id) {\n                    return self.findOne(id);\n                  },\n                  // To be able to get back to the collection from the store.\n                  _getCollection: function _getCollection() {\n                    return self;\n                  }\n                });\n\n                if (!ok) {\n                  var message = \"There is already a collection named \\\"\".concat(name, \"\\\"\");\n\n                  if (_suppressSameNameError === true) {\n                    // XXX In theory we do not have to throw when `ok` is falsy. The\n                    // store is already defined for this collection name, but this\n                    // will simply be another reference to it and everything should\n                    // work. However, we have historically thrown an error here, so\n                    // for now we will skip the error only when _suppressSameNameError\n                    // is `true`, allowing people to opt in and give this some real\n                    // world testing.\n                    console.warn ? console.warn(message) : console.log(message);\n                  } else {\n                    throw new Error(message);\n                  }\n                }\n              },\n              ///\n              /// Main collection API\n              ///\n              _getFindSelector: function _getFindSelector(args) {\n                if (args.length == 0) return {};else return args[0];\n              },\n              _getFindOptions: function _getFindOptions(args) {\n                var self = this;\n\n                if (args.length < 2) {\n                  return {\n                    transform: self._transform\n                  };\n                } else {\n                  check(args[1], Match.Optional(Match.ObjectIncluding({\n                    fields: Match.Optional(Match.OneOf(Object, undefined)),\n                    sort: Match.Optional(Match.OneOf(Object, Array, Function, undefined)),\n                    limit: Match.Optional(Match.OneOf(Number, undefined)),\n                    skip: Match.Optional(Match.OneOf(Number, undefined))\n                  })));\n                  return (0, _objectSpread2.default)({\n                    transform: self._transform\n                  }, args[1]);\n                }\n              },\n\n              /**\n               * @summary Find the documents in a collection that match the selector.\n               * @locus Anywhere\n               * @method find\n               * @memberof Mongo.Collection\n               * @instance\n               * @param {MongoSelector} [selector] A query describing the documents to find\n               * @param {Object} [options]\n               * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n               * @param {Number} options.skip Number of results to skip at the beginning\n               * @param {Number} options.limit Maximum number of results to return\n               * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n               * @param {Boolean} options.reactive (Client only) Default `true`; pass `false` to disable reactivity\n               * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n               * @param {Boolean} options.disableOplog (Server only) Pass true to disable oplog-tailing on this query. This affects the way server processes calls to `observe` on this query. Disabling the oplog can be useful when working with data that updates in large batches.\n               * @param {Number} options.pollingIntervalMs (Server only) When oplog is disabled (through the use of `disableOplog` or when otherwise not available), the frequency (in milliseconds) of how often to poll this query when observing on the server. Defaults to 10000ms (10 seconds).\n               * @param {Number} options.pollingThrottleMs (Server only) When oplog is disabled (through the use of `disableOplog` or when otherwise not available), the minimum time (in milliseconds) to allow between re-polling when observing on the server. Increasing this will save CPU and mongo load at the expense of slower updates to users. Decreasing this is not recommended. Defaults to 50ms.\n               * @param {Number} options.maxTimeMs (Server only) If set, instructs MongoDB to set a time limit for this cursor's operations. If the operation reaches the specified time limit (in milliseconds) without the having been completed, an exception will be thrown. Useful to prevent an (accidental or malicious) unoptimized query from causing a full collection scan that would disrupt other database users, at the expense of needing to handle the resulting error.\n               * @param {String|Object} options.hint (Server only) Overrides MongoDB's default index selection and query optimization process. Specify an index to force its use, either by its name or index specification. You can also specify `{ $natural : 1 }` to force a forwards collection scan, or `{ $natural : -1 }` for a reverse collection scan. Setting this is only recommended for advanced users.\n               * @returns {Mongo.Cursor}\n               */\n              find: function find() {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                } // Collection.find() (return all docs) behaves differently\n                // from Collection.find(undefined) (return 0 docs).  so be\n                // careful about the length of arguments.\n\n\n                return this._collection.find(this._getFindSelector(args), this._getFindOptions(args));\n              },\n\n              /**\n               * @summary Finds the first document that matches the selector, as ordered by sort and skip options. Returns `undefined` if no matching document is found.\n               * @locus Anywhere\n               * @method findOne\n               * @memberof Mongo.Collection\n               * @instance\n               * @param {MongoSelector} [selector] A query describing the documents to find\n               * @param {Object} [options]\n               * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n               * @param {Number} options.skip Number of results to skip at the beginning\n               * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n               * @param {Boolean} options.reactive (Client only) Default true; pass false to disable reactivity\n               * @param {Function} options.transform Overrides `transform` on the [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n               * @returns {Object}\n               */\n              findOne: function findOne() {\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n\n                return this._collection.findOne(this._getFindSelector(args), this._getFindOptions(args));\n              }\n            });\n            Object.assign(Mongo.Collection, {\n              _publishCursor: function _publishCursor(cursor, sub, collection) {\n                var observeHandle = cursor.observeChanges({\n                  added: function added(id, fields) {\n                    sub.added(collection, id, fields);\n                  },\n                  changed: function changed(id, fields) {\n                    sub.changed(collection, id, fields);\n                  },\n                  removed: function removed(id) {\n                    sub.removed(collection, id);\n                  }\n                }); // We don't call sub.ready() here: it gets called in livedata_server, after\n                // possibly calling _publishCursor on multiple returned cursors.\n                // register stop callback (expects lambda w/ no args).\n\n                sub.onStop(function () {\n                  observeHandle.stop();\n                }); // return the observeHandle in case it needs to be stopped early\n\n                return observeHandle;\n              },\n              // protect against dangerous selectors.  falsey and {_id: falsey} are both\n              // likely programmer error, and not what you want, particularly for destructive\n              // operations. If a falsey _id is sent in, a new string _id will be\n              // generated and returned; if a fallbackId is provided, it will be returned\n              // instead.\n              _rewriteSelector: function _rewriteSelector(selector) {\n                var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n                    fallbackId = _ref2.fallbackId; // shorthand -- scalars match _id\n\n\n                if (LocalCollection._selectorIsId(selector)) selector = {\n                  _id: selector\n                };\n\n                if (Array.isArray(selector)) {\n                  // This is consistent with the Mongo console itself; if we don't do this\n                  // check passing an empty array ends up selecting all items\n                  throw new Error(\"Mongo selector can't be an array.\");\n                }\n\n                if (!selector || '_id' in selector && !selector._id) {\n                  // can't match anything\n                  return {\n                    _id: fallbackId || Random.id()\n                  };\n                }\n\n                return selector;\n              }\n            });\n            Object.assign(Mongo.Collection.prototype, {\n              // 'insert' immediately returns the inserted document's new _id.\n              // The others return values immediately if you are in a stub, an in-memory\n              // unmanaged collection, or a mongo-backed collection and you don't pass a\n              // callback. 'update' and 'remove' return the number of affected\n              // documents. 'upsert' returns an object with keys 'numberAffected' and, if an\n              // insert happened, 'insertedId'.\n              //\n              // Otherwise, the semantics are exactly like other methods: they take\n              // a callback as an optional last argument; if no callback is\n              // provided, they block until the operation is complete, and throw an\n              // exception if it fails; if a callback is provided, then they don't\n              // necessarily block, and they call the callback when they finish with error and\n              // result arguments.  (The insert method provides the document ID as its result;\n              // update and remove provide the number of affected docs as the result; upsert\n              // provides an object with numberAffected and maybe insertedId.)\n              //\n              // On the client, blocking is impossible, so if a callback\n              // isn't provided, they just return immediately and any error\n              // information is lost.\n              //\n              // There's one more tweak. On the client, if you don't provide a\n              // callback, then if there is an error, a message will be logged with\n              // Meteor._debug.\n              //\n              // The intent (though this is actually determined by the underlying\n              // drivers) is that the operations should be done synchronously, not\n              // generating their result until the database has acknowledged\n              // them. In the future maybe we should provide a flag to turn this\n              // off.\n\n              /**\n               * @summary Insert a document in the collection.  Returns its unique _id.\n               * @locus Anywhere\n               * @method  insert\n               * @memberof Mongo.Collection\n               * @instance\n               * @param {Object} doc The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.\n               * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the _id as the second.\n               */\n              insert: function insert(doc, callback) {\n                // Make sure we were passed a document to insert\n                if (!doc) {\n                  throw new Error(\"insert requires an argument\");\n                } // Make a shallow clone of the document, preserving its prototype.\n\n\n                doc = Object.create(Object.getPrototypeOf(doc), Object.getOwnPropertyDescriptors(doc));\n\n                if ('_id' in doc) {\n                  if (!doc._id || !(typeof doc._id === 'string' || doc._id instanceof Mongo.ObjectID)) {\n                    throw new Error(\"Meteor requires document _id fields to be non-empty strings or ObjectIDs\");\n                  }\n                } else {\n                  var generateId = true; // Don't generate the id if we're the client and the 'outermost' call\n                  // This optimization saves us passing both the randomSeed and the id\n                  // Passing both is redundant.\n\n                  if (this._isRemoteCollection()) {\n                    var enclosing = DDP._CurrentMethodInvocation.get();\n\n                    if (!enclosing) {\n                      generateId = false;\n                    }\n                  }\n\n                  if (generateId) {\n                    doc._id = this._makeNewID();\n                  }\n                } // On inserts, always return the id that we generated; on all other\n                // operations, just return the result from the collection.\n\n\n                var chooseReturnValueFromCollectionResult = function chooseReturnValueFromCollectionResult(result) {\n                  if (doc._id) {\n                    return doc._id;\n                  } // XXX what is this for??\n                  // It's some iteraction between the callback to _callMutatorMethod and\n                  // the return value conversion\n\n\n                  doc._id = result;\n                  return result;\n                };\n\n                var wrappedCallback = wrapCallback(callback, chooseReturnValueFromCollectionResult);\n\n                if (this._isRemoteCollection()) {\n                  var result = this._callMutatorMethod(\"insert\", [doc], wrappedCallback);\n\n                  return chooseReturnValueFromCollectionResult(result);\n                } // it's my collection.  descend into the collection object\n                // and propagate any exception.\n\n\n                try {\n                  // If the user provided a callback and the collection implements this\n                  // operation asynchronously, then queryRet will be undefined, and the\n                  // result will be returned through the callback instead.\n                  var _result = this._collection.insert(doc, wrappedCallback);\n\n                  return chooseReturnValueFromCollectionResult(_result);\n                } catch (e) {\n                  if (callback) {\n                    callback(e);\n                    return null;\n                  }\n\n                  throw e;\n                }\n              },\n\n              /**\n               * @summary Modify one or more documents in the collection. Returns the number of matched documents.\n               * @locus Anywhere\n               * @method update\n               * @memberof Mongo.Collection\n               * @instance\n               * @param {MongoSelector} selector Specifies which documents to modify\n               * @param {MongoModifier} modifier Specifies how to modify the documents\n               * @param {Object} [options]\n               * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n               * @param {Boolean} options.upsert True to insert a document if no matching documents are found.\n               * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n               */\n              update: function update(selector, modifier) {\n                for (var _len3 = arguments.length, optionsAndCallback = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n                  optionsAndCallback[_key3 - 2] = arguments[_key3];\n                }\n\n                var callback = popCallbackFromArgs(optionsAndCallback); // We've already popped off the callback, so we are left with an array\n                // of one or zero items\n\n                var options = (0, _objectSpread2.default)({}, optionsAndCallback[0] || null);\n                var insertedId;\n\n                if (options && options.upsert) {\n                  // set `insertedId` if absent.  `insertedId` is a Meteor extension.\n                  if (options.insertedId) {\n                    if (!(typeof options.insertedId === 'string' || options.insertedId instanceof Mongo.ObjectID)) throw new Error(\"insertedId must be string or ObjectID\");\n                    insertedId = options.insertedId;\n                  } else if (!selector || !selector._id) {\n                    insertedId = this._makeNewID();\n                    options.generatedId = true;\n                    options.insertedId = insertedId;\n                  }\n                }\n\n                selector = Mongo.Collection._rewriteSelector(selector, {\n                  fallbackId: insertedId\n                });\n                var wrappedCallback = wrapCallback(callback);\n\n                if (this._isRemoteCollection()) {\n                  var args = [selector, modifier, options];\n                  return this._callMutatorMethod(\"update\", args, wrappedCallback);\n                } // it's my collection.  descend into the collection object\n                // and propagate any exception.\n\n\n                try {\n                  // If the user provided a callback and the collection implements this\n                  // operation asynchronously, then queryRet will be undefined, and the\n                  // result will be returned through the callback instead.\n                  return this._collection.update(selector, modifier, options, wrappedCallback);\n                } catch (e) {\n                  if (callback) {\n                    callback(e);\n                    return null;\n                  }\n\n                  throw e;\n                }\n              },\n\n              /**\n               * @summary Remove documents from the collection\n               * @locus Anywhere\n               * @method remove\n               * @memberof Mongo.Collection\n               * @instance\n               * @param {MongoSelector} selector Specifies which documents to remove\n               * @param {Function} [callback] Optional.  If present, called with an error object as its argument.\n               */\n              remove: function remove(selector, callback) {\n                selector = Mongo.Collection._rewriteSelector(selector);\n                var wrappedCallback = wrapCallback(callback);\n\n                if (this._isRemoteCollection()) {\n                  return this._callMutatorMethod(\"remove\", [selector], wrappedCallback);\n                } // it's my collection.  descend into the collection object\n                // and propagate any exception.\n\n\n                try {\n                  // If the user provided a callback and the collection implements this\n                  // operation asynchronously, then queryRet will be undefined, and the\n                  // result will be returned through the callback instead.\n                  return this._collection.remove(selector, wrappedCallback);\n                } catch (e) {\n                  if (callback) {\n                    callback(e);\n                    return null;\n                  }\n\n                  throw e;\n                }\n              },\n              // Determine if this collection is simply a minimongo representation of a real\n              // database on another server\n              _isRemoteCollection: function _isRemoteCollection() {\n                // XXX see #MeteorServerNull\n                return this._connection && this._connection !== Meteor.server;\n              },\n\n              /**\n               * @summary Modify one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys `numberAffected` (the number of documents modified)  and `insertedId` (the unique _id of the document that was inserted, if any).\n               * @locus Anywhere\n               * @method upsert\n               * @memberof Mongo.Collection\n               * @instance\n               * @param {MongoSelector} selector Specifies which documents to modify\n               * @param {MongoModifier} modifier Specifies how to modify the documents\n               * @param {Object} [options]\n               * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n               * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n               */\n              upsert: function upsert(selector, modifier, options, callback) {\n                if (!callback && typeof options === \"function\") {\n                  callback = options;\n                  options = {};\n                }\n\n                return this.update(selector, modifier, (0, _objectSpread2.default)({}, options, {\n                  _returnObject: true,\n                  upsert: true\n                }), callback);\n              },\n              // We'll actually design an index API later. For now, we just pass through to\n              // Mongo's, but make it synchronous.\n              _ensureIndex: function _ensureIndex(index, options) {\n                var self = this;\n                if (!self._collection._ensureIndex) throw new Error(\"Can only call _ensureIndex on server collections\");\n\n                self._collection._ensureIndex(index, options);\n              },\n              _dropIndex: function _dropIndex(index) {\n                var self = this;\n                if (!self._collection._dropIndex) throw new Error(\"Can only call _dropIndex on server collections\");\n\n                self._collection._dropIndex(index);\n              },\n              _dropCollection: function _dropCollection() {\n                var self = this;\n                if (!self._collection.dropCollection) throw new Error(\"Can only call _dropCollection on server collections\");\n\n                self._collection.dropCollection();\n              },\n              _createCappedCollection: function _createCappedCollection(byteSize, maxDocuments) {\n                var self = this;\n                if (!self._collection._createCappedCollection) throw new Error(\"Can only call _createCappedCollection on server collections\");\n\n                self._collection._createCappedCollection(byteSize, maxDocuments);\n              },\n\n              /**\n               * @summary Returns the [`Collection`](http://mongodb.github.io/node-mongodb-native/3.0/api/Collection.html) object corresponding to this collection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n               * @locus Server\n               * @memberof Mongo.Collection\n               * @instance\n               */\n              rawCollection: function rawCollection() {\n                var self = this;\n\n                if (!self._collection.rawCollection) {\n                  throw new Error(\"Can only call rawCollection on server collections\");\n                }\n\n                return self._collection.rawCollection();\n              },\n\n              /**\n               * @summary Returns the [`Db`](http://mongodb.github.io/node-mongodb-native/3.0/api/Db.html) object corresponding to this collection's database connection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n               * @locus Server\n               * @memberof Mongo.Collection\n               * @instance\n               */\n              rawDatabase: function rawDatabase() {\n                var self = this;\n\n                if (!(self._driver.mongo && self._driver.mongo.db)) {\n                  throw new Error(\"Can only call rawDatabase on server collections\");\n                }\n\n                return self._driver.mongo.db;\n              }\n            }); // Convert the callback to not return a result if there is an error\n\n            function wrapCallback(callback, convertResult) {\n              return callback && function (error, result) {\n                if (error) {\n                  callback(error);\n                } else if (typeof convertResult === \"function\") {\n                  callback(null, convertResult(result));\n                } else {\n                  callback(null, result);\n                }\n              };\n            }\n            /**\n             * @summary Create a Mongo-style `ObjectID`.  If you don't specify a `hexString`, the `ObjectID` will generated randomly (not using MongoDB's ID construction rules).\n             * @locus Anywhere\n             * @class\n             * @param {String} [hexString] Optional.  The 24-character hexadecimal contents of the ObjectID to create\n             */\n\n\n            Mongo.ObjectID = MongoID.ObjectID;\n            /**\n             * @summary To create a cursor, use find. To access the documents in a cursor, use forEach, map, or fetch.\n             * @class\n             * @instanceName cursor\n             */\n\n            Mongo.Cursor = LocalCollection.Cursor;\n            /**\n             * @deprecated in 0.9.1\n             */\n\n            Mongo.Collection.Cursor = Mongo.Cursor;\n            /**\n             * @deprecated in 0.9.1\n             */\n\n            Mongo.Collection.ObjectID = Mongo.ObjectID;\n            /**\n             * @deprecated in 0.9.1\n             */\n\n            Meteor.Collection = Mongo.Collection; // Allow deny stuff is now in the allow-deny package\n\n            Object.assign(Meteor.Collection.prototype, AllowDeny.CollectionPrototype);\n\n            function popCallbackFromArgs(args) {\n              // Pull off any callback (or perhaps a 'callback' variable that was passed\n              // in undefined, like how 'upsert' does it).\n              if (args.length && (args[args.length - 1] === undefined || args[args.length - 1] instanceof Function)) {\n                return args.pop();\n              }\n            } ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  require(\"/node_modules/meteor/mongo/local_collection_driver.js\");\n\n  require(\"/node_modules/meteor/mongo/collection.js\");\n  /* Exports */\n\n\n  Package._define(\"mongo\", {\n    Mongo: Mongo\n  });\n})();\n\nmodule.exports = window.Package[\"mongo\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/mongo.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/ordered-dict.js":
/*!*****************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/ordered-dict.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var OrderedDict;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"ordered-dict\": {\n          \"ordered_dict.js\": function ordered_dictJs(require, exports, module) {\n            //////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                      //\n            // packages/ordered-dict/ordered_dict.js                                                                //\n            //                                                                                                      //\n            //////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              OrderedDict: function OrderedDict() {\n                return _OrderedDict;\n              }\n            }); // This file defines an ordered dictionary abstraction that is useful for\n            // maintaining a dataset backed by observeChanges.  It supports ordering items\n            // by specifying the item they now come before.\n            // The implementation is a dictionary that contains nodes of a doubly-linked\n            // list as its values.\n            // constructs a new element struct\n            // next and prev are whole elements, not keys.\n\n            function element(key, value, next, prev) {\n              return {\n                key: key,\n                value: value,\n                next: next,\n                prev: prev\n              };\n            }\n\n            var _OrderedDict =\n            /*#__PURE__*/\n            function () {\n              function _OrderedDict() {\n                var _this = this;\n\n                _classCallCheck(this, _OrderedDict);\n\n                this._dict = Object.create(null);\n                this._first = null;\n                this._last = null;\n                this._size = 0;\n\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n\n                if (typeof args[0] === 'function') {\n                  this._stringify = args.shift();\n                } else {\n                  this._stringify = function (x) {\n                    return x;\n                  };\n                }\n\n                args.forEach(function (kv) {\n                  return _this.putBefore(kv[0], kv[1], null);\n                });\n              } // the \"prefix keys with a space\" thing comes from here\n              // https://github.com/documentcloud/underscore/issues/376#issuecomment-2815649\n\n\n              _createClass(_OrderedDict, [{\n                key: \"_k\",\n                value: function _k(key) {\n                  return \" \" + this._stringify(key);\n                }\n              }, {\n                key: \"empty\",\n                value: function empty() {\n                  return !this._first;\n                }\n              }, {\n                key: \"size\",\n                value: function size() {\n                  return this._size;\n                }\n              }, {\n                key: \"_linkEltIn\",\n                value: function _linkEltIn(elt) {\n                  if (!elt.next) {\n                    elt.prev = this._last;\n                    if (this._last) this._last.next = elt;\n                    this._last = elt;\n                  } else {\n                    elt.prev = elt.next.prev;\n                    elt.next.prev = elt;\n                    if (elt.prev) elt.prev.next = elt;\n                  }\n\n                  if (this._first === null || this._first === elt.next) this._first = elt;\n                }\n              }, {\n                key: \"_linkEltOut\",\n                value: function _linkEltOut(elt) {\n                  if (elt.next) elt.next.prev = elt.prev;\n                  if (elt.prev) elt.prev.next = elt.next;\n                  if (elt === this._last) this._last = elt.prev;\n                  if (elt === this._first) this._first = elt.next;\n                }\n              }, {\n                key: \"putBefore\",\n                value: function putBefore(key, item, before) {\n                  if (this._dict[this._k(key)]) throw new Error(\"Item \" + key + \" already present in OrderedDict\");\n                  var elt = before ? element(key, item, this._dict[this._k(before)]) : element(key, item, null);\n                  if (typeof elt.next === \"undefined\") throw new Error(\"could not find item to put this one before\");\n\n                  this._linkEltIn(elt);\n\n                  this._dict[this._k(key)] = elt;\n                  this._size++;\n                }\n              }, {\n                key: \"append\",\n                value: function append(key, item) {\n                  this.putBefore(key, item, null);\n                }\n              }, {\n                key: \"remove\",\n                value: function remove(key) {\n                  var elt = this._dict[this._k(key)];\n\n                  if (typeof elt === \"undefined\") throw new Error(\"Item \" + key + \" not present in OrderedDict\");\n\n                  this._linkEltOut(elt);\n\n                  this._size--;\n                  delete this._dict[this._k(key)];\n                  return elt.value;\n                }\n              }, {\n                key: \"get\",\n                value: function get(key) {\n                  if (this.has(key)) {\n                    return this._dict[this._k(key)].value;\n                  }\n                }\n              }, {\n                key: \"has\",\n                value: function has(key) {\n                  return Object.prototype.hasOwnProperty.call(this._dict, this._k(key));\n                } // Iterate through the items in this dictionary in order, calling\n                // iter(value, key, index) on each one.\n                // Stops whenever iter returns OrderedDict.BREAK, or after the last element.\n\n              }, {\n                key: \"forEach\",\n                value: function forEach(iter) {\n                  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n                  var i = 0;\n                  var elt = this._first;\n\n                  while (elt !== null) {\n                    var b = iter.call(context, elt.value, elt.key, i);\n                    if (b === _OrderedDict.BREAK) return;\n                    elt = elt.next;\n                    i++;\n                  }\n                }\n              }, {\n                key: \"first\",\n                value: function first() {\n                  if (this.empty()) {\n                    return;\n                  }\n\n                  return this._first.key;\n                }\n              }, {\n                key: \"firstValue\",\n                value: function firstValue() {\n                  if (this.empty()) {\n                    return;\n                  }\n\n                  return this._first.value;\n                }\n              }, {\n                key: \"last\",\n                value: function last() {\n                  if (this.empty()) {\n                    return;\n                  }\n\n                  return this._last.key;\n                }\n              }, {\n                key: \"lastValue\",\n                value: function lastValue() {\n                  if (this.empty()) {\n                    return;\n                  }\n\n                  return this._last.value;\n                }\n              }, {\n                key: \"prev\",\n                value: function prev(key) {\n                  if (this.has(key)) {\n                    var elt = this._dict[this._k(key)];\n\n                    if (elt.prev) return elt.prev.key;\n                  }\n\n                  return null;\n                }\n              }, {\n                key: \"next\",\n                value: function next(key) {\n                  if (this.has(key)) {\n                    var elt = this._dict[this._k(key)];\n\n                    if (elt.next) return elt.next.key;\n                  }\n\n                  return null;\n                }\n              }, {\n                key: \"moveBefore\",\n                value: function moveBefore(key, before) {\n                  var elt = this._dict[this._k(key)];\n\n                  var eltBefore = before ? this._dict[this._k(before)] : null;\n\n                  if (typeof elt === \"undefined\") {\n                    throw new Error(\"Item to move is not present\");\n                  }\n\n                  if (typeof eltBefore === \"undefined\") {\n                    throw new Error(\"Could not find element to move this one before\");\n                  }\n\n                  if (eltBefore === elt.next) // no moving necessary\n                    return; // remove from its old place\n\n                  this._linkEltOut(elt); // patch into its new place\n\n\n                  elt.next = eltBefore;\n\n                  this._linkEltIn(elt);\n                } // Linear, sadly.\n\n              }, {\n                key: \"indexOf\",\n                value: function indexOf(key) {\n                  var _this2 = this;\n\n                  var ret = null;\n                  this.forEach(function (v, k, i) {\n                    if (_this2._k(k) === _this2._k(key)) {\n                      ret = i;\n                      return _OrderedDict.BREAK;\n                    }\n\n                    return;\n                  });\n                  return ret;\n                }\n              }, {\n                key: \"_checkRep\",\n                value: function _checkRep() {\n                  var _this3 = this;\n\n                  Object.keys(this._dict).forEach(function (k) {\n                    var v = _this3._dict[k];\n\n                    if (v.next === v) {\n                      throw new Error(\"Next is a loop\");\n                    }\n\n                    if (v.prev === v) {\n                      throw new Error(\"Prev is a loop\");\n                    }\n                  });\n                }\n              }]);\n\n              return _OrderedDict;\n            }();\n\n            _OrderedDict.BREAK = {\n              \"break\": true\n            }; //////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/ordered-dict/ordered_dict.js\");\n  /* Exports */\n\n\n  Package._define(\"ordered-dict\", exports, {\n    OrderedDict: OrderedDict\n  });\n})();\n\nmodule.exports = window.Package[\"ordered-dict\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/ordered-dict.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/promise.js":
/*!************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/promise.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  /* Package-scope variables */\n\n  var Promise;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"promise\": {\n          \"modern.js\": function modernJs() {\n            /////////////////////////////////////////////////////////////////////////////\n            //                                                                         //\n            // packages/promise/modern.js                                              //\n            //                                                                         //\n            /////////////////////////////////////////////////////////////////////////////\n            //\n            // Initialize the package-scoped Promise variable with global.Promise in\n            // all environments, even if it's not defined.\n            Promise = global.Promise; /////////////////////////////////////////////////////////////////////////////\n          },\n          \"client.js\": function clientJs(require) {\n            /////////////////////////////////////////////////////////////////////////////\n            //                                                                         //\n            // packages/promise/client.js                                              //\n            //                                                                         //\n            /////////////////////////////////////////////////////////////////////////////\n            //\n            require(\"./extensions.js\");\n\n            require(\"meteor-promise\").makeCompatible(Promise); /////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"extensions.js\": function extensionsJs() {\n            /////////////////////////////////////////////////////////////////////////////\n            //                                                                         //\n            // packages/promise/extensions.js                                          //\n            //                                                                         //\n            /////////////////////////////////////////////////////////////////////////////\n            //\n            var proto = Promise.prototype;\n            var hasOwn = Object.prototype.hasOwnProperty;\n\n            proto.done = function (onFulfilled, onRejected) {\n              var self = this;\n\n              if (arguments.length > 0) {\n                self = this.then.apply(this, arguments);\n              }\n\n              self.then(null, function (err) {\n                Meteor._setImmediate(function () {\n                  throw err;\n                });\n              });\n            };\n\n            if (!hasOwn.call(proto, \"finally\")) {\n              proto[\"finally\"] = function (onFinally) {\n                var threw = false,\n                    result;\n                return this.then(function (value) {\n                  result = value; // Most implementations of Promise.prototype.finally call\n                  // Promise.resolve(onFinally()) (or this.constructor.resolve or even\n                  // this.constructor[Symbol.species].resolve, depending on how spec\n                  // compliant they're trying to be), but this implementation simply\n                  // relies on the standard Promise behavior of resolving any value\n                  // returned from a .then callback function.\n\n                  return onFinally();\n                }, function (error) {\n                  // Make the final .then callback (below) re-throw the error instead\n                  // of returning it.\n                  threw = true;\n                  result = error;\n                  return onFinally();\n                }).then(function () {\n                  if (threw) throw result;\n                  return result;\n                });\n              };\n            } /////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"node_modules\": {\n            \"meteor-promise\": {\n              \"package.json\": function packageJson(require, exports) {\n                /////////////////////////////////////////////////////////////////////////////\n                //                                                                         //\n                // node_modules/meteor/promise/node_modules/meteor-promise/package.json    //\n                //                                                                         //\n                /////////////////////////////////////////////////////////////////////////////\n                //\n                exports.name = \"meteor-promise\";\n                exports.version = \"0.8.6\";\n                exports.browser = \"promise_client.js\";\n                exports.main = \"promise_server.js\"; /////////////////////////////////////////////////////////////////////////////\n              },\n              \"promise_client.js\": function promise_clientJs(require, exports) {\n                /////////////////////////////////////////////////////////////////////////////\n                //                                                                         //\n                // node_modules/meteor/promise/node_modules/meteor-promise/promise_client. //\n                //                                                                         //\n                /////////////////////////////////////////////////////////////////////////////\n                //\n                exports.makeCompatible = function (Promise) {\n                  var es6PromiseThen = Promise.prototype.then;\n\n                  Promise.prototype.then = function (onResolved, onRejected) {\n                    if (_typeof(Meteor) === \"object\" && typeof Meteor.bindEnvironment === \"function\") {\n                      return es6PromiseThen.call(this, onResolved && Meteor.bindEnvironment(onResolved, raise), onRejected && Meteor.bindEnvironment(onRejected, raise));\n                    }\n\n                    return es6PromiseThen.call(this, onResolved, onRejected);\n                  };\n                };\n\n                function raise(exception) {\n                  throw exception;\n                } /////////////////////////////////////////////////////////////////////////////\n\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  require(\"/node_modules/meteor/promise/modern.js\");\n\n  var exports = require(\"/node_modules/meteor/promise/client.js\");\n  /* Exports */\n\n\n  Package._define(\"promise\", exports, {\n    Promise: Promise\n  });\n})();\n\nmodule.exports = window.Package[\"promise\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/promise.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/random.js":
/*!***********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/random.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var Random;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"random\": {\n          \"random.js\": function randomJs(require) {\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                               //\n            // packages/random/random.js                                                                                     //\n            //                                                                                                               //\n            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // We use cryptographically strong PRNGs (crypto.getRandomBytes() on the server,\n            // window.crypto.getRandomValues() in the browser) when available. If these\n            // PRNGs fail, we fall back to the Alea PRNG, which is not cryptographically\n            // strong, and we seed it with various sources such as the date, Math.random,\n            // and window size on the client.  When using crypto.getRandomValues(), our\n            // primitive is hexString(), from which we construct fraction(). When using\n            // window.crypto.getRandomValues() or alea, the primitive is fraction and we use\n            // that to construct hex string.\n            if (Meteor.isServer) var nodeCrypto = Npm.require('crypto'); // see http://baagoe.org/en/wiki/Better_random_numbers_for_javascript\n            // for a full discussion and Alea implementation.\n\n            var Alea = function Alea() {\n              function Mash() {\n                var n = 0xefc8249d;\n\n                var mash = function mash(data) {\n                  data = data.toString();\n\n                  for (var i = 0; i < data.length; i++) {\n                    n += data.charCodeAt(i);\n                    var h = 0.02519603282416938 * n;\n                    n = h >>> 0;\n                    h -= n;\n                    h *= n;\n                    n = h >>> 0;\n                    h -= n;\n                    n += h * 0x100000000; // 2^32\n                  }\n\n                  return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n                };\n\n                mash.version = 'Mash 0.9';\n                return mash;\n              }\n\n              return function (args) {\n                var s0 = 0;\n                var s1 = 0;\n                var s2 = 0;\n                var c = 1;\n\n                if (args.length == 0) {\n                  args = [+new Date()];\n                }\n\n                var mash = Mash();\n                s0 = mash(' ');\n                s1 = mash(' ');\n                s2 = mash(' ');\n\n                for (var i = 0; i < args.length; i++) {\n                  s0 -= mash(args[i]);\n\n                  if (s0 < 0) {\n                    s0 += 1;\n                  }\n\n                  s1 -= mash(args[i]);\n\n                  if (s1 < 0) {\n                    s1 += 1;\n                  }\n\n                  s2 -= mash(args[i]);\n\n                  if (s2 < 0) {\n                    s2 += 1;\n                  }\n                }\n\n                mash = null;\n\n                var random = function random() {\n                  var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n\n                  s0 = s1;\n                  s1 = s2;\n                  return s2 = t - (c = t | 0);\n                };\n\n                random.uint32 = function () {\n                  return random() * 0x100000000; // 2^32\n                };\n\n                random.fract53 = function () {\n                  return random() + (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n                };\n\n                random.version = 'Alea 0.9';\n                random.args = args;\n                return random;\n              }(Array.prototype.slice.call(arguments));\n            };\n\n            var UNMISTAKABLE_CHARS = \"23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz\";\n            var BASE64_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"0123456789-_\"; // `type` is one of `RandomGenerator.Type` as defined below.\n            //\n            // options:\n            // - seeds: (required, only for RandomGenerator.Type.ALEA) an array\n            //   whose items will be `toString`ed and used as the seed to the Alea\n            //   algorithm\n\n            var RandomGenerator = function RandomGenerator(type, options) {\n              var self = this;\n              self.type = type;\n\n              if (!RandomGenerator.Type[type]) {\n                throw new Error(\"Unknown random generator type: \" + type);\n              }\n\n              if (type === RandomGenerator.Type.ALEA) {\n                if (!options.seeds) {\n                  throw new Error(\"No seeds were provided for Alea PRNG\");\n                }\n\n                self.alea = Alea.apply(null, options.seeds);\n              }\n            }; // Types of PRNGs supported by the `RandomGenerator` class\n\n\n            RandomGenerator.Type = {\n              // Use Node's built-in `crypto.getRandomBytes` (cryptographically\n              // secure but not seedable, runs only on the server). Reverts to\n              // `crypto.getPseudoRandomBytes` in the extremely uncommon case that\n              // there isn't enough entropy yet\n              NODE_CRYPTO: \"NODE_CRYPTO\",\n              // Use non-IE browser's built-in `window.crypto.getRandomValues`\n              // (cryptographically secure but not seedable, runs only in the\n              // browser).\n              BROWSER_CRYPTO: \"BROWSER_CRYPTO\",\n              // Use the *fast*, seedaable and not cryptographically secure\n              // Alea algorithm\n              ALEA: \"ALEA\"\n            };\n            /**\n             * @name Random.fraction\n             * @summary Return a number between 0 and 1, like `Math.random`.\n             * @locus Anywhere\n             */\n\n            RandomGenerator.prototype.fraction = function () {\n              var self = this;\n\n              if (self.type === RandomGenerator.Type.ALEA) {\n                return self.alea();\n              } else if (self.type === RandomGenerator.Type.NODE_CRYPTO) {\n                var numerator = parseInt(self.hexString(8), 16);\n                return numerator * 2.3283064365386963e-10; // 2^-32\n              } else if (self.type === RandomGenerator.Type.BROWSER_CRYPTO) {\n                var array = new Uint32Array(1);\n                window.crypto.getRandomValues(array);\n                return array[0] * 2.3283064365386963e-10; // 2^-32\n              } else {\n                throw new Error('Unknown random generator type: ' + self.type);\n              }\n            };\n            /**\n             * @name Random.hexString\n             * @summary Return a random string of `n` hexadecimal digits.\n             * @locus Anywhere\n             * @param {Number} n Length of the string\n             */\n\n\n            RandomGenerator.prototype.hexString = function (digits) {\n              var self = this;\n\n              if (self.type === RandomGenerator.Type.NODE_CRYPTO) {\n                var numBytes = Math.ceil(digits / 2);\n                var bytes; // Try to get cryptographically strong randomness. Fall back to\n                // non-cryptographically strong if not available.\n\n                try {\n                  bytes = nodeCrypto.randomBytes(numBytes);\n                } catch (e) {\n                  // XXX should re-throw any error except insufficient entropy\n                  bytes = nodeCrypto.pseudoRandomBytes(numBytes);\n                }\n\n                var result = bytes.toString(\"hex\"); // If the number of digits is odd, we'll have generated an extra 4 bits\n                // of randomness, so we need to trim the last digit.\n\n                return result.substring(0, digits);\n              } else {\n                return this._randomString(digits, \"0123456789abcdef\");\n              }\n            };\n\n            RandomGenerator.prototype._randomString = function (charsCount, alphabet) {\n              var self = this;\n              var digits = [];\n\n              for (var i = 0; i < charsCount; i++) {\n                digits[i] = self.choice(alphabet);\n              }\n\n              return digits.join(\"\");\n            };\n            /**\n             * @name Random.id\n             * @summary Return a unique identifier, such as `\"Jjwjg6gouWLXhMGKW\"`, that is\n             * likely to be unique in the whole world.\n             * @locus Anywhere\n             * @param {Number} [n] Optional length of the identifier in characters\n             *   (defaults to 17)\n             */\n\n\n            RandomGenerator.prototype.id = function (charsCount) {\n              var self = this; // 17 characters is around 96 bits of entropy, which is the amount of\n              // state in the Alea PRNG.\n\n              if (charsCount === undefined) charsCount = 17;\n              return self._randomString(charsCount, UNMISTAKABLE_CHARS);\n            };\n            /**\n             * @name Random.secret\n             * @summary Return a random string of printable characters with 6 bits of\n             * entropy per character. Use `Random.secret` for security-critical secrets\n             * that are intended for machine, rather than human, consumption.\n             * @locus Anywhere\n             * @param {Number} [n] Optional length of the secret string (defaults to 43\n             *   characters, or 256 bits of entropy)\n             */\n\n\n            RandomGenerator.prototype.secret = function (charsCount) {\n              var self = this; // Default to 256 bits of entropy, or 43 characters at 6 bits per\n              // character.\n\n              if (charsCount === undefined) charsCount = 43;\n              return self._randomString(charsCount, BASE64_CHARS);\n            };\n            /**\n             * @name Random.choice\n             * @summary Return a random element of the given array or string.\n             * @locus Anywhere\n             * @param {Array|String} arrayOrString Array or string to choose from\n             */\n\n\n            RandomGenerator.prototype.choice = function (arrayOrString) {\n              var index = Math.floor(this.fraction() * arrayOrString.length);\n              if (typeof arrayOrString === \"string\") return arrayOrString.substr(index, 1);else return arrayOrString[index];\n            }; // instantiate RNG.  Heuristically collect entropy from various sources when a\n            // cryptographic PRNG isn't available.\n            // client sources\n\n\n            var height = typeof window !== 'undefined' && window.innerHeight || typeof document !== 'undefined' && document.documentElement && document.documentElement.clientHeight || typeof document !== 'undefined' && document.body && document.body.clientHeight || 1;\n            var width = typeof window !== 'undefined' && window.innerWidth || typeof document !== 'undefined' && document.documentElement && document.documentElement.clientWidth || typeof document !== 'undefined' && document.body && document.body.clientWidth || 1;\n            var agent = typeof navigator !== 'undefined' && navigator.userAgent || \"\";\n\n            function createAleaGeneratorWithGeneratedSeed() {\n              return new RandomGenerator(RandomGenerator.Type.ALEA, {\n                seeds: [new Date(), height, width, agent, Math.random()]\n              });\n            }\n\n            ;\n\n            if (Meteor.isServer) {\n              Random = new RandomGenerator(RandomGenerator.Type.NODE_CRYPTO);\n            } else {\n              if (typeof window !== \"undefined\" && window.crypto && window.crypto.getRandomValues) {\n                Random = new RandomGenerator(RandomGenerator.Type.BROWSER_CRYPTO);\n              } else {\n                // On IE 10 and below, there's no browser crypto API\n                // available. Fall back to Alea\n                //\n                // XXX looks like at the moment, we use Alea in IE 11 as well,\n                // which has `window.msCrypto` instead of `window.crypto`.\n                Random = createAleaGeneratorWithGeneratedSeed();\n              }\n            } // Create a non-cryptographically secure PRNG with a given seed (using\n            // the Alea algorithm)\n\n\n            Random.createWithSeeds = function () {\n              for (var _len = arguments.length, seeds = new Array(_len), _key = 0; _key < _len; _key++) {\n                seeds[_key] = arguments[_key];\n              }\n\n              if (seeds.length === 0) {\n                throw new Error(\"No seeds were provided\");\n              }\n\n              return new RandomGenerator(RandomGenerator.Type.ALEA, {\n                seeds: seeds\n              });\n            }; // Used like `Random`, but much faster and not cryptographically\n            // secure\n\n\n            Random.insecure = createAleaGeneratorWithGeneratedSeed(); ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  require(\"/node_modules/meteor/random/random.js\");\n  /* Exports */\n\n\n  Package._define(\"random\", {\n    Random: Random\n  });\n})();\n\nmodule.exports = window.Package[\"random\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/random.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/reactive-var.js":
/*!*****************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/reactive-var.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var Tracker = Package.tracker.Tracker;\n  var Deps = Package.tracker.Deps;\n  /* Package-scope variables */\n\n  var _ReactiveVar;\n\n  (function () {\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                              //\n    // packages/reactive-var/reactive-var.js                                                                        //\n    //                                                                                                              //\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n\n    /*\n     * ## [new] ReactiveVar(initialValue, [equalsFunc])\n     *\n     * A ReactiveVar holds a single value that can be get and set,\n     * such that calling `set` will invalidate any Computations that\n     * called `get`, according to the usual contract for reactive\n     * data sources.\n     *\n     * A ReactiveVar is much like a Session variable -- compare `foo.get()`\n     * to `Session.get(\"foo\")` -- but it doesn't have a global name and isn't\n     * automatically migrated across hot code pushes.  Also, while Session\n     * variables can only hold JSON or EJSON, ReactiveVars can hold any value.\n     *\n     * An important property of ReactiveVars, which is sometimes the reason\n     * to use one, is that setting the value to the same value as before has\n     * no effect, meaning ReactiveVars can be used to absorb extra\n     * invalidations that wouldn't serve a purpose.  However, by default,\n     * ReactiveVars are extremely conservative about what changes they\n     * absorb.  Calling `set` with an object argument will *always* trigger\n     * invalidations, because even if the new value is `===` the old value,\n     * the object may have been mutated.  You can change the default behavior\n     * by passing a function of two arguments, `oldValue` and `newValue`,\n     * to the constructor as `equalsFunc`.\n     *\n     * This class is extremely basic right now, but the idea is to evolve\n     * it into the ReactiveVar of Geoff's Lickable Forms proposal.\n     */\n\n    /**\n     * @class \n     * @instanceName reactiveVar\n     * @summary Constructor for a ReactiveVar, which represents a single reactive variable.\n     * @locus Client\n     * @param {Any} initialValue The initial value to set.  `equalsFunc` is ignored when setting the initial value.\n     * @param {Function} [equalsFunc] Optional.  A function of two arguments, called on the old value and the new value whenever the ReactiveVar is set.  If it returns true, no set is performed.  If omitted, the default `equalsFunc` returns true if its arguments are `===` and are of type number, boolean, string, undefined, or null.\n     */\n    _ReactiveVar = function ReactiveVar(initialValue, equalsFunc) {\n      if (!(this instanceof _ReactiveVar)) // called without `new`\n        return new _ReactiveVar(initialValue, equalsFunc);\n      this.curValue = initialValue;\n      this.equalsFunc = equalsFunc;\n      this.dep = new Tracker.Dependency();\n    };\n\n    _ReactiveVar._isEqual = function (oldValue, newValue) {\n      var a = oldValue,\n          b = newValue; // Two values are \"equal\" here if they are `===` and are\n      // number, boolean, string, undefined, or null.\n\n      if (a !== b) return false;else return !a || typeof a === 'number' || typeof a === 'boolean' || typeof a === 'string';\n    };\n    /**\n     * @summary Returns the current value of the ReactiveVar, establishing a reactive dependency.\n     * @locus Client\n     */\n\n\n    _ReactiveVar.prototype.get = function () {\n      if (Tracker.active) this.dep.depend();\n      return this.curValue;\n    };\n    /**\n     * @summary Sets the current value of the ReactiveVar, invalidating the Computations that called `get` if `newValue` is different from the old value.\n     * @locus Client\n     * @param {Any} newValue\n     */\n\n\n    _ReactiveVar.prototype.set = function (newValue) {\n      var oldValue = this.curValue;\n      if ((this.equalsFunc || _ReactiveVar._isEqual)(oldValue, newValue)) // value is same as last time\n        return;\n      this.curValue = newValue;\n      this.dep.changed();\n    };\n\n    _ReactiveVar.prototype.toString = function () {\n      return 'ReactiveVar{' + this.get() + '}';\n    };\n\n    _ReactiveVar.prototype._numListeners = function () {\n      // Tests want to know.\n      // Accesses a private field of Tracker.Dependency.\n      var count = 0;\n\n      for (var id in this.dep._dependentsById) {\n        count++;\n      }\n\n      return count;\n    }; //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  }).call(this);\n  /* Exports */\n\n  Package._define(\"reactive-var\", {\n    ReactiveVar: _ReactiveVar\n  });\n})();\n\nmodule.exports = window.Package[\"reactive-var\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/reactive-var.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/reload.js":
/*!***********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/reload.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var Reload;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"reload\": {\n          \"reload.js\": function reloadJs(require, exports, module) {\n            ///////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                           //\n            // packages/reload/reload.js                                                                 //\n            //                                                                                           //\n            ///////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              Reload: function Reload() {\n                return _Reload;\n              }\n            });\n            var _Reload = {};\n            var KEY_NAME = 'Meteor_Reload';\n            var old_data = {}; // read in old data at startup.\n\n            var old_json; // This logic for sessionStorage detection is based on browserstate/history.js\n\n            var safeSessionStorage = null;\n\n            try {\n              // This throws a SecurityError on Chrome if cookies & localStorage are\n              // explicitly disabled\n              //\n              // On Firefox with dom.storage.enabled set to false, sessionStorage is null\n              //\n              // We can't even do (typeof sessionStorage) on Chrome, it throws.  So we rely\n              // on the throw if sessionStorage == null; the alternative is browser\n              // detection, but this seems better.\n              safeSessionStorage = window.sessionStorage; // Check we can actually use it\n\n              if (safeSessionStorage) {\n                safeSessionStorage.setItem('__dummy__', '1');\n                safeSessionStorage.removeItem('__dummy__');\n              } else {\n                // Be consistently null, for safety\n                safeSessionStorage = null;\n              }\n            } catch (e) {\n              // Expected on chrome with strict security, or if sessionStorage not supported\n              safeSessionStorage = null;\n            } // Exported for test.\n\n\n            _Reload._getData = function () {\n              return safeSessionStorage && safeSessionStorage.getItem(KEY_NAME);\n            };\n\n            if (safeSessionStorage) {\n              old_json = _Reload._getData();\n              safeSessionStorage.removeItem(KEY_NAME);\n            } else {// Unsupported browser (IE 6,7) or locked down security settings.\n              // No session resumption.\n              // Meteor._debug(\"XXX UNSUPPORTED BROWSER/SETTINGS\");\n            }\n\n            if (!old_json) old_json = '{}';\n            var old_parsed = {};\n\n            try {\n              old_parsed = JSON.parse(old_json);\n\n              if (_typeof(old_parsed) !== \"object\") {\n                Meteor._debug(\"Got bad data on reload. Ignoring.\");\n\n                old_parsed = {};\n              }\n            } catch (err) {\n              Meteor._debug(\"Got invalid JSON on reload. Ignoring.\");\n            }\n\n            if (old_parsed.reload && _typeof(old_parsed.data) === \"object\") {\n              // Meteor._debug(\"Restoring reload data.\");\n              old_data = old_parsed.data;\n            }\n\n            var providers = []; ////////// External API //////////\n            // Packages that support migration should register themselves by calling\n            // this function. When it's time to migrate, callback will be called\n            // with one argument, the \"retry function,\" and an optional 'option'\n            // argument (containing a key 'immediateMigration'). If the package\n            // is ready to migrate, it should return [true, data], where data is\n            // its migration data, an arbitrary JSON value (or [true] if it has\n            // no migration data this time). If the package needs more time\n            // before it is ready to migrate, it should return false. Then, once\n            // it is ready to migrating again, it should call the retry\n            // function. The retry function will return immediately, but will\n            // schedule the migration to be retried, meaning that every package\n            // will be polled once again for its migration data. If they are all\n            // ready this time, then the migration will happen. name must be set if there\n            // is migration data. If 'immediateMigration' is set in the options\n            // argument, then it doesn't matter whether the package is ready to\n            // migrate or not; the reload will happen immediately without waiting\n            // (used for OAuth redirect login).\n            //\n\n            _Reload._onMigrate = function (name, callback) {\n              if (!callback) {\n                // name not provided, so first arg is callback.\n                callback = name;\n                name = undefined;\n              }\n\n              providers.push({\n                name: name,\n                callback: callback\n              });\n            }; // Called by packages when they start up.\n            // Returns the object that was saved, or undefined if none saved.\n            //\n\n\n            _Reload._migrationData = function (name) {\n              return old_data[name];\n            }; // Options are the same as for `Reload._migrate`.\n\n\n            var pollProviders = function pollProviders(tryReload, options) {\n              tryReload = tryReload || function () {};\n\n              options = options || {};\n              var migrationData = {};\n              var remaining = providers.slice(0);\n              var allReady = true;\n\n              while (remaining.length) {\n                var p = remaining.shift();\n                var status = p.callback(tryReload, options);\n                if (!status[0]) allReady = false;\n                if (status.length > 1 && p.name) migrationData[p.name] = status[1];\n              }\n\n              ;\n              if (allReady || options.immediateMigration) return migrationData;else return null;\n            }; // Options are:\n            //  - immediateMigration: true if the page will be reloaded immediately\n            //    regardless of whether packages report that they are ready or not.\n\n\n            _Reload._migrate = function (tryReload, options) {\n              // Make sure each package is ready to go, and collect their\n              // migration data\n              var migrationData = pollProviders(tryReload, options);\n              if (migrationData === null) return false; // not ready yet..\n\n              try {\n                // Persist the migration data\n                var json = JSON.stringify({\n                  data: migrationData,\n                  reload: true\n                });\n              } catch (err) {\n                Meteor._debug(\"Couldn't serialize data for migration\", migrationData);\n\n                throw err;\n              }\n\n              if (safeSessionStorage) {\n                try {\n                  safeSessionStorage.setItem(KEY_NAME, json);\n                } catch (err) {\n                  // We should have already checked this, but just log - don't throw\n                  Meteor._debug(\"Couldn't save data for migration to sessionStorage\", err);\n                }\n              } else {\n                Meteor._debug(\"Browser does not support sessionStorage. Not saving migration state.\");\n              }\n\n              return true;\n            }; // Allows tests to isolate the list of providers.\n\n\n            _Reload._withFreshProvidersForTest = function (f) {\n              var originalProviders = providers.slice(0);\n              providers = [];\n\n              try {\n                f();\n              } finally {\n                providers = originalProviders;\n              }\n            }; // Migrating reload: reload this page (presumably to pick up a new\n            // version of the code or assets), but save the program state and\n            // migrate it over. This function returns immediately. The reload\n            // will happen at some point in the future once all of the packages\n            // are ready to migrate.\n            //\n\n\n            var reloading = false;\n\n            _Reload._reload = function (options) {\n              options = options || {};\n              if (reloading) return;\n              reloading = true;\n\n              function tryReload() {\n                setTimeout(reload, 1);\n              }\n\n              function reload() {\n                if (_Reload._migrate(tryReload, options)) {\n                  // We'd like to make the browser reload the page using location.replace()\n                  // instead of location.reload(), because this avoids validating assets\n                  // with the server if we still have a valid cached copy. This doesn't work\n                  // when the location contains a hash however, because that wouldn't reload\n                  // the page and just scroll to the hash location instead.\n                  if (window.location.hash || window.location.href.endsWith(\"#\")) {\n                    window.location.reload();\n                  } else {\n                    window.location.replace(window.location.href);\n                  }\n                }\n              }\n\n              tryReload();\n            }; ///////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/reload/reload.js\");\n  /* Exports */\n\n\n  Package._define(\"reload\", exports, {\n    Reload: Reload\n  });\n})();\n\nmodule.exports = window.Package[\"reload\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/reload.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/retry.js":
/*!**********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/retry.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var Random = Package.random.Random;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var Retry;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"retry\": {\n          \"retry.js\": function retryJs(require, exports, module) {\n            //////////////////////////////////////////////////////////////////////////////////\n            //                                                                              //\n            // packages/retry/retry.js                                                      //\n            //                                                                              //\n            //////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              Retry: function Retry() {\n                return _Retry;\n              }\n            });\n\n            var _Retry =\n            /*#__PURE__*/\n            function () {\n              function _Retry() {\n                _classCallCheck(this, _Retry);\n\n                var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                    _ref$baseTimeout = _ref.baseTimeout,\n                    baseTimeout = _ref$baseTimeout === void 0 ? 1000 : _ref$baseTimeout,\n                    _ref$exponent = _ref.exponent,\n                    exponent = _ref$exponent === void 0 ? 2.2 : _ref$exponent,\n                    _ref$maxTimeout = _ref.maxTimeout,\n                    maxTimeout = _ref$maxTimeout === void 0 ? 5 * 60 * 1000 : _ref$maxTimeout,\n                    _ref$minTimeout = _ref.minTimeout,\n                    minTimeout = _ref$minTimeout === void 0 ? 10 : _ref$minTimeout,\n                    _ref$minCount = _ref.minCount,\n                    minCount = _ref$minCount === void 0 ? 2 : _ref$minCount,\n                    _ref$fuzz = _ref.fuzz,\n                    fuzz = _ref$fuzz === void 0 ? 0.5 : _ref$fuzz;\n\n                this.baseTimeout = baseTimeout;\n                this.exponent = exponent;\n                this.maxTimeout = maxTimeout;\n                this.minTimeout = minTimeout;\n                this.minCount = minCount;\n                this.fuzz = fuzz;\n                this.retryTimer = null;\n              } // Reset a pending retry, if any.\n\n\n              _createClass(_Retry, [{\n                key: \"clear\",\n                value: function clear() {\n                  if (this.retryTimer) {\n                    clearTimeout(this.retryTimer);\n                  }\n\n                  this.retryTimer = null;\n                } // Calculate how long to wait in milliseconds to retry, based on the\n                // `count` of which retry this is.\n\n              }, {\n                key: \"_timeout\",\n                value: function _timeout(count) {\n                  if (count < this.minCount) {\n                    return this.minTimeout;\n                  } // fuzz the timeout randomly, to avoid reconnect storms when a\n                  // server goes down.\n\n\n                  var timeout = Math.min(this.maxTimeout, this.baseTimeout * Math.pow(this.exponent, count)) * (Random.fraction() * this.fuzz + (1 - this.fuzz / 2));\n                  return timeout;\n                } // Call `fn` after a delay, based on the `count` of which retry this is.\n\n              }, {\n                key: \"retryLater\",\n                value: function retryLater(count, fn) {\n                  var timeout = this._timeout(count);\n\n                  if (this.retryTimer) clearTimeout(this.retryTimer);\n                  this.retryTimer = Meteor.setTimeout(fn, timeout);\n                  return timeout;\n                }\n              }]);\n\n              return _Retry;\n            }(); //////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/retry/retry.js\");\n  /* Exports */\n\n\n  Package._define(\"retry\", exports, {\n    Retry: Retry\n  });\n})();\n\nmodule.exports = window.Package[\"retry\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/retry.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/shell-server.js":
/*!*****************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/shell-server.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/shell-server.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/socket-stream-client.js":
/*!*************************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/socket-stream-client.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var Retry = Package.retry.Retry;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var options, SockJS;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"socket-stream-client\": {\n          \"browser.js\": function browserJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/socket-stream-client/browser.js                                                                            //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var _interopRequireDefault = require(\"@babel/runtime/helpers/builtin/interopRequireDefault\");\n\n            var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\n            module.export({\n              ClientStream: function ClientStream() {\n                return _ClientStream;\n              }\n            });\n\n            var _toSockjsUrl, _toWebsocketUrl;\n\n            module.watch(require(\"./urls.js\"), {\n              toSockjsUrl: function toSockjsUrl(v) {\n                _toSockjsUrl = v;\n              },\n              toWebsocketUrl: function toWebsocketUrl(v) {\n                _toWebsocketUrl = v;\n              }\n            }, 0);\n\n            var _StreamClientCommon;\n\n            module.watch(require(\"./common.js\"), {\n              StreamClientCommon: function StreamClientCommon(v) {\n                _StreamClientCommon = v;\n              }\n            }, 1);\n            module.watch(require(\"./sockjs-0.3.4.js\"));\n\n            var _ClientStream =\n            /*#__PURE__*/\n            function (_StreamClientCommon2) {\n              _inherits(_ClientStream, _StreamClientCommon2);\n\n              // @param url {String} URL to Meteor app\n              //   \"http://subdomain.meteor.com/\" or \"/\" or\n              //   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\n              function _ClientStream(url, options) {\n                var _this;\n\n                _classCallCheck(this, _ClientStream);\n\n                _this = _possibleConstructorReturn(this, _getPrototypeOf(_ClientStream).call(this, options));\n\n                _this._initCommon(_this.options); //// Constants\n                // how long between hearing heartbeat from the server until we declare\n                // the connection dead. heartbeats come every 45s (stream_server.js)\n                //\n                // NOTE: this is a older timeout mechanism. We now send heartbeats at\n                // the DDP level (https://github.com/meteor/meteor/pull/1865), and\n                // expect those timeouts to kill a non-responsive connection before\n                // this timeout fires. This is kept around for compatibility (when\n                // talking to a server that doesn't support DDP heartbeats) and can be\n                // removed later.\n\n\n                _this.HEARTBEAT_TIMEOUT = 100 * 1000;\n                _this.rawUrl = url;\n                _this.socket = null;\n                _this.lastError = null;\n                _this.heartbeatTimer = null; // Listen to global 'online' event if we are running in a browser.\n                // (IE8 does not support addEventListener)\n\n                if (typeof window !== 'undefined' && window.addEventListener) window.addEventListener('online', _this._online.bind(_assertThisInitialized(_assertThisInitialized(_this))), false\n                /* useCapture. make FF3.6 happy. */\n                ); //// Kickoff!\n\n                _this._launchConnection();\n\n                return _this;\n              } // data is a utf8 string. Data sent while not connected is dropped on\n              // the floor, and it is up the user of this API to retransmit lost\n              // messages on 'reset'\n\n\n              _createClass(_ClientStream, [{\n                key: \"send\",\n                value: function send(data) {\n                  if (this.currentStatus.connected) {\n                    this.socket.send(data);\n                  }\n                } // Changes where this connection points\n\n              }, {\n                key: \"_changeUrl\",\n                value: function _changeUrl(url) {\n                  this.rawUrl = url;\n                }\n              }, {\n                key: \"_connected\",\n                value: function _connected() {\n                  if (this.connectionTimer) {\n                    clearTimeout(this.connectionTimer);\n                    this.connectionTimer = null;\n                  }\n\n                  if (this.currentStatus.connected) {\n                    // already connected. do nothing. this probably shouldn't happen.\n                    return;\n                  } // update status\n\n\n                  this.currentStatus.status = 'connected';\n                  this.currentStatus.connected = true;\n                  this.currentStatus.retryCount = 0;\n                  this.statusChanged(); // fire resets. This must come after status change so that clients\n                  // can call send from within a reset callback.\n\n                  this.forEachCallback('reset', function (callback) {\n                    callback();\n                  });\n                }\n              }, {\n                key: \"_cleanup\",\n                value: function _cleanup(maybeError) {\n                  this._clearConnectionAndHeartbeatTimers();\n\n                  if (this.socket) {\n                    this.socket.onmessage = this.socket.onclose = this.socket.onerror = this.socket.onheartbeat = function () {};\n\n                    this.socket.close();\n                    this.socket = null;\n                  }\n\n                  this.forEachCallback('disconnect', function (callback) {\n                    callback(maybeError);\n                  });\n                }\n              }, {\n                key: \"_clearConnectionAndHeartbeatTimers\",\n                value: function _clearConnectionAndHeartbeatTimers() {\n                  if (this.connectionTimer) {\n                    clearTimeout(this.connectionTimer);\n                    this.connectionTimer = null;\n                  }\n\n                  if (this.heartbeatTimer) {\n                    clearTimeout(this.heartbeatTimer);\n                    this.heartbeatTimer = null;\n                  }\n                }\n              }, {\n                key: \"_heartbeat_timeout\",\n                value: function _heartbeat_timeout() {\n                  console.log('Connection timeout. No sockjs heartbeat received.');\n\n                  this._lostConnection(new this.ConnectionError(\"Heartbeat timed out\"));\n                }\n              }, {\n                key: \"_heartbeat_received\",\n                value: function _heartbeat_received() {\n                  // If we've already permanently shut down this stream, the timeout is\n                  // already cleared, and we don't need to set it again.\n                  if (this._forcedToDisconnect) return;\n                  if (this.heartbeatTimer) clearTimeout(this.heartbeatTimer);\n                  this.heartbeatTimer = setTimeout(this._heartbeat_timeout.bind(this), this.HEARTBEAT_TIMEOUT);\n                }\n              }, {\n                key: \"_sockjsProtocolsWhitelist\",\n                value: function _sockjsProtocolsWhitelist() {\n                  // only allow polling protocols. no streaming.  streaming\n                  // makes safari spin.\n                  var protocolsWhitelist = ['xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling']; // iOS 4 and 5 and below crash when using websockets over certain\n                  // proxies. this seems to be resolved with iOS 6. eg\n                  // https://github.com/LearnBoost/socket.io/issues/193#issuecomment-7308865.\n                  //\n                  // iOS <4 doesn't support websockets at all so sockjs will just\n                  // immediately fall back to http\n\n                  var noWebsockets = navigator && /iPhone|iPad|iPod/.test(navigator.userAgent) && /OS 4_|OS 5_/.test(navigator.userAgent);\n                  if (!noWebsockets) protocolsWhitelist = ['websocket'].concat(protocolsWhitelist);\n                  return protocolsWhitelist;\n                }\n              }, {\n                key: \"_launchConnection\",\n                value: function _launchConnection() {\n                  var _this2 = this;\n\n                  this._cleanup(); // cleanup the old socket, if there was one.\n\n\n                  var options = (0, _objectSpread2.default)({\n                    protocols_whitelist: this._sockjsProtocolsWhitelist()\n                  }, this.options._sockjsOptions);\n                  var hasSockJS = typeof SockJS === \"function\";\n                  this.socket = hasSockJS // Convert raw URL to SockJS URL each time we open a connection, so\n                  // that we can connect to random hostnames and get around browser\n                  // per-host connection limits.\n                  ? new SockJS(_toSockjsUrl(this.rawUrl), undefined, options) : new WebSocket(_toWebsocketUrl(this.rawUrl));\n\n                  this.socket.onopen = function (data) {\n                    _this2.lastError = null;\n\n                    _this2._connected();\n                  };\n\n                  this.socket.onmessage = function (data) {\n                    _this2.lastError = null;\n\n                    _this2._heartbeat_received();\n\n                    if (_this2.currentStatus.connected) {\n                      _this2.forEachCallback('message', function (callback) {\n                        callback(data.data);\n                      });\n                    }\n                  };\n\n                  this.socket.onclose = function () {\n                    Promise.resolve( // If the socket is closing because there was an error, and we\n                    // didn't load SockJS before, try loading it dynamically before\n                    // retrying the connection.\n                    _this2.lastError && !hasSockJS && module.dynamicImport(\"./sockjs-0.3.4.js\")).done(function () {\n                      _this2._lostConnection();\n                    });\n                  };\n\n                  this.socket.onerror = function (error) {\n                    var lastError = _this2.lastError;\n                    _this2.lastError = error;\n                    if (lastError) return;\n                    console.log('stream error', error, new Date().toDateString());\n                  };\n\n                  this.socket.onheartbeat = function () {\n                    _this2.lastError = null;\n\n                    _this2._heartbeat_received();\n                  };\n\n                  if (this.connectionTimer) clearTimeout(this.connectionTimer);\n                  this.connectionTimer = setTimeout(function () {\n                    _this2._lostConnection(new _this2.ConnectionError(\"DDP connection timed out\"));\n                  }, this.CONNECT_TIMEOUT);\n                }\n              }]);\n\n              return _ClientStream;\n            }(_StreamClientCommon); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"common.js\": function commonJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/socket-stream-client/common.js                                                                             //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            var _interopRequireDefault = require(\"@babel/runtime/helpers/builtin/interopRequireDefault\");\n\n            var _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/builtin/objectSpread\"));\n\n            module.export({\n              StreamClientCommon: function StreamClientCommon() {\n                return _StreamClientCommon3;\n              }\n            });\n\n            var _Retry;\n\n            module.watch(require(\"meteor/retry\"), {\n              Retry: function Retry(v) {\n                _Retry = v;\n              }\n            }, 0);\n            var forcedReconnectError = new Error(\"forced reconnect\");\n\n            var _StreamClientCommon3 =\n            /*#__PURE__*/\n            function () {\n              function _StreamClientCommon3(options) {\n                _classCallCheck(this, _StreamClientCommon3);\n\n                this.options = (0, _objectSpread2.default)({\n                  retry: true\n                }, options || null);\n                this.ConnectionError = options && options.ConnectionError || Error;\n              } // Register for callbacks.\n\n\n              _createClass(_StreamClientCommon3, [{\n                key: \"on\",\n                value: function on(name, callback) {\n                  if (name !== 'message' && name !== 'reset' && name !== 'disconnect') throw new Error('unknown event type: ' + name);\n                  if (!this.eventCallbacks[name]) this.eventCallbacks[name] = [];\n                  this.eventCallbacks[name].push(callback);\n                }\n              }, {\n                key: \"forEachCallback\",\n                value: function forEachCallback(name, cb) {\n                  if (!this.eventCallbacks[name] || !this.eventCallbacks[name].length) {\n                    return;\n                  }\n\n                  this.eventCallbacks[name].forEach(cb);\n                }\n              }, {\n                key: \"_initCommon\",\n                value: function _initCommon(options) {\n                  var _this3 = this;\n\n                  options = options || Object.create(null); //// Constants\n                  // how long to wait until we declare the connection attempt\n                  // failed.\n\n                  this.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;\n                  this.eventCallbacks = Object.create(null); // name -> [callback]\n\n                  this._forcedToDisconnect = false; //// Reactive status\n\n                  this.currentStatus = {\n                    status: 'connecting',\n                    connected: false,\n                    retryCount: 0\n                  };\n\n                  if (Package.tracker) {\n                    this.statusListeners = new Package.tracker.Tracker.Dependency();\n                  }\n\n                  this.statusChanged = function () {\n                    if (_this3.statusListeners) {\n                      _this3.statusListeners.changed();\n                    }\n                  }; //// Retry logic\n\n\n                  this._retry = new _Retry();\n                  this.connectionTimer = null;\n                } // Trigger a reconnect.\n\n              }, {\n                key: \"reconnect\",\n                value: function reconnect(options) {\n                  options = options || Object.create(null);\n\n                  if (options.url) {\n                    this._changeUrl(options.url);\n                  }\n\n                  if (options._sockjsOptions) {\n                    this.options._sockjsOptions = options._sockjsOptions;\n                  }\n\n                  if (this.currentStatus.connected) {\n                    if (options._force || options.url) {\n                      this._lostConnection(forcedReconnectError);\n                    }\n\n                    return;\n                  } // if we're mid-connection, stop it.\n\n\n                  if (this.currentStatus.status === 'connecting') {\n                    // Pretend it's a clean close.\n                    this._lostConnection();\n                  }\n\n                  this._retry.clear();\n\n                  this.currentStatus.retryCount -= 1; // don't count manual retries\n\n                  this._retryNow();\n                }\n              }, {\n                key: \"disconnect\",\n                value: function disconnect(options) {\n                  options = options || Object.create(null); // Failed is permanent. If we're failed, don't let people go back\n                  // online by calling 'disconnect' then 'reconnect'.\n\n                  if (this._forcedToDisconnect) return; // If _permanent is set, permanently disconnect a stream. Once a stream\n                  // is forced to disconnect, it can never reconnect. This is for\n                  // error cases such as ddp version mismatch, where trying again\n                  // won't fix the problem.\n\n                  if (options._permanent) {\n                    this._forcedToDisconnect = true;\n                  }\n\n                  this._cleanup();\n\n                  this._retry.clear();\n\n                  this.currentStatus = {\n                    status: options._permanent ? 'failed' : 'offline',\n                    connected: false,\n                    retryCount: 0\n                  };\n                  if (options._permanent && options._error) this.currentStatus.reason = options._error;\n                  this.statusChanged();\n                } // maybeError is set unless it's a clean protocol-level close.\n\n              }, {\n                key: \"_lostConnection\",\n                value: function _lostConnection(maybeError) {\n                  this._cleanup(maybeError);\n\n                  this._retryLater(maybeError); // sets status. no need to do it here.\n\n                } // fired when we detect that we've gone online. try to reconnect\n                // immediately.\n\n              }, {\n                key: \"_online\",\n                value: function _online() {\n                  // if we've requested to be offline by disconnecting, don't reconnect.\n                  if (this.currentStatus.status != 'offline') this.reconnect();\n                }\n              }, {\n                key: \"_retryLater\",\n                value: function _retryLater(maybeError) {\n                  var timeout = 0;\n\n                  if (this.options.retry || maybeError === forcedReconnectError) {\n                    timeout = this._retry.retryLater(this.currentStatus.retryCount, this._retryNow.bind(this));\n                    this.currentStatus.status = 'waiting';\n                    this.currentStatus.retryTime = new Date().getTime() + timeout;\n                  } else {\n                    this.currentStatus.status = 'failed';\n                    delete this.currentStatus.retryTime;\n                  }\n\n                  this.currentStatus.connected = false;\n                  this.statusChanged();\n                }\n              }, {\n                key: \"_retryNow\",\n                value: function _retryNow() {\n                  if (this._forcedToDisconnect) return;\n                  this.currentStatus.retryCount += 1;\n                  this.currentStatus.status = 'connecting';\n                  this.currentStatus.connected = false;\n                  delete this.currentStatus.retryTime;\n                  this.statusChanged();\n\n                  this._launchConnection();\n                } // Get current status. Reactive.\n\n              }, {\n                key: \"status\",\n                value: function status() {\n                  if (this.statusListeners) {\n                    this.statusListeners.depend();\n                  }\n\n                  return this.currentStatus;\n                }\n              }]);\n\n              return _StreamClientCommon3;\n            }(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"sockjs-0.3.4.js\": function sockjs034Js(require) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/socket-stream-client/sockjs-0.3.4.js                                                                       //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            // XXX METEOR changes in <METEOR>\n\n            /* SockJS client, version 0.3.4, http://sockjs.org, MIT License\n            \n            Copyright (c) 2011-2012 VMware, Inc.\n            \n            Permission is hereby granted, free of charge, to any person obtaining a copy\n            of this software and associated documentation files (the \"Software\"), to deal\n            in the Software without restriction, including without limitation the rights\n            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n            copies of the Software, and to permit persons to whom the Software is\n            furnished to do so, subject to the following conditions:\n            \n            The above copyright notice and this permission notice shall be included in\n            all copies or substantial portions of the Software.\n            \n            THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n            THE SOFTWARE.\n            */\n            // <METEOR> Commented out JSO implementation (use json package instead).\n            // JSON2 by Douglas Crockford (minified).\n            // var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i==\"object\"&&typeof i.toJSON==\"function\"&&(i=i.toJSON(a)),typeof rep==\"function\"&&(i=rep.call(b,a,i));switch(typeof i){case\"string\":return quote(i);case\"number\":return isFinite(i)?String(i):\"null\";case\"boolean\":case\"null\":return String(i);case\"object\":if(!i)return\"null\";gap+=indent,h=[];if(Object.prototype.toString.apply(i)===\"[object Array]\"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||\"null\";e=h.length===0?\"[]\":gap?\"[\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"]\":\"[\"+h.join(\",\")+\"]\",gap=g;return e}if(rep&&typeof rep==\"object\"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]==\"string\"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e));e=h.length===0?\"{}\":gap?\"{\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"}\":\"{\"+h.join(\",\")+\"}\",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'\"'+a.replace(escapable,function(a){var b=meta[a];return typeof b==\"string\"?b:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+a+'\"'}function f(a){return a<10?\"0\"+a:a}\"use strict\",typeof Date.prototype.toJSON!=\"function\"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+\"-\"+f(this.getUTCMonth()+1)+\"-\"+f(this.getUTCDate())+\"T\"+f(this.getUTCHours())+\":\"+f(this.getUTCMinutes())+\":\"+f(this.getUTCSeconds())+\"Z\":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;typeof JSON.stringify!=\"function\"&&(JSON.stringify=function(a,b,c){var d;gap=\"\",indent=\"\";if(typeof c==\"number\")for(d=0;d<c;d+=1)indent+=\" \";else typeof c==\"string\"&&(indent=c);rep=b;if(!b||typeof b==\"function\"||typeof b==\"object\"&&typeof b.length==\"number\")return str(\"\",{\"\":a});throw new Error(\"JSON.stringify\")}),typeof JSON.parse!=\"function\"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e==\"object\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\"))){j=eval(\"(\"+text+\")\");return typeof reviver==\"function\"?walk({\"\":j},\"\"):j}throw new SyntaxError(\"JSON.parse\")})}()\n            // </METEOR>\n            //     [*] Including lib/index.js\n            // Public object\n            SockJS = function () {\n              var _document = document;\n              var _window = window;\n              var utils = {}; //         [*] Including lib/reventtarget.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n              /* Simplified implementation of DOM2 EventTarget.\n               *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\n               */\n\n              var REventTarget = function REventTarget() {};\n\n              REventTarget.prototype.addEventListener = function (eventType, listener) {\n                if (!this._listeners) {\n                  this._listeners = {};\n                }\n\n                if (!(eventType in this._listeners)) {\n                  this._listeners[eventType] = [];\n                }\n\n                var arr = this._listeners[eventType];\n\n                if (utils.arrIndexOf(arr, listener) === -1) {\n                  arr.push(listener);\n                }\n\n                return;\n              };\n\n              REventTarget.prototype.removeEventListener = function (eventType, listener) {\n                if (!(this._listeners && eventType in this._listeners)) {\n                  return;\n                }\n\n                var arr = this._listeners[eventType];\n                var idx = utils.arrIndexOf(arr, listener);\n\n                if (idx !== -1) {\n                  if (arr.length > 1) {\n                    this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));\n                  } else {\n                    delete this._listeners[eventType];\n                  }\n\n                  return;\n                }\n\n                return;\n              };\n\n              REventTarget.prototype.dispatchEvent = function (event) {\n                var t = event.type;\n                var args = Array.prototype.slice.call(arguments, 0);\n\n                if (this['on' + t]) {\n                  this['on' + t].apply(this, args);\n                }\n\n                if (this._listeners && t in this._listeners) {\n                  for (var i = 0; i < this._listeners[t].length; i++) {\n                    this._listeners[t][i].apply(this, args);\n                  }\n                }\n              }; //         [*] End of lib/reventtarget.js\n              //         [*] Including lib/simpleevent.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var SimpleEvent = function SimpleEvent(type, obj) {\n                this.type = type;\n\n                if (typeof obj !== 'undefined') {\n                  for (var k in obj) {\n                    if (!obj.hasOwnProperty(k)) continue;\n                    this[k] = obj[k];\n                  }\n                }\n              };\n\n              SimpleEvent.prototype.toString = function () {\n                var r = [];\n\n                for (var k in this) {\n                  if (!this.hasOwnProperty(k)) continue;\n                  var v = this[k];\n                  if (typeof v === 'function') v = '[function]';\n                  r.push(k + '=' + v);\n                }\n\n                return 'SimpleEvent(' + r.join(', ') + ')';\n              }; //         [*] End of lib/simpleevent.js\n              //         [*] Including lib/eventemitter.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var EventEmitter = function EventEmitter(events) {\n                var that = this;\n                that._events = events || [];\n                that._listeners = {};\n              };\n\n              EventEmitter.prototype.emit = function (type) {\n                var that = this;\n\n                that._verifyType(type);\n\n                if (that._nuked) return;\n                var args = Array.prototype.slice.call(arguments, 1);\n\n                if (that['on' + type]) {\n                  that['on' + type].apply(that, args);\n                }\n\n                if (type in that._listeners) {\n                  for (var i = 0; i < that._listeners[type].length; i++) {\n                    that._listeners[type][i].apply(that, args);\n                  }\n                }\n              };\n\n              EventEmitter.prototype.on = function (type, callback) {\n                var that = this;\n\n                that._verifyType(type);\n\n                if (that._nuked) return;\n\n                if (!(type in that._listeners)) {\n                  that._listeners[type] = [];\n                }\n\n                that._listeners[type].push(callback);\n              };\n\n              EventEmitter.prototype._verifyType = function (type) {\n                var that = this;\n\n                if (utils.arrIndexOf(that._events, type) === -1) {\n                  utils.log('Event ' + JSON.stringify(type) + ' not listed ' + JSON.stringify(that._events) + ' in ' + that);\n                }\n              };\n\n              EventEmitter.prototype.nuke = function () {\n                var that = this;\n                that._nuked = true;\n\n                for (var i = 0; i < that._events.length; i++) {\n                  delete that[that._events[i]];\n                }\n\n                that._listeners = {};\n              }; //         [*] End of lib/eventemitter.js\n              //         [*] Including lib/utils.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\n\n              utils.random_string = function (length, max) {\n                max = max || random_string_chars.length;\n                var i,\n                    ret = [];\n\n                for (i = 0; i < length; i++) {\n                  ret.push(random_string_chars.substr(Math.floor(Math.random() * max), 1));\n                }\n\n                return ret.join('');\n              };\n\n              utils.random_number = function (max) {\n                return Math.floor(Math.random() * max);\n              };\n\n              utils.random_number_string = function (max) {\n                var t = ('' + (max - 1)).length;\n                var p = Array(t + 1).join('0');\n                return (p + utils.random_number(max)).slice(-t);\n              }; // Assuming that url looks like: http://asdasd:111/asd\n\n\n              utils.getOrigin = function (url) {\n                url += '/';\n                var parts = url.split('/').slice(0, 3);\n                return parts.join('/');\n              };\n\n              utils.isSameOriginUrl = function (url_a, url_b) {\n                // location.origin would do, but it's not always available.\n                if (!url_b) url_b = _window.location.href;\n                return url_a.split('/').slice(0, 3).join('/') === url_b.split('/').slice(0, 3).join('/');\n              }; // <METEOR>\n              // https://github.com/sockjs/sockjs-client/issues/79\n\n\n              utils.isSameOriginScheme = function (url_a, url_b) {\n                if (!url_b) url_b = _window.location.href;\n                return url_a.split(':')[0] === url_b.split(':')[0];\n              }; // </METEOR>\n\n\n              utils.getParentDomain = function (url) {\n                // ipv4 ip address\n                if (/^[0-9.]*$/.test(url)) return url; // ipv6 ip address\n\n                if (/^\\[/.test(url)) return url; // no dots\n\n                if (!/[.]/.test(url)) return url;\n                var parts = url.split('.').slice(1);\n                return parts.join('.');\n              };\n\n              utils.objectExtend = function (dst, src) {\n                for (var k in src) {\n                  if (src.hasOwnProperty(k)) {\n                    dst[k] = src[k];\n                  }\n                }\n\n                return dst;\n              };\n\n              var WPrefix = '_jp';\n\n              utils.polluteGlobalNamespace = function () {\n                if (!(WPrefix in _window)) {\n                  _window[WPrefix] = {};\n                }\n              };\n\n              utils.closeFrame = function (code, reason) {\n                return 'c' + JSON.stringify([code, reason]);\n              };\n\n              utils.userSetCode = function (code) {\n                return code === 1000 || code >= 3000 && code <= 4999;\n              }; // See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\n              // and RFC 2988.\n\n\n              utils.countRTO = function (rtt) {\n                var rto;\n\n                if (rtt > 100) {\n                  rto = 3 * rtt; // rto > 300msec\n                } else {\n                  rto = rtt + 200; // 200msec < rto <= 300msec\n                }\n\n                return rto;\n              };\n\n              utils.log = function () {\n                if (_window.console && console.log && console.log.apply) {\n                  console.log.apply(console, arguments);\n                }\n              };\n\n              utils.bind = function (fun, that) {\n                if (fun.bind) {\n                  return fun.bind(that);\n                } else {\n                  return function () {\n                    return fun.apply(that, arguments);\n                  };\n                }\n              };\n\n              utils.flatUrl = function (url) {\n                return url.indexOf('?') === -1 && url.indexOf('#') === -1;\n              }; // `relativeTo` is an optional absolute URL. If provided, `url` will be\n              // interpreted relative to `relativeTo`. Defaults to `document.location`.\n              // <METEOR>\n\n\n              utils.amendUrl = function (url, relativeTo) {\n                var baseUrl;\n\n                if (relativeTo === undefined) {\n                  baseUrl = _document.location;\n                } else {\n                  var protocolMatch = /^([a-z0-9.+-]+:)/i.exec(relativeTo);\n\n                  if (protocolMatch) {\n                    var protocol = protocolMatch[0].toLowerCase();\n                    var rest = relativeTo.substring(protocol.length);\n                    var hostMatch = /[a-z0-9\\.-]+(:[0-9]+)?/.exec(rest);\n                    if (hostMatch) var host = hostMatch[0];\n                  }\n\n                  if (!protocol || !host) throw new Error(\"relativeTo must be an absolute url\");\n                  baseUrl = {\n                    protocol: protocol,\n                    host: host\n                  };\n                }\n\n                if (!url) {\n                  throw new Error('Wrong url for SockJS');\n                }\n\n                if (!utils.flatUrl(url)) {\n                  throw new Error('Only basic urls are supported in SockJS');\n                } //  '//abc' --> 'http://abc'\n\n\n                if (url.indexOf('//') === 0) {\n                  url = baseUrl.protocol + url;\n                } // '/abc' --> 'http://localhost:1234/abc'\n\n\n                if (url.indexOf('/') === 0) {\n                  url = baseUrl.protocol + '//' + baseUrl.host + url;\n                } // </METEOR>\n                // strip trailing slashes\n\n\n                url = url.replace(/[/]+$/, ''); // We have a full url here, with proto and host. For some browsers\n                // http://localhost:80/ is not in the same origin as http://localhost/\n                // Remove explicit :80 or :443 in such cases. See #74\n\n                var parts = url.split(\"/\");\n\n                if (parts[0] === \"http:\" && /:80$/.test(parts[2]) || parts[0] === \"https:\" && /:443$/.test(parts[2])) {\n                  parts[2] = parts[2].replace(/:(80|443)$/, \"\");\n                }\n\n                url = parts.join(\"/\");\n                return url;\n              }; // IE doesn't support [].indexOf.\n\n\n              utils.arrIndexOf = function (arr, obj) {\n                for (var i = 0; i < arr.length; i++) {\n                  if (arr[i] === obj) {\n                    return i;\n                  }\n                }\n\n                return -1;\n              };\n\n              utils.arrSkip = function (arr, obj) {\n                var idx = utils.arrIndexOf(arr, obj);\n\n                if (idx === -1) {\n                  return arr.slice();\n                } else {\n                  var dst = arr.slice(0, idx);\n                  return dst.concat(arr.slice(idx + 1));\n                }\n              }; // Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df\n\n\n              utils.isArray = Array.isArray || function (value) {\n                return {}.toString.call(value).indexOf('Array') >= 0;\n              };\n\n              utils.delay = function (t, fun) {\n                if (typeof t === 'function') {\n                  fun = t;\n                  t = 0;\n                }\n\n                return setTimeout(fun, t);\n              }; // Chars worth escaping, as defined by Douglas Crockford:\n              //   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196\n\n\n              var json_escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n                  json_lookup = {\n                \"\\0\": \"\\\\u0000\",\n                \"\\x01\": \"\\\\u0001\",\n                \"\\x02\": \"\\\\u0002\",\n                \"\\x03\": \"\\\\u0003\",\n                \"\\x04\": \"\\\\u0004\",\n                \"\\x05\": \"\\\\u0005\",\n                \"\\x06\": \"\\\\u0006\",\n                \"\\x07\": \"\\\\u0007\",\n                \"\\b\": \"\\\\b\",\n                \"\\t\": \"\\\\t\",\n                \"\\n\": \"\\\\n\",\n                \"\\x0B\": \"\\\\u000b\",\n                \"\\f\": \"\\\\f\",\n                \"\\r\": \"\\\\r\",\n                \"\\x0E\": \"\\\\u000e\",\n                \"\\x0F\": \"\\\\u000f\",\n                \"\\x10\": \"\\\\u0010\",\n                \"\\x11\": \"\\\\u0011\",\n                \"\\x12\": \"\\\\u0012\",\n                \"\\x13\": \"\\\\u0013\",\n                \"\\x14\": \"\\\\u0014\",\n                \"\\x15\": \"\\\\u0015\",\n                \"\\x16\": \"\\\\u0016\",\n                \"\\x17\": \"\\\\u0017\",\n                \"\\x18\": \"\\\\u0018\",\n                \"\\x19\": \"\\\\u0019\",\n                \"\\x1A\": \"\\\\u001a\",\n                \"\\x1B\": \"\\\\u001b\",\n                \"\\x1C\": \"\\\\u001c\",\n                \"\\x1D\": \"\\\\u001d\",\n                \"\\x1E\": \"\\\\u001e\",\n                \"\\x1F\": \"\\\\u001f\",\n                \"\\\"\": \"\\\\\\\"\",\n                \"\\\\\": \"\\\\\\\\\",\n                \"\\x7F\": \"\\\\u007f\",\n                \"\\x80\": \"\\\\u0080\",\n                \"\\x81\": \"\\\\u0081\",\n                \"\\x82\": \"\\\\u0082\",\n                \"\\x83\": \"\\\\u0083\",\n                \"\\x84\": \"\\\\u0084\",\n                \"\\x85\": \"\\\\u0085\",\n                \"\\x86\": \"\\\\u0086\",\n                \"\\x87\": \"\\\\u0087\",\n                \"\\x88\": \"\\\\u0088\",\n                \"\\x89\": \"\\\\u0089\",\n                \"\\x8A\": \"\\\\u008a\",\n                \"\\x8B\": \"\\\\u008b\",\n                \"\\x8C\": \"\\\\u008c\",\n                \"\\x8D\": \"\\\\u008d\",\n                \"\\x8E\": \"\\\\u008e\",\n                \"\\x8F\": \"\\\\u008f\",\n                \"\\x90\": \"\\\\u0090\",\n                \"\\x91\": \"\\\\u0091\",\n                \"\\x92\": \"\\\\u0092\",\n                \"\\x93\": \"\\\\u0093\",\n                \"\\x94\": \"\\\\u0094\",\n                \"\\x95\": \"\\\\u0095\",\n                \"\\x96\": \"\\\\u0096\",\n                \"\\x97\": \"\\\\u0097\",\n                \"\\x98\": \"\\\\u0098\",\n                \"\\x99\": \"\\\\u0099\",\n                \"\\x9A\": \"\\\\u009a\",\n                \"\\x9B\": \"\\\\u009b\",\n                \"\\x9C\": \"\\\\u009c\",\n                \"\\x9D\": \"\\\\u009d\",\n                \"\\x9E\": \"\\\\u009e\",\n                \"\\x9F\": \"\\\\u009f\",\n                \"\\xAD\": \"\\\\u00ad\",\n                \"\\u0600\": \"\\\\u0600\",\n                \"\\u0601\": \"\\\\u0601\",\n                \"\\u0602\": \"\\\\u0602\",\n                \"\\u0603\": \"\\\\u0603\",\n                \"\\u0604\": \"\\\\u0604\",\n                \"\\u070F\": \"\\\\u070f\",\n                \"\\u17B4\": \"\\\\u17b4\",\n                \"\\u17B5\": \"\\\\u17b5\",\n                \"\\u200C\": \"\\\\u200c\",\n                \"\\u200D\": \"\\\\u200d\",\n                \"\\u200E\": \"\\\\u200e\",\n                \"\\u200F\": \"\\\\u200f\",\n                \"\\u2028\": \"\\\\u2028\",\n                \"\\u2029\": \"\\\\u2029\",\n                \"\\u202A\": \"\\\\u202a\",\n                \"\\u202B\": \"\\\\u202b\",\n                \"\\u202C\": \"\\\\u202c\",\n                \"\\u202D\": \"\\\\u202d\",\n                \"\\u202E\": \"\\\\u202e\",\n                \"\\u202F\": \"\\\\u202f\",\n                \"\\u2060\": \"\\\\u2060\",\n                \"\\u2061\": \"\\\\u2061\",\n                \"\\u2062\": \"\\\\u2062\",\n                \"\\u2063\": \"\\\\u2063\",\n                \"\\u2064\": \"\\\\u2064\",\n                \"\\u2065\": \"\\\\u2065\",\n                \"\\u2066\": \"\\\\u2066\",\n                \"\\u2067\": \"\\\\u2067\",\n                \"\\u2068\": \"\\\\u2068\",\n                \"\\u2069\": \"\\\\u2069\",\n                \"\\u206A\": \"\\\\u206a\",\n                \"\\u206B\": \"\\\\u206b\",\n                \"\\u206C\": \"\\\\u206c\",\n                \"\\u206D\": \"\\\\u206d\",\n                \"\\u206E\": \"\\\\u206e\",\n                \"\\u206F\": \"\\\\u206f\",\n                \"\\uFEFF\": \"\\\\ufeff\",\n                \"\\uFFF0\": \"\\\\ufff0\",\n                \"\\uFFF1\": \"\\\\ufff1\",\n                \"\\uFFF2\": \"\\\\ufff2\",\n                \"\\uFFF3\": \"\\\\ufff3\",\n                \"\\uFFF4\": \"\\\\ufff4\",\n                \"\\uFFF5\": \"\\\\ufff5\",\n                \"\\uFFF6\": \"\\\\ufff6\",\n                \"\\uFFF7\": \"\\\\ufff7\",\n                \"\\uFFF8\": \"\\\\ufff8\",\n                \"\\uFFF9\": \"\\\\ufff9\",\n                \"\\uFFFA\": \"\\\\ufffa\",\n                \"\\uFFFB\": \"\\\\ufffb\",\n                \"\\uFFFC\": \"\\\\ufffc\",\n                \"\\uFFFD\": \"\\\\ufffd\",\n                \"\\uFFFE\": \"\\\\ufffe\",\n                \"\\uFFFF\": \"\\\\uffff\"\n              }; // Some extra characters that Chrome gets wrong, and substitutes with\n              // something else on the wire.\n\n              var extra_escapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g,\n                  extra_lookup; // JSON Quote string. Use native implementation when possible.\n\n              var JSONQuote = JSON && JSON.stringify || function (string) {\n                json_escapable.lastIndex = 0;\n\n                if (json_escapable.test(string)) {\n                  string = string.replace(json_escapable, function (a) {\n                    return json_lookup[a];\n                  });\n                }\n\n                return '\"' + string + '\"';\n              }; // This may be quite slow, so let's delay until user actually uses bad\n              // characters.\n\n\n              var unroll_lookup = function unroll_lookup(escapable) {\n                var i;\n                var unrolled = {};\n                var c = [];\n\n                for (i = 0; i < 65536; i++) {\n                  c.push(String.fromCharCode(i));\n                }\n\n                escapable.lastIndex = 0;\n                c.join('').replace(escapable, function (a) {\n                  unrolled[a] = \"\\\\u\" + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                  return '';\n                });\n                escapable.lastIndex = 0;\n                return unrolled;\n              }; // Quote string, also taking care of unicode characters that browsers\n              // often break. Especially, take care of unicode surrogates:\n              //    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\n\n\n              utils.quote = function (string) {\n                var quoted = JSONQuote(string); // In most cases this should be very fast and good enough.\n\n                extra_escapable.lastIndex = 0;\n\n                if (!extra_escapable.test(quoted)) {\n                  return quoted;\n                }\n\n                if (!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);\n                return quoted.replace(extra_escapable, function (a) {\n                  return extra_lookup[a];\n                });\n              };\n\n              var _all_protocols = ['websocket', 'xdr-streaming', 'xhr-streaming', 'iframe-eventsource', 'iframe-htmlfile', 'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'];\n\n              utils.probeProtocols = function () {\n                var probed = {};\n\n                for (var i = 0; i < _all_protocols.length; i++) {\n                  var protocol = _all_protocols[i]; // User can have a typo in protocol name.\n\n                  probed[protocol] = SockJS[protocol] && SockJS[protocol].enabled();\n                }\n\n                return probed;\n              };\n\n              utils.detectProtocols = function (probed, protocols_whitelist, info) {\n                var pe = {},\n                    protocols = [];\n                if (!protocols_whitelist) protocols_whitelist = _all_protocols;\n\n                for (var i = 0; i < protocols_whitelist.length; i++) {\n                  var protocol = protocols_whitelist[i];\n                  pe[protocol] = probed[protocol];\n                }\n\n                var maybe_push = function maybe_push(protos) {\n                  var proto = protos.shift();\n\n                  if (pe[proto]) {\n                    protocols.push(proto);\n                  } else {\n                    if (protos.length > 0) {\n                      maybe_push(protos);\n                    }\n                  }\n                }; // 1. Websocket\n\n\n                if (info.websocket !== false) {\n                  maybe_push(['websocket']);\n                } // 2. Streaming\n\n\n                if (pe['xhr-streaming'] && !info.null_origin) {\n                  protocols.push('xhr-streaming');\n                } else {\n                  if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {\n                    protocols.push('xdr-streaming');\n                  } else {\n                    maybe_push(['iframe-eventsource', 'iframe-htmlfile']);\n                  }\n                } // 3. Polling\n\n\n                if (pe['xhr-polling'] && !info.null_origin) {\n                  protocols.push('xhr-polling');\n                } else {\n                  if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {\n                    protocols.push('xdr-polling');\n                  } else {\n                    maybe_push(['iframe-xhr-polling', 'jsonp-polling']);\n                  }\n                }\n\n                return protocols;\n              }; //         [*] End of lib/utils.js\n              //         [*] Including lib/dom.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n              // May be used by htmlfile jsonp and transports.\n\n\n              var MPrefix = '_sockjs_global';\n\n              utils.createHook = function () {\n                var window_id = 'a' + utils.random_string(8);\n\n                if (!(MPrefix in _window)) {\n                  var map = {};\n\n                  _window[MPrefix] = function (window_id) {\n                    if (!(window_id in map)) {\n                      map[window_id] = {\n                        id: window_id,\n                        del: function del() {\n                          delete map[window_id];\n                        }\n                      };\n                    }\n\n                    return map[window_id];\n                  };\n                }\n\n                return _window[MPrefix](window_id);\n              };\n\n              utils.attachMessage = function (listener) {\n                utils.attachEvent('message', listener);\n              };\n\n              utils.attachEvent = function (event, listener) {\n                if (typeof _window.addEventListener !== 'undefined') {\n                  _window.addEventListener(event, listener, false);\n                } else {\n                  // IE quirks.\n                  // According to: http://stevesouders.com/misc/test-postmessage.php\n                  // the message gets delivered only to 'document', not 'window'.\n                  _document.attachEvent(\"on\" + event, listener); // I get 'window' for ie8.\n\n\n                  _window.attachEvent(\"on\" + event, listener);\n                }\n              };\n\n              utils.detachMessage = function (listener) {\n                utils.detachEvent('message', listener);\n              };\n\n              utils.detachEvent = function (event, listener) {\n                if (typeof _window.addEventListener !== 'undefined') {\n                  _window.removeEventListener(event, listener, false);\n                } else {\n                  _document.detachEvent(\"on\" + event, listener);\n\n                  _window.detachEvent(\"on\" + event, listener);\n                }\n              };\n\n              var on_unload = {}; // Things registered after beforeunload are to be called immediately.\n\n              var after_unload = false;\n\n              var trigger_unload_callbacks = function trigger_unload_callbacks() {\n                for (var ref in on_unload) {\n                  on_unload[ref]();\n                  delete on_unload[ref];\n                }\n\n                ;\n              };\n\n              var unload_triggered = function unload_triggered() {\n                if (after_unload) return;\n                after_unload = true;\n                trigger_unload_callbacks();\n              }; // 'unload' alone is not reliable in opera within an iframe, but we\n              // can't use `beforeunload` as IE fires it on javascript: links.\n\n\n              utils.attachEvent('unload', unload_triggered);\n\n              utils.unload_add = function (listener) {\n                var ref = utils.random_string(8);\n                on_unload[ref] = listener;\n\n                if (after_unload) {\n                  utils.delay(trigger_unload_callbacks);\n                }\n\n                return ref;\n              };\n\n              utils.unload_del = function (ref) {\n                if (ref in on_unload) delete on_unload[ref];\n              };\n\n              utils.createIframe = function (iframe_url, error_callback) {\n                var iframe = _document.createElement('iframe');\n\n                var tref, unload_ref;\n\n                var unattach = function unattach() {\n                  clearTimeout(tref); // Explorer had problems with that.\n\n                  try {\n                    iframe.onload = null;\n                  } catch (x) {}\n\n                  iframe.onerror = null;\n                };\n\n                var cleanup = function cleanup() {\n                  if (iframe) {\n                    unattach(); // This timeout makes chrome fire onbeforeunload event\n                    // within iframe. Without the timeout it goes straight to\n                    // onunload.\n\n                    setTimeout(function () {\n                      if (iframe) {\n                        iframe.parentNode.removeChild(iframe);\n                      }\n\n                      iframe = null;\n                    }, 0);\n                    utils.unload_del(unload_ref);\n                  }\n                };\n\n                var onerror = function onerror(r) {\n                  if (iframe) {\n                    cleanup();\n                    error_callback(r);\n                  }\n                };\n\n                var post = function post(msg, origin) {\n                  try {\n                    // When the iframe is not loaded, IE raises an exception\n                    // on 'contentWindow'.\n                    if (iframe && iframe.contentWindow) {\n                      iframe.contentWindow.postMessage(msg, origin);\n                    }\n                  } catch (x) {}\n\n                  ;\n                };\n\n                iframe.src = iframe_url;\n                iframe.style.display = 'none';\n                iframe.style.position = 'absolute';\n\n                iframe.onerror = function () {\n                  onerror('onerror');\n                };\n\n                iframe.onload = function () {\n                  // `onload` is triggered before scripts on the iframe are\n                  // executed. Give it few seconds to actually load stuff.\n                  clearTimeout(tref);\n                  tref = setTimeout(function () {\n                    onerror('onload timeout');\n                  }, 2000);\n                };\n\n                _document.body.appendChild(iframe);\n\n                tref = setTimeout(function () {\n                  onerror('timeout');\n                }, 15000);\n                unload_ref = utils.unload_add(cleanup);\n                return {\n                  post: post,\n                  cleanup: cleanup,\n                  loaded: unattach\n                };\n              };\n\n              utils.createHtmlfile = function (iframe_url, error_callback) {\n                var doc = new ActiveXObject('htmlfile');\n                var tref, unload_ref;\n                var iframe;\n\n                var unattach = function unattach() {\n                  clearTimeout(tref);\n                };\n\n                var cleanup = function cleanup() {\n                  if (doc) {\n                    unattach();\n                    utils.unload_del(unload_ref);\n                    iframe.parentNode.removeChild(iframe);\n                    iframe = doc = null;\n                    CollectGarbage();\n                  }\n                };\n\n                var onerror = function onerror(r) {\n                  if (doc) {\n                    cleanup();\n                    error_callback(r);\n                  }\n                };\n\n                var post = function post(msg, origin) {\n                  try {\n                    // When the iframe is not loaded, IE raises an exception\n                    // on 'contentWindow'.\n                    if (iframe && iframe.contentWindow) {\n                      iframe.contentWindow.postMessage(msg, origin);\n                    }\n                  } catch (x) {}\n\n                  ;\n                };\n\n                doc.open();\n                doc.write('<html><s' + 'cript>' + 'document.domain=\"' + document.domain + '\";' + '</s' + 'cript></html>');\n                doc.close();\n                doc.parentWindow[WPrefix] = _window[WPrefix];\n                var c = doc.createElement('div');\n                doc.body.appendChild(c);\n                iframe = doc.createElement('iframe');\n                c.appendChild(iframe);\n                iframe.src = iframe_url;\n                tref = setTimeout(function () {\n                  onerror('timeout');\n                }, 15000);\n                unload_ref = utils.unload_add(cleanup);\n                return {\n                  post: post,\n                  cleanup: cleanup,\n                  loaded: unattach\n                };\n              }; //         [*] End of lib/dom.js\n              //         [*] Including lib/dom2.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var AbstractXHRObject = function AbstractXHRObject() {};\n\n              AbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);\n\n              AbstractXHRObject.prototype._start = function (method, url, payload, opts) {\n                var that = this;\n\n                try {\n                  that.xhr = new XMLHttpRequest();\n                } catch (x) {}\n\n                ;\n\n                if (!that.xhr) {\n                  try {\n                    that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');\n                  } catch (x) {}\n\n                  ;\n                }\n\n                if (_window.ActiveXObject || _window.XDomainRequest) {\n                  // IE8 caches even POSTs\n                  url += (url.indexOf('?') === -1 ? '?' : '&') + 't=' + +new Date();\n                } // Explorer tends to keep connection open, even after the\n                // tab gets closed: http://bugs.jquery.com/ticket/5280\n\n\n                that.unload_ref = utils.unload_add(function () {\n                  that._cleanup(true);\n                });\n\n                try {\n                  that.xhr.open(method, url, true);\n                } catch (e) {\n                  // IE raises an exception on wrong port.\n                  that.emit('finish', 0, '');\n\n                  that._cleanup();\n\n                  return;\n                }\n\n                ;\n\n                if (!opts || !opts.no_credentials) {\n                  // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\n                  // \"This never affects same-site requests.\"\n                  that.xhr.withCredentials = 'true';\n                }\n\n                if (opts && opts.headers) {\n                  for (var key in opts.headers) {\n                    that.xhr.setRequestHeader(key, opts.headers[key]);\n                  }\n                }\n\n                that.xhr.onreadystatechange = function () {\n                  if (that.xhr) {\n                    var x = that.xhr;\n\n                    switch (x.readyState) {\n                      case 3:\n                        // IE doesn't like peeking into responseText or status\n                        // on Microsoft.XMLHTTP and readystate=3\n                        try {\n                          var status = x.status;\n                          var text = x.responseText;\n                        } catch (x) {}\n\n                        ; // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\n\n                        if (status === 1223) status = 204; // IE does return readystate == 3 for 404 answers.\n\n                        if (text && text.length > 0) {\n                          that.emit('chunk', status, text);\n                        }\n\n                        break;\n\n                      case 4:\n                        var status = x.status; // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\n\n                        if (status === 1223) status = 204;\n                        that.emit('finish', status, x.responseText);\n\n                        that._cleanup(false);\n\n                        break;\n                    }\n                  }\n                };\n\n                that.xhr.send(payload);\n              };\n\n              AbstractXHRObject.prototype._cleanup = function (abort) {\n                var that = this;\n                if (!that.xhr) return;\n                utils.unload_del(that.unload_ref); // IE needs this field to be a function\n\n                that.xhr.onreadystatechange = function () {};\n\n                if (abort) {\n                  try {\n                    that.xhr.abort();\n                  } catch (x) {}\n\n                  ;\n                }\n\n                that.unload_ref = that.xhr = null;\n              };\n\n              AbstractXHRObject.prototype.close = function () {\n                var that = this;\n                that.nuke();\n\n                that._cleanup(true);\n              };\n\n              var XHRCorsObject = utils.XHRCorsObject = function () {\n                var that = this,\n                    args = arguments;\n                utils.delay(function () {\n                  that._start.apply(that, args);\n                });\n              };\n\n              XHRCorsObject.prototype = new AbstractXHRObject();\n\n              var XHRLocalObject = utils.XHRLocalObject = function (method, url, payload) {\n                var that = this;\n                utils.delay(function () {\n                  that._start(method, url, payload, {\n                    no_credentials: true\n                  });\n                });\n              };\n\n              XHRLocalObject.prototype = new AbstractXHRObject(); // References:\n              //   http://ajaxian.com/archives/100-line-ajax-wrapper\n              //   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\n\n              var XDRObject = utils.XDRObject = function (method, url, payload) {\n                var that = this;\n                utils.delay(function () {\n                  that._start(method, url, payload);\n                });\n              };\n\n              XDRObject.prototype = new EventEmitter(['chunk', 'finish']);\n\n              XDRObject.prototype._start = function (method, url, payload) {\n                var that = this;\n                var xdr = new XDomainRequest(); // IE caches even POSTs\n\n                url += (url.indexOf('?') === -1 ? '?' : '&') + 't=' + +new Date();\n\n                var onerror = xdr.ontimeout = xdr.onerror = function () {\n                  that.emit('finish', 0, '');\n\n                  that._cleanup(false);\n                };\n\n                xdr.onprogress = function () {\n                  that.emit('chunk', 200, xdr.responseText);\n                };\n\n                xdr.onload = function () {\n                  that.emit('finish', 200, xdr.responseText);\n\n                  that._cleanup(false);\n                };\n\n                that.xdr = xdr;\n                that.unload_ref = utils.unload_add(function () {\n                  that._cleanup(true);\n                });\n\n                try {\n                  // Fails with AccessDenied if port number is bogus\n                  that.xdr.open(method, url);\n                  that.xdr.send(payload);\n                } catch (x) {\n                  onerror();\n                }\n              };\n\n              XDRObject.prototype._cleanup = function (abort) {\n                var that = this;\n                if (!that.xdr) return;\n                utils.unload_del(that.unload_ref);\n                that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress = that.xdr.onload = null;\n\n                if (abort) {\n                  try {\n                    that.xdr.abort();\n                  } catch (x) {}\n\n                  ;\n                }\n\n                that.unload_ref = that.xdr = null;\n              };\n\n              XDRObject.prototype.close = function () {\n                var that = this;\n                that.nuke();\n\n                that._cleanup(true);\n              }; // 1. Is natively via XHR\n              // 2. Is natively via XDR\n              // 3. Nope, but postMessage is there so it should work via the Iframe.\n              // 4. Nope, sorry.\n\n\n              utils.isXHRCorsCapable = function () {\n                if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {\n                  return 1;\n                } // XDomainRequest doesn't work if page is served from file://\n\n\n                if (_window.XDomainRequest && _document.domain) {\n                  return 2;\n                }\n\n                if (IframeTransport.enabled()) {\n                  return 3;\n                }\n\n                return 4;\n              }; //         [*] End of lib/dom2.js\n              //         [*] Including lib/sockjs.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var SockJS = function SockJS(url, dep_protocols_whitelist, options) {\n                if (!(this instanceof SockJS)) {\n                  // makes `new` optional\n                  return new SockJS(url, dep_protocols_whitelist, options);\n                }\n\n                var that = this,\n                    protocols_whitelist;\n                that._options = {\n                  devel: false,\n                  debug: false,\n                  protocols_whitelist: [],\n                  info: undefined,\n                  rtt: undefined\n                };\n\n                if (options) {\n                  utils.objectExtend(that._options, options);\n                }\n\n                that._base_url = utils.amendUrl(url);\n                that._server = that._options.server || utils.random_number_string(1000);\n\n                if (that._options.protocols_whitelist && that._options.protocols_whitelist.length) {\n                  protocols_whitelist = that._options.protocols_whitelist;\n                } else {\n                  // Deprecated API\n                  if (typeof dep_protocols_whitelist === 'string' && dep_protocols_whitelist.length > 0) {\n                    protocols_whitelist = [dep_protocols_whitelist];\n                  } else if (utils.isArray(dep_protocols_whitelist)) {\n                    protocols_whitelist = dep_protocols_whitelist;\n                  } else {\n                    protocols_whitelist = null;\n                  }\n\n                  if (protocols_whitelist) {\n                    that._debug('Deprecated API: Use \"protocols_whitelist\" option ' + 'instead of supplying protocol list as a second ' + 'parameter to SockJS constructor.');\n                  }\n                }\n\n                that._protocols = [];\n                that.protocol = null;\n                that.readyState = SockJS.CONNECTING;\n                that._ir = createInfoReceiver(that._base_url);\n\n                that._ir.onfinish = function (info, rtt) {\n                  that._ir = null;\n\n                  if (info) {\n                    if (that._options.info) {\n                      // Override if user supplies the option\n                      info = utils.objectExtend(info, that._options.info);\n                    }\n\n                    if (that._options.rtt) {\n                      rtt = that._options.rtt;\n                    }\n\n                    that._applyInfo(info, rtt, protocols_whitelist);\n\n                    that._didClose();\n                  } else {\n                    that._didClose(1002, 'Can\\'t connect to server', true);\n                  }\n                };\n              }; // Inheritance\n\n\n              SockJS.prototype = new REventTarget();\n              SockJS.version = \"0.3.4\";\n              SockJS.CONNECTING = 0;\n              SockJS.OPEN = 1;\n              SockJS.CLOSING = 2;\n              SockJS.CLOSED = 3;\n\n              SockJS.prototype._debug = function () {\n                if (this._options.debug) utils.log.apply(utils, arguments);\n              };\n\n              SockJS.prototype._dispatchOpen = function () {\n                var that = this;\n\n                if (that.readyState === SockJS.CONNECTING) {\n                  if (that._transport_tref) {\n                    clearTimeout(that._transport_tref);\n                    that._transport_tref = null;\n                  }\n\n                  that.readyState = SockJS.OPEN;\n                  that.dispatchEvent(new SimpleEvent(\"open\"));\n                } else {\n                  // The server might have been restarted, and lost track of our\n                  // connection.\n                  that._didClose(1006, \"Server lost session\");\n                }\n              };\n\n              SockJS.prototype._dispatchMessage = function (data) {\n                var that = this;\n                if (that.readyState !== SockJS.OPEN) return;\n                that.dispatchEvent(new SimpleEvent(\"message\", {\n                  data: data\n                }));\n              };\n\n              SockJS.prototype._dispatchHeartbeat = function (data) {\n                var that = this;\n                if (that.readyState !== SockJS.OPEN) return;\n                that.dispatchEvent(new SimpleEvent('heartbeat', {}));\n              };\n\n              SockJS.prototype._didClose = function (code, reason, force) {\n                var that = this;\n                if (that.readyState !== SockJS.CONNECTING && that.readyState !== SockJS.OPEN && that.readyState !== SockJS.CLOSING) throw new Error('INVALID_STATE_ERR');\n\n                if (that._ir) {\n                  that._ir.nuke();\n\n                  that._ir = null;\n                }\n\n                if (that._transport) {\n                  that._transport.doCleanup();\n\n                  that._transport = null;\n                }\n\n                var close_event = new SimpleEvent(\"close\", {\n                  code: code,\n                  reason: reason,\n                  wasClean: utils.userSetCode(code)\n                });\n\n                if (!utils.userSetCode(code) && that.readyState === SockJS.CONNECTING && !force) {\n                  if (that._try_next_protocol(close_event)) {\n                    return;\n                  }\n\n                  close_event = new SimpleEvent(\"close\", {\n                    code: 2000,\n                    reason: \"All transports failed\",\n                    wasClean: false,\n                    last_event: close_event\n                  });\n                }\n\n                that.readyState = SockJS.CLOSED;\n                utils.delay(function () {\n                  that.dispatchEvent(close_event);\n                });\n              };\n\n              SockJS.prototype._didMessage = function (data) {\n                var that = this;\n                var type = data.slice(0, 1);\n\n                switch (type) {\n                  case 'o':\n                    that._dispatchOpen();\n\n                    break;\n\n                  case 'a':\n                    var payload = JSON.parse(data.slice(1) || '[]');\n\n                    for (var i = 0; i < payload.length; i++) {\n                      that._dispatchMessage(payload[i]);\n                    }\n\n                    break;\n\n                  case 'm':\n                    var payload = JSON.parse(data.slice(1) || 'null');\n\n                    that._dispatchMessage(payload);\n\n                    break;\n\n                  case 'c':\n                    var payload = JSON.parse(data.slice(1) || '[]');\n\n                    that._didClose(payload[0], payload[1]);\n\n                    break;\n\n                  case 'h':\n                    that._dispatchHeartbeat();\n\n                    break;\n                }\n              };\n\n              SockJS.prototype._try_next_protocol = function (close_event) {\n                var that = this;\n\n                if (that.protocol) {\n                  that._debug('Closed transport:', that.protocol, '' + close_event);\n\n                  that.protocol = null;\n                }\n\n                if (that._transport_tref) {\n                  clearTimeout(that._transport_tref);\n                  that._transport_tref = null;\n                }\n\n                while (1) {\n                  var protocol = that.protocol = that._protocols.shift();\n\n                  if (!protocol) {\n                    return false;\n                  } // Some protocols require access to `body`, what if were in\n                  // the `head`?\n\n\n                  if (SockJS[protocol] && SockJS[protocol].need_body === true && (!_document.body || typeof _document.readyState !== 'undefined' && _document.readyState !== 'complete')) {\n                    that._protocols.unshift(protocol);\n\n                    that.protocol = 'waiting-for-load';\n                    utils.attachEvent('load', function () {\n                      that._try_next_protocol();\n                    });\n                    return true;\n                  }\n\n                  if (!SockJS[protocol] || !SockJS[protocol].enabled(that._options)) {\n                    that._debug('Skipping transport:', protocol);\n                  } else {\n                    var roundTrips = SockJS[protocol].roundTrips || 1;\n                    var to = (that._options.rto || 0) * roundTrips || 5000;\n                    that._transport_tref = utils.delay(to, function () {\n                      if (that.readyState === SockJS.CONNECTING) {\n                        // I can't understand how it is possible to run\n                        // this timer, when the state is CLOSED, but\n                        // apparently in IE everythin is possible.\n                        that._didClose(2007, \"Transport timeouted\");\n                      }\n                    });\n                    var connid = utils.random_string(8);\n                    var trans_url = that._base_url + '/' + that._server + '/' + connid;\n\n                    that._debug('Opening transport:', protocol, ' url:' + trans_url, ' RTO:' + that._options.rto);\n\n                    that._transport = new SockJS[protocol](that, trans_url, that._base_url);\n                    return true;\n                  }\n                }\n              };\n\n              SockJS.prototype.close = function (code, reason) {\n                var that = this;\n                if (code && !utils.userSetCode(code)) throw new Error(\"INVALID_ACCESS_ERR\");\n\n                if (that.readyState !== SockJS.CONNECTING && that.readyState !== SockJS.OPEN) {\n                  return false;\n                }\n\n                that.readyState = SockJS.CLOSING;\n\n                that._didClose(code || 1000, reason || \"Normal closure\");\n\n                return true;\n              };\n\n              SockJS.prototype.send = function (data) {\n                var that = this;\n                if (that.readyState === SockJS.CONNECTING) throw new Error('INVALID_STATE_ERR');\n\n                if (that.readyState === SockJS.OPEN) {\n                  that._transport.doSend(utils.quote('' + data));\n                }\n\n                return true;\n              };\n\n              SockJS.prototype._applyInfo = function (info, rtt, protocols_whitelist) {\n                var that = this;\n                that._options.info = info;\n                that._options.rtt = rtt;\n                that._options.rto = utils.countRTO(rtt);\n                that._options.info.null_origin = !_document.domain; // Servers can override base_url, eg to provide a randomized domain name and\n                // avoid browser per-domain connection limits.\n\n                if (info.base_url) // <METEOR>\n                  that._base_url = utils.amendUrl(info.base_url, that._base_url); // </METEOR>\n\n                var probed = utils.probeProtocols();\n                that._protocols = utils.detectProtocols(probed, protocols_whitelist, info); // <METEOR>\n                // https://github.com/sockjs/sockjs-client/issues/79\n                // Hack to avoid XDR when using different protocols\n                // We're on IE trying to do cross-protocol. jsonp only.\n\n                if (!utils.isSameOriginScheme(that._base_url) && 2 === utils.isXHRCorsCapable()) {\n                  that._protocols = ['jsonp-polling'];\n                } // </METEOR>\n\n              }; //         [*] End of lib/sockjs.js\n              //         [*] Including lib/trans-websocket.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var WebSocketTransport = SockJS.websocket = function (ri, trans_url) {\n                var that = this;\n                var url = trans_url + '/websocket';\n\n                if (url.slice(0, 5) === 'https') {\n                  url = 'wss' + url.slice(5);\n                } else {\n                  url = 'ws' + url.slice(4);\n                }\n\n                that.ri = ri;\n                that.url = url;\n                var Constructor = _window.WebSocket || _window.MozWebSocket;\n                that.ws = new Constructor(that.url);\n\n                that.ws.onmessage = function (e) {\n                  that.ri._didMessage(e.data);\n                }; // Firefox has an interesting bug. If a websocket connection is\n                // created after onunload, it stays alive even when user\n                // navigates away from the page. In such situation let's lie -\n                // let's not open the ws connection at all. See:\n                // https://github.com/sockjs/sockjs-client/issues/28\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\n\n\n                that.unload_ref = utils.unload_add(function () {\n                  that.ws.close();\n                });\n\n                that.ws.onclose = function () {\n                  that.ri._didMessage(utils.closeFrame(1006, \"WebSocket connection broken\"));\n                };\n              };\n\n              WebSocketTransport.prototype.doSend = function (data) {\n                this.ws.send('[' + data + ']');\n              };\n\n              WebSocketTransport.prototype.doCleanup = function () {\n                var that = this;\n                var ws = that.ws;\n\n                if (ws) {\n                  ws.onmessage = ws.onclose = null;\n                  ws.close();\n                  utils.unload_del(that.unload_ref);\n                  that.unload_ref = that.ri = that.ws = null;\n                }\n              };\n\n              WebSocketTransport.enabled = function () {\n                return !!(_window.WebSocket || _window.MozWebSocket);\n              }; // In theory, ws should require 1 round trip. But in chrome, this is\n              // not very stable over SSL. Most likely a ws connection requires a\n              // separate SSL connection, in which case 2 round trips are an\n              // absolute minumum.\n\n\n              WebSocketTransport.roundTrips = 2; //         [*] End of lib/trans-websocket.js\n              //         [*] Including lib/trans-sender.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n              var BufferedSender = function BufferedSender() {};\n\n              BufferedSender.prototype.send_constructor = function (sender) {\n                var that = this;\n                that.send_buffer = [];\n                that.sender = sender;\n              };\n\n              BufferedSender.prototype.doSend = function (message) {\n                var that = this;\n                that.send_buffer.push(message);\n\n                if (!that.send_stop) {\n                  that.send_schedule();\n                }\n              }; // For polling transports in a situation when in the message callback,\n              // new message is being send. If the sending connection was started\n              // before receiving one, it is possible to saturate the network and\n              // timeout due to the lack of receiving socket. To avoid that we delay\n              // sending messages by some small time, in order to let receiving\n              // connection be started beforehand. This is only a halfmeasure and\n              // does not fix the big problem, but it does make the tests go more\n              // stable on slow networks.\n\n\n              BufferedSender.prototype.send_schedule_wait = function () {\n                var that = this;\n                var tref;\n\n                that.send_stop = function () {\n                  that.send_stop = null;\n                  clearTimeout(tref);\n                };\n\n                tref = utils.delay(25, function () {\n                  that.send_stop = null;\n                  that.send_schedule();\n                });\n              };\n\n              BufferedSender.prototype.send_schedule = function () {\n                var that = this;\n\n                if (that.send_buffer.length > 0) {\n                  var payload = '[' + that.send_buffer.join(',') + ']';\n                  that.send_stop = that.sender(that.trans_url, payload, function (success, abort_reason) {\n                    that.send_stop = null;\n\n                    if (success === false) {\n                      that.ri._didClose(1006, 'Sending error ' + abort_reason);\n                    } else {\n                      that.send_schedule_wait();\n                    }\n                  });\n                  that.send_buffer = [];\n                }\n              };\n\n              BufferedSender.prototype.send_destructor = function () {\n                var that = this;\n\n                if (that._send_stop) {\n                  that._send_stop();\n                }\n\n                that._send_stop = null;\n              };\n\n              var jsonPGenericSender = function jsonPGenericSender(url, payload, callback) {\n                var that = this;\n\n                if (!('_send_form' in that)) {\n                  var form = that._send_form = _document.createElement('form');\n\n                  var area = that._send_area = _document.createElement('textarea');\n\n                  area.name = 'd';\n                  form.style.display = 'none';\n                  form.style.position = 'absolute';\n                  form.method = 'POST';\n                  form.enctype = 'application/x-www-form-urlencoded';\n                  form.acceptCharset = \"UTF-8\";\n                  form.appendChild(area);\n\n                  _document.body.appendChild(form);\n                }\n\n                var form = that._send_form;\n                var area = that._send_area;\n                var id = 'a' + utils.random_string(8);\n                form.target = id;\n                form.action = url + '/jsonp_send?i=' + id;\n                var iframe;\n\n                try {\n                  // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n                  iframe = _document.createElement('<iframe name=\"' + id + '\">');\n                } catch (x) {\n                  iframe = _document.createElement('iframe');\n                  iframe.name = id;\n                }\n\n                iframe.id = id;\n                form.appendChild(iframe);\n                iframe.style.display = 'none';\n\n                try {\n                  area.value = payload;\n                } catch (e) {\n                  utils.log('Your browser is seriously broken. Go home! ' + e.message);\n                }\n\n                form.submit();\n\n                var completed = function completed(e) {\n                  if (!iframe.onerror) return;\n                  iframe.onreadystatechange = iframe.onerror = iframe.onload = null; // Opera mini doesn't like if we GC iframe\n                  // immediately, thus this timeout.\n\n                  utils.delay(500, function () {\n                    iframe.parentNode.removeChild(iframe);\n                    iframe = null;\n                  });\n                  area.value = ''; // It is not possible to detect if the iframe succeeded or\n                  // failed to submit our form.\n\n                  callback(true);\n                };\n\n                iframe.onerror = iframe.onload = completed;\n\n                iframe.onreadystatechange = function (e) {\n                  if (iframe.readyState == 'complete') completed();\n                };\n\n                return completed;\n              };\n\n              var createAjaxSender = function createAjaxSender(AjaxObject) {\n                return function (url, payload, callback) {\n                  var xo = new AjaxObject('POST', url + '/xhr_send', payload);\n\n                  xo.onfinish = function (status, text) {\n                    callback(status === 200 || status === 204, 'http status ' + status);\n                  };\n\n                  return function (abort_reason) {\n                    callback(false, abort_reason);\n                  };\n                };\n              }; //         [*] End of lib/trans-sender.js\n              //         [*] Including lib/trans-jsonp-receiver.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n              // Parts derived from Socket.io:\n              //    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js\n              // and jQuery-JSONP:\n              //    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js\n\n\n              var jsonPGenericReceiver = function jsonPGenericReceiver(url, callback) {\n                var tref;\n\n                var script = _document.createElement('script');\n\n                var script2; // Opera synchronous load trick.\n\n                var close_script = function close_script(frame) {\n                  if (script2) {\n                    script2.parentNode.removeChild(script2);\n                    script2 = null;\n                  }\n\n                  if (script) {\n                    clearTimeout(tref); // Unfortunately, you can't really abort script loading of\n                    // the script.\n\n                    script.parentNode.removeChild(script);\n                    script.onreadystatechange = script.onerror = script.onload = script.onclick = null;\n                    script = null;\n                    callback(frame);\n                    callback = null;\n                  }\n                }; // IE9 fires 'error' event after orsc or before, in random order.\n\n\n                var loaded_okay = false;\n                var error_timer = null;\n                script.id = 'a' + utils.random_string(8);\n                script.src = url;\n                script.type = 'text/javascript';\n                script.charset = 'UTF-8';\n\n                script.onerror = function (e) {\n                  if (!error_timer) {\n                    // Delay firing close_script.\n                    error_timer = setTimeout(function () {\n                      if (!loaded_okay) {\n                        close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onerror)\"));\n                      }\n                    }, 1000);\n                  }\n                };\n\n                script.onload = function (e) {\n                  close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onload)\"));\n                };\n\n                script.onreadystatechange = function (e) {\n                  if (/loaded|closed/.test(script.readyState)) {\n                    if (script && script.htmlFor && script.onclick) {\n                      loaded_okay = true;\n\n                      try {\n                        // In IE, actually execute the script.\n                        script.onclick();\n                      } catch (x) {}\n                    }\n\n                    if (script) {\n                      close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onreadystatechange)\"));\n                    }\n                  }\n                }; // IE: event/htmlFor/onclick trick.\n                // One can't rely on proper order for onreadystatechange. In order to\n                // make sure, set a 'htmlFor' and 'event' properties, so that\n                // script code will be installed as 'onclick' handler for the\n                // script object. Later, onreadystatechange, manually execute this\n                // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\n                // set. For reference see:\n                //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\n                // Also, read on that about script ordering:\n                //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n\n\n                if (typeof script.async === 'undefined' && _document.attachEvent) {\n                  // According to mozilla docs, in recent browsers script.async defaults\n                  // to 'true', so we may use it to detect a good browser:\n                  // https://developer.mozilla.org/en/HTML/Element/script\n                  if (!/opera/i.test(navigator.userAgent)) {\n                    // Naively assume we're in IE\n                    try {\n                      script.htmlFor = script.id;\n                      script.event = \"onclick\";\n                    } catch (x) {}\n\n                    script.async = true;\n                  } else {\n                    // Opera, second sync script hack\n                    script2 = _document.createElement('script');\n                    script2.text = \"try{var a = document.getElementById('\" + script.id + \"'); if(a)a.onerror();}catch(x){};\";\n                    script.async = script2.async = false;\n                  }\n                }\n\n                if (typeof script.async !== 'undefined') {\n                  script.async = true;\n                } // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\n\n\n                tref = setTimeout(function () {\n                  close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (timeout)\"));\n                }, 35000);\n\n                var head = _document.getElementsByTagName('head')[0];\n\n                head.insertBefore(script, head.firstChild);\n\n                if (script2) {\n                  head.insertBefore(script2, head.firstChild);\n                }\n\n                return close_script;\n              }; //         [*] End of lib/trans-jsonp-receiver.js\n              //         [*] Including lib/trans-jsonp-polling.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n              // The simplest and most robust transport, using the well-know cross\n              // domain hack - JSONP. This transport is quite inefficient - one\n              // mssage could use up to one http request. But at least it works almost\n              // everywhere.\n              // Known limitations:\n              //   o you will get a spinning cursor\n              //   o for Konqueror a dumb timer is needed to detect errors\n\n\n              var JsonPTransport = SockJS['jsonp-polling'] = function (ri, trans_url) {\n                utils.polluteGlobalNamespace();\n                var that = this;\n                that.ri = ri;\n                that.trans_url = trans_url;\n                that.send_constructor(jsonPGenericSender);\n\n                that._schedule_recv();\n              }; // Inheritnace\n\n\n              JsonPTransport.prototype = new BufferedSender();\n\n              JsonPTransport.prototype._schedule_recv = function () {\n                var that = this;\n\n                var callback = function callback(data) {\n                  that._recv_stop = null;\n\n                  if (data) {\n                    // no data - heartbeat;\n                    if (!that._is_closing) {\n                      that.ri._didMessage(data);\n                    }\n                  } // The message can be a close message, and change is_closing state.\n\n\n                  if (!that._is_closing) {\n                    that._schedule_recv();\n                  }\n                };\n\n                that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp', jsonPGenericReceiver, callback);\n              };\n\n              JsonPTransport.enabled = function () {\n                return true;\n              };\n\n              JsonPTransport.need_body = true;\n\n              JsonPTransport.prototype.doCleanup = function () {\n                var that = this;\n                that._is_closing = true;\n\n                if (that._recv_stop) {\n                  that._recv_stop();\n                }\n\n                that.ri = that._recv_stop = null;\n                that.send_destructor();\n              }; // Abstract away code that handles global namespace pollution.\n\n\n              var jsonPReceiverWrapper = function jsonPReceiverWrapper(url, constructReceiver, user_callback) {\n                var id = 'a' + utils.random_string(6);\n                var url_id = url + '?c=' + escape(WPrefix + '.' + id); // Unfortunately it is not possible to abort loading of the\n                // script. We need to keep track of frake close frames.\n\n                var aborting = 0; // Callback will be called exactly once.\n\n                var callback = function callback(frame) {\n                  switch (aborting) {\n                    case 0:\n                      // Normal behaviour - delete hook _and_ emit message.\n                      delete _window[WPrefix][id];\n                      user_callback(frame);\n                      break;\n\n                    case 1:\n                      // Fake close frame - emit but don't delete hook.\n                      user_callback(frame);\n                      aborting = 2;\n                      break;\n\n                    case 2:\n                      // Got frame after connection was closed, delete hook, don't emit.\n                      delete _window[WPrefix][id];\n                      break;\n                  }\n                };\n\n                var close_script = constructReceiver(url_id, callback);\n                _window[WPrefix][id] = close_script;\n\n                var stop = function stop() {\n                  if (_window[WPrefix][id]) {\n                    aborting = 1;\n\n                    _window[WPrefix][id](utils.closeFrame(1000, \"JSONP user aborted read\"));\n                  }\n                };\n\n                return stop;\n              }; //         [*] End of lib/trans-jsonp-polling.js\n              //         [*] Including lib/trans-xhr.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var AjaxBasedTransport = function AjaxBasedTransport() {};\n\n              AjaxBasedTransport.prototype = new BufferedSender();\n\n              AjaxBasedTransport.prototype.run = function (ri, trans_url, url_suffix, Receiver, AjaxObject) {\n                var that = this;\n                that.ri = ri;\n                that.trans_url = trans_url;\n                that.send_constructor(createAjaxSender(AjaxObject));\n                that.poll = new Polling(ri, Receiver, trans_url + url_suffix, AjaxObject);\n              };\n\n              AjaxBasedTransport.prototype.doCleanup = function () {\n                var that = this;\n\n                if (that.poll) {\n                  that.poll.abort();\n                  that.poll = null;\n                }\n              }; // xhr-streaming\n\n\n              var XhrStreamingTransport = SockJS['xhr-streaming'] = function (ri, trans_url) {\n                this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);\n              };\n\n              XhrStreamingTransport.prototype = new AjaxBasedTransport();\n\n              XhrStreamingTransport.enabled = function () {\n                // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but\n                // doesn't do streaming.\n                return _window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest() && !/opera/i.test(navigator.userAgent);\n              };\n\n              XhrStreamingTransport.roundTrips = 2; // preflight, ajax\n              // Safari gets confused when a streaming ajax request is started\n              // before onload. This causes the load indicator to spin indefinetely.\n\n              XhrStreamingTransport.need_body = true; // According to:\n              //   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\n              //   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n              // xdr-streaming\n\n              var XdrStreamingTransport = SockJS['xdr-streaming'] = function (ri, trans_url) {\n                this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);\n              };\n\n              XdrStreamingTransport.prototype = new AjaxBasedTransport();\n\n              XdrStreamingTransport.enabled = function () {\n                return !!_window.XDomainRequest;\n              };\n\n              XdrStreamingTransport.roundTrips = 2; // preflight, ajax\n              // xhr-polling\n\n              var XhrPollingTransport = SockJS['xhr-polling'] = function (ri, trans_url) {\n                this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);\n              };\n\n              XhrPollingTransport.prototype = new AjaxBasedTransport();\n              XhrPollingTransport.enabled = XhrStreamingTransport.enabled;\n              XhrPollingTransport.roundTrips = 2; // preflight, ajax\n              // xdr-polling\n\n              var XdrPollingTransport = SockJS['xdr-polling'] = function (ri, trans_url) {\n                this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);\n              };\n\n              XdrPollingTransport.prototype = new AjaxBasedTransport();\n              XdrPollingTransport.enabled = XdrStreamingTransport.enabled;\n              XdrPollingTransport.roundTrips = 2; // preflight, ajax\n              //         [*] End of lib/trans-xhr.js\n              //         [*] Including lib/trans-iframe.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n              // Few cool transports do work only for same-origin. In order to make\n              // them working cross-domain we shall use iframe, served form the\n              // remote domain. New browsers, have capabilities to communicate with\n              // cross domain iframe, using postMessage(). In IE it was implemented\n              // from IE 8+, but of course, IE got some details wrong:\n              //    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\n              //    http://stevesouders.com/misc/test-postmessage.php\n\n              var IframeTransport = function IframeTransport() {};\n\n              IframeTransport.prototype.i_constructor = function (ri, trans_url, base_url) {\n                var that = this;\n                that.ri = ri;\n                that.origin = utils.getOrigin(base_url);\n                that.base_url = base_url;\n                that.trans_url = trans_url;\n                var iframe_url = base_url + '/iframe.html';\n\n                if (that.ri._options.devel) {\n                  iframe_url += '?t=' + +new Date();\n                }\n\n                that.window_id = utils.random_string(8);\n                iframe_url += '#' + that.window_id;\n                that.iframeObj = utils.createIframe(iframe_url, function (r) {\n                  that.ri._didClose(1006, \"Unable to load an iframe (\" + r + \")\");\n                });\n                that.onmessage_cb = utils.bind(that.onmessage, that);\n                utils.attachMessage(that.onmessage_cb);\n              };\n\n              IframeTransport.prototype.doCleanup = function () {\n                var that = this;\n\n                if (that.iframeObj) {\n                  utils.detachMessage(that.onmessage_cb);\n\n                  try {\n                    // When the iframe is not loaded, IE raises an exception\n                    // on 'contentWindow'.\n                    if (that.iframeObj.iframe.contentWindow) {\n                      that.postMessage('c');\n                    }\n                  } catch (x) {}\n\n                  that.iframeObj.cleanup();\n                  that.iframeObj = null;\n                  that.onmessage_cb = that.iframeObj = null;\n                }\n              };\n\n              IframeTransport.prototype.onmessage = function (e) {\n                var that = this;\n                if (e.origin !== that.origin) return;\n                var window_id = e.data.slice(0, 8);\n                var type = e.data.slice(8, 9);\n                var data = e.data.slice(9);\n                if (window_id !== that.window_id) return;\n\n                switch (type) {\n                  case 's':\n                    that.iframeObj.loaded();\n                    that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));\n                    break;\n\n                  case 't':\n                    that.ri._didMessage(data);\n\n                    break;\n                }\n              };\n\n              IframeTransport.prototype.postMessage = function (type, data) {\n                var that = this;\n                that.iframeObj.post(that.window_id + type + (data || ''), that.origin);\n              };\n\n              IframeTransport.prototype.doSend = function (message) {\n                this.postMessage('m', message);\n              };\n\n              IframeTransport.enabled = function () {\n                // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\n                // huge delay, or not at all.\n                var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;\n                return (typeof _window.postMessage === 'function' || _typeof(_window.postMessage) === 'object') && !konqueror;\n              }; //         [*] End of lib/trans-iframe.js\n              //         [*] Including lib/trans-iframe-within.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var curr_window_id;\n\n              var postMessage = function postMessage(type, data) {\n                if (parent !== _window) {\n                  parent.postMessage(curr_window_id + type + (data || ''), '*');\n                } else {\n                  utils.log(\"Can't postMessage, no parent window.\", type, data);\n                }\n              };\n\n              var FacadeJS = function FacadeJS() {};\n\n              FacadeJS.prototype._didClose = function (code, reason) {\n                postMessage('t', utils.closeFrame(code, reason));\n              };\n\n              FacadeJS.prototype._didMessage = function (frame) {\n                postMessage('t', frame);\n              };\n\n              FacadeJS.prototype._doSend = function (data) {\n                this._transport.doSend(data);\n              };\n\n              FacadeJS.prototype._doCleanup = function () {\n                this._transport.doCleanup();\n              };\n\n              utils.parent_origin = undefined;\n\n              SockJS.bootstrap_iframe = function () {\n                var facade;\n                curr_window_id = _document.location.hash.slice(1);\n\n                var onMessage = function onMessage(e) {\n                  if (e.source !== parent) return;\n                  if (typeof utils.parent_origin === 'undefined') utils.parent_origin = e.origin;\n                  if (e.origin !== utils.parent_origin) return;\n                  var window_id = e.data.slice(0, 8);\n                  var type = e.data.slice(8, 9);\n                  var data = e.data.slice(9);\n                  if (window_id !== curr_window_id) return;\n\n                  switch (type) {\n                    case 's':\n                      var p = JSON.parse(data);\n                      var version = p[0];\n                      var protocol = p[1];\n                      var trans_url = p[2];\n                      var base_url = p[3];\n\n                      if (version !== SockJS.version) {\n                        utils.log(\"Incompatibile SockJS! Main site uses:\" + \" \\\"\" + version + \"\\\", the iframe:\" + \" \\\"\" + SockJS.version + \"\\\".\");\n                      }\n\n                      if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {\n                        utils.log(\"Only basic urls are supported in SockJS\");\n                        return;\n                      }\n\n                      if (!utils.isSameOriginUrl(trans_url) || !utils.isSameOriginUrl(base_url)) {\n                        utils.log(\"Can't connect to different domain from within an \" + \"iframe. (\" + JSON.stringify([_window.location.href, trans_url, base_url]) + \")\");\n                        return;\n                      }\n\n                      facade = new FacadeJS();\n                      facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);\n                      break;\n\n                    case 'm':\n                      facade._doSend(data);\n\n                      break;\n\n                    case 'c':\n                      if (facade) facade._doCleanup();\n                      facade = null;\n                      break;\n                  }\n                }; // alert('test ticker');\n                // facade = new FacadeJS();\n                // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');\n\n\n                utils.attachMessage(onMessage); // Start\n\n                postMessage('s');\n              }; //         [*] End of lib/trans-iframe-within.js\n              //         [*] Including lib/info.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var InfoReceiver = function InfoReceiver(base_url, AjaxObject) {\n                var that = this;\n                utils.delay(function () {\n                  that.doXhr(base_url, AjaxObject);\n                });\n              };\n\n              InfoReceiver.prototype = new EventEmitter(['finish']);\n\n              InfoReceiver.prototype.doXhr = function (base_url, AjaxObject) {\n                var that = this;\n                var t0 = new Date().getTime(); // <METEOR>\n                // https://github.com/sockjs/sockjs-client/pull/129\n                // var xo = new AjaxObject('GET', base_url + '/info');\n\n                var xo = new AjaxObject( // add cachebusting parameter to url to work around a chrome bug:\n                // https://code.google.com/p/chromium/issues/detail?id=263981\n                // or misbehaving proxies.\n                'GET', base_url + '/info?cb=' + utils.random_string(10)); // </METEOR>\n\n                var tref = utils.delay(8000, function () {\n                  xo.ontimeout();\n                });\n\n                xo.onfinish = function (status, text) {\n                  clearTimeout(tref);\n                  tref = null;\n\n                  if (status === 200) {\n                    var rtt = new Date().getTime() - t0;\n                    var info = JSON.parse(text);\n                    if (_typeof(info) !== 'object') info = {};\n                    that.emit('finish', info, rtt);\n                  } else {\n                    that.emit('finish');\n                  }\n                };\n\n                xo.ontimeout = function () {\n                  xo.close();\n                  that.emit('finish');\n                };\n              };\n\n              var InfoReceiverIframe = function InfoReceiverIframe(base_url) {\n                var that = this;\n\n                var go = function go() {\n                  var ifr = new IframeTransport();\n                  ifr.protocol = 'w-iframe-info-receiver';\n\n                  var fun = function fun(r) {\n                    if (typeof r === 'string' && r.substr(0, 1) === 'm') {\n                      var d = JSON.parse(r.substr(1));\n                      var info = d[0],\n                          rtt = d[1];\n                      that.emit('finish', info, rtt);\n                    } else {\n                      that.emit('finish');\n                    }\n\n                    ifr.doCleanup();\n                    ifr = null;\n                  };\n\n                  var mock_ri = {\n                    _options: {},\n                    _didClose: fun,\n                    _didMessage: fun\n                  };\n                  ifr.i_constructor(mock_ri, base_url, base_url);\n                };\n\n                if (!_document.body) {\n                  utils.attachEvent('load', go);\n                } else {\n                  go();\n                }\n              };\n\n              InfoReceiverIframe.prototype = new EventEmitter(['finish']);\n\n              var InfoReceiverFake = function InfoReceiverFake() {\n                // It may not be possible to do cross domain AJAX to get the info\n                // data, for example for IE7. But we want to run JSONP, so let's\n                // fake the response, with rtt=2s (rto=6s).\n                var that = this;\n                utils.delay(function () {\n                  that.emit('finish', {}, 2000);\n                });\n              };\n\n              InfoReceiverFake.prototype = new EventEmitter(['finish']);\n\n              var createInfoReceiver = function createInfoReceiver(base_url) {\n                if (utils.isSameOriginUrl(base_url)) {\n                  // If, for some reason, we have SockJS locally - there's no\n                  // need to start up the complex machinery. Just use ajax.\n                  return new InfoReceiver(base_url, utils.XHRLocalObject);\n                }\n\n                switch (utils.isXHRCorsCapable()) {\n                  case 1:\n                    // XHRLocalObject -> no_credentials=true\n                    return new InfoReceiver(base_url, utils.XHRLocalObject);\n\n                  case 2:\n                    // <METEOR>\n                    // https://github.com/sockjs/sockjs-client/issues/79\n                    // XDR doesn't work across different schemes\n                    // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n                    if (utils.isSameOriginScheme(base_url)) return new InfoReceiver(base_url, utils.XDRObject);else return new InfoReceiverFake();\n                  // </METEOR>\n\n                  case 3:\n                    // Opera\n                    return new InfoReceiverIframe(base_url);\n\n                  default:\n                    // IE 7\n                    return new InfoReceiverFake();\n                }\n\n                ;\n              };\n\n              var WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function (ri, _trans_url, base_url) {\n                var ir = new InfoReceiver(base_url, utils.XHRLocalObject);\n\n                ir.onfinish = function (info, rtt) {\n                  ri._didMessage('m' + JSON.stringify([info, rtt]));\n\n                  ri._didClose();\n                };\n              };\n\n              WInfoReceiverIframe.prototype.doCleanup = function () {}; //         [*] End of lib/info.js\n              //         [*] Including lib/trans-iframe-eventsource.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {\n                var that = this;\n                that.protocol = 'w-iframe-eventsource';\n                that.i_constructor.apply(that, arguments);\n              };\n\n              EventSourceIframeTransport.prototype = new IframeTransport();\n\n              EventSourceIframeTransport.enabled = function () {\n                return 'EventSource' in _window && IframeTransport.enabled();\n              };\n\n              EventSourceIframeTransport.need_body = true;\n              EventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource\n              // w-iframe-eventsource\n\n              var EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function (ri, trans_url) {\n                this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);\n              };\n\n              EventSourceTransport.prototype = new AjaxBasedTransport(); //         [*] End of lib/trans-iframe-eventsource.js\n              //         [*] Including lib/trans-iframe-xhr-polling.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n              var XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {\n                var that = this;\n                that.protocol = 'w-iframe-xhr-polling';\n                that.i_constructor.apply(that, arguments);\n              };\n\n              XhrPollingIframeTransport.prototype = new IframeTransport();\n\n              XhrPollingIframeTransport.enabled = function () {\n                return _window.XMLHttpRequest && IframeTransport.enabled();\n              };\n\n              XhrPollingIframeTransport.need_body = true;\n              XhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr\n              // w-iframe-xhr-polling\n\n              var XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function (ri, trans_url) {\n                this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);\n              };\n\n              XhrPollingITransport.prototype = new AjaxBasedTransport(); //         [*] End of lib/trans-iframe-xhr-polling.js\n              //         [*] Including lib/trans-iframe-htmlfile.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n              // This transport generally works in any browser, but will cause a\n              // spinning cursor to appear in any browser other than IE.\n              // We may test this transport in all browsers - why not, but in\n              // production it should be only run in IE.\n\n              var HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {\n                var that = this;\n                that.protocol = 'w-iframe-htmlfile';\n                that.i_constructor.apply(that, arguments);\n              }; // Inheritance.\n\n\n              HtmlFileIframeTransport.prototype = new IframeTransport();\n\n              HtmlFileIframeTransport.enabled = function () {\n                return IframeTransport.enabled();\n              };\n\n              HtmlFileIframeTransport.need_body = true;\n              HtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile\n              // w-iframe-htmlfile\n\n              var HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function (ri, trans_url) {\n                this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);\n              };\n\n              HtmlFileTransport.prototype = new AjaxBasedTransport(); //         [*] End of lib/trans-iframe-htmlfile.js\n              //         [*] Including lib/trans-polling.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n              var Polling = function Polling(ri, Receiver, recv_url, AjaxObject) {\n                var that = this;\n                that.ri = ri;\n                that.Receiver = Receiver;\n                that.recv_url = recv_url;\n                that.AjaxObject = AjaxObject;\n\n                that._scheduleRecv();\n              };\n\n              Polling.prototype._scheduleRecv = function () {\n                var that = this;\n                var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);\n                var msg_counter = 0;\n\n                poll.onmessage = function (e) {\n                  msg_counter += 1;\n\n                  that.ri._didMessage(e.data);\n                };\n\n                poll.onclose = function (e) {\n                  that.poll = poll = poll.onmessage = poll.onclose = null;\n\n                  if (!that.poll_is_closing) {\n                    if (e.reason === 'permanent') {\n                      that.ri._didClose(1006, 'Polling error (' + e.reason + ')');\n                    } else {\n                      that._scheduleRecv();\n                    }\n                  }\n                };\n              };\n\n              Polling.prototype.abort = function () {\n                var that = this;\n                that.poll_is_closing = true;\n\n                if (that.poll) {\n                  that.poll.abort();\n                }\n              }; //         [*] End of lib/trans-polling.js\n              //         [*] Including lib/trans-receiver-eventsource.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var EventSourceReceiver = function EventSourceReceiver(url) {\n                var that = this;\n                var es = new EventSource(url);\n\n                es.onmessage = function (e) {\n                  that.dispatchEvent(new SimpleEvent('message', {\n                    'data': unescape(e.data)\n                  }));\n                };\n\n                that.es_close = es.onerror = function (e, abort_reason) {\n                  // ES on reconnection has readyState = 0 or 1.\n                  // on network error it's CLOSED = 2\n                  var reason = abort_reason ? 'user' : es.readyState !== 2 ? 'network' : 'permanent';\n                  that.es_close = es.onmessage = es.onerror = null; // EventSource reconnects automatically.\n\n                  es.close();\n                  es = null; // Safari and chrome < 15 crash if we close window before\n                  // waiting for ES cleanup. See:\n                  //   https://code.google.com/p/chromium/issues/detail?id=89155\n\n                  utils.delay(200, function () {\n                    that.dispatchEvent(new SimpleEvent('close', {\n                      reason: reason\n                    }));\n                  });\n                };\n              };\n\n              EventSourceReceiver.prototype = new REventTarget();\n\n              EventSourceReceiver.prototype.abort = function () {\n                var that = this;\n\n                if (that.es_close) {\n                  that.es_close({}, true);\n                }\n              }; //         [*] End of lib/trans-receiver-eventsource.js\n              //         [*] Including lib/trans-receiver-htmlfile.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var _is_ie_htmlfile_capable;\n\n              var isIeHtmlfileCapable = function isIeHtmlfileCapable() {\n                if (_is_ie_htmlfile_capable === undefined) {\n                  if ('ActiveXObject' in _window) {\n                    try {\n                      _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');\n                    } catch (x) {}\n                  } else {\n                    _is_ie_htmlfile_capable = false;\n                  }\n                }\n\n                return _is_ie_htmlfile_capable;\n              };\n\n              var HtmlfileReceiver = function HtmlfileReceiver(url) {\n                var that = this;\n                utils.polluteGlobalNamespace();\n                that.id = 'a' + utils.random_string(6, 26);\n                url += (url.indexOf('?') === -1 ? '?' : '&') + 'c=' + escape(WPrefix + '.' + that.id);\n                var constructor = isIeHtmlfileCapable() ? utils.createHtmlfile : utils.createIframe;\n                var iframeObj;\n                _window[WPrefix][that.id] = {\n                  start: function start() {\n                    iframeObj.loaded();\n                  },\n                  message: function message(data) {\n                    that.dispatchEvent(new SimpleEvent('message', {\n                      'data': data\n                    }));\n                  },\n                  stop: function stop() {\n                    that.iframe_close({}, 'network');\n                  }\n                };\n\n                that.iframe_close = function (e, abort_reason) {\n                  iframeObj.cleanup();\n                  that.iframe_close = iframeObj = null;\n                  delete _window[WPrefix][that.id];\n                  that.dispatchEvent(new SimpleEvent('close', {\n                    reason: abort_reason\n                  }));\n                };\n\n                iframeObj = constructor(url, function (e) {\n                  that.iframe_close({}, 'permanent');\n                });\n              };\n\n              HtmlfileReceiver.prototype = new REventTarget();\n\n              HtmlfileReceiver.prototype.abort = function () {\n                var that = this;\n\n                if (that.iframe_close) {\n                  that.iframe_close({}, 'user');\n                }\n              }; //         [*] End of lib/trans-receiver-htmlfile.js\n              //         [*] Including lib/trans-receiver-xhr.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n\n\n              var XhrReceiver = function XhrReceiver(url, AjaxObject) {\n                var that = this;\n                var buf_pos = 0;\n                that.xo = new AjaxObject('POST', url, null);\n\n                that.xo.onchunk = function (status, text) {\n                  if (status !== 200) return;\n\n                  while (1) {\n                    var buf = text.slice(buf_pos);\n                    var p = buf.indexOf('\\n');\n                    if (p === -1) break;\n                    buf_pos += p + 1;\n                    var msg = buf.slice(0, p);\n                    that.dispatchEvent(new SimpleEvent('message', {\n                      data: msg\n                    }));\n                  }\n                };\n\n                that.xo.onfinish = function (status, text) {\n                  that.xo.onchunk(status, text);\n                  that.xo = null;\n                  var reason = status === 200 ? 'network' : 'permanent';\n                  that.dispatchEvent(new SimpleEvent('close', {\n                    reason: reason\n                  }));\n                };\n              };\n\n              XhrReceiver.prototype = new REventTarget();\n\n              XhrReceiver.prototype.abort = function () {\n                var that = this;\n\n                if (that.xo) {\n                  that.xo.close();\n                  that.dispatchEvent(new SimpleEvent('close', {\n                    reason: 'user'\n                  }));\n                  that.xo = null;\n                }\n              }; //         [*] End of lib/trans-receiver-xhr.js\n              //         [*] Including lib/test-hooks.js\n\n              /*\n               * ***** BEGIN LICENSE BLOCK *****\n               * Copyright (c) 2011-2012 VMware, Inc.\n               *\n               * For the license see COPYING.\n               * ***** END LICENSE BLOCK *****\n               */\n              // For testing\n\n\n              SockJS.getUtils = function () {\n                return utils;\n              };\n\n              SockJS.getIframeTransport = function () {\n                return IframeTransport;\n              }; //         [*] End of lib/test-hooks.js\n\n\n              return SockJS;\n            }();\n\n            if ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1); // AMD compliance\n\n            if (typeof define === 'function' && define.amd) {\n              define('sockjs', [], function () {\n                return SockJS;\n              });\n            } //     [*] End of lib/index.js\n            // [*] End of lib/all.js\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"urls.js\": function urlsJs(require, exports, module) {\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                     //\n            // packages/socket-stream-client/urls.js                                                                               //\n            //                                                                                                                     //\n            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              toSockjsUrl: function toSockjsUrl() {\n                return _toSockjsUrl2;\n              },\n              toWebsocketUrl: function toWebsocketUrl() {\n                return _toWebsocketUrl2;\n              }\n            }); // @param url {String} URL to Meteor app, eg:\n            //   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"\n            //   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n            // @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.\n            // for scheme \"http\" and subPath \"sockjs\"\n            //   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"\n            //   or \"https://ddp--1234-foo.meteor.com/sockjs\"\n\n            function translateUrl(url, newSchemeBase, subPath) {\n              if (!newSchemeBase) {\n                newSchemeBase = 'http';\n              }\n\n              if (subPath !== \"sockjs\" && url.startsWith(\"/\")) {\n                url = Meteor.absoluteUrl(url.substr(1));\n              }\n\n              var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);\n              var httpUrlMatch = url.match(/^http(s?):\\/\\//);\n              var newScheme;\n\n              if (ddpUrlMatch) {\n                // Remove scheme and split off the host.\n                var urlAfterDDP = url.substr(ddpUrlMatch[0].length);\n                newScheme = ddpUrlMatch[1] === 'i' ? newSchemeBase : newSchemeBase + 's';\n                var slashPos = urlAfterDDP.indexOf('/');\n                var host = slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);\n                var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos); // In the host (ONLY!), change '*' characters into random digits. This\n                // allows different stream connections to connect to different hostnames\n                // and avoid browser per-hostname connection limits.\n\n                host = host.replace(/\\*/g, function () {\n                  return Math.floor(Math.random() * 10);\n                });\n                return newScheme + '://' + host + rest;\n              } else if (httpUrlMatch) {\n                newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + 's';\n                var urlAfterHttp = url.substr(httpUrlMatch[0].length);\n                url = newScheme + '://' + urlAfterHttp;\n              } // Prefix FQDNs but not relative URLs\n\n\n              if (url.indexOf('://') === -1 && !url.startsWith('/')) {\n                url = newSchemeBase + '://' + url;\n              } // XXX This is not what we should be doing: if I have a site\n              // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect\n              // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if\n              // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")\n              // to connect to \"/foo/bar\").\n              //\n              // We should make this properly honor absolute paths rather than\n              // forcing the path to be relative to the site root. Simultaneously,\n              // we should set DDP_DEFAULT_CONNECTION_URL to include the site\n              // root. See also client_convenience.js #RationalizingRelativeDDPURLs\n\n\n              url = Meteor._relativeToSiteRootUrl(url);\n              if (url.endsWith('/')) return url + subPath;else return url + '/' + subPath;\n            }\n\n            function _toSockjsUrl2(url) {\n              return translateUrl(url, 'http', 'sockjs');\n            }\n\n            function _toWebsocketUrl2(url) {\n              return translateUrl(url, 'ws', 'websocket');\n            } /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n  /* Exports */\n\n\n  Package._define(\"socket-stream-client\");\n})();\n\nmodule.exports = window.Package[\"socket-stream-client\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/socket-stream-client.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/standard-minifier-css.js":
/*!**************************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/standard-minifier-css.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/standard-minifier-css.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/standard-minifier-js.js":
/*!*************************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/standard-minifier-js.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/standard-minifier-js.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/static-html.js":
/*!****************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/static-html.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/static-html.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/tracker.js":
/*!************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/tracker.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var Tracker, Deps, computation;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"tracker\": {\n          \"tracker.js\": function trackerJs() {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/tracker/tracker.js                                                                                        //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            /////////////////////////////////////////////////////\n            // Package docs at http://docs.meteor.com/#tracker //\n            /////////////////////////////////////////////////////\n\n            /**\n             * @namespace Tracker\n             * @summary The namespace for Tracker-related methods.\n             */\n            Tracker = {};\n            /**\n             * @namespace Deps\n             * @deprecated\n             */\n\n            Deps = Tracker; // http://docs.meteor.com/#tracker_active\n\n            /**\n             * @summary True if there is a current computation, meaning that dependencies on reactive data sources will be tracked and potentially cause the current computation to be rerun.\n             * @locus Client\n             * @type {Boolean}\n             */\n\n            Tracker.active = false; // http://docs.meteor.com/#tracker_currentcomputation\n\n            /**\n             * @summary The current computation, or `null` if there isn't one.  The current computation is the [`Tracker.Computation`](#tracker_computation) object created by the innermost active call to `Tracker.autorun`, and it's the computation that gains dependencies when reactive data sources are accessed.\n             * @locus Client\n             * @type {Tracker.Computation}\n             */\n\n            Tracker.currentComputation = null;\n\n            function setCurrentComputation(c) {\n              Tracker.currentComputation = c;\n              Tracker.active = !!c;\n            }\n\n            function _debugFunc() {\n              // We want this code to work without Meteor, and also without\n              // \"console\" (which is technically non-standard and may be missing\n              // on some browser we come across, like it was on IE 7).\n              //\n              // Lazy evaluation because `Meteor` does not exist right away.(??)\n              return typeof Meteor !== \"undefined\" ? Meteor._debug : typeof console !== \"undefined\" && console.error ? function () {\n                console.error.apply(console, arguments);\n              } : function () {};\n            }\n\n            function _maybeSuppressMoreLogs(messagesLength) {\n              // Sometimes when running tests, we intentionally suppress logs on expected\n              // printed errors. Since the current implementation of _throwOrLog can log\n              // multiple separate log messages, suppress all of them if at least one suppress\n              // is expected as we still want them to count as one.\n              if (typeof Meteor !== \"undefined\") {\n                if (Meteor._suppressed_log_expected()) {\n                  Meteor._suppress_log(messagesLength - 1);\n                }\n              }\n            }\n\n            function _throwOrLog(from, e) {\n              if (throwFirstError) {\n                throw e;\n              } else {\n                var printArgs = [\"Exception from Tracker \" + from + \" function:\"];\n\n                if (e.stack && e.message && e.name) {\n                  var idx = e.stack.indexOf(e.message);\n\n                  if (idx < 0 || idx > e.name.length + 2) {\n                    // check for \"Error: \"\n                    // message is not part of the stack\n                    var message = e.name + \": \" + e.message;\n                    printArgs.push(message);\n                  }\n                }\n\n                printArgs.push(e.stack);\n\n                _maybeSuppressMoreLogs(printArgs.length);\n\n                for (var i = 0; i < printArgs.length; i++) {\n                  _debugFunc()(printArgs[i]);\n                }\n              }\n            } // Takes a function `f`, and wraps it in a `Meteor._noYieldsAllowed`\n            // block if we are running on the server. On the client, returns the\n            // original function (since `Meteor._noYieldsAllowed` is a\n            // no-op). This has the benefit of not adding an unnecessary stack\n            // frame on the client.\n\n\n            function withNoYieldsAllowed(f) {\n              if (typeof Meteor === 'undefined' || Meteor.isClient) {\n                return f;\n              } else {\n                return function () {\n                  var args = arguments;\n\n                  Meteor._noYieldsAllowed(function () {\n                    f.apply(null, args);\n                  });\n                };\n              }\n            }\n\n            var nextId = 1; // computations whose callbacks we should call at flush time\n\n            var pendingComputations = []; // `true` if a Tracker.flush is scheduled, or if we are in Tracker.flush now\n\n            var willFlush = false; // `true` if we are in Tracker.flush now\n\n            var inFlush = false; // `true` if we are computing a computation now, either first time\n            // or recompute.  This matches Tracker.active unless we are inside\n            // Tracker.nonreactive, which nullfies currentComputation even though\n            // an enclosing computation may still be running.\n\n            var inCompute = false; // `true` if the `_throwFirstError` option was passed in to the call\n            // to Tracker.flush that we are in. When set, throw rather than log the\n            // first error encountered while flushing. Before throwing the error,\n            // finish flushing (from a finally block), logging any subsequent\n            // errors.\n\n            var throwFirstError = false;\n            var afterFlushCallbacks = [];\n\n            function requireFlush() {\n              if (!willFlush) {\n                // We want this code to work without Meteor, see debugFunc above\n                if (typeof Meteor !== \"undefined\") Meteor._setImmediate(Tracker._runFlush);else setTimeout(Tracker._runFlush, 0);\n                willFlush = true;\n              }\n            } // Tracker.Computation constructor is visible but private\n            // (throws an error if you try to call it)\n\n\n            var constructingComputation = false; //\n            // http://docs.meteor.com/#tracker_computation\n\n            /**\n             * @summary A Computation object represents code that is repeatedly rerun\n             * in response to\n             * reactive data changes. Computations don't have return values; they just\n             * perform actions, such as rerendering a template on the screen. Computations\n             * are created using Tracker.autorun. Use stop to prevent further rerunning of a\n             * computation.\n             * @instancename computation\n             */\n\n            Tracker.Computation =\n            /*#__PURE__*/\n            function () {\n              function Computation(f, parent, onError) {\n                _classCallCheck(this, Computation);\n\n                if (!constructingComputation) throw new Error(\"Tracker.Computation constructor is private; use Tracker.autorun\");\n                constructingComputation = false; // http://docs.meteor.com/#computation_stopped\n\n                /**\n                 * @summary True if this computation has been stopped.\n                 * @locus Client\n                 * @memberOf Tracker.Computation\n                 * @instance\n                 * @name  stopped\n                 */\n\n                this.stopped = false; // http://docs.meteor.com/#computation_invalidated\n\n                /**\n                 * @summary True if this computation has been invalidated (and not yet rerun), or if it has been stopped.\n                 * @locus Client\n                 * @memberOf Tracker.Computation\n                 * @instance\n                 * @name  invalidated\n                 * @type {Boolean}\n                 */\n\n                this.invalidated = false; // http://docs.meteor.com/#computation_firstrun\n\n                /**\n                 * @summary True during the initial run of the computation at the time `Tracker.autorun` is called, and false on subsequent reruns and at other times.\n                 * @locus Client\n                 * @memberOf Tracker.Computation\n                 * @instance\n                 * @name  firstRun\n                 * @type {Boolean}\n                 */\n\n                this.firstRun = true;\n                this._id = nextId++;\n                this._onInvalidateCallbacks = [];\n                this._onStopCallbacks = []; // the plan is at some point to use the parent relation\n                // to constrain the order that computations are processed\n\n                this._parent = parent;\n                this._func = f;\n                this._onError = onError;\n                this._recomputing = false;\n                var errored = true;\n\n                try {\n                  this._compute();\n\n                  errored = false;\n                } finally {\n                  this.firstRun = false;\n                  if (errored) this.stop();\n                }\n              } // http://docs.meteor.com/#computation_oninvalidate\n\n              /**\n               * @summary Registers `callback` to run when this computation is next invalidated, or runs it immediately if the computation is already invalidated.  The callback is run exactly once and not upon future invalidations unless `onInvalidate` is called again after the computation becomes valid again.\n               * @locus Client\n               * @param {Function} callback Function to be called on invalidation. Receives one argument, the computation that was invalidated.\n               */\n\n\n              _createClass(Computation, [{\n                key: \"onInvalidate\",\n                value: function onInvalidate(f) {\n                  var _this = this;\n\n                  if (typeof f !== 'function') throw new Error(\"onInvalidate requires a function\");\n\n                  if (this.invalidated) {\n                    Tracker.nonreactive(function () {\n                      withNoYieldsAllowed(f)(_this);\n                    });\n                  } else {\n                    this._onInvalidateCallbacks.push(f);\n                  }\n                }\n                /**\n                 * @summary Registers `callback` to run when this computation is stopped, or runs it immediately if the computation is already stopped.  The callback is run after any `onInvalidate` callbacks.\n                 * @locus Client\n                 * @param {Function} callback Function to be called on stop. Receives one argument, the computation that was stopped.\n                 */\n\n              }, {\n                key: \"onStop\",\n                value: function onStop(f) {\n                  var _this2 = this;\n\n                  if (typeof f !== 'function') throw new Error(\"onStop requires a function\");\n\n                  if (this.stopped) {\n                    Tracker.nonreactive(function () {\n                      withNoYieldsAllowed(f)(_this2);\n                    });\n                  } else {\n                    this._onStopCallbacks.push(f);\n                  }\n                } // http://docs.meteor.com/#computation_invalidate\n\n                /**\n                 * @summary Invalidates this computation so that it will be rerun.\n                 * @locus Client\n                 */\n\n              }, {\n                key: \"invalidate\",\n                value: function invalidate() {\n                  var _this3 = this;\n\n                  if (!this.invalidated) {\n                    // if we're currently in _recompute(), don't enqueue\n                    // ourselves, since we'll rerun immediately anyway.\n                    if (!this._recomputing && !this.stopped) {\n                      requireFlush();\n                      pendingComputations.push(this);\n                    }\n\n                    this.invalidated = true; // callbacks can't add callbacks, because\n                    // this.invalidated === true.\n\n                    for (var i = 0, f; f = this._onInvalidateCallbacks[i]; i++) {\n                      Tracker.nonreactive(function () {\n                        withNoYieldsAllowed(f)(_this3);\n                      });\n                    }\n\n                    this._onInvalidateCallbacks = [];\n                  }\n                } // http://docs.meteor.com/#computation_stop\n\n                /**\n                 * @summary Prevents this computation from rerunning.\n                 * @locus Client\n                 */\n\n              }, {\n                key: \"stop\",\n                value: function stop() {\n                  var _this4 = this;\n\n                  if (!this.stopped) {\n                    this.stopped = true;\n                    this.invalidate();\n\n                    for (var i = 0, f; f = this._onStopCallbacks[i]; i++) {\n                      Tracker.nonreactive(function () {\n                        withNoYieldsAllowed(f)(_this4);\n                      });\n                    }\n\n                    this._onStopCallbacks = [];\n                  }\n                }\n              }, {\n                key: \"_compute\",\n                value: function _compute() {\n                  this.invalidated = false;\n                  var previous = Tracker.currentComputation;\n                  setCurrentComputation(this);\n                  var previousInCompute = inCompute;\n                  inCompute = true;\n\n                  try {\n                    withNoYieldsAllowed(this._func)(this);\n                  } finally {\n                    setCurrentComputation(previous);\n                    inCompute = previousInCompute;\n                  }\n                }\n              }, {\n                key: \"_needsRecompute\",\n                value: function _needsRecompute() {\n                  return this.invalidated && !this.stopped;\n                }\n              }, {\n                key: \"_recompute\",\n                value: function _recompute() {\n                  this._recomputing = true;\n\n                  try {\n                    if (this._needsRecompute()) {\n                      try {\n                        this._compute();\n                      } catch (e) {\n                        if (this._onError) {\n                          this._onError(e);\n                        } else {\n                          _throwOrLog(\"recompute\", e);\n                        }\n                      }\n                    }\n                  } finally {\n                    this._recomputing = false;\n                  }\n                }\n                /**\n                 * @summary Process the reactive updates for this computation immediately\n                 * and ensure that the computation is rerun. The computation is rerun only\n                 * if it is invalidated.\n                 * @locus Client\n                 */\n\n              }, {\n                key: \"flush\",\n                value: function flush() {\n                  if (this._recomputing) return;\n\n                  this._recompute();\n                }\n                /**\n                 * @summary Causes the function inside this computation to run and\n                 * synchronously process all reactive updtes.\n                 * @locus Client\n                 */\n\n              }, {\n                key: \"run\",\n                value: function run() {\n                  this.invalidate();\n                  this.flush();\n                }\n              }]);\n\n              return Computation;\n            }(); //\n            // http://docs.meteor.com/#tracker_dependency\n\n            /**\n             * @summary A Dependency represents an atomic unit of reactive data that a\n             * computation might depend on. Reactive data sources such as Session or\n             * Minimongo internally create different Dependency objects for different\n             * pieces of data, each of which may be depended on by multiple computations.\n             * When the data changes, the computations are invalidated.\n             * @class\n             * @instanceName dependency\n             */\n\n\n            Tracker.Dependency =\n            /*#__PURE__*/\n            function () {\n              function Dependency() {\n                _classCallCheck(this, Dependency);\n\n                this._dependentsById = Object.create(null);\n              } // http://docs.meteor.com/#dependency_depend\n              //\n              // Adds `computation` to this set if it is not already\n              // present.  Returns true if `computation` is a new member of the set.\n              // If no argument, defaults to currentComputation, or does nothing\n              // if there is no currentComputation.\n\n              /**\n               * @summary Declares that the current computation (or `fromComputation` if given) depends on `dependency`.  The computation will be invalidated the next time `dependency` changes.\n                If there is no current computation and `depend()` is called with no arguments, it does nothing and returns false.\n                Returns true if the computation is a new dependent of `dependency` rather than an existing one.\n               * @locus Client\n               * @param {Tracker.Computation} [fromComputation] An optional computation declared to depend on `dependency` instead of the current computation.\n               * @returns {Boolean}\n               */\n\n\n              _createClass(Dependency, [{\n                key: \"depend\",\n                value: function depend(computation) {\n                  var _this5 = this;\n\n                  if (!computation) {\n                    if (!Tracker.active) return false;\n                    computation = Tracker.currentComputation;\n                  }\n\n                  var id = computation._id;\n\n                  if (!(id in this._dependentsById)) {\n                    this._dependentsById[id] = computation;\n                    computation.onInvalidate(function () {\n                      delete _this5._dependentsById[id];\n                    });\n                    return true;\n                  }\n\n                  return false;\n                } // http://docs.meteor.com/#dependency_changed\n\n                /**\n                 * @summary Invalidate all dependent computations immediately and remove them as dependents.\n                 * @locus Client\n                 */\n\n              }, {\n                key: \"changed\",\n                value: function changed() {\n                  for (var id in this._dependentsById) {\n                    this._dependentsById[id].invalidate();\n                  }\n                } // http://docs.meteor.com/#dependency_hasdependents\n\n                /**\n                 * @summary True if this Dependency has one or more dependent Computations, which would be invalidated if this Dependency were to change.\n                 * @locus Client\n                 * @returns {Boolean}\n                 */\n\n              }, {\n                key: \"hasDependents\",\n                value: function hasDependents() {\n                  for (var id in this._dependentsById) {\n                    return true;\n                  }\n\n                  return false;\n                }\n              }]);\n\n              return Dependency;\n            }(); // http://docs.meteor.com/#tracker_flush\n\n            /**\n             * @summary Process all reactive updates immediately and ensure that all invalidated computations are rerun.\n             * @locus Client\n             */\n\n\n            Tracker.flush = function (options) {\n              Tracker._runFlush({\n                finishSynchronously: true,\n                throwFirstError: options && options._throwFirstError\n              });\n            };\n            /**\n             * @summary True if we are computing a computation now, either first time or recompute.  This matches Tracker.active unless we are inside Tracker.nonreactive, which nullfies currentComputation even though an enclosing computation may still be running.\n             * @locus Client\n             * @returns {Boolean}\n             */\n\n\n            Tracker.inFlush = function () {\n              return inFlush;\n            }; // Run all pending computations and afterFlush callbacks.  If we were not called\n            // directly via Tracker.flush, this may return before they're all done to allow\n            // the event loop to run a little before continuing.\n\n\n            Tracker._runFlush = function (options) {\n              // XXX What part of the comment below is still true? (We no longer\n              // have Spark)\n              //\n              // Nested flush could plausibly happen if, say, a flush causes\n              // DOM mutation, which causes a \"blur\" event, which runs an\n              // app event handler that calls Tracker.flush.  At the moment\n              // Spark blocks event handlers during DOM mutation anyway,\n              // because the LiveRange tree isn't valid.  And we don't have\n              // any useful notion of a nested flush.\n              //\n              // https://app.asana.com/0/159908330244/385138233856\n              if (Tracker.inFlush()) throw new Error(\"Can't call Tracker.flush while flushing\");\n              if (inCompute) throw new Error(\"Can't flush inside Tracker.autorun\");\n              options = options || {};\n              inFlush = true;\n              willFlush = true;\n              throwFirstError = !!options.throwFirstError;\n              var recomputedCount = 0;\n              var finishedTry = false;\n\n              try {\n                while (pendingComputations.length || afterFlushCallbacks.length) {\n                  // recompute all pending computations\n                  while (pendingComputations.length) {\n                    var comp = pendingComputations.shift();\n\n                    comp._recompute();\n\n                    if (comp._needsRecompute()) {\n                      pendingComputations.unshift(comp);\n                    }\n\n                    if (!options.finishSynchronously && ++recomputedCount > 1000) {\n                      finishedTry = true;\n                      return;\n                    }\n                  }\n\n                  if (afterFlushCallbacks.length) {\n                    // call one afterFlush callback, which may\n                    // invalidate more computations\n                    var func = afterFlushCallbacks.shift();\n\n                    try {\n                      func();\n                    } catch (e) {\n                      _throwOrLog(\"afterFlush\", e);\n                    }\n                  }\n                }\n\n                finishedTry = true;\n              } finally {\n                if (!finishedTry) {\n                  // we're erroring due to throwFirstError being true.\n                  inFlush = false; // needed before calling `Tracker.flush()` again\n                  // finish flushing\n\n                  Tracker._runFlush({\n                    finishSynchronously: options.finishSynchronously,\n                    throwFirstError: false\n                  });\n                }\n\n                willFlush = false;\n                inFlush = false;\n\n                if (pendingComputations.length || afterFlushCallbacks.length) {\n                  // We're yielding because we ran a bunch of computations and we aren't\n                  // required to finish synchronously, so we'd like to give the event loop a\n                  // chance. We should flush again soon.\n                  if (options.finishSynchronously) {\n                    throw new Error(\"still have more to do?\"); // shouldn't happen\n                  }\n\n                  setTimeout(requireFlush, 10);\n                }\n              }\n            }; // http://docs.meteor.com/#tracker_autorun\n            //\n            // Run f(). Record its dependencies. Rerun it whenever the\n            // dependencies change.\n            //\n            // Returns a new Computation, which is also passed to f.\n            //\n            // Links the computation to the current computation\n            // so that it is stopped if the current computation is invalidated.\n\n            /**\n             * @callback Tracker.ComputationFunction\n             * @param {Tracker.Computation}\n             */\n\n            /**\n             * @summary Run a function now and rerun it later whenever its dependencies\n             * change. Returns a Computation object that can be used to stop or observe the\n             * rerunning.\n             * @locus Client\n             * @param {Tracker.ComputationFunction} runFunc The function to run. It receives\n             * one argument: the Computation object that will be returned.\n             * @param {Object} [options]\n             * @param {Function} options.onError Optional. The function to run when an error\n             * happens in the Computation. The only argument it receives is the Error\n             * thrown. Defaults to the error being logged to the console.\n             * @returns {Tracker.Computation}\n             */\n\n\n            Tracker.autorun = function (f, options) {\n              if (typeof f !== 'function') throw new Error('Tracker.autorun requires a function argument');\n              options = options || {};\n              constructingComputation = true;\n              var c = new Tracker.Computation(f, Tracker.currentComputation, options.onError);\n              if (Tracker.active) Tracker.onInvalidate(function () {\n                c.stop();\n              });\n              return c;\n            }; // http://docs.meteor.com/#tracker_nonreactive\n            //\n            // Run `f` with no current computation, returning the return value\n            // of `f`.  Used to turn off reactivity for the duration of `f`,\n            // so that reactive data sources accessed by `f` will not result in any\n            // computations being invalidated.\n\n            /**\n             * @summary Run a function without tracking dependencies.\n             * @locus Client\n             * @param {Function} func A function to call immediately.\n             */\n\n\n            Tracker.nonreactive = function (f) {\n              var previous = Tracker.currentComputation;\n              setCurrentComputation(null);\n\n              try {\n                return f();\n              } finally {\n                setCurrentComputation(previous);\n              }\n            }; // http://docs.meteor.com/#tracker_oninvalidate\n\n            /**\n             * @summary Registers a new [`onInvalidate`](#computation_oninvalidate) callback on the current computation (which must exist), to be called immediately when the current computation is invalidated or stopped.\n             * @locus Client\n             * @param {Function} callback A callback function that will be invoked as `func(c)`, where `c` is the computation on which the callback is registered.\n             */\n\n\n            Tracker.onInvalidate = function (f) {\n              if (!Tracker.active) throw new Error(\"Tracker.onInvalidate requires a currentComputation\");\n              Tracker.currentComputation.onInvalidate(f);\n            }; // http://docs.meteor.com/#tracker_afterflush\n\n            /**\n             * @summary Schedules a function to be called during the next flush, or later in the current flush if one is in progress, after all invalidated computations have been rerun.  The function will be run once and not on subsequent flushes unless `afterFlush` is called again.\n             * @locus Client\n             * @param {Function} callback A function to call at flush time.\n             */\n\n\n            Tracker.afterFlush = function (f) {\n              afterFlushCallbacks.push(f);\n              requireFlush();\n            }; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  require(\"/node_modules/meteor/tracker/tracker.js\");\n  /* Exports */\n\n\n  Package._define(\"tracker\", {\n    Tracker: Tracker,\n    Deps: Deps\n  });\n})();\n\nmodule.exports = window.Package[\"tracker\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/tracker.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap.js":
/*!*******************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var $ = Package.jquery.$;\n  var jQuery = Package.jquery.jQuery;\n  (function () {\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //                                                                                                                     //\n    // packages/twbs_bootstrap/dist/js/bootstrap.js                                                                        //\n    //                                                                                                                     //\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n\n    /*!\n     * Bootstrap v3.3.6 (http://getbootstrap.com)\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under the MIT license\n     */\n    if (typeof jQuery === 'undefined') {\n      throw new Error('Bootstrap\\'s JavaScript requires jQuery');\n    }\n\n    +function ($) {\n      'use strict';\n\n      var version = $.fn.jquery.split(' ')[0].split('.');\n\n      if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] > 2) {\n        throw new Error('Bootstrap\\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3');\n      }\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: transition.js v3.3.6\n     * http://getbootstrap.com/javascript/#transitions\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\n      // ============================================================\n\n      function transitionEnd() {\n        var el = document.createElement('bootstrap');\n        var transEndEventNames = {\n          WebkitTransition: 'webkitTransitionEnd',\n          MozTransition: 'transitionend',\n          OTransition: 'oTransitionEnd otransitionend',\n          transition: 'transitionend'\n        };\n\n        for (var name in transEndEventNames) {\n          if (el.style[name] !== undefined) {\n            return {\n              end: transEndEventNames[name]\n            };\n          }\n        }\n\n        return false; // explicit for ie8 (  ._.)\n      } // http://blog.alexmaccaw.com/css-transitions\n\n\n      $.fn.emulateTransitionEnd = function (duration) {\n        var called = false;\n        var $el = this;\n        $(this).one('bsTransitionEnd', function () {\n          called = true;\n        });\n\n        var callback = function callback() {\n          if (!called) $($el).trigger($.support.transition.end);\n        };\n\n        setTimeout(callback, duration);\n        return this;\n      };\n\n      $(function () {\n        $.support.transition = transitionEnd();\n        if (!$.support.transition) return;\n        $.event.special.bsTransitionEnd = {\n          bindType: $.support.transition.end,\n          delegateType: $.support.transition.end,\n          handle: function handle(e) {\n            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);\n          }\n        };\n      });\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: alert.js v3.3.6\n     * http://getbootstrap.com/javascript/#alerts\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // ALERT CLASS DEFINITION\n      // ======================\n\n      var dismiss = '[data-dismiss=\"alert\"]';\n\n      var Alert = function Alert(el) {\n        $(el).on('click', dismiss, this.close);\n      };\n\n      Alert.VERSION = '3.3.6';\n      Alert.TRANSITION_DURATION = 150;\n\n      Alert.prototype.close = function (e) {\n        var $this = $(this);\n        var selector = $this.attr('data-target');\n\n        if (!selector) {\n          selector = $this.attr('href');\n          selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, ''); // strip for ie7\n        }\n\n        var $parent = $(selector);\n        if (e) e.preventDefault();\n\n        if (!$parent.length) {\n          $parent = $this.closest('.alert');\n        }\n\n        $parent.trigger(e = $.Event('close.bs.alert'));\n        if (e.isDefaultPrevented()) return;\n        $parent.removeClass('in');\n\n        function removeElement() {\n          // detach from parent, fire event then clean up data\n          $parent.detach().trigger('closed.bs.alert').remove();\n        }\n\n        $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();\n      }; // ALERT PLUGIN DEFINITION\n      // =======================\n\n\n      function Plugin(option) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.alert');\n          if (!data) $this.data('bs.alert', data = new Alert(this));\n          if (typeof option == 'string') data[option].call($this);\n        });\n      }\n\n      var old = $.fn.alert;\n      $.fn.alert = Plugin;\n      $.fn.alert.Constructor = Alert; // ALERT NO CONFLICT\n      // =================\n\n      $.fn.alert.noConflict = function () {\n        $.fn.alert = old;\n        return this;\n      }; // ALERT DATA-API\n      // ==============\n\n\n      $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: button.js v3.3.6\n     * http://getbootstrap.com/javascript/#buttons\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // BUTTON PUBLIC CLASS DEFINITION\n      // ==============================\n\n      var Button = function Button(element, options) {\n        this.$element = $(element);\n        this.options = $.extend({}, Button.DEFAULTS, options);\n        this.isLoading = false;\n      };\n\n      Button.VERSION = '3.3.6';\n      Button.DEFAULTS = {\n        loadingText: 'loading...'\n      };\n\n      Button.prototype.setState = function (state) {\n        var d = 'disabled';\n        var $el = this.$element;\n        var val = $el.is('input') ? 'val' : 'html';\n        var data = $el.data();\n        state += 'Text';\n        if (data.resetText == null) $el.data('resetText', $el[val]()); // push to event loop to allow forms to submit\n\n        setTimeout($.proxy(function () {\n          $el[val](data[state] == null ? this.options[state] : data[state]);\n\n          if (state == 'loadingText') {\n            this.isLoading = true;\n            $el.addClass(d).attr(d, d);\n          } else if (this.isLoading) {\n            this.isLoading = false;\n            $el.removeClass(d).removeAttr(d);\n          }\n        }, this), 0);\n      };\n\n      Button.prototype.toggle = function () {\n        var changed = true;\n        var $parent = this.$element.closest('[data-toggle=\"buttons\"]');\n\n        if ($parent.length) {\n          var $input = this.$element.find('input');\n\n          if ($input.prop('type') == 'radio') {\n            if ($input.prop('checked')) changed = false;\n            $parent.find('.active').removeClass('active');\n            this.$element.addClass('active');\n          } else if ($input.prop('type') == 'checkbox') {\n            if ($input.prop('checked') !== this.$element.hasClass('active')) changed = false;\n            this.$element.toggleClass('active');\n          }\n\n          $input.prop('checked', this.$element.hasClass('active'));\n          if (changed) $input.trigger('change');\n        } else {\n          this.$element.attr('aria-pressed', !this.$element.hasClass('active'));\n          this.$element.toggleClass('active');\n        }\n      }; // BUTTON PLUGIN DEFINITION\n      // ========================\n\n\n      function Plugin(option) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.button');\n          var options = _typeof(option) == 'object' && option;\n          if (!data) $this.data('bs.button', data = new Button(this, options));\n          if (option == 'toggle') data.toggle();else if (option) data.setState(option);\n        });\n      }\n\n      var old = $.fn.button;\n      $.fn.button = Plugin;\n      $.fn.button.Constructor = Button; // BUTTON NO CONFLICT\n      // ==================\n\n      $.fn.button.noConflict = function () {\n        $.fn.button = old;\n        return this;\n      }; // BUTTON DATA-API\n      // ===============\n\n\n      $(document).on('click.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n        var $btn = $(e.target);\n        if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn');\n        Plugin.call($btn, 'toggle');\n        if (!($(e.target).is('input[type=\"radio\"]') || $(e.target).is('input[type=\"checkbox\"]'))) e.preventDefault();\n      }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n        $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));\n      });\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: carousel.js v3.3.6\n     * http://getbootstrap.com/javascript/#carousel\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // CAROUSEL CLASS DEFINITION\n      // =========================\n\n      var Carousel = function Carousel(element, options) {\n        this.$element = $(element);\n        this.$indicators = this.$element.find('.carousel-indicators');\n        this.options = options;\n        this.paused = null;\n        this.sliding = null;\n        this.interval = null;\n        this.$active = null;\n        this.$items = null;\n        this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));\n        this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));\n      };\n\n      Carousel.VERSION = '3.3.6';\n      Carousel.TRANSITION_DURATION = 600;\n      Carousel.DEFAULTS = {\n        interval: 5000,\n        pause: 'hover',\n        wrap: true,\n        keyboard: true\n      };\n\n      Carousel.prototype.keydown = function (e) {\n        if (/input|textarea/i.test(e.target.tagName)) return;\n\n        switch (e.which) {\n          case 37:\n            this.prev();\n            break;\n\n          case 39:\n            this.next();\n            break;\n\n          default:\n            return;\n        }\n\n        e.preventDefault();\n      };\n\n      Carousel.prototype.cycle = function (e) {\n        e || (this.paused = false);\n        this.interval && clearInterval(this.interval);\n        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));\n        return this;\n      };\n\n      Carousel.prototype.getItemIndex = function (item) {\n        this.$items = item.parent().children('.item');\n        return this.$items.index(item || this.$active);\n      };\n\n      Carousel.prototype.getItemForDirection = function (direction, active) {\n        var activeIndex = this.getItemIndex(active);\n        var willWrap = direction == 'prev' && activeIndex === 0 || direction == 'next' && activeIndex == this.$items.length - 1;\n        if (willWrap && !this.options.wrap) return active;\n        var delta = direction == 'prev' ? -1 : 1;\n        var itemIndex = (activeIndex + delta) % this.$items.length;\n        return this.$items.eq(itemIndex);\n      };\n\n      Carousel.prototype.to = function (pos) {\n        var that = this;\n        var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));\n        if (pos > this.$items.length - 1 || pos < 0) return;\n        if (this.sliding) return this.$element.one('slid.bs.carousel', function () {\n          that.to(pos);\n        }); // yes, \"slid\"\n\n        if (activeIndex == pos) return this.pause().cycle();\n        return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));\n      };\n\n      Carousel.prototype.pause = function (e) {\n        e || (this.paused = true);\n\n        if (this.$element.find('.next, .prev').length && $.support.transition) {\n          this.$element.trigger($.support.transition.end);\n          this.cycle(true);\n        }\n\n        this.interval = clearInterval(this.interval);\n        return this;\n      };\n\n      Carousel.prototype.next = function () {\n        if (this.sliding) return;\n        return this.slide('next');\n      };\n\n      Carousel.prototype.prev = function () {\n        if (this.sliding) return;\n        return this.slide('prev');\n      };\n\n      Carousel.prototype.slide = function (type, next) {\n        var $active = this.$element.find('.item.active');\n        var $next = next || this.getItemForDirection(type, $active);\n        var isCycling = this.interval;\n        var direction = type == 'next' ? 'left' : 'right';\n        var that = this;\n        if ($next.hasClass('active')) return this.sliding = false;\n        var relatedTarget = $next[0];\n        var slideEvent = $.Event('slide.bs.carousel', {\n          relatedTarget: relatedTarget,\n          direction: direction\n        });\n        this.$element.trigger(slideEvent);\n        if (slideEvent.isDefaultPrevented()) return;\n        this.sliding = true;\n        isCycling && this.pause();\n\n        if (this.$indicators.length) {\n          this.$indicators.find('.active').removeClass('active');\n          var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);\n          $nextIndicator && $nextIndicator.addClass('active');\n        }\n\n        var slidEvent = $.Event('slid.bs.carousel', {\n          relatedTarget: relatedTarget,\n          direction: direction\n        }); // yes, \"slid\"\n\n        if ($.support.transition && this.$element.hasClass('slide')) {\n          $next.addClass(type);\n          $next[0].offsetWidth; // force reflow\n\n          $active.addClass(direction);\n          $next.addClass(direction);\n          $active.one('bsTransitionEnd', function () {\n            $next.removeClass([type, direction].join(' ')).addClass('active');\n            $active.removeClass(['active', direction].join(' '));\n            that.sliding = false;\n            setTimeout(function () {\n              that.$element.trigger(slidEvent);\n            }, 0);\n          }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);\n        } else {\n          $active.removeClass('active');\n          $next.addClass('active');\n          this.sliding = false;\n          this.$element.trigger(slidEvent);\n        }\n\n        isCycling && this.cycle();\n        return this;\n      }; // CAROUSEL PLUGIN DEFINITION\n      // ==========================\n\n\n      function Plugin(option) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.carousel');\n          var options = $.extend({}, Carousel.DEFAULTS, $this.data(), _typeof(option) == 'object' && option);\n          var action = typeof option == 'string' ? option : options.slide;\n          if (!data) $this.data('bs.carousel', data = new Carousel(this, options));\n          if (typeof option == 'number') data.to(option);else if (action) data[action]();else if (options.interval) data.pause().cycle();\n        });\n      }\n\n      var old = $.fn.carousel;\n      $.fn.carousel = Plugin;\n      $.fn.carousel.Constructor = Carousel; // CAROUSEL NO CONFLICT\n      // ====================\n\n      $.fn.carousel.noConflict = function () {\n        $.fn.carousel = old;\n        return this;\n      }; // CAROUSEL DATA-API\n      // =================\n\n\n      var clickHandler = function clickHandler(e) {\n        var href;\n        var $this = $(this);\n        var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '')); // strip for ie7\n\n        if (!$target.hasClass('carousel')) return;\n        var options = $.extend({}, $target.data(), $this.data());\n        var slideIndex = $this.attr('data-slide-to');\n        if (slideIndex) options.interval = false;\n        Plugin.call($target, options);\n\n        if (slideIndex) {\n          $target.data('bs.carousel').to(slideIndex);\n        }\n\n        e.preventDefault();\n      };\n\n      $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);\n      $(window).on('load', function () {\n        $('[data-ride=\"carousel\"]').each(function () {\n          var $carousel = $(this);\n          Plugin.call($carousel, $carousel.data());\n        });\n      });\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: collapse.js v3.3.6\n     * http://getbootstrap.com/javascript/#collapse\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // COLLAPSE PUBLIC CLASS DEFINITION\n      // ================================\n\n      var Collapse = function Collapse(element, options) {\n        this.$element = $(element);\n        this.options = $.extend({}, Collapse.DEFAULTS, options);\n        this.$trigger = $('[data-toggle=\"collapse\"][href=\"#' + element.id + '\"],' + '[data-toggle=\"collapse\"][data-target=\"#' + element.id + '\"]');\n        this.transitioning = null;\n\n        if (this.options.parent) {\n          this.$parent = this.getParent();\n        } else {\n          this.addAriaAndCollapsedClass(this.$element, this.$trigger);\n        }\n\n        if (this.options.toggle) this.toggle();\n      };\n\n      Collapse.VERSION = '3.3.6';\n      Collapse.TRANSITION_DURATION = 350;\n      Collapse.DEFAULTS = {\n        toggle: true\n      };\n\n      Collapse.prototype.dimension = function () {\n        var hasWidth = this.$element.hasClass('width');\n        return hasWidth ? 'width' : 'height';\n      };\n\n      Collapse.prototype.show = function () {\n        if (this.transitioning || this.$element.hasClass('in')) return;\n        var activesData;\n        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');\n\n        if (actives && actives.length) {\n          activesData = actives.data('bs.collapse');\n          if (activesData && activesData.transitioning) return;\n        }\n\n        var startEvent = $.Event('show.bs.collapse');\n        this.$element.trigger(startEvent);\n        if (startEvent.isDefaultPrevented()) return;\n\n        if (actives && actives.length) {\n          Plugin.call(actives, 'hide');\n          activesData || actives.data('bs.collapse', null);\n        }\n\n        var dimension = this.dimension();\n        this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);\n        this.$trigger.removeClass('collapsed').attr('aria-expanded', true);\n        this.transitioning = 1;\n\n        var complete = function complete() {\n          this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');\n          this.transitioning = 0;\n          this.$element.trigger('shown.bs.collapse');\n        };\n\n        if (!$.support.transition) return complete.call(this);\n        var scrollSize = $.camelCase(['scroll', dimension].join('-'));\n        this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);\n      };\n\n      Collapse.prototype.hide = function () {\n        if (this.transitioning || !this.$element.hasClass('in')) return;\n        var startEvent = $.Event('hide.bs.collapse');\n        this.$element.trigger(startEvent);\n        if (startEvent.isDefaultPrevented()) return;\n        var dimension = this.dimension();\n        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;\n        this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);\n        this.$trigger.addClass('collapsed').attr('aria-expanded', false);\n        this.transitioning = 1;\n\n        var complete = function complete() {\n          this.transitioning = 0;\n          this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');\n        };\n\n        if (!$.support.transition) return complete.call(this);\n        this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);\n      };\n\n      Collapse.prototype.toggle = function () {\n        this[this.$element.hasClass('in') ? 'hide' : 'show']();\n      };\n\n      Collapse.prototype.getParent = function () {\n        return $(this.options.parent).find('[data-toggle=\"collapse\"][data-parent=\"' + this.options.parent + '\"]').each($.proxy(function (i, element) {\n          var $element = $(element);\n          this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);\n        }, this)).end();\n      };\n\n      Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {\n        var isOpen = $element.hasClass('in');\n        $element.attr('aria-expanded', isOpen);\n        $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);\n      };\n\n      function getTargetFromTrigger($trigger) {\n        var href;\n        var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, ''); // strip for ie7\n\n        return $(target);\n      } // COLLAPSE PLUGIN DEFINITION\n      // ==========================\n\n\n      function Plugin(option) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.collapse');\n          var options = $.extend({}, Collapse.DEFAULTS, $this.data(), _typeof(option) == 'object' && option);\n          if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;\n          if (!data) $this.data('bs.collapse', data = new Collapse(this, options));\n          if (typeof option == 'string') data[option]();\n        });\n      }\n\n      var old = $.fn.collapse;\n      $.fn.collapse = Plugin;\n      $.fn.collapse.Constructor = Collapse; // COLLAPSE NO CONFLICT\n      // ====================\n\n      $.fn.collapse.noConflict = function () {\n        $.fn.collapse = old;\n        return this;\n      }; // COLLAPSE DATA-API\n      // =================\n\n\n      $(document).on('click.bs.collapse.data-api', '[data-toggle=\"collapse\"]', function (e) {\n        var $this = $(this);\n        if (!$this.attr('data-target')) e.preventDefault();\n        var $target = getTargetFromTrigger($this);\n        var data = $target.data('bs.collapse');\n        var option = data ? 'toggle' : $this.data();\n        Plugin.call($target, option);\n      });\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: dropdown.js v3.3.6\n     * http://getbootstrap.com/javascript/#dropdowns\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // DROPDOWN CLASS DEFINITION\n      // =========================\n\n      var backdrop = '.dropdown-backdrop';\n      var toggle = '[data-toggle=\"dropdown\"]';\n\n      var Dropdown = function Dropdown(element) {\n        $(element).on('click.bs.dropdown', this.toggle);\n      };\n\n      Dropdown.VERSION = '3.3.6';\n\n      function getParent($this) {\n        var selector = $this.attr('data-target');\n\n        if (!selector) {\n          selector = $this.attr('href');\n          selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, ''); // strip for ie7\n        }\n\n        var $parent = selector && $(selector);\n        return $parent && $parent.length ? $parent : $this.parent();\n      }\n\n      function clearMenus(e) {\n        if (e && e.which === 3) return;\n        $(backdrop).remove();\n        $(toggle).each(function () {\n          var $this = $(this);\n          var $parent = getParent($this);\n          var relatedTarget = {\n            relatedTarget: this\n          };\n          if (!$parent.hasClass('open')) return;\n          if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return;\n          $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));\n          if (e.isDefaultPrevented()) return;\n          $this.attr('aria-expanded', 'false');\n          $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget));\n        });\n      }\n\n      Dropdown.prototype.toggle = function (e) {\n        var $this = $(this);\n        if ($this.is('.disabled, :disabled')) return;\n        var $parent = getParent($this);\n        var isActive = $parent.hasClass('open');\n        clearMenus();\n\n        if (!isActive) {\n          if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\n            // if mobile we use a backdrop because click events don't delegate\n            $(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus);\n          }\n\n          var relatedTarget = {\n            relatedTarget: this\n          };\n          $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));\n          if (e.isDefaultPrevented()) return;\n          $this.trigger('focus').attr('aria-expanded', 'true');\n          $parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget));\n        }\n\n        return false;\n      };\n\n      Dropdown.prototype.keydown = function (e) {\n        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;\n        var $this = $(this);\n        e.preventDefault();\n        e.stopPropagation();\n        if ($this.is('.disabled, :disabled')) return;\n        var $parent = getParent($this);\n        var isActive = $parent.hasClass('open');\n\n        if (!isActive && e.which != 27 || isActive && e.which == 27) {\n          if (e.which == 27) $parent.find(toggle).trigger('focus');\n          return $this.trigger('click');\n        }\n\n        var desc = ' li:not(.disabled):visible a';\n        var $items = $parent.find('.dropdown-menu' + desc);\n        if (!$items.length) return;\n        var index = $items.index(e.target);\n        if (e.which == 38 && index > 0) index--; // up\n\n        if (e.which == 40 && index < $items.length - 1) index++; // down\n\n        if (!~index) index = 0;\n        $items.eq(index).trigger('focus');\n      }; // DROPDOWN PLUGIN DEFINITION\n      // ==========================\n\n\n      function Plugin(option) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.dropdown');\n          if (!data) $this.data('bs.dropdown', data = new Dropdown(this));\n          if (typeof option == 'string') data[option].call($this);\n        });\n      }\n\n      var old = $.fn.dropdown;\n      $.fn.dropdown = Plugin;\n      $.fn.dropdown.Constructor = Dropdown; // DROPDOWN NO CONFLICT\n      // ====================\n\n      $.fn.dropdown.noConflict = function () {\n        $.fn.dropdown = old;\n        return this;\n      }; // APPLY TO STANDARD DROPDOWN ELEMENTS\n      // ===================================\n\n\n      $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function (e) {\n        e.stopPropagation();\n      }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: modal.js v3.3.6\n     * http://getbootstrap.com/javascript/#modals\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // MODAL CLASS DEFINITION\n      // ======================\n\n      var Modal = function Modal(element, options) {\n        this.options = options;\n        this.$body = $(document.body);\n        this.$element = $(element);\n        this.$dialog = this.$element.find('.modal-dialog');\n        this.$backdrop = null;\n        this.isShown = null;\n        this.originalBodyPad = null;\n        this.scrollbarWidth = 0;\n        this.ignoreBackdropClick = false;\n\n        if (this.options.remote) {\n          this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {\n            this.$element.trigger('loaded.bs.modal');\n          }, this));\n        }\n      };\n\n      Modal.VERSION = '3.3.6';\n      Modal.TRANSITION_DURATION = 300;\n      Modal.BACKDROP_TRANSITION_DURATION = 150;\n      Modal.DEFAULTS = {\n        backdrop: true,\n        keyboard: true,\n        show: true\n      };\n\n      Modal.prototype.toggle = function (_relatedTarget) {\n        return this.isShown ? this.hide() : this.show(_relatedTarget);\n      };\n\n      Modal.prototype.show = function (_relatedTarget) {\n        var that = this;\n        var e = $.Event('show.bs.modal', {\n          relatedTarget: _relatedTarget\n        });\n        this.$element.trigger(e);\n        if (this.isShown || e.isDefaultPrevented()) return;\n        this.isShown = true;\n        this.checkScrollbar();\n        this.setScrollbar();\n        this.$body.addClass('modal-open');\n        this.escape();\n        this.resize();\n        this.$element.on('click.dismiss.bs.modal', '[data-dismiss=\"modal\"]', $.proxy(this.hide, this));\n        this.$dialog.on('mousedown.dismiss.bs.modal', function () {\n          that.$element.one('mouseup.dismiss.bs.modal', function (e) {\n            if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;\n          });\n        });\n        this.backdrop(function () {\n          var transition = $.support.transition && that.$element.hasClass('fade');\n\n          if (!that.$element.parent().length) {\n            that.$element.appendTo(that.$body); // don't move modals dom position\n          }\n\n          that.$element.show().scrollTop(0);\n          that.adjustDialog();\n\n          if (transition) {\n            that.$element[0].offsetWidth; // force reflow\n          }\n\n          that.$element.addClass('in');\n          that.enforceFocus();\n          var e = $.Event('shown.bs.modal', {\n            relatedTarget: _relatedTarget\n          });\n          transition ? that.$dialog // wait for modal to slide in\n          .one('bsTransitionEnd', function () {\n            that.$element.trigger('focus').trigger(e);\n          }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);\n        });\n      };\n\n      Modal.prototype.hide = function (e) {\n        if (e) e.preventDefault();\n        e = $.Event('hide.bs.modal');\n        this.$element.trigger(e);\n        if (!this.isShown || e.isDefaultPrevented()) return;\n        this.isShown = false;\n        this.escape();\n        this.resize();\n        $(document).off('focusin.bs.modal');\n        this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');\n        this.$dialog.off('mousedown.dismiss.bs.modal');\n        $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();\n      };\n\n      Modal.prototype.enforceFocus = function () {\n        $(document).off('focusin.bs.modal') // guard against infinite focus loop\n        .on('focusin.bs.modal', $.proxy(function (e) {\n          if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {\n            this.$element.trigger('focus');\n          }\n        }, this));\n      };\n\n      Modal.prototype.escape = function () {\n        if (this.isShown && this.options.keyboard) {\n          this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {\n            e.which == 27 && this.hide();\n          }, this));\n        } else if (!this.isShown) {\n          this.$element.off('keydown.dismiss.bs.modal');\n        }\n      };\n\n      Modal.prototype.resize = function () {\n        if (this.isShown) {\n          $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));\n        } else {\n          $(window).off('resize.bs.modal');\n        }\n      };\n\n      Modal.prototype.hideModal = function () {\n        var that = this;\n        this.$element.hide();\n        this.backdrop(function () {\n          that.$body.removeClass('modal-open');\n          that.resetAdjustments();\n          that.resetScrollbar();\n          that.$element.trigger('hidden.bs.modal');\n        });\n      };\n\n      Modal.prototype.removeBackdrop = function () {\n        this.$backdrop && this.$backdrop.remove();\n        this.$backdrop = null;\n      };\n\n      Modal.prototype.backdrop = function (callback) {\n        var that = this;\n        var animate = this.$element.hasClass('fade') ? 'fade' : '';\n\n        if (this.isShown && this.options.backdrop) {\n          var doAnimate = $.support.transition && animate;\n          this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);\n          this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {\n            if (this.ignoreBackdropClick) {\n              this.ignoreBackdropClick = false;\n              return;\n            }\n\n            if (e.target !== e.currentTarget) return;\n            this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();\n          }, this));\n          if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow\n\n          this.$backdrop.addClass('in');\n          if (!callback) return;\n          doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();\n        } else if (!this.isShown && this.$backdrop) {\n          this.$backdrop.removeClass('in');\n\n          var callbackRemove = function callbackRemove() {\n            that.removeBackdrop();\n            callback && callback();\n          };\n\n          $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();\n        } else if (callback) {\n          callback();\n        }\n      }; // these following methods are used to handle overflowing modals\n\n\n      Modal.prototype.handleUpdate = function () {\n        this.adjustDialog();\n      };\n\n      Modal.prototype.adjustDialog = function () {\n        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;\n        this.$element.css({\n          paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',\n          paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''\n        });\n      };\n\n      Modal.prototype.resetAdjustments = function () {\n        this.$element.css({\n          paddingLeft: '',\n          paddingRight: ''\n        });\n      };\n\n      Modal.prototype.checkScrollbar = function () {\n        var fullWindowWidth = window.innerWidth;\n\n        if (!fullWindowWidth) {\n          // workaround for missing window.innerWidth in IE8\n          var documentElementRect = document.documentElement.getBoundingClientRect();\n          fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);\n        }\n\n        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;\n        this.scrollbarWidth = this.measureScrollbar();\n      };\n\n      Modal.prototype.setScrollbar = function () {\n        var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);\n        this.originalBodyPad = document.body.style.paddingRight || '';\n        if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);\n      };\n\n      Modal.prototype.resetScrollbar = function () {\n        this.$body.css('padding-right', this.originalBodyPad);\n      };\n\n      Modal.prototype.measureScrollbar = function () {\n        // thx walsh\n        var scrollDiv = document.createElement('div');\n        scrollDiv.className = 'modal-scrollbar-measure';\n        this.$body.append(scrollDiv);\n        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n        this.$body[0].removeChild(scrollDiv);\n        return scrollbarWidth;\n      }; // MODAL PLUGIN DEFINITION\n      // =======================\n\n\n      function Plugin(option, _relatedTarget) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.modal');\n          var options = $.extend({}, Modal.DEFAULTS, $this.data(), _typeof(option) == 'object' && option);\n          if (!data) $this.data('bs.modal', data = new Modal(this, options));\n          if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);\n        });\n      }\n\n      var old = $.fn.modal;\n      $.fn.modal = Plugin;\n      $.fn.modal.Constructor = Modal; // MODAL NO CONFLICT\n      // =================\n\n      $.fn.modal.noConflict = function () {\n        $.fn.modal = old;\n        return this;\n      }; // MODAL DATA-API\n      // ==============\n\n\n      $(document).on('click.bs.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\n        var $this = $(this);\n        var href = $this.attr('href');\n        var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\\s]+$)/, '')); // strip for ie7\n\n        var option = $target.data('bs.modal') ? 'toggle' : $.extend({\n          remote: !/#/.test(href) && href\n        }, $target.data(), $this.data());\n        if ($this.is('a')) e.preventDefault();\n        $target.one('show.bs.modal', function (showEvent) {\n          if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown\n\n          $target.one('hidden.bs.modal', function () {\n            $this.is(':visible') && $this.trigger('focus');\n          });\n        });\n        Plugin.call($target, option, this);\n      });\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: tooltip.js v3.3.6\n     * http://getbootstrap.com/javascript/#tooltip\n     * Inspired by the original jQuery.tipsy by Jason Frame\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // TOOLTIP PUBLIC CLASS DEFINITION\n      // ===============================\n\n      var Tooltip = function Tooltip(element, options) {\n        this.type = null;\n        this.options = null;\n        this.enabled = null;\n        this.timeout = null;\n        this.hoverState = null;\n        this.$element = null;\n        this.inState = null;\n        this.init('tooltip', element, options);\n      };\n\n      Tooltip.VERSION = '3.3.6';\n      Tooltip.TRANSITION_DURATION = 150;\n      Tooltip.DEFAULTS = {\n        animation: true,\n        placement: 'top',\n        selector: false,\n        template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n        trigger: 'hover focus',\n        title: '',\n        delay: 0,\n        html: false,\n        container: false,\n        viewport: {\n          selector: 'body',\n          padding: 0\n        }\n      };\n\n      Tooltip.prototype.init = function (type, element, options) {\n        this.enabled = true;\n        this.type = type;\n        this.$element = $(element);\n        this.options = this.getOptions(options);\n        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);\n        this.inState = {\n          click: false,\n          hover: false,\n          focus: false\n        };\n\n        if (this.$element[0] instanceof document.constructor && !this.options.selector) {\n          throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');\n        }\n\n        var triggers = this.options.trigger.split(' ');\n\n        for (var i = triggers.length; i--;) {\n          var trigger = triggers[i];\n\n          if (trigger == 'click') {\n            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));\n          } else if (trigger != 'manual') {\n            var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';\n            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';\n            this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));\n            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));\n          }\n        }\n\n        this.options.selector ? this._options = $.extend({}, this.options, {\n          trigger: 'manual',\n          selector: ''\n        }) : this.fixTitle();\n      };\n\n      Tooltip.prototype.getDefaults = function () {\n        return Tooltip.DEFAULTS;\n      };\n\n      Tooltip.prototype.getOptions = function (options) {\n        options = $.extend({}, this.getDefaults(), this.$element.data(), options);\n\n        if (options.delay && typeof options.delay == 'number') {\n          options.delay = {\n            show: options.delay,\n            hide: options.delay\n          };\n        }\n\n        return options;\n      };\n\n      Tooltip.prototype.getDelegateOptions = function () {\n        var options = {};\n        var defaults = this.getDefaults();\n        this._options && $.each(this._options, function (key, value) {\n          if (defaults[key] != value) options[key] = value;\n        });\n        return options;\n      };\n\n      Tooltip.prototype.enter = function (obj) {\n        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);\n\n        if (!self) {\n          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());\n          $(obj.currentTarget).data('bs.' + this.type, self);\n        }\n\n        if (obj instanceof $.Event) {\n          self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true;\n        }\n\n        if (self.tip().hasClass('in') || self.hoverState == 'in') {\n          self.hoverState = 'in';\n          return;\n        }\n\n        clearTimeout(self.timeout);\n        self.hoverState = 'in';\n        if (!self.options.delay || !self.options.delay.show) return self.show();\n        self.timeout = setTimeout(function () {\n          if (self.hoverState == 'in') self.show();\n        }, self.options.delay.show);\n      };\n\n      Tooltip.prototype.isInStateTrue = function () {\n        for (var key in this.inState) {\n          if (this.inState[key]) return true;\n        }\n\n        return false;\n      };\n\n      Tooltip.prototype.leave = function (obj) {\n        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);\n\n        if (!self) {\n          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());\n          $(obj.currentTarget).data('bs.' + this.type, self);\n        }\n\n        if (obj instanceof $.Event) {\n          self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false;\n        }\n\n        if (self.isInStateTrue()) return;\n        clearTimeout(self.timeout);\n        self.hoverState = 'out';\n        if (!self.options.delay || !self.options.delay.hide) return self.hide();\n        self.timeout = setTimeout(function () {\n          if (self.hoverState == 'out') self.hide();\n        }, self.options.delay.hide);\n      };\n\n      Tooltip.prototype.show = function () {\n        var e = $.Event('show.bs.' + this.type);\n\n        if (this.hasContent() && this.enabled) {\n          this.$element.trigger(e);\n          var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);\n          if (e.isDefaultPrevented() || !inDom) return;\n          var that = this;\n          var $tip = this.tip();\n          var tipId = this.getUID(this.type);\n          this.setContent();\n          $tip.attr('id', tipId);\n          this.$element.attr('aria-describedby', tipId);\n          if (this.options.animation) $tip.addClass('fade');\n          var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n          if (autoPlace) placement = placement.replace(autoToken, '') || 'top';\n          $tip.detach().css({\n            top: 0,\n            left: 0,\n            display: 'block'\n          }).addClass(placement).data('bs.' + this.type, this);\n          this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);\n          this.$element.trigger('inserted.bs.' + this.type);\n          var pos = this.getPosition();\n          var actualWidth = $tip[0].offsetWidth;\n          var actualHeight = $tip[0].offsetHeight;\n\n          if (autoPlace) {\n            var orgPlacement = placement;\n            var viewportDim = this.getPosition(this.$viewport);\n            placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement;\n            $tip.removeClass(orgPlacement).addClass(placement);\n          }\n\n          var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);\n          this.applyPlacement(calculatedOffset, placement);\n\n          var complete = function complete() {\n            var prevHoverState = that.hoverState;\n            that.$element.trigger('shown.bs.' + that.type);\n            that.hoverState = null;\n            if (prevHoverState == 'out') that.leave(that);\n          };\n\n          $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();\n        }\n      };\n\n      Tooltip.prototype.applyPlacement = function (offset, placement) {\n        var $tip = this.tip();\n        var width = $tip[0].offsetWidth;\n        var height = $tip[0].offsetHeight; // manually read margins because getBoundingClientRect includes difference\n\n        var marginTop = parseInt($tip.css('margin-top'), 10);\n        var marginLeft = parseInt($tip.css('margin-left'), 10); // we must check for NaN for ie 8/9\n\n        if (isNaN(marginTop)) marginTop = 0;\n        if (isNaN(marginLeft)) marginLeft = 0;\n        offset.top += marginTop;\n        offset.left += marginLeft; // $.fn.offset doesn't round pixel values\n        // so we use setOffset directly with our own function B-0\n\n        $.offset.setOffset($tip[0], $.extend({\n          using: function using(props) {\n            $tip.css({\n              top: Math.round(props.top),\n              left: Math.round(props.left)\n            });\n          }\n        }, offset), 0);\n        $tip.addClass('in'); // check to see if placing tip in new offset caused the tip to resize itself\n\n        var actualWidth = $tip[0].offsetWidth;\n        var actualHeight = $tip[0].offsetHeight;\n\n        if (placement == 'top' && actualHeight != height) {\n          offset.top = offset.top + height - actualHeight;\n        }\n\n        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n        if (delta.left) offset.left += delta.left;else offset.top += delta.top;\n        var isVertical = /top|bottom/.test(placement);\n        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n        $tip.offset(offset);\n        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);\n      };\n\n      Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {\n        this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');\n      };\n\n      Tooltip.prototype.setContent = function () {\n        var $tip = this.tip();\n        var title = this.getTitle();\n        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);\n        $tip.removeClass('fade in top bottom left right');\n      };\n\n      Tooltip.prototype.hide = function (callback) {\n        var that = this;\n        var $tip = $(this.$tip);\n        var e = $.Event('hide.bs.' + this.type);\n\n        function complete() {\n          if (that.hoverState != 'in') $tip.detach();\n          that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);\n          callback && callback();\n        }\n\n        this.$element.trigger(e);\n        if (e.isDefaultPrevented()) return;\n        $tip.removeClass('in');\n        $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();\n        this.hoverState = null;\n        return this;\n      };\n\n      Tooltip.prototype.fixTitle = function () {\n        var $e = this.$element;\n\n        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {\n          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');\n        }\n      };\n\n      Tooltip.prototype.hasContent = function () {\n        return this.getTitle();\n      };\n\n      Tooltip.prototype.getPosition = function ($element) {\n        $element = $element || this.$element;\n        var el = $element[0];\n        var isBody = el.tagName == 'BODY';\n        var elRect = el.getBoundingClientRect();\n\n        if (elRect.width == null) {\n          // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n          elRect = $.extend({}, elRect, {\n            width: elRect.right - elRect.left,\n            height: elRect.bottom - elRect.top\n          });\n        }\n\n        var elOffset = isBody ? {\n          top: 0,\n          left: 0\n        } : $element.offset();\n        var scroll = {\n          scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()\n        };\n        var outerDims = isBody ? {\n          width: $(window).width(),\n          height: $(window).height()\n        } : null;\n        return $.extend({}, elRect, scroll, outerDims, elOffset);\n      };\n\n      Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\n        return placement == 'bottom' ? {\n          top: pos.top + pos.height,\n          left: pos.left + pos.width / 2 - actualWidth / 2\n        } : placement == 'top' ? {\n          top: pos.top - actualHeight,\n          left: pos.left + pos.width / 2 - actualWidth / 2\n        } : placement == 'left' ? {\n          top: pos.top + pos.height / 2 - actualHeight / 2,\n          left: pos.left - actualWidth\n        } :\n        /* placement == 'right' */\n        {\n          top: pos.top + pos.height / 2 - actualHeight / 2,\n          left: pos.left + pos.width\n        };\n      };\n\n      Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\n        var delta = {\n          top: 0,\n          left: 0\n        };\n        if (!this.$viewport) return delta;\n        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;\n        var viewportDimensions = this.getPosition(this.$viewport);\n\n        if (/right|left/.test(placement)) {\n          var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;\n          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n\n          if (topEdgeOffset < viewportDimensions.top) {\n            // top overflow\n            delta.top = viewportDimensions.top - topEdgeOffset;\n          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {\n            // bottom overflow\n            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n          }\n        } else {\n          var leftEdgeOffset = pos.left - viewportPadding;\n          var rightEdgeOffset = pos.left + viewportPadding + actualWidth;\n\n          if (leftEdgeOffset < viewportDimensions.left) {\n            // left overflow\n            delta.left = viewportDimensions.left - leftEdgeOffset;\n          } else if (rightEdgeOffset > viewportDimensions.right) {\n            // right overflow\n            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n          }\n        }\n\n        return delta;\n      };\n\n      Tooltip.prototype.getTitle = function () {\n        var title;\n        var $e = this.$element;\n        var o = this.options;\n        title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);\n        return title;\n      };\n\n      Tooltip.prototype.getUID = function (prefix) {\n        do {\n          prefix += ~~(Math.random() * 1000000);\n        } while (document.getElementById(prefix));\n\n        return prefix;\n      };\n\n      Tooltip.prototype.tip = function () {\n        if (!this.$tip) {\n          this.$tip = $(this.options.template);\n\n          if (this.$tip.length != 1) {\n            throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!');\n          }\n        }\n\n        return this.$tip;\n      };\n\n      Tooltip.prototype.arrow = function () {\n        return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');\n      };\n\n      Tooltip.prototype.enable = function () {\n        this.enabled = true;\n      };\n\n      Tooltip.prototype.disable = function () {\n        this.enabled = false;\n      };\n\n      Tooltip.prototype.toggleEnabled = function () {\n        this.enabled = !this.enabled;\n      };\n\n      Tooltip.prototype.toggle = function (e) {\n        var self = this;\n\n        if (e) {\n          self = $(e.currentTarget).data('bs.' + this.type);\n\n          if (!self) {\n            self = new this.constructor(e.currentTarget, this.getDelegateOptions());\n            $(e.currentTarget).data('bs.' + this.type, self);\n          }\n        }\n\n        if (e) {\n          self.inState.click = !self.inState.click;\n          if (self.isInStateTrue()) self.enter(self);else self.leave(self);\n        } else {\n          self.tip().hasClass('in') ? self.leave(self) : self.enter(self);\n        }\n      };\n\n      Tooltip.prototype.destroy = function () {\n        var that = this;\n        clearTimeout(this.timeout);\n        this.hide(function () {\n          that.$element.off('.' + that.type).removeData('bs.' + that.type);\n\n          if (that.$tip) {\n            that.$tip.detach();\n          }\n\n          that.$tip = null;\n          that.$arrow = null;\n          that.$viewport = null;\n        });\n      }; // TOOLTIP PLUGIN DEFINITION\n      // =========================\n\n\n      function Plugin(option) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.tooltip');\n          var options = _typeof(option) == 'object' && option;\n          if (!data && /destroy|hide/.test(option)) return;\n          if (!data) $this.data('bs.tooltip', data = new Tooltip(this, options));\n          if (typeof option == 'string') data[option]();\n        });\n      }\n\n      var old = $.fn.tooltip;\n      $.fn.tooltip = Plugin;\n      $.fn.tooltip.Constructor = Tooltip; // TOOLTIP NO CONFLICT\n      // ===================\n\n      $.fn.tooltip.noConflict = function () {\n        $.fn.tooltip = old;\n        return this;\n      };\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: popover.js v3.3.6\n     * http://getbootstrap.com/javascript/#popovers\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // POPOVER PUBLIC CLASS DEFINITION\n      // ===============================\n\n      var Popover = function Popover(element, options) {\n        this.init('popover', element, options);\n      };\n\n      if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');\n      Popover.VERSION = '3.3.6';\n      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\n        placement: 'right',\n        trigger: 'click',\n        content: '',\n        template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\n      }); // NOTE: POPOVER EXTENDS tooltip.js\n      // ================================\n\n      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);\n      Popover.prototype.constructor = Popover;\n\n      Popover.prototype.getDefaults = function () {\n        return Popover.DEFAULTS;\n      };\n\n      Popover.prototype.setContent = function () {\n        var $tip = this.tip();\n        var title = this.getTitle();\n        var content = this.getContent();\n        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);\n        $tip.find('.popover-content').children().detach().end()[// we use append for html objects to maintain js events\n        this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);\n        $tip.removeClass('fade top bottom left right in'); // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do\n        // this manually by checking the contents.\n\n        if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();\n      };\n\n      Popover.prototype.hasContent = function () {\n        return this.getTitle() || this.getContent();\n      };\n\n      Popover.prototype.getContent = function () {\n        var $e = this.$element;\n        var o = this.options;\n        return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);\n      };\n\n      Popover.prototype.arrow = function () {\n        return this.$arrow = this.$arrow || this.tip().find('.arrow');\n      }; // POPOVER PLUGIN DEFINITION\n      // =========================\n\n\n      function Plugin(option) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.popover');\n          var options = _typeof(option) == 'object' && option;\n          if (!data && /destroy|hide/.test(option)) return;\n          if (!data) $this.data('bs.popover', data = new Popover(this, options));\n          if (typeof option == 'string') data[option]();\n        });\n      }\n\n      var old = $.fn.popover;\n      $.fn.popover = Plugin;\n      $.fn.popover.Constructor = Popover; // POPOVER NO CONFLICT\n      // ===================\n\n      $.fn.popover.noConflict = function () {\n        $.fn.popover = old;\n        return this;\n      };\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: scrollspy.js v3.3.6\n     * http://getbootstrap.com/javascript/#scrollspy\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // SCROLLSPY CLASS DEFINITION\n      // ==========================\n\n      function ScrollSpy(element, options) {\n        this.$body = $(document.body);\n        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);\n        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);\n        this.selector = (this.options.target || '') + ' .nav li > a';\n        this.offsets = [];\n        this.targets = [];\n        this.activeTarget = null;\n        this.scrollHeight = 0;\n        this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));\n        this.refresh();\n        this.process();\n      }\n\n      ScrollSpy.VERSION = '3.3.6';\n      ScrollSpy.DEFAULTS = {\n        offset: 10\n      };\n\n      ScrollSpy.prototype.getScrollHeight = function () {\n        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);\n      };\n\n      ScrollSpy.prototype.refresh = function () {\n        var that = this;\n        var offsetMethod = 'offset';\n        var offsetBase = 0;\n        this.offsets = [];\n        this.targets = [];\n        this.scrollHeight = this.getScrollHeight();\n\n        if (!$.isWindow(this.$scrollElement[0])) {\n          offsetMethod = 'position';\n          offsetBase = this.$scrollElement.scrollTop();\n        }\n\n        this.$body.find(this.selector).map(function () {\n          var $el = $(this);\n          var href = $el.data('target') || $el.attr('href');\n          var $href = /^#./.test(href) && $(href);\n          return $href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]] || null;\n        }).sort(function (a, b) {\n          return a[0] - b[0];\n        }).each(function () {\n          that.offsets.push(this[0]);\n          that.targets.push(this[1]);\n        });\n      };\n\n      ScrollSpy.prototype.process = function () {\n        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;\n        var scrollHeight = this.getScrollHeight();\n        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();\n        var offsets = this.offsets;\n        var targets = this.targets;\n        var activeTarget = this.activeTarget;\n        var i;\n\n        if (this.scrollHeight != scrollHeight) {\n          this.refresh();\n        }\n\n        if (scrollTop >= maxScroll) {\n          return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);\n        }\n\n        if (activeTarget && scrollTop < offsets[0]) {\n          this.activeTarget = null;\n          return this.clear();\n        }\n\n        for (i = offsets.length; i--;) {\n          activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);\n        }\n      };\n\n      ScrollSpy.prototype.activate = function (target) {\n        this.activeTarget = target;\n        this.clear();\n        var selector = this.selector + '[data-target=\"' + target + '\"],' + this.selector + '[href=\"' + target + '\"]';\n        var active = $(selector).parents('li').addClass('active');\n\n        if (active.parent('.dropdown-menu').length) {\n          active = active.closest('li.dropdown').addClass('active');\n        }\n\n        active.trigger('activate.bs.scrollspy');\n      };\n\n      ScrollSpy.prototype.clear = function () {\n        $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');\n      }; // SCROLLSPY PLUGIN DEFINITION\n      // ===========================\n\n\n      function Plugin(option) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.scrollspy');\n          var options = _typeof(option) == 'object' && option;\n          if (!data) $this.data('bs.scrollspy', data = new ScrollSpy(this, options));\n          if (typeof option == 'string') data[option]();\n        });\n      }\n\n      var old = $.fn.scrollspy;\n      $.fn.scrollspy = Plugin;\n      $.fn.scrollspy.Constructor = ScrollSpy; // SCROLLSPY NO CONFLICT\n      // =====================\n\n      $.fn.scrollspy.noConflict = function () {\n        $.fn.scrollspy = old;\n        return this;\n      }; // SCROLLSPY DATA-API\n      // ==================\n\n\n      $(window).on('load.bs.scrollspy.data-api', function () {\n        $('[data-spy=\"scroll\"]').each(function () {\n          var $spy = $(this);\n          Plugin.call($spy, $spy.data());\n        });\n      });\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: tab.js v3.3.6\n     * http://getbootstrap.com/javascript/#tabs\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // TAB CLASS DEFINITION\n      // ====================\n\n      var Tab = function Tab(element) {\n        // jscs:disable requireDollarBeforejQueryAssignment\n        this.element = $(element); // jscs:enable requireDollarBeforejQueryAssignment\n      };\n\n      Tab.VERSION = '3.3.6';\n      Tab.TRANSITION_DURATION = 150;\n\n      Tab.prototype.show = function () {\n        var $this = this.element;\n        var $ul = $this.closest('ul:not(.dropdown-menu)');\n        var selector = $this.data('target');\n\n        if (!selector) {\n          selector = $this.attr('href');\n          selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, ''); // strip for ie7\n        }\n\n        if ($this.parent('li').hasClass('active')) return;\n        var $previous = $ul.find('.active:last a');\n        var hideEvent = $.Event('hide.bs.tab', {\n          relatedTarget: $this[0]\n        });\n        var showEvent = $.Event('show.bs.tab', {\n          relatedTarget: $previous[0]\n        });\n        $previous.trigger(hideEvent);\n        $this.trigger(showEvent);\n        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;\n        var $target = $(selector);\n        this.activate($this.closest('li'), $ul);\n        this.activate($target, $target.parent(), function () {\n          $previous.trigger({\n            type: 'hidden.bs.tab',\n            relatedTarget: $this[0]\n          });\n          $this.trigger({\n            type: 'shown.bs.tab',\n            relatedTarget: $previous[0]\n          });\n        });\n      };\n\n      Tab.prototype.activate = function (element, container, callback) {\n        var $active = container.find('> .active');\n        var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);\n\n        function next() {\n          $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle=\"tab\"]').attr('aria-expanded', false);\n          element.addClass('active').find('[data-toggle=\"tab\"]').attr('aria-expanded', true);\n\n          if (transition) {\n            element[0].offsetWidth; // reflow for transition\n\n            element.addClass('in');\n          } else {\n            element.removeClass('fade');\n          }\n\n          if (element.parent('.dropdown-menu').length) {\n            element.closest('li.dropdown').addClass('active').end().find('[data-toggle=\"tab\"]').attr('aria-expanded', true);\n          }\n\n          callback && callback();\n        }\n\n        $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();\n        $active.removeClass('in');\n      }; // TAB PLUGIN DEFINITION\n      // =====================\n\n\n      function Plugin(option) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.tab');\n          if (!data) $this.data('bs.tab', data = new Tab(this));\n          if (typeof option == 'string') data[option]();\n        });\n      }\n\n      var old = $.fn.tab;\n      $.fn.tab = Plugin;\n      $.fn.tab.Constructor = Tab; // TAB NO CONFLICT\n      // ===============\n\n      $.fn.tab.noConflict = function () {\n        $.fn.tab = old;\n        return this;\n      }; // TAB DATA-API\n      // ============\n\n\n      var clickHandler = function clickHandler(e) {\n        e.preventDefault();\n        Plugin.call($(this), 'show');\n      };\n\n      $(document).on('click.bs.tab.data-api', '[data-toggle=\"tab\"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle=\"pill\"]', clickHandler);\n    }(jQuery);\n    /* ========================================================================\n     * Bootstrap: affix.js v3.3.6\n     * http://getbootstrap.com/javascript/#affix\n     * ========================================================================\n     * Copyright 2011-2015 Twitter, Inc.\n     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n     * ======================================================================== */\n\n    +function ($) {\n      'use strict'; // AFFIX CLASS DEFINITION\n      // ======================\n\n      var Affix = function Affix(element, options) {\n        this.options = $.extend({}, Affix.DEFAULTS, options);\n        this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));\n        this.$element = $(element);\n        this.affixed = null;\n        this.unpin = null;\n        this.pinnedOffset = null;\n        this.checkPosition();\n      };\n\n      Affix.VERSION = '3.3.6';\n      Affix.RESET = 'affix affix-top affix-bottom';\n      Affix.DEFAULTS = {\n        offset: 0,\n        target: window\n      };\n\n      Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {\n        var scrollTop = this.$target.scrollTop();\n        var position = this.$element.offset();\n        var targetHeight = this.$target.height();\n        if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false;\n\n        if (this.affixed == 'bottom') {\n          if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : 'bottom';\n          return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : 'bottom';\n        }\n\n        var initializing = this.affixed == null;\n        var colliderTop = initializing ? scrollTop : position.top;\n        var colliderHeight = initializing ? targetHeight : height;\n        if (offsetTop != null && scrollTop <= offsetTop) return 'top';\n        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return 'bottom';\n        return false;\n      };\n\n      Affix.prototype.getPinnedOffset = function () {\n        if (this.pinnedOffset) return this.pinnedOffset;\n        this.$element.removeClass(Affix.RESET).addClass('affix');\n        var scrollTop = this.$target.scrollTop();\n        var position = this.$element.offset();\n        return this.pinnedOffset = position.top - scrollTop;\n      };\n\n      Affix.prototype.checkPositionWithEventLoop = function () {\n        setTimeout($.proxy(this.checkPosition, this), 1);\n      };\n\n      Affix.prototype.checkPosition = function () {\n        if (!this.$element.is(':visible')) return;\n        var height = this.$element.height();\n        var offset = this.options.offset;\n        var offsetTop = offset.top;\n        var offsetBottom = offset.bottom;\n        var scrollHeight = Math.max($(document).height(), $(document.body).height());\n        if (_typeof(offset) != 'object') offsetBottom = offsetTop = offset;\n        if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element);\n        if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element);\n        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);\n\n        if (this.affixed != affix) {\n          if (this.unpin != null) this.$element.css('top', '');\n          var affixType = 'affix' + (affix ? '-' + affix : '');\n          var e = $.Event(affixType + '.bs.affix');\n          this.$element.trigger(e);\n          if (e.isDefaultPrevented()) return;\n          this.affixed = affix;\n          this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;\n          this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');\n        }\n\n        if (affix == 'bottom') {\n          this.$element.offset({\n            top: scrollHeight - height - offsetBottom\n          });\n        }\n      }; // AFFIX PLUGIN DEFINITION\n      // =======================\n\n\n      function Plugin(option) {\n        return this.each(function () {\n          var $this = $(this);\n          var data = $this.data('bs.affix');\n          var options = _typeof(option) == 'object' && option;\n          if (!data) $this.data('bs.affix', data = new Affix(this, options));\n          if (typeof option == 'string') data[option]();\n        });\n      }\n\n      var old = $.fn.affix;\n      $.fn.affix = Plugin;\n      $.fn.affix.Constructor = Affix; // AFFIX NO CONFLICT\n      // =================\n\n      $.fn.affix.noConflict = function () {\n        $.fn.affix = old;\n        return this;\n      }; // AFFIX DATA-API\n      // ==============\n\n\n      $(window).on('load', function () {\n        $('[data-spy=\"affix\"]').each(function () {\n          var $spy = $(this);\n          var data = $spy.data();\n          data.offset = data.offset || {};\n          if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;\n          if (data.offsetTop != null) data.offset.top = data.offsetTop;\n          Plugin.call($spy, data);\n        });\n      });\n    }(jQuery); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  }).call(this);\n  /* Exports */\n\n  Package._define(\"twbs:bootstrap\");\n})();\n\nmodule.exports = window.Package[\"twbs:bootstrap\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.eot":
/*!************************************************************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.eot ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"f4769f9bdb7466be65088239c12046d1.eot\";\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.eot?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.svg":
/*!************************************************************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.svg ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"89889688147bd7575d6327160d64e760.svg\";\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.svg?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.ttf":
/*!************************************************************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.ttf ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"e18bbf611f2a2e43afc071aa2f4e1512.ttf\";\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.ttf?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.woff":
/*!*************************************************************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.woff ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"fa2772327f55d8198301fdb8bcfc8158.woff\";\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.woff?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.woff2":
/*!**************************************************************************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.woff2 ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"448c34a56d699c29117adc64c43affeb.woff2\";\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.woff2?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/url.js":
/*!********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/url.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  /* Package-scope variables */\n\n  var URL;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"url\": {\n          \"url_client.js\": function url_clientJs(require, exports) {\n            /////////////////////////////////////////////////////////////////////////////////\n            //                                                                             //\n            // packages/url/url_client.js                                                  //\n            //                                                                             //\n            /////////////////////////////////////////////////////////////////////////////////\n            //\n            var common = require(\"./url_common.js\");\n\n            var URL = exports.URL = common.URL;\n\n            URL._constructUrl = function (url, query, params) {\n              var query_match = /^(.*?)(\\?.*)?$/.exec(url);\n              return common.buildUrl(query_match[1], query_match[2], query, params);\n            }; /////////////////////////////////////////////////////////////////////////////////\n\n          },\n          \"url_common.js\": function url_commonJs(require, exports) {\n            /////////////////////////////////////////////////////////////////////////////////\n            //                                                                             //\n            // packages/url/url_common.js                                                  //\n            //                                                                             //\n            /////////////////////////////////////////////////////////////////////////////////\n            //\n            var URL = exports.URL = {};\n\n            function encodeString(str) {\n              return encodeURIComponent(str).replace(/\\*/g, '%2A');\n            } // Encode URL paramaters into a query string, handling nested objects and\n            // arrays properly.\n\n\n            URL._encodeParams = function (params, prefix) {\n              var str = [];\n              var isParamsArray = Array.isArray(params);\n\n              for (var p in params) {\n                if (Object.prototype.hasOwnProperty.call(params, p)) {\n                  var k = prefix ? prefix + '[' + (isParamsArray ? '' : p) + ']' : p;\n                  var v = params[p];\n\n                  if (_typeof(v) === 'object') {\n                    str.push(this._encodeParams(v, k));\n                  } else {\n                    var encodedKey = encodeString(k).replace('%5B', '[').replace('%5D', ']');\n                    str.push(encodedKey + '=' + encodeString(v));\n                  }\n                }\n              }\n\n              return str.join('&').replace(/%20/g, '+');\n            };\n\n            exports.buildUrl = function (before_qmark, from_qmark, opt_query, opt_params) {\n              var url_without_query = before_qmark;\n              var query = from_qmark ? from_qmark.slice(1) : null;\n              if (typeof opt_query === \"string\") query = String(opt_query);\n\n              if (opt_params) {\n                query = query || \"\";\n\n                var prms = URL._encodeParams(opt_params);\n\n                if (query && prms) query += '&';\n                query += prms;\n              }\n\n              var url = url_without_query;\n              if (query !== null) url += \"?\" + query;\n              return url;\n            }; /////////////////////////////////////////////////////////////////////////////////\n\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/url/url_client.js\");\n  /* Exports */\n\n\n  Package._define(\"url\", exports, {\n    URL: URL\n  });\n})();\n\nmodule.exports = window.Package[\"url\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/url.js?");

/***/ }),

/***/ "./build/pkg-only/bundle/programs/web.browser/packages/webapp.js":
/*!***********************************************************************!*\
  !*** ./build/pkg-only/bundle/programs/web.browser/packages/webapp.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n(function () {\n  /* Imports */\n  var Meteor = Package.meteor.Meteor;\n  var global = Package.meteor.global;\n  var meteorEnv = Package.meteor.meteorEnv;\n  var meteorInstall = Package.modules.meteorInstall;\n  var meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\n  var Promise = Package.promise.Promise;\n  /* Package-scope variables */\n\n  var WebApp;\n\n  var require = meteorInstall({\n    \"node_modules\": {\n      \"meteor\": {\n        \"webapp\": {\n          \"webapp_client.js\": function webapp_clientJs(require, exports, module) {\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //                                                                                                                    //\n            // packages/webapp/webapp_client.js                                                                                   //\n            //                                                                                                                    //\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n            //\n            module.export({\n              WebApp: function WebApp() {\n                return _WebApp;\n              }\n            });\n            var _WebApp = {\n              _isCssLoaded: function _isCssLoaded() {\n                if (document.styleSheets.length === 0) {\n                  return true;\n                }\n\n                return Array.prototype.find.call(document.styleSheets, function (sheet) {\n                  if (sheet.cssText && !sheet.cssRules) {\n                    // IE8\n                    return !sheet.cssText.match(/meteor-css-not-found-error/);\n                  }\n\n                  return !Array.prototype.find.call(sheet.cssRules, function (rule) {\n                    return rule.selectorText === '.meteor-css-not-found-error';\n                  });\n                });\n              }\n            }; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          }\n        }\n      }\n    }\n  }, {\n    \"extensions\": [\".js\", \".json\"]\n  });\n\n  var exports = require(\"/node_modules/meteor/webapp/webapp_client.js\");\n  /* Exports */\n\n\n  Package._define(\"webapp\", exports, {\n    WebApp: WebApp\n  });\n})();\n\nmodule.exports = window.Package[\"webapp\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/packages/webapp.js?");

/***/ }),

/***/ "./meteor-app/client sync recursive \\.css$":
/*!***************************************!*\
  !*** ./meteor-app/client sync \.css$ ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./main.css\": \"./meteor-app/client/main.css\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./meteor-app/client sync recursive \\\\.css$\";\n\n//# sourceURL=webpack:///./meteor-app/client_sync_\\.css$?");

/***/ }),

/***/ "./meteor-app/client/main.css":
/*!************************************!*\
  !*** ./meteor-app/client/main.css ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader!./main.css */ \"./node_modules/css-loader/index.js!./meteor-app/client/main.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./meteor-app/client/main.css?");

/***/ }),

/***/ "./meteor-app/imports/both/both.js":
/*!*****************************************!*\
  !*** ./meteor-app/imports/both/both.js ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var meteor_meteor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! meteor/meteor */ \"./meteor/meteor\");\n/* harmony import */ var meteor_meteor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(meteor_meteor__WEBPACK_IMPORTED_MODULE_0__);\n\nconsole.log('This code is run both on the server and client. Meteor.isClient:', meteor_meteor__WEBPACK_IMPORTED_MODULE_0__[\"Meteor\"].isClient);\n\n//# sourceURL=webpack:///./meteor-app/imports/both/both.js?");

/***/ }),

/***/ "./meteor-app/imports/client/HelloWorld.jsx":
/*!**************************************************!*\
  !*** ./meteor-app/imports/client/HelloWorld.jsx ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return HelloWorld; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar HelloWorld =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(HelloWorld, _React$Component);\n\n  function HelloWorld() {\n    var _this;\n\n    _classCallCheck(this, HelloWorld);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HelloWorld).call(this));\n    _this.state = {\n      counter: 0\n    };\n\n    _this.onClick = function () {\n      _this.setState({\n        counter: _this.state.counter + 1\n      });\n    };\n\n    return _this;\n  }\n\n  _createClass(HelloWorld, [{\n    key: \"render\",\n    value: function render() {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"button\", {\n        onClick: this.onClick\n      }, \"Click Me\"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"p\", null, \"You've pressed the button \", this.state.counter, \" times.\"));\n    }\n  }]);\n\n  return HelloWorld;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\n\n\n//# sourceURL=webpack:///./meteor-app/imports/client/HelloWorld.jsx?");

/***/ }),

/***/ "./meteor-app/imports/client/start.jsx":
/*!*********************************************!*\
  !*** ./meteor-app/imports/client/start.jsx ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _both_both__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../both/both */ \"./meteor-app/imports/both/both.js\");\n/* harmony import */ var meteor_meteor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! meteor/meteor */ \"./meteor/meteor\");\n/* harmony import */ var meteor_meteor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(meteor_meteor__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _HelloWorld_jsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HelloWorld.jsx */ \"./meteor-app/imports/client/HelloWorld.jsx\");\n\n\n\n\n\nmeteor_meteor__WEBPACK_IMPORTED_MODULE_1__[\"Meteor\"].startup(function () {\n  Object(react_dom__WEBPACK_IMPORTED_MODULE_3__[\"render\"])(react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(_HelloWorld_jsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"], null), document.getElementById('app'));\n  meteor_meteor__WEBPACK_IMPORTED_MODULE_1__[\"Meteor\"].call('hello', function (err, res) {\n    console.log(\"The server replied: \\\"\".concat(res, \"\\\"\"));\n  });\n});\n\n//# sourceURL=webpack:///./meteor-app/imports/client/start.jsx?");

/***/ }),

/***/ "./meteor/meteor":
/*!*********************!*\
  !*** meteor/meteor ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! meteor-imports */ \"./node_modules/meteor-imports-webpack-plugin/meteor-imports.js\")(\"meteor/meteor\");\n\n//# sourceURL=webpack:///meteor/meteor?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/builtin/defineProperty.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/builtin/defineProperty.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/builtin/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/builtin/interopRequireDefault.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/builtin/interopRequireDefault.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/builtin/interopRequireDefault.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/builtin/objectSpread.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/builtin/objectSpread.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var defineProperty = __webpack_require__(/*! ./defineProperty */ \"./node_modules/@babel/runtime/helpers/builtin/defineProperty.js\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nmodule.exports = _objectSpread;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/builtin/objectSpread.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_a-function.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_add-to-unscopables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = __webpack_require__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\")(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_add-to-unscopables.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_an-object.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-includes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\nvar toLength = __webpack_require__(/*! ./_to-length */ \"./node_modules/core-js/modules/_to-length.js\");\nvar toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ \"./node_modules/core-js/modules/_to-absolute-index.js\");\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_array-includes.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-constructor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-constructor.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\nvar isArray = __webpack_require__(/*! ./_is-array */ \"./node_modules/core-js/modules/_is-array.js\");\nvar SPECIES = __webpack_require__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")('species');\n\nmodule.exports = function (original) {\n  var C;\n  if (isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_array-species-constructor.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-create.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-create.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ \"./node_modules/core-js/modules/_array-species-constructor.js\");\n\nmodule.exports = function (original, length) {\n  return new (speciesConstructor(original))(length);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_array-species-create.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_cof.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_core.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_create-property.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_create-property.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar $defineProperty = __webpack_require__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\");\nvar createDesc = __webpack_require__(/*! ./_property-desc */ \"./node_modules/core-js/modules/_property-desc.js\");\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_create-property.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// optional / simple context binding\nvar aFunction = __webpack_require__(/*! ./_a-function */ \"./node_modules/core-js/modules/_a-function.js\");\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_ctx.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_defined.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_defined.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(/*! ./_fails */ \"./node_modules/core-js/modules/_fails.js\")(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_descriptors.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\nvar document = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_dom-create.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_enum-bug-keys.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\nvar core = __webpack_require__(/*! ./_core */ \"./node_modules/core-js/modules/_core.js\");\nvar hide = __webpack_require__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\");\nvar redefine = __webpack_require__(/*! ./_redefine */ \"./node_modules/core-js/modules/_redefine.js\");\nvar ctx = __webpack_require__(/*! ./_ctx */ \"./node_modules/core-js/modules/_ctx.js\");\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_export.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_fails.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_flatten-into-array.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_flatten-into-array.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray\nvar isArray = __webpack_require__(/*! ./_is-array */ \"./node_modules/core-js/modules/_is-array.js\");\nvar isObject = __webpack_require__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\nvar toLength = __webpack_require__(/*! ./_to-length */ \"./node_modules/core-js/modules/_to-length.js\");\nvar ctx = __webpack_require__(/*! ./_ctx */ \"./node_modules/core-js/modules/_ctx.js\");\nvar IS_CONCAT_SPREADABLE = __webpack_require__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")('isConcatSpreadable');\n\nfunction flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {\n  var targetIndex = start;\n  var sourceIndex = 0;\n  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;\n  var element, spreadable;\n\n  while (sourceIndex < sourceLen) {\n    if (sourceIndex in source) {\n      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];\n\n      spreadable = false;\n      if (isObject(element)) {\n        spreadable = element[IS_CONCAT_SPREADABLE];\n        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);\n      }\n\n      if (spreadable && depth > 0) {\n        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;\n      } else {\n        if (targetIndex >= 0x1fffffffffffff) throw TypeError();\n        target[targetIndex] = element;\n      }\n\n      targetIndex++;\n    }\n    sourceIndex++;\n  }\n  return targetIndex;\n}\n\nmodule.exports = flattenIntoArray;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_flatten-into-array.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_global.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_has.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var dP = __webpack_require__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\");\nvar createDesc = __webpack_require__(/*! ./_property-desc */ \"./node_modules/core-js/modules/_property-desc.js\");\nmodule.exports = __webpack_require__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_hide.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = !__webpack_require__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") && !__webpack_require__(/*! ./_fails */ \"./node_modules/core-js/modules/_fails.js\")(function () {\n  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ \"./node_modules/core-js/modules/_dom-create.js\")('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_ie8-dom-define.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_iobject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(/*! ./_cof */ \"./node_modules/core-js/modules/_cof.js\");\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_iobject.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(/*! ./_cof */ \"./node_modules/core-js/modules/_cof.js\");\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_is-array.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_is-object.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_library.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = false;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_library.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var anObject = __webpack_require__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ \"./node_modules/core-js/modules/_ie8-dom-define.js\");\nvar toPrimitive = __webpack_require__(/*! ./_to-primitive */ \"./node_modules/core-js/modules/_to-primitive.js\");\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_object-dp.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopd.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var pIE = __webpack_require__(/*! ./_object-pie */ \"./node_modules/core-js/modules/_object-pie.js\");\nvar createDesc = __webpack_require__(/*! ./_property-desc */ \"./node_modules/core-js/modules/_property-desc.js\");\nvar toIObject = __webpack_require__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\nvar toPrimitive = __webpack_require__(/*! ./_to-primitive */ \"./node_modules/core-js/modules/_to-primitive.js\");\nvar has = __webpack_require__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ \"./node_modules/core-js/modules/_ie8-dom-define.js\");\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_object-gopd.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = __webpack_require__(/*! ./_object-keys-internal */ \"./node_modules/core-js/modules/_object-keys-internal.js\");\nvar hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ \"./node_modules/core-js/modules/_enum-bug-keys.js\").concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_object-gopn.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gops.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gops.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.f = Object.getOwnPropertySymbols;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_object-gops.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var has = __webpack_require__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\nvar toIObject = __webpack_require__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\nvar arrayIndexOf = __webpack_require__(/*! ./_array-includes */ \"./node_modules/core-js/modules/_array-includes.js\")(false);\nvar IE_PROTO = __webpack_require__(/*! ./_shared-key */ \"./node_modules/core-js/modules/_shared-key.js\")('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_object-keys-internal.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(/*! ./_object-keys-internal */ \"./node_modules/core-js/modules/_object-keys-internal.js\");\nvar enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ \"./node_modules/core-js/modules/_enum-bug-keys.js\");\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_object-keys.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_object-pie.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-pie.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.f = {}.propertyIsEnumerable;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_object-pie.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_object-to-array.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-to-array.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var getKeys = __webpack_require__(/*! ./_object-keys */ \"./node_modules/core-js/modules/_object-keys.js\");\nvar toIObject = __webpack_require__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\nvar isEnum = __webpack_require__(/*! ./_object-pie */ \"./node_modules/core-js/modules/_object-pie.js\").f;\nmodule.exports = function (isEntries) {\n  return function (it) {\n    var O = toIObject(it);\n    var keys = getKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) if (isEnum.call(O, key = keys[i++])) {\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_object-to-array.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_own-keys.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_own-keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// all object keys, includes non-enumerable and symbols\nvar gOPN = __webpack_require__(/*! ./_object-gopn */ \"./node_modules/core-js/modules/_object-gopn.js\");\nvar gOPS = __webpack_require__(/*! ./_object-gops */ \"./node_modules/core-js/modules/_object-gops.js\");\nvar anObject = __webpack_require__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\nvar Reflect = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = gOPN.f(anObject(it));\n  var getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_own-keys.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_property-desc.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\nvar hide = __webpack_require__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\");\nvar has = __webpack_require__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\nvar SRC = __webpack_require__(/*! ./_uid */ \"./node_modules/core-js/modules/_uid.js\")('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\n__webpack_require__(/*! ./_core */ \"./node_modules/core-js/modules/_core.js\").inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_redefine.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_same-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_same-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y) {\n  // eslint-disable-next-line no-self-compare\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_same-value.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_shared-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var shared = __webpack_require__(/*! ./_shared */ \"./node_modules/core-js/modules/_shared.js\")('keys');\nvar uid = __webpack_require__(/*! ./_uid */ \"./node_modules/core-js/modules/_uid.js\");\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_shared-key.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_shared.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var core = __webpack_require__(/*! ./_core */ \"./node_modules/core-js/modules/_core.js\");\nvar global = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __webpack_require__(/*! ./_library */ \"./node_modules/core-js/modules/_library.js\") ? 'pure' : 'global',\n  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_shared.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_string-pad.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-pad.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// https://github.com/tc39/proposal-string-pad-start-end\nvar toLength = __webpack_require__(/*! ./_to-length */ \"./node_modules/core-js/modules/_to-length.js\");\nvar repeat = __webpack_require__(/*! ./_string-repeat */ \"./node_modules/core-js/modules/_string-repeat.js\");\nvar defined = __webpack_require__(/*! ./_defined */ \"./node_modules/core-js/modules/_defined.js\");\n\nmodule.exports = function (that, maxLength, fillString, left) {\n  var S = String(defined(that));\n  var stringLength = S.length;\n  var fillStr = fillString === undefined ? ' ' : String(fillString);\n  var intMaxLength = toLength(maxLength);\n  if (intMaxLength <= stringLength || fillStr == '') return S;\n  var fillLen = intMaxLength - stringLength;\n  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);\n  return left ? stringFiller + S : S + stringFiller;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_string-pad.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_string-repeat.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-repeat.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar toInteger = __webpack_require__(/*! ./_to-integer */ \"./node_modules/core-js/modules/_to-integer.js\");\nvar defined = __webpack_require__(/*! ./_defined */ \"./node_modules/core-js/modules/_defined.js\");\n\nmodule.exports = function repeat(count) {\n  var str = String(defined(this));\n  var res = '';\n  var n = toInteger(count);\n  if (n < 0 || n == Infinity) throw RangeError(\"Count can't be negative\");\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;\n  return res;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_string-repeat.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toInteger = __webpack_require__(/*! ./_to-integer */ \"./node_modules/core-js/modules/_to-integer.js\");\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_to-absolute-index.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_to-integer.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-iobject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(/*! ./_iobject */ \"./node_modules/core-js/modules/_iobject.js\");\nvar defined = __webpack_require__(/*! ./_defined */ \"./node_modules/core-js/modules/_defined.js\");\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_to-iobject.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 7.1.15 ToLength\nvar toInteger = __webpack_require__(/*! ./_to-integer */ \"./node_modules/core-js/modules/_to-integer.js\");\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_to-length.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(/*! ./_defined */ \"./node_modules/core-js/modules/_defined.js\");\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_to-object.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_to-primitive.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_uid.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_user-agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_user-agent.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\nvar navigator = global.navigator;\n\nmodule.exports = navigator && navigator.userAgent || '';\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_user-agent.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_wks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var store = __webpack_require__(/*! ./_shared */ \"./node_modules/core-js/modules/_shared.js\")('wks');\nvar uid = __webpack_require__(/*! ./_uid */ \"./node_modules/core-js/modules/_uid.js\");\nvar Symbol = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/_wks.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.name.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.name.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var dP = __webpack_require__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\").f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || __webpack_require__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es6.function.name.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-finite.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-finite.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 20.1.2.2 Number.isFinite(number)\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\nvar _isFinite = __webpack_require__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").isFinite;\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it) {\n    return typeof it == 'number' && _isFinite(it);\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es6.number.is-finite.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-nan.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-nan.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 20.1.2.4 Number.isNaN(number)\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare\n    return number != number;\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es6.number.is-nan.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 19.1.3.10 Object.is(value1, value2)\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\n$export($export.S, 'Object', { is: __webpack_require__(/*! ./_same-value */ \"./node_modules/core-js/modules/_same-value.js\") });\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es6.object.is.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flat-map.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.flat-map.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\nvar flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ \"./node_modules/core-js/modules/_flatten-into-array.js\");\nvar toObject = __webpack_require__(/*! ./_to-object */ \"./node_modules/core-js/modules/_to-object.js\");\nvar toLength = __webpack_require__(/*! ./_to-length */ \"./node_modules/core-js/modules/_to-length.js\");\nvar aFunction = __webpack_require__(/*! ./_a-function */ \"./node_modules/core-js/modules/_a-function.js\");\nvar arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ \"./node_modules/core-js/modules/_array-species-create.js\");\n\n$export($export.P, 'Array', {\n  flatMap: function flatMap(callbackfn /* , thisArg */) {\n    var O = toObject(this);\n    var sourceLen, A;\n    aFunction(callbackfn);\n    sourceLen = toLength(O.length);\n    A = arraySpeciesCreate(O, 0);\n    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);\n    return A;\n  }\n});\n\n__webpack_require__(/*! ./_add-to-unscopables */ \"./node_modules/core-js/modules/_add-to-unscopables.js\")('flatMap');\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es7.array.flat-map.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flatten.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.flatten.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\nvar flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ \"./node_modules/core-js/modules/_flatten-into-array.js\");\nvar toObject = __webpack_require__(/*! ./_to-object */ \"./node_modules/core-js/modules/_to-object.js\");\nvar toLength = __webpack_require__(/*! ./_to-length */ \"./node_modules/core-js/modules/_to-length.js\");\nvar toInteger = __webpack_require__(/*! ./_to-integer */ \"./node_modules/core-js/modules/_to-integer.js\");\nvar arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ \"./node_modules/core-js/modules/_array-species-create.js\");\n\n$export($export.P, 'Array', {\n  flatten: function flatten(/* depthArg = 1 */) {\n    var depthArg = arguments[0];\n    var O = toObject(this);\n    var sourceLen = toLength(O.length);\n    var A = arraySpeciesCreate(O, 0);\n    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));\n    return A;\n  }\n});\n\n__webpack_require__(/*! ./_add-to-unscopables */ \"./node_modules/core-js/modules/_add-to-unscopables.js\")('flatten');\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es7.array.flatten.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.entries.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.entries.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// https://github.com/tc39/proposal-object-values-entries\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\nvar $entries = __webpack_require__(/*! ./_object-to-array */ \"./node_modules/core-js/modules/_object-to-array.js\")(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it) {\n    return $entries(it);\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es7.object.entries.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// https://github.com/tc39/proposal-object-getownpropertydescriptors\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\nvar ownKeys = __webpack_require__(/*! ./_own-keys */ \"./node_modules/core-js/modules/_own-keys.js\");\nvar toIObject = __webpack_require__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\nvar gOPD = __webpack_require__(/*! ./_object-gopd */ \"./node_modules/core-js/modules/_object-gopd.js\");\nvar createProperty = __webpack_require__(/*! ./_create-property */ \"./node_modules/core-js/modules/_create-property.js\");\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIObject(object);\n    var getDesc = gOPD.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var i = 0;\n    var key, desc;\n    while (keys.length > i) {\n      desc = getDesc(O, key = keys[i++]);\n      if (desc !== undefined) createProperty(result, key, desc);\n    }\n    return result;\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.values.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.values.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// https://github.com/tc39/proposal-object-values-entries\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\nvar $values = __webpack_require__(/*! ./_object-to-array */ \"./node_modules/core-js/modules/_object-to-array.js\")(false);\n\n$export($export.S, 'Object', {\n  values: function values(it) {\n    return $values(it);\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es7.object.values.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-end.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-end.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\nvar $pad = __webpack_require__(/*! ./_string-pad */ \"./node_modules/core-js/modules/_string-pad.js\");\nvar userAgent = __webpack_require__(/*! ./_user-agent */ \"./node_modules/core-js/modules/_user-agent.js\");\n\n// https://github.com/zloirock/core-js/issues/280\n$export($export.P + $export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(userAgent), 'String', {\n  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es7.string.pad-end.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-start.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-start.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = __webpack_require__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\nvar $pad = __webpack_require__(/*! ./_string-pad */ \"./node_modules/core-js/modules/_string-pad.js\");\nvar userAgent = __webpack_require__(/*! ./_user-agent */ \"./node_modules/core-js/modules/_user-agent.js\");\n\n// https://github.com/zloirock/core-js/issues/280\n$export($export.P + $export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(userAgent), 'String', {\n  padStart: function padStart(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es7.string.pad-start.js?");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./build/pkg-only/bundle/programs/web.browser/merged-stylesheets.css":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/css-loader!./build/pkg-only/bundle/programs/web.browser/merged-stylesheets.css ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(/*! ../../../../../node_modules/css-loader/lib/url/escape.js */ \"./node_modules/css-loader/lib/url/escape.js\");\nexports = module.exports = __webpack_require__(/*! ../../../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/*!\\n * Bootstrap v3.3.6 (http://getbootstrap.com)\\n * Copyright 2011-2015 Twitter, Inc.\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n */\\n/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */\\nhtml {\\n  font-family: sans-serif;\\n  -webkit-text-size-adjust: 100%;\\n      -ms-text-size-adjust: 100%;\\n}\\nbody {\\n  margin: 0;\\n}\\narticle,\\naside,\\ndetails,\\nfigcaption,\\nfigure,\\nfooter,\\nheader,\\nhgroup,\\nmain,\\nmenu,\\nnav,\\nsection,\\nsummary {\\n  display: block;\\n}\\naudio,\\ncanvas,\\nprogress,\\nvideo {\\n  display: inline-block;\\n  vertical-align: baseline;\\n}\\naudio:not([controls]) {\\n  display: none;\\n  height: 0;\\n}\\n[hidden],\\ntemplate {\\n  display: none;\\n}\\na {\\n  background-color: transparent;\\n}\\na:active,\\na:hover {\\n  outline: 0;\\n}\\nabbr[title] {\\n  border-bottom: 1px dotted;\\n}\\nb,\\nstrong {\\n  font-weight: bold;\\n}\\ndfn {\\n  font-style: italic;\\n}\\nh1 {\\n  margin: .67em 0;\\n  font-size: 2em;\\n}\\nmark {\\n  color: #000;\\n  background: #ff0;\\n}\\nsmall {\\n  font-size: 80%;\\n}\\nsub,\\nsup {\\n  position: relative;\\n  font-size: 75%;\\n  line-height: 0;\\n  vertical-align: baseline;\\n}\\nsup {\\n  top: -.5em;\\n}\\nsub {\\n  bottom: -.25em;\\n}\\nimg {\\n  border: 0;\\n}\\nsvg:not(:root) {\\n  overflow: hidden;\\n}\\nfigure {\\n  margin: 1em 40px;\\n}\\nhr {\\n  height: 0;\\n  -webkit-box-sizing: content-box;\\n     -moz-box-sizing: content-box;\\n          box-sizing: content-box;\\n}\\npre {\\n  overflow: auto;\\n}\\ncode,\\nkbd,\\npre,\\nsamp {\\n  font-family: monospace, monospace;\\n  font-size: 1em;\\n}\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  margin: 0;\\n  font: inherit;\\n  color: inherit;\\n}\\nbutton {\\n  overflow: visible;\\n}\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\nbutton,\\nhtml input[type=\\\"button\\\"],\\ninput[type=\\\"reset\\\"],\\ninput[type=\\\"submit\\\"] {\\n  -webkit-appearance: button;\\n  cursor: pointer;\\n}\\nbutton[disabled],\\nhtml input[disabled] {\\n  cursor: default;\\n}\\nbutton::-moz-focus-inner,\\ninput::-moz-focus-inner {\\n  padding: 0;\\n  border: 0;\\n}\\ninput {\\n  line-height: normal;\\n}\\ninput[type=\\\"checkbox\\\"],\\ninput[type=\\\"radio\\\"] {\\n  -webkit-box-sizing: border-box;\\n     -moz-box-sizing: border-box;\\n          box-sizing: border-box;\\n  padding: 0;\\n}\\ninput[type=\\\"number\\\"]::-webkit-inner-spin-button,\\ninput[type=\\\"number\\\"]::-webkit-outer-spin-button {\\n  height: auto;\\n}\\ninput[type=\\\"search\\\"] {\\n  -webkit-box-sizing: content-box;\\n     -moz-box-sizing: content-box;\\n          box-sizing: content-box;\\n  -webkit-appearance: textfield;\\n}\\ninput[type=\\\"search\\\"]::-webkit-search-cancel-button,\\ninput[type=\\\"search\\\"]::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\nfieldset {\\n  padding: .35em .625em .75em;\\n  margin: 0 2px;\\n  border: 1px solid #c0c0c0;\\n}\\nlegend {\\n  padding: 0;\\n  border: 0;\\n}\\ntextarea {\\n  overflow: auto;\\n}\\noptgroup {\\n  font-weight: bold;\\n}\\ntable {\\n  border-spacing: 0;\\n  border-collapse: collapse;\\n}\\ntd,\\nth {\\n  padding: 0;\\n}\\n/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */\\n@media print {\\n  *,\\n  *:before,\\n  *:after {\\n    color: #000 !important;\\n    text-shadow: none !important;\\n    background: transparent !important;\\n    -webkit-box-shadow: none !important;\\n            box-shadow: none !important;\\n  }\\n  a,\\n  a:visited {\\n    text-decoration: underline;\\n  }\\n  a[href]:after {\\n    content: \\\" (\\\" attr(href) \\\")\\\";\\n  }\\n  abbr[title]:after {\\n    content: \\\" (\\\" attr(title) \\\")\\\";\\n  }\\n  a[href^=\\\"#\\\"]:after,\\n  a[href^=\\\"javascript:\\\"]:after {\\n    content: \\\"\\\";\\n  }\\n  pre,\\n  blockquote {\\n    border: 1px solid #999;\\n\\n    page-break-inside: avoid;\\n  }\\n  thead {\\n    display: table-header-group;\\n  }\\n  tr,\\n  img {\\n    page-break-inside: avoid;\\n  }\\n  img {\\n    max-width: 100% !important;\\n  }\\n  p,\\n  h2,\\n  h3 {\\n    orphans: 3;\\n    widows: 3;\\n  }\\n  h2,\\n  h3 {\\n    page-break-after: avoid;\\n  }\\n  .navbar {\\n    display: none;\\n  }\\n  .btn > .caret,\\n  .dropup > .btn > .caret {\\n    border-top-color: #000 !important;\\n  }\\n  .label {\\n    border: 1px solid #000;\\n  }\\n  .table {\\n    border-collapse: collapse !important;\\n  }\\n  .table td,\\n  .table th {\\n    background-color: #fff !important;\\n  }\\n  .table-bordered th,\\n  .table-bordered td {\\n    border: 1px solid #ddd !important;\\n  }\\n}\\n@font-face {\\n  font-family: 'Glyphicons Halflings';\\n\\n  src: url(\" + escape(__webpack_require__(/*! ./packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.eot */ \"./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.eot\")) + \");\\n  src: url(\" + escape(__webpack_require__(/*! ./packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.eot */ \"./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.eot\")) + \"?#iefix) format('embedded-opentype'), url(\" + escape(__webpack_require__(/*! ./packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.woff2 */ \"./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.woff2\")) + \") format('woff2'), url(\" + escape(__webpack_require__(/*! ./packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.woff */ \"./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.woff\")) + \") format('woff'), url(\" + escape(__webpack_require__(/*! ./packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.ttf */ \"./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.ttf\")) + \") format('truetype'), url(\" + escape(__webpack_require__(/*! ./packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.svg */ \"./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap/dist/fonts/glyphicons-halflings-regular.svg\")) + \"#glyphicons_halflingsregular) format('svg');\\n}\\n.glyphicon {\\n  position: relative;\\n  top: 1px;\\n  display: inline-block;\\n  font-family: 'Glyphicons Halflings';\\n  font-style: normal;\\n  font-weight: normal;\\n  line-height: 1;\\n\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n.glyphicon-asterisk:before {\\n  content: \\\"*\\\";\\n}\\n.glyphicon-plus:before {\\n  content: \\\"+\\\";\\n}\\n.glyphicon-euro:before,\\n.glyphicon-eur:before {\\n  content: \\\"\\\\20AC\\\";\\n}\\n.glyphicon-minus:before {\\n  content: \\\"\\\\2212\\\";\\n}\\n.glyphicon-cloud:before {\\n  content: \\\"\\\\2601\\\";\\n}\\n.glyphicon-envelope:before {\\n  content: \\\"\\\\2709\\\";\\n}\\n.glyphicon-pencil:before {\\n  content: \\\"\\\\270F\\\";\\n}\\n.glyphicon-glass:before {\\n  content: \\\"\\\\E001\\\";\\n}\\n.glyphicon-music:before {\\n  content: \\\"\\\\E002\\\";\\n}\\n.glyphicon-search:before {\\n  content: \\\"\\\\E003\\\";\\n}\\n.glyphicon-heart:before {\\n  content: \\\"\\\\E005\\\";\\n}\\n.glyphicon-star:before {\\n  content: \\\"\\\\E006\\\";\\n}\\n.glyphicon-star-empty:before {\\n  content: \\\"\\\\E007\\\";\\n}\\n.glyphicon-user:before {\\n  content: \\\"\\\\E008\\\";\\n}\\n.glyphicon-film:before {\\n  content: \\\"\\\\E009\\\";\\n}\\n.glyphicon-th-large:before {\\n  content: \\\"\\\\E010\\\";\\n}\\n.glyphicon-th:before {\\n  content: \\\"\\\\E011\\\";\\n}\\n.glyphicon-th-list:before {\\n  content: \\\"\\\\E012\\\";\\n}\\n.glyphicon-ok:before {\\n  content: \\\"\\\\E013\\\";\\n}\\n.glyphicon-remove:before {\\n  content: \\\"\\\\E014\\\";\\n}\\n.glyphicon-zoom-in:before {\\n  content: \\\"\\\\E015\\\";\\n}\\n.glyphicon-zoom-out:before {\\n  content: \\\"\\\\E016\\\";\\n}\\n.glyphicon-off:before {\\n  content: \\\"\\\\E017\\\";\\n}\\n.glyphicon-signal:before {\\n  content: \\\"\\\\E018\\\";\\n}\\n.glyphicon-cog:before {\\n  content: \\\"\\\\E019\\\";\\n}\\n.glyphicon-trash:before {\\n  content: \\\"\\\\E020\\\";\\n}\\n.glyphicon-home:before {\\n  content: \\\"\\\\E021\\\";\\n}\\n.glyphicon-file:before {\\n  content: \\\"\\\\E022\\\";\\n}\\n.glyphicon-time:before {\\n  content: \\\"\\\\E023\\\";\\n}\\n.glyphicon-road:before {\\n  content: \\\"\\\\E024\\\";\\n}\\n.glyphicon-download-alt:before {\\n  content: \\\"\\\\E025\\\";\\n}\\n.glyphicon-download:before {\\n  content: \\\"\\\\E026\\\";\\n}\\n.glyphicon-upload:before {\\n  content: \\\"\\\\E027\\\";\\n}\\n.glyphicon-inbox:before {\\n  content: \\\"\\\\E028\\\";\\n}\\n.glyphicon-play-circle:before {\\n  content: \\\"\\\\E029\\\";\\n}\\n.glyphicon-repeat:before {\\n  content: \\\"\\\\E030\\\";\\n}\\n.glyphicon-refresh:before {\\n  content: \\\"\\\\E031\\\";\\n}\\n.glyphicon-list-alt:before {\\n  content: \\\"\\\\E032\\\";\\n}\\n.glyphicon-lock:before {\\n  content: \\\"\\\\E033\\\";\\n}\\n.glyphicon-flag:before {\\n  content: \\\"\\\\E034\\\";\\n}\\n.glyphicon-headphones:before {\\n  content: \\\"\\\\E035\\\";\\n}\\n.glyphicon-volume-off:before {\\n  content: \\\"\\\\E036\\\";\\n}\\n.glyphicon-volume-down:before {\\n  content: \\\"\\\\E037\\\";\\n}\\n.glyphicon-volume-up:before {\\n  content: \\\"\\\\E038\\\";\\n}\\n.glyphicon-qrcode:before {\\n  content: \\\"\\\\E039\\\";\\n}\\n.glyphicon-barcode:before {\\n  content: \\\"\\\\E040\\\";\\n}\\n.glyphicon-tag:before {\\n  content: \\\"\\\\E041\\\";\\n}\\n.glyphicon-tags:before {\\n  content: \\\"\\\\E042\\\";\\n}\\n.glyphicon-book:before {\\n  content: \\\"\\\\E043\\\";\\n}\\n.glyphicon-bookmark:before {\\n  content: \\\"\\\\E044\\\";\\n}\\n.glyphicon-print:before {\\n  content: \\\"\\\\E045\\\";\\n}\\n.glyphicon-camera:before {\\n  content: \\\"\\\\E046\\\";\\n}\\n.glyphicon-font:before {\\n  content: \\\"\\\\E047\\\";\\n}\\n.glyphicon-bold:before {\\n  content: \\\"\\\\E048\\\";\\n}\\n.glyphicon-italic:before {\\n  content: \\\"\\\\E049\\\";\\n}\\n.glyphicon-text-height:before {\\n  content: \\\"\\\\E050\\\";\\n}\\n.glyphicon-text-width:before {\\n  content: \\\"\\\\E051\\\";\\n}\\n.glyphicon-align-left:before {\\n  content: \\\"\\\\E052\\\";\\n}\\n.glyphicon-align-center:before {\\n  content: \\\"\\\\E053\\\";\\n}\\n.glyphicon-align-right:before {\\n  content: \\\"\\\\E054\\\";\\n}\\n.glyphicon-align-justify:before {\\n  content: \\\"\\\\E055\\\";\\n}\\n.glyphicon-list:before {\\n  content: \\\"\\\\E056\\\";\\n}\\n.glyphicon-indent-left:before {\\n  content: \\\"\\\\E057\\\";\\n}\\n.glyphicon-indent-right:before {\\n  content: \\\"\\\\E058\\\";\\n}\\n.glyphicon-facetime-video:before {\\n  content: \\\"\\\\E059\\\";\\n}\\n.glyphicon-picture:before {\\n  content: \\\"\\\\E060\\\";\\n}\\n.glyphicon-map-marker:before {\\n  content: \\\"\\\\E062\\\";\\n}\\n.glyphicon-adjust:before {\\n  content: \\\"\\\\E063\\\";\\n}\\n.glyphicon-tint:before {\\n  content: \\\"\\\\E064\\\";\\n}\\n.glyphicon-edit:before {\\n  content: \\\"\\\\E065\\\";\\n}\\n.glyphicon-share:before {\\n  content: \\\"\\\\E066\\\";\\n}\\n.glyphicon-check:before {\\n  content: \\\"\\\\E067\\\";\\n}\\n.glyphicon-move:before {\\n  content: \\\"\\\\E068\\\";\\n}\\n.glyphicon-step-backward:before {\\n  content: \\\"\\\\E069\\\";\\n}\\n.glyphicon-fast-backward:before {\\n  content: \\\"\\\\E070\\\";\\n}\\n.glyphicon-backward:before {\\n  content: \\\"\\\\E071\\\";\\n}\\n.glyphicon-play:before {\\n  content: \\\"\\\\E072\\\";\\n}\\n.glyphicon-pause:before {\\n  content: \\\"\\\\E073\\\";\\n}\\n.glyphicon-stop:before {\\n  content: \\\"\\\\E074\\\";\\n}\\n.glyphicon-forward:before {\\n  content: \\\"\\\\E075\\\";\\n}\\n.glyphicon-fast-forward:before {\\n  content: \\\"\\\\E076\\\";\\n}\\n.glyphicon-step-forward:before {\\n  content: \\\"\\\\E077\\\";\\n}\\n.glyphicon-eject:before {\\n  content: \\\"\\\\E078\\\";\\n}\\n.glyphicon-chevron-left:before {\\n  content: \\\"\\\\E079\\\";\\n}\\n.glyphicon-chevron-right:before {\\n  content: \\\"\\\\E080\\\";\\n}\\n.glyphicon-plus-sign:before {\\n  content: \\\"\\\\E081\\\";\\n}\\n.glyphicon-minus-sign:before {\\n  content: \\\"\\\\E082\\\";\\n}\\n.glyphicon-remove-sign:before {\\n  content: \\\"\\\\E083\\\";\\n}\\n.glyphicon-ok-sign:before {\\n  content: \\\"\\\\E084\\\";\\n}\\n.glyphicon-question-sign:before {\\n  content: \\\"\\\\E085\\\";\\n}\\n.glyphicon-info-sign:before {\\n  content: \\\"\\\\E086\\\";\\n}\\n.glyphicon-screenshot:before {\\n  content: \\\"\\\\E087\\\";\\n}\\n.glyphicon-remove-circle:before {\\n  content: \\\"\\\\E088\\\";\\n}\\n.glyphicon-ok-circle:before {\\n  content: \\\"\\\\E089\\\";\\n}\\n.glyphicon-ban-circle:before {\\n  content: \\\"\\\\E090\\\";\\n}\\n.glyphicon-arrow-left:before {\\n  content: \\\"\\\\E091\\\";\\n}\\n.glyphicon-arrow-right:before {\\n  content: \\\"\\\\E092\\\";\\n}\\n.glyphicon-arrow-up:before {\\n  content: \\\"\\\\E093\\\";\\n}\\n.glyphicon-arrow-down:before {\\n  content: \\\"\\\\E094\\\";\\n}\\n.glyphicon-share-alt:before {\\n  content: \\\"\\\\E095\\\";\\n}\\n.glyphicon-resize-full:before {\\n  content: \\\"\\\\E096\\\";\\n}\\n.glyphicon-resize-small:before {\\n  content: \\\"\\\\E097\\\";\\n}\\n.glyphicon-exclamation-sign:before {\\n  content: \\\"\\\\E101\\\";\\n}\\n.glyphicon-gift:before {\\n  content: \\\"\\\\E102\\\";\\n}\\n.glyphicon-leaf:before {\\n  content: \\\"\\\\E103\\\";\\n}\\n.glyphicon-fire:before {\\n  content: \\\"\\\\E104\\\";\\n}\\n.glyphicon-eye-open:before {\\n  content: \\\"\\\\E105\\\";\\n}\\n.glyphicon-eye-close:before {\\n  content: \\\"\\\\E106\\\";\\n}\\n.glyphicon-warning-sign:before {\\n  content: \\\"\\\\E107\\\";\\n}\\n.glyphicon-plane:before {\\n  content: \\\"\\\\E108\\\";\\n}\\n.glyphicon-calendar:before {\\n  content: \\\"\\\\E109\\\";\\n}\\n.glyphicon-random:before {\\n  content: \\\"\\\\E110\\\";\\n}\\n.glyphicon-comment:before {\\n  content: \\\"\\\\E111\\\";\\n}\\n.glyphicon-magnet:before {\\n  content: \\\"\\\\E112\\\";\\n}\\n.glyphicon-chevron-up:before {\\n  content: \\\"\\\\E113\\\";\\n}\\n.glyphicon-chevron-down:before {\\n  content: \\\"\\\\E114\\\";\\n}\\n.glyphicon-retweet:before {\\n  content: \\\"\\\\E115\\\";\\n}\\n.glyphicon-shopping-cart:before {\\n  content: \\\"\\\\E116\\\";\\n}\\n.glyphicon-folder-close:before {\\n  content: \\\"\\\\E117\\\";\\n}\\n.glyphicon-folder-open:before {\\n  content: \\\"\\\\E118\\\";\\n}\\n.glyphicon-resize-vertical:before {\\n  content: \\\"\\\\E119\\\";\\n}\\n.glyphicon-resize-horizontal:before {\\n  content: \\\"\\\\E120\\\";\\n}\\n.glyphicon-hdd:before {\\n  content: \\\"\\\\E121\\\";\\n}\\n.glyphicon-bullhorn:before {\\n  content: \\\"\\\\E122\\\";\\n}\\n.glyphicon-bell:before {\\n  content: \\\"\\\\E123\\\";\\n}\\n.glyphicon-certificate:before {\\n  content: \\\"\\\\E124\\\";\\n}\\n.glyphicon-thumbs-up:before {\\n  content: \\\"\\\\E125\\\";\\n}\\n.glyphicon-thumbs-down:before {\\n  content: \\\"\\\\E126\\\";\\n}\\n.glyphicon-hand-right:before {\\n  content: \\\"\\\\E127\\\";\\n}\\n.glyphicon-hand-left:before {\\n  content: \\\"\\\\E128\\\";\\n}\\n.glyphicon-hand-up:before {\\n  content: \\\"\\\\E129\\\";\\n}\\n.glyphicon-hand-down:before {\\n  content: \\\"\\\\E130\\\";\\n}\\n.glyphicon-circle-arrow-right:before {\\n  content: \\\"\\\\E131\\\";\\n}\\n.glyphicon-circle-arrow-left:before {\\n  content: \\\"\\\\E132\\\";\\n}\\n.glyphicon-circle-arrow-up:before {\\n  content: \\\"\\\\E133\\\";\\n}\\n.glyphicon-circle-arrow-down:before {\\n  content: \\\"\\\\E134\\\";\\n}\\n.glyphicon-globe:before {\\n  content: \\\"\\\\E135\\\";\\n}\\n.glyphicon-wrench:before {\\n  content: \\\"\\\\E136\\\";\\n}\\n.glyphicon-tasks:before {\\n  content: \\\"\\\\E137\\\";\\n}\\n.glyphicon-filter:before {\\n  content: \\\"\\\\E138\\\";\\n}\\n.glyphicon-briefcase:before {\\n  content: \\\"\\\\E139\\\";\\n}\\n.glyphicon-fullscreen:before {\\n  content: \\\"\\\\E140\\\";\\n}\\n.glyphicon-dashboard:before {\\n  content: \\\"\\\\E141\\\";\\n}\\n.glyphicon-paperclip:before {\\n  content: \\\"\\\\E142\\\";\\n}\\n.glyphicon-heart-empty:before {\\n  content: \\\"\\\\E143\\\";\\n}\\n.glyphicon-link:before {\\n  content: \\\"\\\\E144\\\";\\n}\\n.glyphicon-phone:before {\\n  content: \\\"\\\\E145\\\";\\n}\\n.glyphicon-pushpin:before {\\n  content: \\\"\\\\E146\\\";\\n}\\n.glyphicon-usd:before {\\n  content: \\\"\\\\E148\\\";\\n}\\n.glyphicon-gbp:before {\\n  content: \\\"\\\\E149\\\";\\n}\\n.glyphicon-sort:before {\\n  content: \\\"\\\\E150\\\";\\n}\\n.glyphicon-sort-by-alphabet:before {\\n  content: \\\"\\\\E151\\\";\\n}\\n.glyphicon-sort-by-alphabet-alt:before {\\n  content: \\\"\\\\E152\\\";\\n}\\n.glyphicon-sort-by-order:before {\\n  content: \\\"\\\\E153\\\";\\n}\\n.glyphicon-sort-by-order-alt:before {\\n  content: \\\"\\\\E154\\\";\\n}\\n.glyphicon-sort-by-attributes:before {\\n  content: \\\"\\\\E155\\\";\\n}\\n.glyphicon-sort-by-attributes-alt:before {\\n  content: \\\"\\\\E156\\\";\\n}\\n.glyphicon-unchecked:before {\\n  content: \\\"\\\\E157\\\";\\n}\\n.glyphicon-expand:before {\\n  content: \\\"\\\\E158\\\";\\n}\\n.glyphicon-collapse-down:before {\\n  content: \\\"\\\\E159\\\";\\n}\\n.glyphicon-collapse-up:before {\\n  content: \\\"\\\\E160\\\";\\n}\\n.glyphicon-log-in:before {\\n  content: \\\"\\\\E161\\\";\\n}\\n.glyphicon-flash:before {\\n  content: \\\"\\\\E162\\\";\\n}\\n.glyphicon-log-out:before {\\n  content: \\\"\\\\E163\\\";\\n}\\n.glyphicon-new-window:before {\\n  content: \\\"\\\\E164\\\";\\n}\\n.glyphicon-record:before {\\n  content: \\\"\\\\E165\\\";\\n}\\n.glyphicon-save:before {\\n  content: \\\"\\\\E166\\\";\\n}\\n.glyphicon-open:before {\\n  content: \\\"\\\\E167\\\";\\n}\\n.glyphicon-saved:before {\\n  content: \\\"\\\\E168\\\";\\n}\\n.glyphicon-import:before {\\n  content: \\\"\\\\E169\\\";\\n}\\n.glyphicon-export:before {\\n  content: \\\"\\\\E170\\\";\\n}\\n.glyphicon-send:before {\\n  content: \\\"\\\\E171\\\";\\n}\\n.glyphicon-floppy-disk:before {\\n  content: \\\"\\\\E172\\\";\\n}\\n.glyphicon-floppy-saved:before {\\n  content: \\\"\\\\E173\\\";\\n}\\n.glyphicon-floppy-remove:before {\\n  content: \\\"\\\\E174\\\";\\n}\\n.glyphicon-floppy-save:before {\\n  content: \\\"\\\\E175\\\";\\n}\\n.glyphicon-floppy-open:before {\\n  content: \\\"\\\\E176\\\";\\n}\\n.glyphicon-credit-card:before {\\n  content: \\\"\\\\E177\\\";\\n}\\n.glyphicon-transfer:before {\\n  content: \\\"\\\\E178\\\";\\n}\\n.glyphicon-cutlery:before {\\n  content: \\\"\\\\E179\\\";\\n}\\n.glyphicon-header:before {\\n  content: \\\"\\\\E180\\\";\\n}\\n.glyphicon-compressed:before {\\n  content: \\\"\\\\E181\\\";\\n}\\n.glyphicon-earphone:before {\\n  content: \\\"\\\\E182\\\";\\n}\\n.glyphicon-phone-alt:before {\\n  content: \\\"\\\\E183\\\";\\n}\\n.glyphicon-tower:before {\\n  content: \\\"\\\\E184\\\";\\n}\\n.glyphicon-stats:before {\\n  content: \\\"\\\\E185\\\";\\n}\\n.glyphicon-sd-video:before {\\n  content: \\\"\\\\E186\\\";\\n}\\n.glyphicon-hd-video:before {\\n  content: \\\"\\\\E187\\\";\\n}\\n.glyphicon-subtitles:before {\\n  content: \\\"\\\\E188\\\";\\n}\\n.glyphicon-sound-stereo:before {\\n  content: \\\"\\\\E189\\\";\\n}\\n.glyphicon-sound-dolby:before {\\n  content: \\\"\\\\E190\\\";\\n}\\n.glyphicon-sound-5-1:before {\\n  content: \\\"\\\\E191\\\";\\n}\\n.glyphicon-sound-6-1:before {\\n  content: \\\"\\\\E192\\\";\\n}\\n.glyphicon-sound-7-1:before {\\n  content: \\\"\\\\E193\\\";\\n}\\n.glyphicon-copyright-mark:before {\\n  content: \\\"\\\\E194\\\";\\n}\\n.glyphicon-registration-mark:before {\\n  content: \\\"\\\\E195\\\";\\n}\\n.glyphicon-cloud-download:before {\\n  content: \\\"\\\\E197\\\";\\n}\\n.glyphicon-cloud-upload:before {\\n  content: \\\"\\\\E198\\\";\\n}\\n.glyphicon-tree-conifer:before {\\n  content: \\\"\\\\E199\\\";\\n}\\n.glyphicon-tree-deciduous:before {\\n  content: \\\"\\\\E200\\\";\\n}\\n.glyphicon-cd:before {\\n  content: \\\"\\\\E201\\\";\\n}\\n.glyphicon-save-file:before {\\n  content: \\\"\\\\E202\\\";\\n}\\n.glyphicon-open-file:before {\\n  content: \\\"\\\\E203\\\";\\n}\\n.glyphicon-level-up:before {\\n  content: \\\"\\\\E204\\\";\\n}\\n.glyphicon-copy:before {\\n  content: \\\"\\\\E205\\\";\\n}\\n.glyphicon-paste:before {\\n  content: \\\"\\\\E206\\\";\\n}\\n.glyphicon-alert:before {\\n  content: \\\"\\\\E209\\\";\\n}\\n.glyphicon-equalizer:before {\\n  content: \\\"\\\\E210\\\";\\n}\\n.glyphicon-king:before {\\n  content: \\\"\\\\E211\\\";\\n}\\n.glyphicon-queen:before {\\n  content: \\\"\\\\E212\\\";\\n}\\n.glyphicon-pawn:before {\\n  content: \\\"\\\\E213\\\";\\n}\\n.glyphicon-bishop:before {\\n  content: \\\"\\\\E214\\\";\\n}\\n.glyphicon-knight:before {\\n  content: \\\"\\\\E215\\\";\\n}\\n.glyphicon-baby-formula:before {\\n  content: \\\"\\\\E216\\\";\\n}\\n.glyphicon-tent:before {\\n  content: \\\"\\\\26FA\\\";\\n}\\n.glyphicon-blackboard:before {\\n  content: \\\"\\\\E218\\\";\\n}\\n.glyphicon-bed:before {\\n  content: \\\"\\\\E219\\\";\\n}\\n.glyphicon-apple:before {\\n  content: \\\"\\\\F8FF\\\";\\n}\\n.glyphicon-erase:before {\\n  content: \\\"\\\\E221\\\";\\n}\\n.glyphicon-hourglass:before {\\n  content: \\\"\\\\231B\\\";\\n}\\n.glyphicon-lamp:before {\\n  content: \\\"\\\\E223\\\";\\n}\\n.glyphicon-duplicate:before {\\n  content: \\\"\\\\E224\\\";\\n}\\n.glyphicon-piggy-bank:before {\\n  content: \\\"\\\\E225\\\";\\n}\\n.glyphicon-scissors:before {\\n  content: \\\"\\\\E226\\\";\\n}\\n.glyphicon-bitcoin:before {\\n  content: \\\"\\\\E227\\\";\\n}\\n.glyphicon-btc:before {\\n  content: \\\"\\\\E227\\\";\\n}\\n.glyphicon-xbt:before {\\n  content: \\\"\\\\E227\\\";\\n}\\n.glyphicon-yen:before {\\n  content: \\\"\\\\A5\\\";\\n}\\n.glyphicon-jpy:before {\\n  content: \\\"\\\\A5\\\";\\n}\\n.glyphicon-ruble:before {\\n  content: \\\"\\\\20BD\\\";\\n}\\n.glyphicon-rub:before {\\n  content: \\\"\\\\20BD\\\";\\n}\\n.glyphicon-scale:before {\\n  content: \\\"\\\\E230\\\";\\n}\\n.glyphicon-ice-lolly:before {\\n  content: \\\"\\\\E231\\\";\\n}\\n.glyphicon-ice-lolly-tasted:before {\\n  content: \\\"\\\\E232\\\";\\n}\\n.glyphicon-education:before {\\n  content: \\\"\\\\E233\\\";\\n}\\n.glyphicon-option-horizontal:before {\\n  content: \\\"\\\\E234\\\";\\n}\\n.glyphicon-option-vertical:before {\\n  content: \\\"\\\\E235\\\";\\n}\\n.glyphicon-menu-hamburger:before {\\n  content: \\\"\\\\E236\\\";\\n}\\n.glyphicon-modal-window:before {\\n  content: \\\"\\\\E237\\\";\\n}\\n.glyphicon-oil:before {\\n  content: \\\"\\\\E238\\\";\\n}\\n.glyphicon-grain:before {\\n  content: \\\"\\\\E239\\\";\\n}\\n.glyphicon-sunglasses:before {\\n  content: \\\"\\\\E240\\\";\\n}\\n.glyphicon-text-size:before {\\n  content: \\\"\\\\E241\\\";\\n}\\n.glyphicon-text-color:before {\\n  content: \\\"\\\\E242\\\";\\n}\\n.glyphicon-text-background:before {\\n  content: \\\"\\\\E243\\\";\\n}\\n.glyphicon-object-align-top:before {\\n  content: \\\"\\\\E244\\\";\\n}\\n.glyphicon-object-align-bottom:before {\\n  content: \\\"\\\\E245\\\";\\n}\\n.glyphicon-object-align-horizontal:before {\\n  content: \\\"\\\\E246\\\";\\n}\\n.glyphicon-object-align-left:before {\\n  content: \\\"\\\\E247\\\";\\n}\\n.glyphicon-object-align-vertical:before {\\n  content: \\\"\\\\E248\\\";\\n}\\n.glyphicon-object-align-right:before {\\n  content: \\\"\\\\E249\\\";\\n}\\n.glyphicon-triangle-right:before {\\n  content: \\\"\\\\E250\\\";\\n}\\n.glyphicon-triangle-left:before {\\n  content: \\\"\\\\E251\\\";\\n}\\n.glyphicon-triangle-bottom:before {\\n  content: \\\"\\\\E252\\\";\\n}\\n.glyphicon-triangle-top:before {\\n  content: \\\"\\\\E253\\\";\\n}\\n.glyphicon-console:before {\\n  content: \\\"\\\\E254\\\";\\n}\\n.glyphicon-superscript:before {\\n  content: \\\"\\\\E255\\\";\\n}\\n.glyphicon-subscript:before {\\n  content: \\\"\\\\E256\\\";\\n}\\n.glyphicon-menu-left:before {\\n  content: \\\"\\\\E257\\\";\\n}\\n.glyphicon-menu-right:before {\\n  content: \\\"\\\\E258\\\";\\n}\\n.glyphicon-menu-down:before {\\n  content: \\\"\\\\E259\\\";\\n}\\n.glyphicon-menu-up:before {\\n  content: \\\"\\\\E260\\\";\\n}\\n* {\\n  -webkit-box-sizing: border-box;\\n     -moz-box-sizing: border-box;\\n          box-sizing: border-box;\\n}\\n*:before,\\n*:after {\\n  -webkit-box-sizing: border-box;\\n     -moz-box-sizing: border-box;\\n          box-sizing: border-box;\\n}\\nhtml {\\n  font-size: 10px;\\n\\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n}\\nbody {\\n  font-family: \\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif;\\n  font-size: 14px;\\n  line-height: 1.42857143;\\n  color: #333;\\n  background-color: #fff;\\n}\\ninput,\\nbutton,\\nselect,\\ntextarea {\\n  font-family: inherit;\\n  font-size: inherit;\\n  line-height: inherit;\\n}\\na {\\n  color: #337ab7;\\n  text-decoration: none;\\n}\\na:hover,\\na:focus {\\n  color: #23527c;\\n  text-decoration: underline;\\n}\\na:focus {\\n  outline: thin dotted;\\n  outline: 5px auto -webkit-focus-ring-color;\\n  outline-offset: -2px;\\n}\\nfigure {\\n  margin: 0;\\n}\\nimg {\\n  vertical-align: middle;\\n}\\n.img-responsive,\\n.thumbnail > img,\\n.thumbnail a > img,\\n.carousel-inner > .item > img,\\n.carousel-inner > .item > a > img {\\n  display: block;\\n  max-width: 100%;\\n  height: auto;\\n}\\n.img-rounded {\\n  border-radius: 6px;\\n}\\n.img-thumbnail {\\n  display: inline-block;\\n  max-width: 100%;\\n  height: auto;\\n  padding: 4px;\\n  line-height: 1.42857143;\\n  background-color: #fff;\\n  border: 1px solid #ddd;\\n  border-radius: 4px;\\n  -webkit-transition: all .2s ease-in-out;\\n       -o-transition: all .2s ease-in-out;\\n          transition: all .2s ease-in-out;\\n}\\n.img-circle {\\n  border-radius: 50%;\\n}\\nhr {\\n  margin-top: 20px;\\n  margin-bottom: 20px;\\n  border: 0;\\n  border-top: 1px solid #eee;\\n}\\n.sr-only {\\n  position: absolute;\\n  width: 1px;\\n  height: 1px;\\n  padding: 0;\\n  margin: -1px;\\n  overflow: hidden;\\n  clip: rect(0, 0, 0, 0);\\n  border: 0;\\n}\\n.sr-only-focusable:active,\\n.sr-only-focusable:focus {\\n  position: static;\\n  width: auto;\\n  height: auto;\\n  margin: 0;\\n  overflow: visible;\\n  clip: auto;\\n}\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\n.h1,\\n.h2,\\n.h3,\\n.h4,\\n.h5,\\n.h6 {\\n  font-family: inherit;\\n  font-weight: 500;\\n  line-height: 1.1;\\n  color: inherit;\\n}\\nh1 small,\\nh2 small,\\nh3 small,\\nh4 small,\\nh5 small,\\nh6 small,\\n.h1 small,\\n.h2 small,\\n.h3 small,\\n.h4 small,\\n.h5 small,\\n.h6 small,\\nh1 .small,\\nh2 .small,\\nh3 .small,\\nh4 .small,\\nh5 .small,\\nh6 .small,\\n.h1 .small,\\n.h2 .small,\\n.h3 .small,\\n.h4 .small,\\n.h5 .small,\\n.h6 .small {\\n  font-weight: normal;\\n  line-height: 1;\\n  color: #777;\\n}\\nh1,\\n.h1,\\nh2,\\n.h2,\\nh3,\\n.h3 {\\n  margin-top: 20px;\\n  margin-bottom: 10px;\\n}\\nh1 small,\\n.h1 small,\\nh2 small,\\n.h2 small,\\nh3 small,\\n.h3 small,\\nh1 .small,\\n.h1 .small,\\nh2 .small,\\n.h2 .small,\\nh3 .small,\\n.h3 .small {\\n  font-size: 65%;\\n}\\nh4,\\n.h4,\\nh5,\\n.h5,\\nh6,\\n.h6 {\\n  margin-top: 10px;\\n  margin-bottom: 10px;\\n}\\nh4 small,\\n.h4 small,\\nh5 small,\\n.h5 small,\\nh6 small,\\n.h6 small,\\nh4 .small,\\n.h4 .small,\\nh5 .small,\\n.h5 .small,\\nh6 .small,\\n.h6 .small {\\n  font-size: 75%;\\n}\\nh1,\\n.h1 {\\n  font-size: 36px;\\n}\\nh2,\\n.h2 {\\n  font-size: 30px;\\n}\\nh3,\\n.h3 {\\n  font-size: 24px;\\n}\\nh4,\\n.h4 {\\n  font-size: 18px;\\n}\\nh5,\\n.h5 {\\n  font-size: 14px;\\n}\\nh6,\\n.h6 {\\n  font-size: 12px;\\n}\\np {\\n  margin: 0 0 10px;\\n}\\n.lead {\\n  margin-bottom: 20px;\\n  font-size: 16px;\\n  font-weight: 300;\\n  line-height: 1.4;\\n}\\n@media (min-width: 768px) {\\n  .lead {\\n    font-size: 21px;\\n  }\\n}\\nsmall,\\n.small {\\n  font-size: 85%;\\n}\\nmark,\\n.mark {\\n  padding: .2em;\\n  background-color: #fcf8e3;\\n}\\n.text-left {\\n  text-align: left;\\n}\\n.text-right {\\n  text-align: right;\\n}\\n.text-center {\\n  text-align: center;\\n}\\n.text-justify {\\n  text-align: justify;\\n}\\n.text-nowrap {\\n  white-space: nowrap;\\n}\\n.text-lowercase {\\n  text-transform: lowercase;\\n}\\n.text-uppercase {\\n  text-transform: uppercase;\\n}\\n.text-capitalize {\\n  text-transform: capitalize;\\n}\\n.text-muted {\\n  color: #777;\\n}\\n.text-primary {\\n  color: #337ab7;\\n}\\na.text-primary:hover,\\na.text-primary:focus {\\n  color: #286090;\\n}\\n.text-success {\\n  color: #3c763d;\\n}\\na.text-success:hover,\\na.text-success:focus {\\n  color: #2b542c;\\n}\\n.text-info {\\n  color: #31708f;\\n}\\na.text-info:hover,\\na.text-info:focus {\\n  color: #245269;\\n}\\n.text-warning {\\n  color: #8a6d3b;\\n}\\na.text-warning:hover,\\na.text-warning:focus {\\n  color: #66512c;\\n}\\n.text-danger {\\n  color: #a94442;\\n}\\na.text-danger:hover,\\na.text-danger:focus {\\n  color: #843534;\\n}\\n.bg-primary {\\n  color: #fff;\\n  background-color: #337ab7;\\n}\\na.bg-primary:hover,\\na.bg-primary:focus {\\n  background-color: #286090;\\n}\\n.bg-success {\\n  background-color: #dff0d8;\\n}\\na.bg-success:hover,\\na.bg-success:focus {\\n  background-color: #c1e2b3;\\n}\\n.bg-info {\\n  background-color: #d9edf7;\\n}\\na.bg-info:hover,\\na.bg-info:focus {\\n  background-color: #afd9ee;\\n}\\n.bg-warning {\\n  background-color: #fcf8e3;\\n}\\na.bg-warning:hover,\\na.bg-warning:focus {\\n  background-color: #f7ecb5;\\n}\\n.bg-danger {\\n  background-color: #f2dede;\\n}\\na.bg-danger:hover,\\na.bg-danger:focus {\\n  background-color: #e4b9b9;\\n}\\n.page-header {\\n  padding-bottom: 9px;\\n  margin: 40px 0 20px;\\n  border-bottom: 1px solid #eee;\\n}\\nul,\\nol {\\n  margin-top: 0;\\n  margin-bottom: 10px;\\n}\\nul ul,\\nol ul,\\nul ol,\\nol ol {\\n  margin-bottom: 0;\\n}\\n.list-unstyled {\\n  padding-left: 0;\\n  list-style: none;\\n}\\n.list-inline {\\n  padding-left: 0;\\n  margin-left: -5px;\\n  list-style: none;\\n}\\n.list-inline > li {\\n  display: inline-block;\\n  padding-right: 5px;\\n  padding-left: 5px;\\n}\\ndl {\\n  margin-top: 0;\\n  margin-bottom: 20px;\\n}\\ndt,\\ndd {\\n  line-height: 1.42857143;\\n}\\ndt {\\n  font-weight: bold;\\n}\\ndd {\\n  margin-left: 0;\\n}\\n@media (min-width: 768px) {\\n  .dl-horizontal dt {\\n    float: left;\\n    width: 160px;\\n    overflow: hidden;\\n    clear: left;\\n    text-align: right;\\n    text-overflow: ellipsis;\\n    white-space: nowrap;\\n  }\\n  .dl-horizontal dd {\\n    margin-left: 180px;\\n  }\\n}\\nabbr[title],\\nabbr[data-original-title] {\\n  cursor: help;\\n  border-bottom: 1px dotted #777;\\n}\\n.initialism {\\n  font-size: 90%;\\n  text-transform: uppercase;\\n}\\nblockquote {\\n  padding: 10px 20px;\\n  margin: 0 0 20px;\\n  font-size: 17.5px;\\n  border-left: 5px solid #eee;\\n}\\nblockquote p:last-child,\\nblockquote ul:last-child,\\nblockquote ol:last-child {\\n  margin-bottom: 0;\\n}\\nblockquote footer,\\nblockquote small,\\nblockquote .small {\\n  display: block;\\n  font-size: 80%;\\n  line-height: 1.42857143;\\n  color: #777;\\n}\\nblockquote footer:before,\\nblockquote small:before,\\nblockquote .small:before {\\n  content: '\\\\2014   \\\\A0';\\n}\\n.blockquote-reverse,\\nblockquote.pull-right {\\n  padding-right: 15px;\\n  padding-left: 0;\\n  text-align: right;\\n  border-right: 5px solid #eee;\\n  border-left: 0;\\n}\\n.blockquote-reverse footer:before,\\nblockquote.pull-right footer:before,\\n.blockquote-reverse small:before,\\nblockquote.pull-right small:before,\\n.blockquote-reverse .small:before,\\nblockquote.pull-right .small:before {\\n  content: '';\\n}\\n.blockquote-reverse footer:after,\\nblockquote.pull-right footer:after,\\n.blockquote-reverse small:after,\\nblockquote.pull-right small:after,\\n.blockquote-reverse .small:after,\\nblockquote.pull-right .small:after {\\n  content: '\\\\A0   \\\\2014';\\n}\\naddress {\\n  margin-bottom: 20px;\\n  font-style: normal;\\n  line-height: 1.42857143;\\n}\\ncode,\\nkbd,\\npre,\\nsamp {\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n}\\ncode {\\n  padding: 2px 4px;\\n  font-size: 90%;\\n  color: #c7254e;\\n  background-color: #f9f2f4;\\n  border-radius: 4px;\\n}\\nkbd {\\n  padding: 2px 4px;\\n  font-size: 90%;\\n  color: #fff;\\n  background-color: #333;\\n  border-radius: 3px;\\n  -webkit-box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .25);\\n          box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .25);\\n}\\nkbd kbd {\\n  padding: 0;\\n  font-size: 100%;\\n  font-weight: bold;\\n  -webkit-box-shadow: none;\\n          box-shadow: none;\\n}\\npre {\\n  display: block;\\n  padding: 9.5px;\\n  margin: 0 0 10px;\\n  font-size: 13px;\\n  line-height: 1.42857143;\\n  color: #333;\\n  word-break: break-all;\\n  word-wrap: break-word;\\n  background-color: #f5f5f5;\\n  border: 1px solid #ccc;\\n  border-radius: 4px;\\n}\\npre code {\\n  padding: 0;\\n  font-size: inherit;\\n  color: inherit;\\n  white-space: pre-wrap;\\n  background-color: transparent;\\n  border-radius: 0;\\n}\\n.pre-scrollable {\\n  max-height: 340px;\\n  overflow-y: scroll;\\n}\\n.container {\\n  padding-right: 15px;\\n  padding-left: 15px;\\n  margin-right: auto;\\n  margin-left: auto;\\n}\\n@media (min-width: 768px) {\\n  .container {\\n    width: 750px;\\n  }\\n}\\n@media (min-width: 992px) {\\n  .container {\\n    width: 970px;\\n  }\\n}\\n@media (min-width: 1200px) {\\n  .container {\\n    width: 1170px;\\n  }\\n}\\n.container-fluid {\\n  padding-right: 15px;\\n  padding-left: 15px;\\n  margin-right: auto;\\n  margin-left: auto;\\n}\\n.row {\\n  margin-right: -15px;\\n  margin-left: -15px;\\n}\\n.col-xs-1, .col-sm-1, .col-md-1, .col-lg-1, .col-xs-2, .col-sm-2, .col-md-2, .col-lg-2, .col-xs-3, .col-sm-3, .col-md-3, .col-lg-3, .col-xs-4, .col-sm-4, .col-md-4, .col-lg-4, .col-xs-5, .col-sm-5, .col-md-5, .col-lg-5, .col-xs-6, .col-sm-6, .col-md-6, .col-lg-6, .col-xs-7, .col-sm-7, .col-md-7, .col-lg-7, .col-xs-8, .col-sm-8, .col-md-8, .col-lg-8, .col-xs-9, .col-sm-9, .col-md-9, .col-lg-9, .col-xs-10, .col-sm-10, .col-md-10, .col-lg-10, .col-xs-11, .col-sm-11, .col-md-11, .col-lg-11, .col-xs-12, .col-sm-12, .col-md-12, .col-lg-12 {\\n  position: relative;\\n  min-height: 1px;\\n  padding-right: 15px;\\n  padding-left: 15px;\\n}\\n.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 {\\n  float: left;\\n}\\n.col-xs-12 {\\n  width: 100%;\\n}\\n.col-xs-11 {\\n  width: 91.66666667%;\\n}\\n.col-xs-10 {\\n  width: 83.33333333%;\\n}\\n.col-xs-9 {\\n  width: 75%;\\n}\\n.col-xs-8 {\\n  width: 66.66666667%;\\n}\\n.col-xs-7 {\\n  width: 58.33333333%;\\n}\\n.col-xs-6 {\\n  width: 50%;\\n}\\n.col-xs-5 {\\n  width: 41.66666667%;\\n}\\n.col-xs-4 {\\n  width: 33.33333333%;\\n}\\n.col-xs-3 {\\n  width: 25%;\\n}\\n.col-xs-2 {\\n  width: 16.66666667%;\\n}\\n.col-xs-1 {\\n  width: 8.33333333%;\\n}\\n.col-xs-pull-12 {\\n  right: 100%;\\n}\\n.col-xs-pull-11 {\\n  right: 91.66666667%;\\n}\\n.col-xs-pull-10 {\\n  right: 83.33333333%;\\n}\\n.col-xs-pull-9 {\\n  right: 75%;\\n}\\n.col-xs-pull-8 {\\n  right: 66.66666667%;\\n}\\n.col-xs-pull-7 {\\n  right: 58.33333333%;\\n}\\n.col-xs-pull-6 {\\n  right: 50%;\\n}\\n.col-xs-pull-5 {\\n  right: 41.66666667%;\\n}\\n.col-xs-pull-4 {\\n  right: 33.33333333%;\\n}\\n.col-xs-pull-3 {\\n  right: 25%;\\n}\\n.col-xs-pull-2 {\\n  right: 16.66666667%;\\n}\\n.col-xs-pull-1 {\\n  right: 8.33333333%;\\n}\\n.col-xs-pull-0 {\\n  right: auto;\\n}\\n.col-xs-push-12 {\\n  left: 100%;\\n}\\n.col-xs-push-11 {\\n  left: 91.66666667%;\\n}\\n.col-xs-push-10 {\\n  left: 83.33333333%;\\n}\\n.col-xs-push-9 {\\n  left: 75%;\\n}\\n.col-xs-push-8 {\\n  left: 66.66666667%;\\n}\\n.col-xs-push-7 {\\n  left: 58.33333333%;\\n}\\n.col-xs-push-6 {\\n  left: 50%;\\n}\\n.col-xs-push-5 {\\n  left: 41.66666667%;\\n}\\n.col-xs-push-4 {\\n  left: 33.33333333%;\\n}\\n.col-xs-push-3 {\\n  left: 25%;\\n}\\n.col-xs-push-2 {\\n  left: 16.66666667%;\\n}\\n.col-xs-push-1 {\\n  left: 8.33333333%;\\n}\\n.col-xs-push-0 {\\n  left: auto;\\n}\\n.col-xs-offset-12 {\\n  margin-left: 100%;\\n}\\n.col-xs-offset-11 {\\n  margin-left: 91.66666667%;\\n}\\n.col-xs-offset-10 {\\n  margin-left: 83.33333333%;\\n}\\n.col-xs-offset-9 {\\n  margin-left: 75%;\\n}\\n.col-xs-offset-8 {\\n  margin-left: 66.66666667%;\\n}\\n.col-xs-offset-7 {\\n  margin-left: 58.33333333%;\\n}\\n.col-xs-offset-6 {\\n  margin-left: 50%;\\n}\\n.col-xs-offset-5 {\\n  margin-left: 41.66666667%;\\n}\\n.col-xs-offset-4 {\\n  margin-left: 33.33333333%;\\n}\\n.col-xs-offset-3 {\\n  margin-left: 25%;\\n}\\n.col-xs-offset-2 {\\n  margin-left: 16.66666667%;\\n}\\n.col-xs-offset-1 {\\n  margin-left: 8.33333333%;\\n}\\n.col-xs-offset-0 {\\n  margin-left: 0;\\n}\\n@media (min-width: 768px) {\\n  .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12 {\\n    float: left;\\n  }\\n  .col-sm-12 {\\n    width: 100%;\\n  }\\n  .col-sm-11 {\\n    width: 91.66666667%;\\n  }\\n  .col-sm-10 {\\n    width: 83.33333333%;\\n  }\\n  .col-sm-9 {\\n    width: 75%;\\n  }\\n  .col-sm-8 {\\n    width: 66.66666667%;\\n  }\\n  .col-sm-7 {\\n    width: 58.33333333%;\\n  }\\n  .col-sm-6 {\\n    width: 50%;\\n  }\\n  .col-sm-5 {\\n    width: 41.66666667%;\\n  }\\n  .col-sm-4 {\\n    width: 33.33333333%;\\n  }\\n  .col-sm-3 {\\n    width: 25%;\\n  }\\n  .col-sm-2 {\\n    width: 16.66666667%;\\n  }\\n  .col-sm-1 {\\n    width: 8.33333333%;\\n  }\\n  .col-sm-pull-12 {\\n    right: 100%;\\n  }\\n  .col-sm-pull-11 {\\n    right: 91.66666667%;\\n  }\\n  .col-sm-pull-10 {\\n    right: 83.33333333%;\\n  }\\n  .col-sm-pull-9 {\\n    right: 75%;\\n  }\\n  .col-sm-pull-8 {\\n    right: 66.66666667%;\\n  }\\n  .col-sm-pull-7 {\\n    right: 58.33333333%;\\n  }\\n  .col-sm-pull-6 {\\n    right: 50%;\\n  }\\n  .col-sm-pull-5 {\\n    right: 41.66666667%;\\n  }\\n  .col-sm-pull-4 {\\n    right: 33.33333333%;\\n  }\\n  .col-sm-pull-3 {\\n    right: 25%;\\n  }\\n  .col-sm-pull-2 {\\n    right: 16.66666667%;\\n  }\\n  .col-sm-pull-1 {\\n    right: 8.33333333%;\\n  }\\n  .col-sm-pull-0 {\\n    right: auto;\\n  }\\n  .col-sm-push-12 {\\n    left: 100%;\\n  }\\n  .col-sm-push-11 {\\n    left: 91.66666667%;\\n  }\\n  .col-sm-push-10 {\\n    left: 83.33333333%;\\n  }\\n  .col-sm-push-9 {\\n    left: 75%;\\n  }\\n  .col-sm-push-8 {\\n    left: 66.66666667%;\\n  }\\n  .col-sm-push-7 {\\n    left: 58.33333333%;\\n  }\\n  .col-sm-push-6 {\\n    left: 50%;\\n  }\\n  .col-sm-push-5 {\\n    left: 41.66666667%;\\n  }\\n  .col-sm-push-4 {\\n    left: 33.33333333%;\\n  }\\n  .col-sm-push-3 {\\n    left: 25%;\\n  }\\n  .col-sm-push-2 {\\n    left: 16.66666667%;\\n  }\\n  .col-sm-push-1 {\\n    left: 8.33333333%;\\n  }\\n  .col-sm-push-0 {\\n    left: auto;\\n  }\\n  .col-sm-offset-12 {\\n    margin-left: 100%;\\n  }\\n  .col-sm-offset-11 {\\n    margin-left: 91.66666667%;\\n  }\\n  .col-sm-offset-10 {\\n    margin-left: 83.33333333%;\\n  }\\n  .col-sm-offset-9 {\\n    margin-left: 75%;\\n  }\\n  .col-sm-offset-8 {\\n    margin-left: 66.66666667%;\\n  }\\n  .col-sm-offset-7 {\\n    margin-left: 58.33333333%;\\n  }\\n  .col-sm-offset-6 {\\n    margin-left: 50%;\\n  }\\n  .col-sm-offset-5 {\\n    margin-left: 41.66666667%;\\n  }\\n  .col-sm-offset-4 {\\n    margin-left: 33.33333333%;\\n  }\\n  .col-sm-offset-3 {\\n    margin-left: 25%;\\n  }\\n  .col-sm-offset-2 {\\n    margin-left: 16.66666667%;\\n  }\\n  .col-sm-offset-1 {\\n    margin-left: 8.33333333%;\\n  }\\n  .col-sm-offset-0 {\\n    margin-left: 0;\\n  }\\n}\\n@media (min-width: 992px) {\\n  .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12 {\\n    float: left;\\n  }\\n  .col-md-12 {\\n    width: 100%;\\n  }\\n  .col-md-11 {\\n    width: 91.66666667%;\\n  }\\n  .col-md-10 {\\n    width: 83.33333333%;\\n  }\\n  .col-md-9 {\\n    width: 75%;\\n  }\\n  .col-md-8 {\\n    width: 66.66666667%;\\n  }\\n  .col-md-7 {\\n    width: 58.33333333%;\\n  }\\n  .col-md-6 {\\n    width: 50%;\\n  }\\n  .col-md-5 {\\n    width: 41.66666667%;\\n  }\\n  .col-md-4 {\\n    width: 33.33333333%;\\n  }\\n  .col-md-3 {\\n    width: 25%;\\n  }\\n  .col-md-2 {\\n    width: 16.66666667%;\\n  }\\n  .col-md-1 {\\n    width: 8.33333333%;\\n  }\\n  .col-md-pull-12 {\\n    right: 100%;\\n  }\\n  .col-md-pull-11 {\\n    right: 91.66666667%;\\n  }\\n  .col-md-pull-10 {\\n    right: 83.33333333%;\\n  }\\n  .col-md-pull-9 {\\n    right: 75%;\\n  }\\n  .col-md-pull-8 {\\n    right: 66.66666667%;\\n  }\\n  .col-md-pull-7 {\\n    right: 58.33333333%;\\n  }\\n  .col-md-pull-6 {\\n    right: 50%;\\n  }\\n  .col-md-pull-5 {\\n    right: 41.66666667%;\\n  }\\n  .col-md-pull-4 {\\n    right: 33.33333333%;\\n  }\\n  .col-md-pull-3 {\\n    right: 25%;\\n  }\\n  .col-md-pull-2 {\\n    right: 16.66666667%;\\n  }\\n  .col-md-pull-1 {\\n    right: 8.33333333%;\\n  }\\n  .col-md-pull-0 {\\n    right: auto;\\n  }\\n  .col-md-push-12 {\\n    left: 100%;\\n  }\\n  .col-md-push-11 {\\n    left: 91.66666667%;\\n  }\\n  .col-md-push-10 {\\n    left: 83.33333333%;\\n  }\\n  .col-md-push-9 {\\n    left: 75%;\\n  }\\n  .col-md-push-8 {\\n    left: 66.66666667%;\\n  }\\n  .col-md-push-7 {\\n    left: 58.33333333%;\\n  }\\n  .col-md-push-6 {\\n    left: 50%;\\n  }\\n  .col-md-push-5 {\\n    left: 41.66666667%;\\n  }\\n  .col-md-push-4 {\\n    left: 33.33333333%;\\n  }\\n  .col-md-push-3 {\\n    left: 25%;\\n  }\\n  .col-md-push-2 {\\n    left: 16.66666667%;\\n  }\\n  .col-md-push-1 {\\n    left: 8.33333333%;\\n  }\\n  .col-md-push-0 {\\n    left: auto;\\n  }\\n  .col-md-offset-12 {\\n    margin-left: 100%;\\n  }\\n  .col-md-offset-11 {\\n    margin-left: 91.66666667%;\\n  }\\n  .col-md-offset-10 {\\n    margin-left: 83.33333333%;\\n  }\\n  .col-md-offset-9 {\\n    margin-left: 75%;\\n  }\\n  .col-md-offset-8 {\\n    margin-left: 66.66666667%;\\n  }\\n  .col-md-offset-7 {\\n    margin-left: 58.33333333%;\\n  }\\n  .col-md-offset-6 {\\n    margin-left: 50%;\\n  }\\n  .col-md-offset-5 {\\n    margin-left: 41.66666667%;\\n  }\\n  .col-md-offset-4 {\\n    margin-left: 33.33333333%;\\n  }\\n  .col-md-offset-3 {\\n    margin-left: 25%;\\n  }\\n  .col-md-offset-2 {\\n    margin-left: 16.66666667%;\\n  }\\n  .col-md-offset-1 {\\n    margin-left: 8.33333333%;\\n  }\\n  .col-md-offset-0 {\\n    margin-left: 0;\\n  }\\n}\\n@media (min-width: 1200px) {\\n  .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12 {\\n    float: left;\\n  }\\n  .col-lg-12 {\\n    width: 100%;\\n  }\\n  .col-lg-11 {\\n    width: 91.66666667%;\\n  }\\n  .col-lg-10 {\\n    width: 83.33333333%;\\n  }\\n  .col-lg-9 {\\n    width: 75%;\\n  }\\n  .col-lg-8 {\\n    width: 66.66666667%;\\n  }\\n  .col-lg-7 {\\n    width: 58.33333333%;\\n  }\\n  .col-lg-6 {\\n    width: 50%;\\n  }\\n  .col-lg-5 {\\n    width: 41.66666667%;\\n  }\\n  .col-lg-4 {\\n    width: 33.33333333%;\\n  }\\n  .col-lg-3 {\\n    width: 25%;\\n  }\\n  .col-lg-2 {\\n    width: 16.66666667%;\\n  }\\n  .col-lg-1 {\\n    width: 8.33333333%;\\n  }\\n  .col-lg-pull-12 {\\n    right: 100%;\\n  }\\n  .col-lg-pull-11 {\\n    right: 91.66666667%;\\n  }\\n  .col-lg-pull-10 {\\n    right: 83.33333333%;\\n  }\\n  .col-lg-pull-9 {\\n    right: 75%;\\n  }\\n  .col-lg-pull-8 {\\n    right: 66.66666667%;\\n  }\\n  .col-lg-pull-7 {\\n    right: 58.33333333%;\\n  }\\n  .col-lg-pull-6 {\\n    right: 50%;\\n  }\\n  .col-lg-pull-5 {\\n    right: 41.66666667%;\\n  }\\n  .col-lg-pull-4 {\\n    right: 33.33333333%;\\n  }\\n  .col-lg-pull-3 {\\n    right: 25%;\\n  }\\n  .col-lg-pull-2 {\\n    right: 16.66666667%;\\n  }\\n  .col-lg-pull-1 {\\n    right: 8.33333333%;\\n  }\\n  .col-lg-pull-0 {\\n    right: auto;\\n  }\\n  .col-lg-push-12 {\\n    left: 100%;\\n  }\\n  .col-lg-push-11 {\\n    left: 91.66666667%;\\n  }\\n  .col-lg-push-10 {\\n    left: 83.33333333%;\\n  }\\n  .col-lg-push-9 {\\n    left: 75%;\\n  }\\n  .col-lg-push-8 {\\n    left: 66.66666667%;\\n  }\\n  .col-lg-push-7 {\\n    left: 58.33333333%;\\n  }\\n  .col-lg-push-6 {\\n    left: 50%;\\n  }\\n  .col-lg-push-5 {\\n    left: 41.66666667%;\\n  }\\n  .col-lg-push-4 {\\n    left: 33.33333333%;\\n  }\\n  .col-lg-push-3 {\\n    left: 25%;\\n  }\\n  .col-lg-push-2 {\\n    left: 16.66666667%;\\n  }\\n  .col-lg-push-1 {\\n    left: 8.33333333%;\\n  }\\n  .col-lg-push-0 {\\n    left: auto;\\n  }\\n  .col-lg-offset-12 {\\n    margin-left: 100%;\\n  }\\n  .col-lg-offset-11 {\\n    margin-left: 91.66666667%;\\n  }\\n  .col-lg-offset-10 {\\n    margin-left: 83.33333333%;\\n  }\\n  .col-lg-offset-9 {\\n    margin-left: 75%;\\n  }\\n  .col-lg-offset-8 {\\n    margin-left: 66.66666667%;\\n  }\\n  .col-lg-offset-7 {\\n    margin-left: 58.33333333%;\\n  }\\n  .col-lg-offset-6 {\\n    margin-left: 50%;\\n  }\\n  .col-lg-offset-5 {\\n    margin-left: 41.66666667%;\\n  }\\n  .col-lg-offset-4 {\\n    margin-left: 33.33333333%;\\n  }\\n  .col-lg-offset-3 {\\n    margin-left: 25%;\\n  }\\n  .col-lg-offset-2 {\\n    margin-left: 16.66666667%;\\n  }\\n  .col-lg-offset-1 {\\n    margin-left: 8.33333333%;\\n  }\\n  .col-lg-offset-0 {\\n    margin-left: 0;\\n  }\\n}\\ntable {\\n  background-color: transparent;\\n}\\ncaption {\\n  padding-top: 8px;\\n  padding-bottom: 8px;\\n  color: #777;\\n  text-align: left;\\n}\\nth {\\n  text-align: left;\\n}\\n.table {\\n  width: 100%;\\n  max-width: 100%;\\n  margin-bottom: 20px;\\n}\\n.table > thead > tr > th,\\n.table > tbody > tr > th,\\n.table > tfoot > tr > th,\\n.table > thead > tr > td,\\n.table > tbody > tr > td,\\n.table > tfoot > tr > td {\\n  padding: 8px;\\n  line-height: 1.42857143;\\n  vertical-align: top;\\n  border-top: 1px solid #ddd;\\n}\\n.table > thead > tr > th {\\n  vertical-align: bottom;\\n  border-bottom: 2px solid #ddd;\\n}\\n.table > caption + thead > tr:first-child > th,\\n.table > colgroup + thead > tr:first-child > th,\\n.table > thead:first-child > tr:first-child > th,\\n.table > caption + thead > tr:first-child > td,\\n.table > colgroup + thead > tr:first-child > td,\\n.table > thead:first-child > tr:first-child > td {\\n  border-top: 0;\\n}\\n.table > tbody + tbody {\\n  border-top: 2px solid #ddd;\\n}\\n.table .table {\\n  background-color: #fff;\\n}\\n.table-condensed > thead > tr > th,\\n.table-condensed > tbody > tr > th,\\n.table-condensed > tfoot > tr > th,\\n.table-condensed > thead > tr > td,\\n.table-condensed > tbody > tr > td,\\n.table-condensed > tfoot > tr > td {\\n  padding: 5px;\\n}\\n.table-bordered {\\n  border: 1px solid #ddd;\\n}\\n.table-bordered > thead > tr > th,\\n.table-bordered > tbody > tr > th,\\n.table-bordered > tfoot > tr > th,\\n.table-bordered > thead > tr > td,\\n.table-bordered > tbody > tr > td,\\n.table-bordered > tfoot > tr > td {\\n  border: 1px solid #ddd;\\n}\\n.table-bordered > thead > tr > th,\\n.table-bordered > thead > tr > td {\\n  border-bottom-width: 2px;\\n}\\n.table-striped > tbody > tr:nth-of-type(odd) {\\n  background-color: #f9f9f9;\\n}\\n.table-hover > tbody > tr:hover {\\n  background-color: #f5f5f5;\\n}\\ntable col[class*=\\\"col-\\\"] {\\n  position: static;\\n  display: table-column;\\n  float: none;\\n}\\ntable td[class*=\\\"col-\\\"],\\ntable th[class*=\\\"col-\\\"] {\\n  position: static;\\n  display: table-cell;\\n  float: none;\\n}\\n.table > thead > tr > td.active,\\n.table > tbody > tr > td.active,\\n.table > tfoot > tr > td.active,\\n.table > thead > tr > th.active,\\n.table > tbody > tr > th.active,\\n.table > tfoot > tr > th.active,\\n.table > thead > tr.active > td,\\n.table > tbody > tr.active > td,\\n.table > tfoot > tr.active > td,\\n.table > thead > tr.active > th,\\n.table > tbody > tr.active > th,\\n.table > tfoot > tr.active > th {\\n  background-color: #f5f5f5;\\n}\\n.table-hover > tbody > tr > td.active:hover,\\n.table-hover > tbody > tr > th.active:hover,\\n.table-hover > tbody > tr.active:hover > td,\\n.table-hover > tbody > tr:hover > .active,\\n.table-hover > tbody > tr.active:hover > th {\\n  background-color: #e8e8e8;\\n}\\n.table > thead > tr > td.success,\\n.table > tbody > tr > td.success,\\n.table > tfoot > tr > td.success,\\n.table > thead > tr > th.success,\\n.table > tbody > tr > th.success,\\n.table > tfoot > tr > th.success,\\n.table > thead > tr.success > td,\\n.table > tbody > tr.success > td,\\n.table > tfoot > tr.success > td,\\n.table > thead > tr.success > th,\\n.table > tbody > tr.success > th,\\n.table > tfoot > tr.success > th {\\n  background-color: #dff0d8;\\n}\\n.table-hover > tbody > tr > td.success:hover,\\n.table-hover > tbody > tr > th.success:hover,\\n.table-hover > tbody > tr.success:hover > td,\\n.table-hover > tbody > tr:hover > .success,\\n.table-hover > tbody > tr.success:hover > th {\\n  background-color: #d0e9c6;\\n}\\n.table > thead > tr > td.info,\\n.table > tbody > tr > td.info,\\n.table > tfoot > tr > td.info,\\n.table > thead > tr > th.info,\\n.table > tbody > tr > th.info,\\n.table > tfoot > tr > th.info,\\n.table > thead > tr.info > td,\\n.table > tbody > tr.info > td,\\n.table > tfoot > tr.info > td,\\n.table > thead > tr.info > th,\\n.table > tbody > tr.info > th,\\n.table > tfoot > tr.info > th {\\n  background-color: #d9edf7;\\n}\\n.table-hover > tbody > tr > td.info:hover,\\n.table-hover > tbody > tr > th.info:hover,\\n.table-hover > tbody > tr.info:hover > td,\\n.table-hover > tbody > tr:hover > .info,\\n.table-hover > tbody > tr.info:hover > th {\\n  background-color: #c4e3f3;\\n}\\n.table > thead > tr > td.warning,\\n.table > tbody > tr > td.warning,\\n.table > tfoot > tr > td.warning,\\n.table > thead > tr > th.warning,\\n.table > tbody > tr > th.warning,\\n.table > tfoot > tr > th.warning,\\n.table > thead > tr.warning > td,\\n.table > tbody > tr.warning > td,\\n.table > tfoot > tr.warning > td,\\n.table > thead > tr.warning > th,\\n.table > tbody > tr.warning > th,\\n.table > tfoot > tr.warning > th {\\n  background-color: #fcf8e3;\\n}\\n.table-hover > tbody > tr > td.warning:hover,\\n.table-hover > tbody > tr > th.warning:hover,\\n.table-hover > tbody > tr.warning:hover > td,\\n.table-hover > tbody > tr:hover > .warning,\\n.table-hover > tbody > tr.warning:hover > th {\\n  background-color: #faf2cc;\\n}\\n.table > thead > tr > td.danger,\\n.table > tbody > tr > td.danger,\\n.table > tfoot > tr > td.danger,\\n.table > thead > tr > th.danger,\\n.table > tbody > tr > th.danger,\\n.table > tfoot > tr > th.danger,\\n.table > thead > tr.danger > td,\\n.table > tbody > tr.danger > td,\\n.table > tfoot > tr.danger > td,\\n.table > thead > tr.danger > th,\\n.table > tbody > tr.danger > th,\\n.table > tfoot > tr.danger > th {\\n  background-color: #f2dede;\\n}\\n.table-hover > tbody > tr > td.danger:hover,\\n.table-hover > tbody > tr > th.danger:hover,\\n.table-hover > tbody > tr.danger:hover > td,\\n.table-hover > tbody > tr:hover > .danger,\\n.table-hover > tbody > tr.danger:hover > th {\\n  background-color: #ebcccc;\\n}\\n.table-responsive {\\n  min-height: .01%;\\n  overflow-x: auto;\\n}\\n@media screen and (max-width: 767px) {\\n  .table-responsive {\\n    width: 100%;\\n    margin-bottom: 15px;\\n    overflow-y: hidden;\\n    -ms-overflow-style: -ms-autohiding-scrollbar;\\n    border: 1px solid #ddd;\\n  }\\n  .table-responsive > .table {\\n    margin-bottom: 0;\\n  }\\n  .table-responsive > .table > thead > tr > th,\\n  .table-responsive > .table > tbody > tr > th,\\n  .table-responsive > .table > tfoot > tr > th,\\n  .table-responsive > .table > thead > tr > td,\\n  .table-responsive > .table > tbody > tr > td,\\n  .table-responsive > .table > tfoot > tr > td {\\n    white-space: nowrap;\\n  }\\n  .table-responsive > .table-bordered {\\n    border: 0;\\n  }\\n  .table-responsive > .table-bordered > thead > tr > th:first-child,\\n  .table-responsive > .table-bordered > tbody > tr > th:first-child,\\n  .table-responsive > .table-bordered > tfoot > tr > th:first-child,\\n  .table-responsive > .table-bordered > thead > tr > td:first-child,\\n  .table-responsive > .table-bordered > tbody > tr > td:first-child,\\n  .table-responsive > .table-bordered > tfoot > tr > td:first-child {\\n    border-left: 0;\\n  }\\n  .table-responsive > .table-bordered > thead > tr > th:last-child,\\n  .table-responsive > .table-bordered > tbody > tr > th:last-child,\\n  .table-responsive > .table-bordered > tfoot > tr > th:last-child,\\n  .table-responsive > .table-bordered > thead > tr > td:last-child,\\n  .table-responsive > .table-bordered > tbody > tr > td:last-child,\\n  .table-responsive > .table-bordered > tfoot > tr > td:last-child {\\n    border-right: 0;\\n  }\\n  .table-responsive > .table-bordered > tbody > tr:last-child > th,\\n  .table-responsive > .table-bordered > tfoot > tr:last-child > th,\\n  .table-responsive > .table-bordered > tbody > tr:last-child > td,\\n  .table-responsive > .table-bordered > tfoot > tr:last-child > td {\\n    border-bottom: 0;\\n  }\\n}\\nfieldset {\\n  min-width: 0;\\n  padding: 0;\\n  margin: 0;\\n  border: 0;\\n}\\nlegend {\\n  display: block;\\n  width: 100%;\\n  padding: 0;\\n  margin-bottom: 20px;\\n  font-size: 21px;\\n  line-height: inherit;\\n  color: #333;\\n  border: 0;\\n  border-bottom: 1px solid #e5e5e5;\\n}\\nlabel {\\n  display: inline-block;\\n  max-width: 100%;\\n  margin-bottom: 5px;\\n  font-weight: bold;\\n}\\ninput[type=\\\"search\\\"] {\\n  -webkit-box-sizing: border-box;\\n     -moz-box-sizing: border-box;\\n          box-sizing: border-box;\\n}\\ninput[type=\\\"radio\\\"],\\ninput[type=\\\"checkbox\\\"] {\\n  margin: 4px 0 0;\\n  margin-top: 1px \\\\9;\\n  line-height: normal;\\n}\\ninput[type=\\\"file\\\"] {\\n  display: block;\\n}\\ninput[type=\\\"range\\\"] {\\n  display: block;\\n  width: 100%;\\n}\\nselect[multiple],\\nselect[size] {\\n  height: auto;\\n}\\ninput[type=\\\"file\\\"]:focus,\\ninput[type=\\\"radio\\\"]:focus,\\ninput[type=\\\"checkbox\\\"]:focus {\\n  outline: thin dotted;\\n  outline: 5px auto -webkit-focus-ring-color;\\n  outline-offset: -2px;\\n}\\noutput {\\n  display: block;\\n  padding-top: 7px;\\n  font-size: 14px;\\n  line-height: 1.42857143;\\n  color: #555;\\n}\\n.form-control {\\n  display: block;\\n  width: 100%;\\n  height: 34px;\\n  padding: 6px 12px;\\n  font-size: 14px;\\n  line-height: 1.42857143;\\n  color: #555;\\n  background-color: #fff;\\n  background-image: none;\\n  border: 1px solid #ccc;\\n  border-radius: 4px;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075);\\n          box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075);\\n  -webkit-transition: border-color ease-in-out .15s, -webkit-box-shadow ease-in-out .15s;\\n       -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;\\n          transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;\\n}\\n.form-control:focus {\\n  border-color: #66afe9;\\n  outline: 0;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\\n          box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\\n}\\n.form-control::-moz-placeholder {\\n  color: #999;\\n  opacity: 1;\\n}\\n.form-control:-ms-input-placeholder {\\n  color: #999;\\n}\\n.form-control::-webkit-input-placeholder {\\n  color: #999;\\n}\\n.form-control::-ms-expand {\\n  background-color: transparent;\\n  border: 0;\\n}\\n.form-control[disabled],\\n.form-control[readonly],\\nfieldset[disabled] .form-control {\\n  background-color: #eee;\\n  opacity: 1;\\n}\\n.form-control[disabled],\\nfieldset[disabled] .form-control {\\n  cursor: not-allowed;\\n}\\ntextarea.form-control {\\n  height: auto;\\n}\\ninput[type=\\\"search\\\"] {\\n  -webkit-appearance: none;\\n}\\n@media screen and (-webkit-min-device-pixel-ratio: 0) {\\n  input[type=\\\"date\\\"].form-control,\\n  input[type=\\\"time\\\"].form-control,\\n  input[type=\\\"datetime-local\\\"].form-control,\\n  input[type=\\\"month\\\"].form-control {\\n    line-height: 34px;\\n  }\\n  input[type=\\\"date\\\"].input-sm,\\n  input[type=\\\"time\\\"].input-sm,\\n  input[type=\\\"datetime-local\\\"].input-sm,\\n  input[type=\\\"month\\\"].input-sm,\\n  .input-group-sm input[type=\\\"date\\\"],\\n  .input-group-sm input[type=\\\"time\\\"],\\n  .input-group-sm input[type=\\\"datetime-local\\\"],\\n  .input-group-sm input[type=\\\"month\\\"] {\\n    line-height: 30px;\\n  }\\n  input[type=\\\"date\\\"].input-lg,\\n  input[type=\\\"time\\\"].input-lg,\\n  input[type=\\\"datetime-local\\\"].input-lg,\\n  input[type=\\\"month\\\"].input-lg,\\n  .input-group-lg input[type=\\\"date\\\"],\\n  .input-group-lg input[type=\\\"time\\\"],\\n  .input-group-lg input[type=\\\"datetime-local\\\"],\\n  .input-group-lg input[type=\\\"month\\\"] {\\n    line-height: 46px;\\n  }\\n}\\n.form-group {\\n  margin-bottom: 15px;\\n}\\n.radio,\\n.checkbox {\\n  position: relative;\\n  display: block;\\n  margin-top: 10px;\\n  margin-bottom: 10px;\\n}\\n.radio label,\\n.checkbox label {\\n  min-height: 20px;\\n  padding-left: 20px;\\n  margin-bottom: 0;\\n  font-weight: normal;\\n  cursor: pointer;\\n}\\n.radio input[type=\\\"radio\\\"],\\n.radio-inline input[type=\\\"radio\\\"],\\n.checkbox input[type=\\\"checkbox\\\"],\\n.checkbox-inline input[type=\\\"checkbox\\\"] {\\n  position: absolute;\\n  margin-top: 4px \\\\9;\\n  margin-left: -20px;\\n}\\n.radio + .radio,\\n.checkbox + .checkbox {\\n  margin-top: -5px;\\n}\\n.radio-inline,\\n.checkbox-inline {\\n  position: relative;\\n  display: inline-block;\\n  padding-left: 20px;\\n  margin-bottom: 0;\\n  font-weight: normal;\\n  vertical-align: middle;\\n  cursor: pointer;\\n}\\n.radio-inline + .radio-inline,\\n.checkbox-inline + .checkbox-inline {\\n  margin-top: 0;\\n  margin-left: 10px;\\n}\\ninput[type=\\\"radio\\\"][disabled],\\ninput[type=\\\"checkbox\\\"][disabled],\\ninput[type=\\\"radio\\\"].disabled,\\ninput[type=\\\"checkbox\\\"].disabled,\\nfieldset[disabled] input[type=\\\"radio\\\"],\\nfieldset[disabled] input[type=\\\"checkbox\\\"] {\\n  cursor: not-allowed;\\n}\\n.radio-inline.disabled,\\n.checkbox-inline.disabled,\\nfieldset[disabled] .radio-inline,\\nfieldset[disabled] .checkbox-inline {\\n  cursor: not-allowed;\\n}\\n.radio.disabled label,\\n.checkbox.disabled label,\\nfieldset[disabled] .radio label,\\nfieldset[disabled] .checkbox label {\\n  cursor: not-allowed;\\n}\\n.form-control-static {\\n  min-height: 34px;\\n  padding-top: 7px;\\n  padding-bottom: 7px;\\n  margin-bottom: 0;\\n}\\n.form-control-static.input-lg,\\n.form-control-static.input-sm {\\n  padding-right: 0;\\n  padding-left: 0;\\n}\\n.input-sm {\\n  height: 30px;\\n  padding: 5px 10px;\\n  font-size: 12px;\\n  line-height: 1.5;\\n  border-radius: 3px;\\n}\\nselect.input-sm {\\n  height: 30px;\\n  line-height: 30px;\\n}\\ntextarea.input-sm,\\nselect[multiple].input-sm {\\n  height: auto;\\n}\\n.form-group-sm .form-control {\\n  height: 30px;\\n  padding: 5px 10px;\\n  font-size: 12px;\\n  line-height: 1.5;\\n  border-radius: 3px;\\n}\\n.form-group-sm select.form-control {\\n  height: 30px;\\n  line-height: 30px;\\n}\\n.form-group-sm textarea.form-control,\\n.form-group-sm select[multiple].form-control {\\n  height: auto;\\n}\\n.form-group-sm .form-control-static {\\n  height: 30px;\\n  min-height: 32px;\\n  padding: 6px 10px;\\n  font-size: 12px;\\n  line-height: 1.5;\\n}\\n.input-lg {\\n  height: 46px;\\n  padding: 10px 16px;\\n  font-size: 18px;\\n  line-height: 1.3333333;\\n  border-radius: 6px;\\n}\\nselect.input-lg {\\n  height: 46px;\\n  line-height: 46px;\\n}\\ntextarea.input-lg,\\nselect[multiple].input-lg {\\n  height: auto;\\n}\\n.form-group-lg .form-control {\\n  height: 46px;\\n  padding: 10px 16px;\\n  font-size: 18px;\\n  line-height: 1.3333333;\\n  border-radius: 6px;\\n}\\n.form-group-lg select.form-control {\\n  height: 46px;\\n  line-height: 46px;\\n}\\n.form-group-lg textarea.form-control,\\n.form-group-lg select[multiple].form-control {\\n  height: auto;\\n}\\n.form-group-lg .form-control-static {\\n  height: 46px;\\n  min-height: 38px;\\n  padding: 11px 16px;\\n  font-size: 18px;\\n  line-height: 1.3333333;\\n}\\n.has-feedback {\\n  position: relative;\\n}\\n.has-feedback .form-control {\\n  padding-right: 42.5px;\\n}\\n.form-control-feedback {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  z-index: 2;\\n  display: block;\\n  width: 34px;\\n  height: 34px;\\n  line-height: 34px;\\n  text-align: center;\\n  pointer-events: none;\\n}\\n.input-lg + .form-control-feedback,\\n.input-group-lg + .form-control-feedback,\\n.form-group-lg .form-control + .form-control-feedback {\\n  width: 46px;\\n  height: 46px;\\n  line-height: 46px;\\n}\\n.input-sm + .form-control-feedback,\\n.input-group-sm + .form-control-feedback,\\n.form-group-sm .form-control + .form-control-feedback {\\n  width: 30px;\\n  height: 30px;\\n  line-height: 30px;\\n}\\n.has-success .help-block,\\n.has-success .control-label,\\n.has-success .radio,\\n.has-success .checkbox,\\n.has-success .radio-inline,\\n.has-success .checkbox-inline,\\n.has-success.radio label,\\n.has-success.checkbox label,\\n.has-success.radio-inline label,\\n.has-success.checkbox-inline label {\\n  color: #3c763d;\\n}\\n.has-success .form-control {\\n  border-color: #3c763d;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075);\\n          box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075);\\n}\\n.has-success .form-control:focus {\\n  border-color: #2b542c;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #67b168;\\n          box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #67b168;\\n}\\n.has-success .input-group-addon {\\n  color: #3c763d;\\n  background-color: #dff0d8;\\n  border-color: #3c763d;\\n}\\n.has-success .form-control-feedback {\\n  color: #3c763d;\\n}\\n.has-warning .help-block,\\n.has-warning .control-label,\\n.has-warning .radio,\\n.has-warning .checkbox,\\n.has-warning .radio-inline,\\n.has-warning .checkbox-inline,\\n.has-warning.radio label,\\n.has-warning.checkbox label,\\n.has-warning.radio-inline label,\\n.has-warning.checkbox-inline label {\\n  color: #8a6d3b;\\n}\\n.has-warning .form-control {\\n  border-color: #8a6d3b;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075);\\n          box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075);\\n}\\n.has-warning .form-control:focus {\\n  border-color: #66512c;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #c0a16b;\\n          box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #c0a16b;\\n}\\n.has-warning .input-group-addon {\\n  color: #8a6d3b;\\n  background-color: #fcf8e3;\\n  border-color: #8a6d3b;\\n}\\n.has-warning .form-control-feedback {\\n  color: #8a6d3b;\\n}\\n.has-error .help-block,\\n.has-error .control-label,\\n.has-error .radio,\\n.has-error .checkbox,\\n.has-error .radio-inline,\\n.has-error .checkbox-inline,\\n.has-error.radio label,\\n.has-error.checkbox label,\\n.has-error.radio-inline label,\\n.has-error.checkbox-inline label {\\n  color: #a94442;\\n}\\n.has-error .form-control {\\n  border-color: #a94442;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075);\\n          box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075);\\n}\\n.has-error .form-control:focus {\\n  border-color: #843534;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #ce8483;\\n          box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px #ce8483;\\n}\\n.has-error .input-group-addon {\\n  color: #a94442;\\n  background-color: #f2dede;\\n  border-color: #a94442;\\n}\\n.has-error .form-control-feedback {\\n  color: #a94442;\\n}\\n.has-feedback label ~ .form-control-feedback {\\n  top: 25px;\\n}\\n.has-feedback label.sr-only ~ .form-control-feedback {\\n  top: 0;\\n}\\n.help-block {\\n  display: block;\\n  margin-top: 5px;\\n  margin-bottom: 10px;\\n  color: #737373;\\n}\\n@media (min-width: 768px) {\\n  .form-inline .form-group {\\n    display: inline-block;\\n    margin-bottom: 0;\\n    vertical-align: middle;\\n  }\\n  .form-inline .form-control {\\n    display: inline-block;\\n    width: auto;\\n    vertical-align: middle;\\n  }\\n  .form-inline .form-control-static {\\n    display: inline-block;\\n  }\\n  .form-inline .input-group {\\n    display: inline-table;\\n    vertical-align: middle;\\n  }\\n  .form-inline .input-group .input-group-addon,\\n  .form-inline .input-group .input-group-btn,\\n  .form-inline .input-group .form-control {\\n    width: auto;\\n  }\\n  .form-inline .input-group > .form-control {\\n    width: 100%;\\n  }\\n  .form-inline .control-label {\\n    margin-bottom: 0;\\n    vertical-align: middle;\\n  }\\n  .form-inline .radio,\\n  .form-inline .checkbox {\\n    display: inline-block;\\n    margin-top: 0;\\n    margin-bottom: 0;\\n    vertical-align: middle;\\n  }\\n  .form-inline .radio label,\\n  .form-inline .checkbox label {\\n    padding-left: 0;\\n  }\\n  .form-inline .radio input[type=\\\"radio\\\"],\\n  .form-inline .checkbox input[type=\\\"checkbox\\\"] {\\n    position: relative;\\n    margin-left: 0;\\n  }\\n  .form-inline .has-feedback .form-control-feedback {\\n    top: 0;\\n  }\\n}\\n.form-horizontal .radio,\\n.form-horizontal .checkbox,\\n.form-horizontal .radio-inline,\\n.form-horizontal .checkbox-inline {\\n  padding-top: 7px;\\n  margin-top: 0;\\n  margin-bottom: 0;\\n}\\n.form-horizontal .radio,\\n.form-horizontal .checkbox {\\n  min-height: 27px;\\n}\\n.form-horizontal .form-group {\\n  margin-right: -15px;\\n  margin-left: -15px;\\n}\\n@media (min-width: 768px) {\\n  .form-horizontal .control-label {\\n    padding-top: 7px;\\n    margin-bottom: 0;\\n    text-align: right;\\n  }\\n}\\n.form-horizontal .has-feedback .form-control-feedback {\\n  right: 15px;\\n}\\n@media (min-width: 768px) {\\n  .form-horizontal .form-group-lg .control-label {\\n    padding-top: 11px;\\n    font-size: 18px;\\n  }\\n}\\n@media (min-width: 768px) {\\n  .form-horizontal .form-group-sm .control-label {\\n    padding-top: 6px;\\n    font-size: 12px;\\n  }\\n}\\n.btn {\\n  display: inline-block;\\n  padding: 6px 12px;\\n  margin-bottom: 0;\\n  font-size: 14px;\\n  font-weight: normal;\\n  line-height: 1.42857143;\\n  text-align: center;\\n  white-space: nowrap;\\n  vertical-align: middle;\\n  -ms-touch-action: manipulation;\\n      touch-action: manipulation;\\n  cursor: pointer;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n      -ms-user-select: none;\\n          user-select: none;\\n  background-image: none;\\n  border: 1px solid transparent;\\n  border-radius: 4px;\\n}\\n.btn:focus,\\n.btn:active:focus,\\n.btn.active:focus,\\n.btn.focus,\\n.btn:active.focus,\\n.btn.active.focus {\\n  outline: thin dotted;\\n  outline: 5px auto -webkit-focus-ring-color;\\n  outline-offset: -2px;\\n}\\n.btn:hover,\\n.btn:focus,\\n.btn.focus {\\n  color: #333;\\n  text-decoration: none;\\n}\\n.btn:active,\\n.btn.active {\\n  background-image: none;\\n  outline: 0;\\n  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);\\n          box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);\\n}\\n.btn.disabled,\\n.btn[disabled],\\nfieldset[disabled] .btn {\\n  cursor: not-allowed;\\n  filter: alpha(opacity=65);\\n  -webkit-box-shadow: none;\\n          box-shadow: none;\\n  opacity: .65;\\n}\\na.btn.disabled,\\nfieldset[disabled] a.btn {\\n  pointer-events: none;\\n}\\n.btn-default {\\n  color: #333;\\n  background-color: #fff;\\n  border-color: #ccc;\\n}\\n.btn-default:focus,\\n.btn-default.focus {\\n  color: #333;\\n  background-color: #e6e6e6;\\n  border-color: #8c8c8c;\\n}\\n.btn-default:hover {\\n  color: #333;\\n  background-color: #e6e6e6;\\n  border-color: #adadad;\\n}\\n.btn-default:active,\\n.btn-default.active,\\n.open > .dropdown-toggle.btn-default {\\n  color: #333;\\n  background-color: #e6e6e6;\\n  border-color: #adadad;\\n}\\n.btn-default:active:hover,\\n.btn-default.active:hover,\\n.open > .dropdown-toggle.btn-default:hover,\\n.btn-default:active:focus,\\n.btn-default.active:focus,\\n.open > .dropdown-toggle.btn-default:focus,\\n.btn-default:active.focus,\\n.btn-default.active.focus,\\n.open > .dropdown-toggle.btn-default.focus {\\n  color: #333;\\n  background-color: #d4d4d4;\\n  border-color: #8c8c8c;\\n}\\n.btn-default:active,\\n.btn-default.active,\\n.open > .dropdown-toggle.btn-default {\\n  background-image: none;\\n}\\n.btn-default.disabled:hover,\\n.btn-default[disabled]:hover,\\nfieldset[disabled] .btn-default:hover,\\n.btn-default.disabled:focus,\\n.btn-default[disabled]:focus,\\nfieldset[disabled] .btn-default:focus,\\n.btn-default.disabled.focus,\\n.btn-default[disabled].focus,\\nfieldset[disabled] .btn-default.focus {\\n  background-color: #fff;\\n  border-color: #ccc;\\n}\\n.btn-default .badge {\\n  color: #fff;\\n  background-color: #333;\\n}\\n.btn-primary {\\n  color: #fff;\\n  background-color: #337ab7;\\n  border-color: #2e6da4;\\n}\\n.btn-primary:focus,\\n.btn-primary.focus {\\n  color: #fff;\\n  background-color: #286090;\\n  border-color: #122b40;\\n}\\n.btn-primary:hover {\\n  color: #fff;\\n  background-color: #286090;\\n  border-color: #204d74;\\n}\\n.btn-primary:active,\\n.btn-primary.active,\\n.open > .dropdown-toggle.btn-primary {\\n  color: #fff;\\n  background-color: #286090;\\n  border-color: #204d74;\\n}\\n.btn-primary:active:hover,\\n.btn-primary.active:hover,\\n.open > .dropdown-toggle.btn-primary:hover,\\n.btn-primary:active:focus,\\n.btn-primary.active:focus,\\n.open > .dropdown-toggle.btn-primary:focus,\\n.btn-primary:active.focus,\\n.btn-primary.active.focus,\\n.open > .dropdown-toggle.btn-primary.focus {\\n  color: #fff;\\n  background-color: #204d74;\\n  border-color: #122b40;\\n}\\n.btn-primary:active,\\n.btn-primary.active,\\n.open > .dropdown-toggle.btn-primary {\\n  background-image: none;\\n}\\n.btn-primary.disabled:hover,\\n.btn-primary[disabled]:hover,\\nfieldset[disabled] .btn-primary:hover,\\n.btn-primary.disabled:focus,\\n.btn-primary[disabled]:focus,\\nfieldset[disabled] .btn-primary:focus,\\n.btn-primary.disabled.focus,\\n.btn-primary[disabled].focus,\\nfieldset[disabled] .btn-primary.focus {\\n  background-color: #337ab7;\\n  border-color: #2e6da4;\\n}\\n.btn-primary .badge {\\n  color: #337ab7;\\n  background-color: #fff;\\n}\\n.btn-success {\\n  color: #fff;\\n  background-color: #5cb85c;\\n  border-color: #4cae4c;\\n}\\n.btn-success:focus,\\n.btn-success.focus {\\n  color: #fff;\\n  background-color: #449d44;\\n  border-color: #255625;\\n}\\n.btn-success:hover {\\n  color: #fff;\\n  background-color: #449d44;\\n  border-color: #398439;\\n}\\n.btn-success:active,\\n.btn-success.active,\\n.open > .dropdown-toggle.btn-success {\\n  color: #fff;\\n  background-color: #449d44;\\n  border-color: #398439;\\n}\\n.btn-success:active:hover,\\n.btn-success.active:hover,\\n.open > .dropdown-toggle.btn-success:hover,\\n.btn-success:active:focus,\\n.btn-success.active:focus,\\n.open > .dropdown-toggle.btn-success:focus,\\n.btn-success:active.focus,\\n.btn-success.active.focus,\\n.open > .dropdown-toggle.btn-success.focus {\\n  color: #fff;\\n  background-color: #398439;\\n  border-color: #255625;\\n}\\n.btn-success:active,\\n.btn-success.active,\\n.open > .dropdown-toggle.btn-success {\\n  background-image: none;\\n}\\n.btn-success.disabled:hover,\\n.btn-success[disabled]:hover,\\nfieldset[disabled] .btn-success:hover,\\n.btn-success.disabled:focus,\\n.btn-success[disabled]:focus,\\nfieldset[disabled] .btn-success:focus,\\n.btn-success.disabled.focus,\\n.btn-success[disabled].focus,\\nfieldset[disabled] .btn-success.focus {\\n  background-color: #5cb85c;\\n  border-color: #4cae4c;\\n}\\n.btn-success .badge {\\n  color: #5cb85c;\\n  background-color: #fff;\\n}\\n.btn-info {\\n  color: #fff;\\n  background-color: #5bc0de;\\n  border-color: #46b8da;\\n}\\n.btn-info:focus,\\n.btn-info.focus {\\n  color: #fff;\\n  background-color: #31b0d5;\\n  border-color: #1b6d85;\\n}\\n.btn-info:hover {\\n  color: #fff;\\n  background-color: #31b0d5;\\n  border-color: #269abc;\\n}\\n.btn-info:active,\\n.btn-info.active,\\n.open > .dropdown-toggle.btn-info {\\n  color: #fff;\\n  background-color: #31b0d5;\\n  border-color: #269abc;\\n}\\n.btn-info:active:hover,\\n.btn-info.active:hover,\\n.open > .dropdown-toggle.btn-info:hover,\\n.btn-info:active:focus,\\n.btn-info.active:focus,\\n.open > .dropdown-toggle.btn-info:focus,\\n.btn-info:active.focus,\\n.btn-info.active.focus,\\n.open > .dropdown-toggle.btn-info.focus {\\n  color: #fff;\\n  background-color: #269abc;\\n  border-color: #1b6d85;\\n}\\n.btn-info:active,\\n.btn-info.active,\\n.open > .dropdown-toggle.btn-info {\\n  background-image: none;\\n}\\n.btn-info.disabled:hover,\\n.btn-info[disabled]:hover,\\nfieldset[disabled] .btn-info:hover,\\n.btn-info.disabled:focus,\\n.btn-info[disabled]:focus,\\nfieldset[disabled] .btn-info:focus,\\n.btn-info.disabled.focus,\\n.btn-info[disabled].focus,\\nfieldset[disabled] .btn-info.focus {\\n  background-color: #5bc0de;\\n  border-color: #46b8da;\\n}\\n.btn-info .badge {\\n  color: #5bc0de;\\n  background-color: #fff;\\n}\\n.btn-warning {\\n  color: #fff;\\n  background-color: #f0ad4e;\\n  border-color: #eea236;\\n}\\n.btn-warning:focus,\\n.btn-warning.focus {\\n  color: #fff;\\n  background-color: #ec971f;\\n  border-color: #985f0d;\\n}\\n.btn-warning:hover {\\n  color: #fff;\\n  background-color: #ec971f;\\n  border-color: #d58512;\\n}\\n.btn-warning:active,\\n.btn-warning.active,\\n.open > .dropdown-toggle.btn-warning {\\n  color: #fff;\\n  background-color: #ec971f;\\n  border-color: #d58512;\\n}\\n.btn-warning:active:hover,\\n.btn-warning.active:hover,\\n.open > .dropdown-toggle.btn-warning:hover,\\n.btn-warning:active:focus,\\n.btn-warning.active:focus,\\n.open > .dropdown-toggle.btn-warning:focus,\\n.btn-warning:active.focus,\\n.btn-warning.active.focus,\\n.open > .dropdown-toggle.btn-warning.focus {\\n  color: #fff;\\n  background-color: #d58512;\\n  border-color: #985f0d;\\n}\\n.btn-warning:active,\\n.btn-warning.active,\\n.open > .dropdown-toggle.btn-warning {\\n  background-image: none;\\n}\\n.btn-warning.disabled:hover,\\n.btn-warning[disabled]:hover,\\nfieldset[disabled] .btn-warning:hover,\\n.btn-warning.disabled:focus,\\n.btn-warning[disabled]:focus,\\nfieldset[disabled] .btn-warning:focus,\\n.btn-warning.disabled.focus,\\n.btn-warning[disabled].focus,\\nfieldset[disabled] .btn-warning.focus {\\n  background-color: #f0ad4e;\\n  border-color: #eea236;\\n}\\n.btn-warning .badge {\\n  color: #f0ad4e;\\n  background-color: #fff;\\n}\\n.btn-danger {\\n  color: #fff;\\n  background-color: #d9534f;\\n  border-color: #d43f3a;\\n}\\n.btn-danger:focus,\\n.btn-danger.focus {\\n  color: #fff;\\n  background-color: #c9302c;\\n  border-color: #761c19;\\n}\\n.btn-danger:hover {\\n  color: #fff;\\n  background-color: #c9302c;\\n  border-color: #ac2925;\\n}\\n.btn-danger:active,\\n.btn-danger.active,\\n.open > .dropdown-toggle.btn-danger {\\n  color: #fff;\\n  background-color: #c9302c;\\n  border-color: #ac2925;\\n}\\n.btn-danger:active:hover,\\n.btn-danger.active:hover,\\n.open > .dropdown-toggle.btn-danger:hover,\\n.btn-danger:active:focus,\\n.btn-danger.active:focus,\\n.open > .dropdown-toggle.btn-danger:focus,\\n.btn-danger:active.focus,\\n.btn-danger.active.focus,\\n.open > .dropdown-toggle.btn-danger.focus {\\n  color: #fff;\\n  background-color: #ac2925;\\n  border-color: #761c19;\\n}\\n.btn-danger:active,\\n.btn-danger.active,\\n.open > .dropdown-toggle.btn-danger {\\n  background-image: none;\\n}\\n.btn-danger.disabled:hover,\\n.btn-danger[disabled]:hover,\\nfieldset[disabled] .btn-danger:hover,\\n.btn-danger.disabled:focus,\\n.btn-danger[disabled]:focus,\\nfieldset[disabled] .btn-danger:focus,\\n.btn-danger.disabled.focus,\\n.btn-danger[disabled].focus,\\nfieldset[disabled] .btn-danger.focus {\\n  background-color: #d9534f;\\n  border-color: #d43f3a;\\n}\\n.btn-danger .badge {\\n  color: #d9534f;\\n  background-color: #fff;\\n}\\n.btn-link {\\n  font-weight: normal;\\n  color: #337ab7;\\n  border-radius: 0;\\n}\\n.btn-link,\\n.btn-link:active,\\n.btn-link.active,\\n.btn-link[disabled],\\nfieldset[disabled] .btn-link {\\n  background-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none;\\n}\\n.btn-link,\\n.btn-link:hover,\\n.btn-link:focus,\\n.btn-link:active {\\n  border-color: transparent;\\n}\\n.btn-link:hover,\\n.btn-link:focus {\\n  color: #23527c;\\n  text-decoration: underline;\\n  background-color: transparent;\\n}\\n.btn-link[disabled]:hover,\\nfieldset[disabled] .btn-link:hover,\\n.btn-link[disabled]:focus,\\nfieldset[disabled] .btn-link:focus {\\n  color: #777;\\n  text-decoration: none;\\n}\\n.btn-lg,\\n.btn-group-lg > .btn {\\n  padding: 10px 16px;\\n  font-size: 18px;\\n  line-height: 1.3333333;\\n  border-radius: 6px;\\n}\\n.btn-sm,\\n.btn-group-sm > .btn {\\n  padding: 5px 10px;\\n  font-size: 12px;\\n  line-height: 1.5;\\n  border-radius: 3px;\\n}\\n.btn-xs,\\n.btn-group-xs > .btn {\\n  padding: 1px 5px;\\n  font-size: 12px;\\n  line-height: 1.5;\\n  border-radius: 3px;\\n}\\n.btn-block {\\n  display: block;\\n  width: 100%;\\n}\\n.btn-block + .btn-block {\\n  margin-top: 5px;\\n}\\ninput[type=\\\"submit\\\"].btn-block,\\ninput[type=\\\"reset\\\"].btn-block,\\ninput[type=\\\"button\\\"].btn-block {\\n  width: 100%;\\n}\\n.fade {\\n  opacity: 0;\\n  -webkit-transition: opacity .15s linear;\\n       -o-transition: opacity .15s linear;\\n          transition: opacity .15s linear;\\n}\\n.fade.in {\\n  opacity: 1;\\n}\\n.collapse {\\n  display: none;\\n}\\n.collapse.in {\\n  display: block;\\n}\\ntr.collapse.in {\\n  display: table-row;\\n}\\ntbody.collapse.in {\\n  display: table-row-group;\\n}\\n.collapsing {\\n  position: relative;\\n  height: 0;\\n  overflow: hidden;\\n  -webkit-transition-timing-function: ease;\\n       -o-transition-timing-function: ease;\\n          transition-timing-function: ease;\\n  -webkit-transition-duration: .35s;\\n       -o-transition-duration: .35s;\\n          transition-duration: .35s;\\n  -webkit-transition-property: height, visibility;\\n       -o-transition-property: height, visibility;\\n          transition-property: height, visibility;\\n}\\n.caret {\\n  display: inline-block;\\n  width: 0;\\n  height: 0;\\n  margin-left: 2px;\\n  vertical-align: middle;\\n  border-top: 4px dashed;\\n  border-top: 4px solid \\\\9;\\n  border-right: 4px solid transparent;\\n  border-left: 4px solid transparent;\\n}\\n.dropup,\\n.dropdown {\\n  position: relative;\\n}\\n.dropdown-toggle:focus {\\n  outline: 0;\\n}\\n.dropdown-menu {\\n  position: absolute;\\n  top: 100%;\\n  left: 0;\\n  z-index: 1000;\\n  display: none;\\n  float: left;\\n  min-width: 160px;\\n  padding: 5px 0;\\n  margin: 2px 0 0;\\n  font-size: 14px;\\n  text-align: left;\\n  list-style: none;\\n  background-color: #fff;\\n  -webkit-background-clip: padding-box;\\n          background-clip: padding-box;\\n  border: 1px solid #ccc;\\n  border: 1px solid rgba(0, 0, 0, .15);\\n  border-radius: 4px;\\n  -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175);\\n          box-shadow: 0 6px 12px rgba(0, 0, 0, .175);\\n}\\n.dropdown-menu.pull-right {\\n  right: 0;\\n  left: auto;\\n}\\n.dropdown-menu .divider {\\n  height: 1px;\\n  margin: 9px 0;\\n  overflow: hidden;\\n  background-color: #e5e5e5;\\n}\\n.dropdown-menu > li > a {\\n  display: block;\\n  padding: 3px 20px;\\n  clear: both;\\n  font-weight: normal;\\n  line-height: 1.42857143;\\n  color: #333;\\n  white-space: nowrap;\\n}\\n.dropdown-menu > li > a:hover,\\n.dropdown-menu > li > a:focus {\\n  color: #262626;\\n  text-decoration: none;\\n  background-color: #f5f5f5;\\n}\\n.dropdown-menu > .active > a,\\n.dropdown-menu > .active > a:hover,\\n.dropdown-menu > .active > a:focus {\\n  color: #fff;\\n  text-decoration: none;\\n  background-color: #337ab7;\\n  outline: 0;\\n}\\n.dropdown-menu > .disabled > a,\\n.dropdown-menu > .disabled > a:hover,\\n.dropdown-menu > .disabled > a:focus {\\n  color: #777;\\n}\\n.dropdown-menu > .disabled > a:hover,\\n.dropdown-menu > .disabled > a:focus {\\n  text-decoration: none;\\n  cursor: not-allowed;\\n  background-color: transparent;\\n  background-image: none;\\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);\\n}\\n.open > .dropdown-menu {\\n  display: block;\\n}\\n.open > a {\\n  outline: 0;\\n}\\n.dropdown-menu-right {\\n  right: 0;\\n  left: auto;\\n}\\n.dropdown-menu-left {\\n  right: auto;\\n  left: 0;\\n}\\n.dropdown-header {\\n  display: block;\\n  padding: 3px 20px;\\n  font-size: 12px;\\n  line-height: 1.42857143;\\n  color: #777;\\n  white-space: nowrap;\\n}\\n.dropdown-backdrop {\\n  position: fixed;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  z-index: 990;\\n}\\n.pull-right > .dropdown-menu {\\n  right: 0;\\n  left: auto;\\n}\\n.dropup .caret,\\n.navbar-fixed-bottom .dropdown .caret {\\n  content: \\\"\\\";\\n  border-top: 0;\\n  border-bottom: 4px dashed;\\n  border-bottom: 4px solid \\\\9;\\n}\\n.dropup .dropdown-menu,\\n.navbar-fixed-bottom .dropdown .dropdown-menu {\\n  top: auto;\\n  bottom: 100%;\\n  margin-bottom: 2px;\\n}\\n@media (min-width: 768px) {\\n  .navbar-right .dropdown-menu {\\n    right: 0;\\n    left: auto;\\n  }\\n  .navbar-right .dropdown-menu-left {\\n    right: auto;\\n    left: 0;\\n  }\\n}\\n.btn-group,\\n.btn-group-vertical {\\n  position: relative;\\n  display: inline-block;\\n  vertical-align: middle;\\n}\\n.btn-group > .btn,\\n.btn-group-vertical > .btn {\\n  position: relative;\\n  float: left;\\n}\\n.btn-group > .btn:hover,\\n.btn-group-vertical > .btn:hover,\\n.btn-group > .btn:focus,\\n.btn-group-vertical > .btn:focus,\\n.btn-group > .btn:active,\\n.btn-group-vertical > .btn:active,\\n.btn-group > .btn.active,\\n.btn-group-vertical > .btn.active {\\n  z-index: 2;\\n}\\n.btn-group .btn + .btn,\\n.btn-group .btn + .btn-group,\\n.btn-group .btn-group + .btn,\\n.btn-group .btn-group + .btn-group {\\n  margin-left: -1px;\\n}\\n.btn-toolbar {\\n  margin-left: -5px;\\n}\\n.btn-toolbar .btn,\\n.btn-toolbar .btn-group,\\n.btn-toolbar .input-group {\\n  float: left;\\n}\\n.btn-toolbar > .btn,\\n.btn-toolbar > .btn-group,\\n.btn-toolbar > .input-group {\\n  margin-left: 5px;\\n}\\n.btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) {\\n  border-radius: 0;\\n}\\n.btn-group > .btn:first-child {\\n  margin-left: 0;\\n}\\n.btn-group > .btn:first-child:not(:last-child):not(.dropdown-toggle) {\\n  border-top-right-radius: 0;\\n  border-bottom-right-radius: 0;\\n}\\n.btn-group > .btn:last-child:not(:first-child),\\n.btn-group > .dropdown-toggle:not(:first-child) {\\n  border-top-left-radius: 0;\\n  border-bottom-left-radius: 0;\\n}\\n.btn-group > .btn-group {\\n  float: left;\\n}\\n.btn-group > .btn-group:not(:first-child):not(:last-child) > .btn {\\n  border-radius: 0;\\n}\\n.btn-group > .btn-group:first-child:not(:last-child) > .btn:last-child,\\n.btn-group > .btn-group:first-child:not(:last-child) > .dropdown-toggle {\\n  border-top-right-radius: 0;\\n  border-bottom-right-radius: 0;\\n}\\n.btn-group > .btn-group:last-child:not(:first-child) > .btn:first-child {\\n  border-top-left-radius: 0;\\n  border-bottom-left-radius: 0;\\n}\\n.btn-group .dropdown-toggle:active,\\n.btn-group.open .dropdown-toggle {\\n  outline: 0;\\n}\\n.btn-group > .btn + .dropdown-toggle {\\n  padding-right: 8px;\\n  padding-left: 8px;\\n}\\n.btn-group > .btn-lg + .dropdown-toggle {\\n  padding-right: 12px;\\n  padding-left: 12px;\\n}\\n.btn-group.open .dropdown-toggle {\\n  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);\\n          box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);\\n}\\n.btn-group.open .dropdown-toggle.btn-link {\\n  -webkit-box-shadow: none;\\n          box-shadow: none;\\n}\\n.btn .caret {\\n  margin-left: 0;\\n}\\n.btn-lg .caret {\\n  border-width: 5px 5px 0;\\n  border-bottom-width: 0;\\n}\\n.dropup .btn-lg .caret {\\n  border-width: 0 5px 5px;\\n}\\n.btn-group-vertical > .btn,\\n.btn-group-vertical > .btn-group,\\n.btn-group-vertical > .btn-group > .btn {\\n  display: block;\\n  float: none;\\n  width: 100%;\\n  max-width: 100%;\\n}\\n.btn-group-vertical > .btn-group > .btn {\\n  float: none;\\n}\\n.btn-group-vertical > .btn + .btn,\\n.btn-group-vertical > .btn + .btn-group,\\n.btn-group-vertical > .btn-group + .btn,\\n.btn-group-vertical > .btn-group + .btn-group {\\n  margin-top: -1px;\\n  margin-left: 0;\\n}\\n.btn-group-vertical > .btn:not(:first-child):not(:last-child) {\\n  border-radius: 0;\\n}\\n.btn-group-vertical > .btn:first-child:not(:last-child) {\\n  border-top-left-radius: 4px;\\n  border-top-right-radius: 4px;\\n  border-bottom-right-radius: 0;\\n  border-bottom-left-radius: 0;\\n}\\n.btn-group-vertical > .btn:last-child:not(:first-child) {\\n  border-top-left-radius: 0;\\n  border-top-right-radius: 0;\\n  border-bottom-right-radius: 4px;\\n  border-bottom-left-radius: 4px;\\n}\\n.btn-group-vertical > .btn-group:not(:first-child):not(:last-child) > .btn {\\n  border-radius: 0;\\n}\\n.btn-group-vertical > .btn-group:first-child:not(:last-child) > .btn:last-child,\\n.btn-group-vertical > .btn-group:first-child:not(:last-child) > .dropdown-toggle {\\n  border-bottom-right-radius: 0;\\n  border-bottom-left-radius: 0;\\n}\\n.btn-group-vertical > .btn-group:last-child:not(:first-child) > .btn:first-child {\\n  border-top-left-radius: 0;\\n  border-top-right-radius: 0;\\n}\\n.btn-group-justified {\\n  display: table;\\n  width: 100%;\\n  table-layout: fixed;\\n  border-collapse: separate;\\n}\\n.btn-group-justified > .btn,\\n.btn-group-justified > .btn-group {\\n  display: table-cell;\\n  float: none;\\n  width: 1%;\\n}\\n.btn-group-justified > .btn-group .btn {\\n  width: 100%;\\n}\\n.btn-group-justified > .btn-group .dropdown-menu {\\n  left: auto;\\n}\\n[data-toggle=\\\"buttons\\\"] > .btn input[type=\\\"radio\\\"],\\n[data-toggle=\\\"buttons\\\"] > .btn-group > .btn input[type=\\\"radio\\\"],\\n[data-toggle=\\\"buttons\\\"] > .btn input[type=\\\"checkbox\\\"],\\n[data-toggle=\\\"buttons\\\"] > .btn-group > .btn input[type=\\\"checkbox\\\"] {\\n  position: absolute;\\n  clip: rect(0, 0, 0, 0);\\n  pointer-events: none;\\n}\\n.input-group {\\n  position: relative;\\n  display: table;\\n  border-collapse: separate;\\n}\\n.input-group[class*=\\\"col-\\\"] {\\n  float: none;\\n  padding-right: 0;\\n  padding-left: 0;\\n}\\n.input-group .form-control {\\n  position: relative;\\n  z-index: 2;\\n  float: left;\\n  width: 100%;\\n  margin-bottom: 0;\\n}\\n.input-group .form-control:focus {\\n  z-index: 3;\\n}\\n.input-group-lg > .form-control,\\n.input-group-lg > .input-group-addon,\\n.input-group-lg > .input-group-btn > .btn {\\n  height: 46px;\\n  padding: 10px 16px;\\n  font-size: 18px;\\n  line-height: 1.3333333;\\n  border-radius: 6px;\\n}\\nselect.input-group-lg > .form-control,\\nselect.input-group-lg > .input-group-addon,\\nselect.input-group-lg > .input-group-btn > .btn {\\n  height: 46px;\\n  line-height: 46px;\\n}\\ntextarea.input-group-lg > .form-control,\\ntextarea.input-group-lg > .input-group-addon,\\ntextarea.input-group-lg > .input-group-btn > .btn,\\nselect[multiple].input-group-lg > .form-control,\\nselect[multiple].input-group-lg > .input-group-addon,\\nselect[multiple].input-group-lg > .input-group-btn > .btn {\\n  height: auto;\\n}\\n.input-group-sm > .form-control,\\n.input-group-sm > .input-group-addon,\\n.input-group-sm > .input-group-btn > .btn {\\n  height: 30px;\\n  padding: 5px 10px;\\n  font-size: 12px;\\n  line-height: 1.5;\\n  border-radius: 3px;\\n}\\nselect.input-group-sm > .form-control,\\nselect.input-group-sm > .input-group-addon,\\nselect.input-group-sm > .input-group-btn > .btn {\\n  height: 30px;\\n  line-height: 30px;\\n}\\ntextarea.input-group-sm > .form-control,\\ntextarea.input-group-sm > .input-group-addon,\\ntextarea.input-group-sm > .input-group-btn > .btn,\\nselect[multiple].input-group-sm > .form-control,\\nselect[multiple].input-group-sm > .input-group-addon,\\nselect[multiple].input-group-sm > .input-group-btn > .btn {\\n  height: auto;\\n}\\n.input-group-addon,\\n.input-group-btn,\\n.input-group .form-control {\\n  display: table-cell;\\n}\\n.input-group-addon:not(:first-child):not(:last-child),\\n.input-group-btn:not(:first-child):not(:last-child),\\n.input-group .form-control:not(:first-child):not(:last-child) {\\n  border-radius: 0;\\n}\\n.input-group-addon,\\n.input-group-btn {\\n  width: 1%;\\n  white-space: nowrap;\\n  vertical-align: middle;\\n}\\n.input-group-addon {\\n  padding: 6px 12px;\\n  font-size: 14px;\\n  font-weight: normal;\\n  line-height: 1;\\n  color: #555;\\n  text-align: center;\\n  background-color: #eee;\\n  border: 1px solid #ccc;\\n  border-radius: 4px;\\n}\\n.input-group-addon.input-sm {\\n  padding: 5px 10px;\\n  font-size: 12px;\\n  border-radius: 3px;\\n}\\n.input-group-addon.input-lg {\\n  padding: 10px 16px;\\n  font-size: 18px;\\n  border-radius: 6px;\\n}\\n.input-group-addon input[type=\\\"radio\\\"],\\n.input-group-addon input[type=\\\"checkbox\\\"] {\\n  margin-top: 0;\\n}\\n.input-group .form-control:first-child,\\n.input-group-addon:first-child,\\n.input-group-btn:first-child > .btn,\\n.input-group-btn:first-child > .btn-group > .btn,\\n.input-group-btn:first-child > .dropdown-toggle,\\n.input-group-btn:last-child > .btn:not(:last-child):not(.dropdown-toggle),\\n.input-group-btn:last-child > .btn-group:not(:last-child) > .btn {\\n  border-top-right-radius: 0;\\n  border-bottom-right-radius: 0;\\n}\\n.input-group-addon:first-child {\\n  border-right: 0;\\n}\\n.input-group .form-control:last-child,\\n.input-group-addon:last-child,\\n.input-group-btn:last-child > .btn,\\n.input-group-btn:last-child > .btn-group > .btn,\\n.input-group-btn:last-child > .dropdown-toggle,\\n.input-group-btn:first-child > .btn:not(:first-child),\\n.input-group-btn:first-child > .btn-group:not(:first-child) > .btn {\\n  border-top-left-radius: 0;\\n  border-bottom-left-radius: 0;\\n}\\n.input-group-addon:last-child {\\n  border-left: 0;\\n}\\n.input-group-btn {\\n  position: relative;\\n  font-size: 0;\\n  white-space: nowrap;\\n}\\n.input-group-btn > .btn {\\n  position: relative;\\n}\\n.input-group-btn > .btn + .btn {\\n  margin-left: -1px;\\n}\\n.input-group-btn > .btn:hover,\\n.input-group-btn > .btn:focus,\\n.input-group-btn > .btn:active {\\n  z-index: 2;\\n}\\n.input-group-btn:first-child > .btn,\\n.input-group-btn:first-child > .btn-group {\\n  margin-right: -1px;\\n}\\n.input-group-btn:last-child > .btn,\\n.input-group-btn:last-child > .btn-group {\\n  z-index: 2;\\n  margin-left: -1px;\\n}\\n.nav {\\n  padding-left: 0;\\n  margin-bottom: 0;\\n  list-style: none;\\n}\\n.nav > li {\\n  position: relative;\\n  display: block;\\n}\\n.nav > li > a {\\n  position: relative;\\n  display: block;\\n  padding: 10px 15px;\\n}\\n.nav > li > a:hover,\\n.nav > li > a:focus {\\n  text-decoration: none;\\n  background-color: #eee;\\n}\\n.nav > li.disabled > a {\\n  color: #777;\\n}\\n.nav > li.disabled > a:hover,\\n.nav > li.disabled > a:focus {\\n  color: #777;\\n  text-decoration: none;\\n  cursor: not-allowed;\\n  background-color: transparent;\\n}\\n.nav .open > a,\\n.nav .open > a:hover,\\n.nav .open > a:focus {\\n  background-color: #eee;\\n  border-color: #337ab7;\\n}\\n.nav .nav-divider {\\n  height: 1px;\\n  margin: 9px 0;\\n  overflow: hidden;\\n  background-color: #e5e5e5;\\n}\\n.nav > li > a > img {\\n  max-width: none;\\n}\\n.nav-tabs {\\n  border-bottom: 1px solid #ddd;\\n}\\n.nav-tabs > li {\\n  float: left;\\n  margin-bottom: -1px;\\n}\\n.nav-tabs > li > a {\\n  margin-right: 2px;\\n  line-height: 1.42857143;\\n  border: 1px solid transparent;\\n  border-radius: 4px 4px 0 0;\\n}\\n.nav-tabs > li > a:hover {\\n  border-color: #eee #eee #ddd;\\n}\\n.nav-tabs > li.active > a,\\n.nav-tabs > li.active > a:hover,\\n.nav-tabs > li.active > a:focus {\\n  color: #555;\\n  cursor: default;\\n  background-color: #fff;\\n  border: 1px solid #ddd;\\n  border-bottom-color: transparent;\\n}\\n.nav-tabs.nav-justified {\\n  width: 100%;\\n  border-bottom: 0;\\n}\\n.nav-tabs.nav-justified > li {\\n  float: none;\\n}\\n.nav-tabs.nav-justified > li > a {\\n  margin-bottom: 5px;\\n  text-align: center;\\n}\\n.nav-tabs.nav-justified > .dropdown .dropdown-menu {\\n  top: auto;\\n  left: auto;\\n}\\n@media (min-width: 768px) {\\n  .nav-tabs.nav-justified > li {\\n    display: table-cell;\\n    width: 1%;\\n  }\\n  .nav-tabs.nav-justified > li > a {\\n    margin-bottom: 0;\\n  }\\n}\\n.nav-tabs.nav-justified > li > a {\\n  margin-right: 0;\\n  border-radius: 4px;\\n}\\n.nav-tabs.nav-justified > .active > a,\\n.nav-tabs.nav-justified > .active > a:hover,\\n.nav-tabs.nav-justified > .active > a:focus {\\n  border: 1px solid #ddd;\\n}\\n@media (min-width: 768px) {\\n  .nav-tabs.nav-justified > li > a {\\n    border-bottom: 1px solid #ddd;\\n    border-radius: 4px 4px 0 0;\\n  }\\n  .nav-tabs.nav-justified > .active > a,\\n  .nav-tabs.nav-justified > .active > a:hover,\\n  .nav-tabs.nav-justified > .active > a:focus {\\n    border-bottom-color: #fff;\\n  }\\n}\\n.nav-pills > li {\\n  float: left;\\n}\\n.nav-pills > li > a {\\n  border-radius: 4px;\\n}\\n.nav-pills > li + li {\\n  margin-left: 2px;\\n}\\n.nav-pills > li.active > a,\\n.nav-pills > li.active > a:hover,\\n.nav-pills > li.active > a:focus {\\n  color: #fff;\\n  background-color: #337ab7;\\n}\\n.nav-stacked > li {\\n  float: none;\\n}\\n.nav-stacked > li + li {\\n  margin-top: 2px;\\n  margin-left: 0;\\n}\\n.nav-justified {\\n  width: 100%;\\n}\\n.nav-justified > li {\\n  float: none;\\n}\\n.nav-justified > li > a {\\n  margin-bottom: 5px;\\n  text-align: center;\\n}\\n.nav-justified > .dropdown .dropdown-menu {\\n  top: auto;\\n  left: auto;\\n}\\n@media (min-width: 768px) {\\n  .nav-justified > li {\\n    display: table-cell;\\n    width: 1%;\\n  }\\n  .nav-justified > li > a {\\n    margin-bottom: 0;\\n  }\\n}\\n.nav-tabs-justified {\\n  border-bottom: 0;\\n}\\n.nav-tabs-justified > li > a {\\n  margin-right: 0;\\n  border-radius: 4px;\\n}\\n.nav-tabs-justified > .active > a,\\n.nav-tabs-justified > .active > a:hover,\\n.nav-tabs-justified > .active > a:focus {\\n  border: 1px solid #ddd;\\n}\\n@media (min-width: 768px) {\\n  .nav-tabs-justified > li > a {\\n    border-bottom: 1px solid #ddd;\\n    border-radius: 4px 4px 0 0;\\n  }\\n  .nav-tabs-justified > .active > a,\\n  .nav-tabs-justified > .active > a:hover,\\n  .nav-tabs-justified > .active > a:focus {\\n    border-bottom-color: #fff;\\n  }\\n}\\n.tab-content > .tab-pane {\\n  display: none;\\n}\\n.tab-content > .active {\\n  display: block;\\n}\\n.nav-tabs .dropdown-menu {\\n  margin-top: -1px;\\n  border-top-left-radius: 0;\\n  border-top-right-radius: 0;\\n}\\n.navbar {\\n  position: relative;\\n  min-height: 50px;\\n  margin-bottom: 20px;\\n  border: 1px solid transparent;\\n}\\n@media (min-width: 768px) {\\n  .navbar {\\n    border-radius: 4px;\\n  }\\n}\\n@media (min-width: 768px) {\\n  .navbar-header {\\n    float: left;\\n  }\\n}\\n.navbar-collapse {\\n  padding-right: 15px;\\n  padding-left: 15px;\\n  overflow-x: visible;\\n  -webkit-overflow-scrolling: touch;\\n  border-top: 1px solid transparent;\\n  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1);\\n          box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1);\\n}\\n.navbar-collapse.in {\\n  overflow-y: auto;\\n}\\n@media (min-width: 768px) {\\n  .navbar-collapse {\\n    width: auto;\\n    border-top: 0;\\n    -webkit-box-shadow: none;\\n            box-shadow: none;\\n  }\\n  .navbar-collapse.collapse {\\n    display: block !important;\\n    height: auto !important;\\n    padding-bottom: 0;\\n    overflow: visible !important;\\n  }\\n  .navbar-collapse.in {\\n    overflow-y: visible;\\n  }\\n  .navbar-fixed-top .navbar-collapse,\\n  .navbar-static-top .navbar-collapse,\\n  .navbar-fixed-bottom .navbar-collapse {\\n    padding-right: 0;\\n    padding-left: 0;\\n  }\\n}\\n.navbar-fixed-top .navbar-collapse,\\n.navbar-fixed-bottom .navbar-collapse {\\n  max-height: 340px;\\n}\\n@media (max-device-width: 480px) and (orientation: landscape) {\\n  .navbar-fixed-top .navbar-collapse,\\n  .navbar-fixed-bottom .navbar-collapse {\\n    max-height: 200px;\\n  }\\n}\\n.container > .navbar-header,\\n.container-fluid > .navbar-header,\\n.container > .navbar-collapse,\\n.container-fluid > .navbar-collapse {\\n  margin-right: -15px;\\n  margin-left: -15px;\\n}\\n@media (min-width: 768px) {\\n  .container > .navbar-header,\\n  .container-fluid > .navbar-header,\\n  .container > .navbar-collapse,\\n  .container-fluid > .navbar-collapse {\\n    margin-right: 0;\\n    margin-left: 0;\\n  }\\n}\\n.navbar-static-top {\\n  z-index: 1000;\\n  border-width: 0 0 1px;\\n}\\n@media (min-width: 768px) {\\n  .navbar-static-top {\\n    border-radius: 0;\\n  }\\n}\\n.navbar-fixed-top,\\n.navbar-fixed-bottom {\\n  position: fixed;\\n  right: 0;\\n  left: 0;\\n  z-index: 1030;\\n}\\n@media (min-width: 768px) {\\n  .navbar-fixed-top,\\n  .navbar-fixed-bottom {\\n    border-radius: 0;\\n  }\\n}\\n.navbar-fixed-top {\\n  top: 0;\\n  border-width: 0 0 1px;\\n}\\n.navbar-fixed-bottom {\\n  bottom: 0;\\n  margin-bottom: 0;\\n  border-width: 1px 0 0;\\n}\\n.navbar-brand {\\n  float: left;\\n  height: 50px;\\n  padding: 15px 15px;\\n  font-size: 18px;\\n  line-height: 20px;\\n}\\n.navbar-brand:hover,\\n.navbar-brand:focus {\\n  text-decoration: none;\\n}\\n.navbar-brand > img {\\n  display: block;\\n}\\n@media (min-width: 768px) {\\n  .navbar > .container .navbar-brand,\\n  .navbar > .container-fluid .navbar-brand {\\n    margin-left: -15px;\\n  }\\n}\\n.navbar-toggle {\\n  position: relative;\\n  float: right;\\n  padding: 9px 10px;\\n  margin-top: 8px;\\n  margin-right: 15px;\\n  margin-bottom: 8px;\\n  background-color: transparent;\\n  background-image: none;\\n  border: 1px solid transparent;\\n  border-radius: 4px;\\n}\\n.navbar-toggle:focus {\\n  outline: 0;\\n}\\n.navbar-toggle .icon-bar {\\n  display: block;\\n  width: 22px;\\n  height: 2px;\\n  border-radius: 1px;\\n}\\n.navbar-toggle .icon-bar + .icon-bar {\\n  margin-top: 4px;\\n}\\n@media (min-width: 768px) {\\n  .navbar-toggle {\\n    display: none;\\n  }\\n}\\n.navbar-nav {\\n  margin: 7.5px -15px;\\n}\\n.navbar-nav > li > a {\\n  padding-top: 10px;\\n  padding-bottom: 10px;\\n  line-height: 20px;\\n}\\n@media (max-width: 767px) {\\n  .navbar-nav .open .dropdown-menu {\\n    position: static;\\n    float: none;\\n    width: auto;\\n    margin-top: 0;\\n    background-color: transparent;\\n    border: 0;\\n    -webkit-box-shadow: none;\\n            box-shadow: none;\\n  }\\n  .navbar-nav .open .dropdown-menu > li > a,\\n  .navbar-nav .open .dropdown-menu .dropdown-header {\\n    padding: 5px 15px 5px 25px;\\n  }\\n  .navbar-nav .open .dropdown-menu > li > a {\\n    line-height: 20px;\\n  }\\n  .navbar-nav .open .dropdown-menu > li > a:hover,\\n  .navbar-nav .open .dropdown-menu > li > a:focus {\\n    background-image: none;\\n  }\\n}\\n@media (min-width: 768px) {\\n  .navbar-nav {\\n    float: left;\\n    margin: 0;\\n  }\\n  .navbar-nav > li {\\n    float: left;\\n  }\\n  .navbar-nav > li > a {\\n    padding-top: 15px;\\n    padding-bottom: 15px;\\n  }\\n}\\n.navbar-form {\\n  padding: 10px 15px;\\n  margin-top: 8px;\\n  margin-right: -15px;\\n  margin-bottom: 8px;\\n  margin-left: -15px;\\n  border-top: 1px solid transparent;\\n  border-bottom: 1px solid transparent;\\n  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1), 0 1px 0 rgba(255, 255, 255, .1);\\n          box-shadow: inset 0 1px 0 rgba(255, 255, 255, .1), 0 1px 0 rgba(255, 255, 255, .1);\\n}\\n@media (min-width: 768px) {\\n  .navbar-form .form-group {\\n    display: inline-block;\\n    margin-bottom: 0;\\n    vertical-align: middle;\\n  }\\n  .navbar-form .form-control {\\n    display: inline-block;\\n    width: auto;\\n    vertical-align: middle;\\n  }\\n  .navbar-form .form-control-static {\\n    display: inline-block;\\n  }\\n  .navbar-form .input-group {\\n    display: inline-table;\\n    vertical-align: middle;\\n  }\\n  .navbar-form .input-group .input-group-addon,\\n  .navbar-form .input-group .input-group-btn,\\n  .navbar-form .input-group .form-control {\\n    width: auto;\\n  }\\n  .navbar-form .input-group > .form-control {\\n    width: 100%;\\n  }\\n  .navbar-form .control-label {\\n    margin-bottom: 0;\\n    vertical-align: middle;\\n  }\\n  .navbar-form .radio,\\n  .navbar-form .checkbox {\\n    display: inline-block;\\n    margin-top: 0;\\n    margin-bottom: 0;\\n    vertical-align: middle;\\n  }\\n  .navbar-form .radio label,\\n  .navbar-form .checkbox label {\\n    padding-left: 0;\\n  }\\n  .navbar-form .radio input[type=\\\"radio\\\"],\\n  .navbar-form .checkbox input[type=\\\"checkbox\\\"] {\\n    position: relative;\\n    margin-left: 0;\\n  }\\n  .navbar-form .has-feedback .form-control-feedback {\\n    top: 0;\\n  }\\n}\\n@media (max-width: 767px) {\\n  .navbar-form .form-group {\\n    margin-bottom: 5px;\\n  }\\n  .navbar-form .form-group:last-child {\\n    margin-bottom: 0;\\n  }\\n}\\n@media (min-width: 768px) {\\n  .navbar-form {\\n    width: auto;\\n    padding-top: 0;\\n    padding-bottom: 0;\\n    margin-right: 0;\\n    margin-left: 0;\\n    border: 0;\\n    -webkit-box-shadow: none;\\n            box-shadow: none;\\n  }\\n}\\n.navbar-nav > li > .dropdown-menu {\\n  margin-top: 0;\\n  border-top-left-radius: 0;\\n  border-top-right-radius: 0;\\n}\\n.navbar-fixed-bottom .navbar-nav > li > .dropdown-menu {\\n  margin-bottom: 0;\\n  border-top-left-radius: 4px;\\n  border-top-right-radius: 4px;\\n  border-bottom-right-radius: 0;\\n  border-bottom-left-radius: 0;\\n}\\n.navbar-btn {\\n  margin-top: 8px;\\n  margin-bottom: 8px;\\n}\\n.navbar-btn.btn-sm {\\n  margin-top: 10px;\\n  margin-bottom: 10px;\\n}\\n.navbar-btn.btn-xs {\\n  margin-top: 14px;\\n  margin-bottom: 14px;\\n}\\n.navbar-text {\\n  margin-top: 15px;\\n  margin-bottom: 15px;\\n}\\n@media (min-width: 768px) {\\n  .navbar-text {\\n    float: left;\\n    margin-right: 15px;\\n    margin-left: 15px;\\n  }\\n}\\n@media (min-width: 768px) {\\n  .navbar-left {\\n    float: left !important;\\n  }\\n  .navbar-right {\\n    float: right !important;\\n    margin-right: -15px;\\n  }\\n  .navbar-right ~ .navbar-right {\\n    margin-right: 0;\\n  }\\n}\\n.navbar-default {\\n  background-color: #f8f8f8;\\n  border-color: #e7e7e7;\\n}\\n.navbar-default .navbar-brand {\\n  color: #777;\\n}\\n.navbar-default .navbar-brand:hover,\\n.navbar-default .navbar-brand:focus {\\n  color: #5e5e5e;\\n  background-color: transparent;\\n}\\n.navbar-default .navbar-text {\\n  color: #777;\\n}\\n.navbar-default .navbar-nav > li > a {\\n  color: #777;\\n}\\n.navbar-default .navbar-nav > li > a:hover,\\n.navbar-default .navbar-nav > li > a:focus {\\n  color: #333;\\n  background-color: transparent;\\n}\\n.navbar-default .navbar-nav > .active > a,\\n.navbar-default .navbar-nav > .active > a:hover,\\n.navbar-default .navbar-nav > .active > a:focus {\\n  color: #555;\\n  background-color: #e7e7e7;\\n}\\n.navbar-default .navbar-nav > .disabled > a,\\n.navbar-default .navbar-nav > .disabled > a:hover,\\n.navbar-default .navbar-nav > .disabled > a:focus {\\n  color: #ccc;\\n  background-color: transparent;\\n}\\n.navbar-default .navbar-toggle {\\n  border-color: #ddd;\\n}\\n.navbar-default .navbar-toggle:hover,\\n.navbar-default .navbar-toggle:focus {\\n  background-color: #ddd;\\n}\\n.navbar-default .navbar-toggle .icon-bar {\\n  background-color: #888;\\n}\\n.navbar-default .navbar-collapse,\\n.navbar-default .navbar-form {\\n  border-color: #e7e7e7;\\n}\\n.navbar-default .navbar-nav > .open > a,\\n.navbar-default .navbar-nav > .open > a:hover,\\n.navbar-default .navbar-nav > .open > a:focus {\\n  color: #555;\\n  background-color: #e7e7e7;\\n}\\n@media (max-width: 767px) {\\n  .navbar-default .navbar-nav .open .dropdown-menu > li > a {\\n    color: #777;\\n  }\\n  .navbar-default .navbar-nav .open .dropdown-menu > li > a:hover,\\n  .navbar-default .navbar-nav .open .dropdown-menu > li > a:focus {\\n    color: #333;\\n    background-color: transparent;\\n  }\\n  .navbar-default .navbar-nav .open .dropdown-menu > .active > a,\\n  .navbar-default .navbar-nav .open .dropdown-menu > .active > a:hover,\\n  .navbar-default .navbar-nav .open .dropdown-menu > .active > a:focus {\\n    color: #555;\\n    background-color: #e7e7e7;\\n  }\\n  .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a,\\n  .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:hover,\\n  .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:focus {\\n    color: #ccc;\\n    background-color: transparent;\\n  }\\n}\\n.navbar-default .navbar-link {\\n  color: #777;\\n}\\n.navbar-default .navbar-link:hover {\\n  color: #333;\\n}\\n.navbar-default .btn-link {\\n  color: #777;\\n}\\n.navbar-default .btn-link:hover,\\n.navbar-default .btn-link:focus {\\n  color: #333;\\n}\\n.navbar-default .btn-link[disabled]:hover,\\nfieldset[disabled] .navbar-default .btn-link:hover,\\n.navbar-default .btn-link[disabled]:focus,\\nfieldset[disabled] .navbar-default .btn-link:focus {\\n  color: #ccc;\\n}\\n.navbar-inverse {\\n  background-color: #222;\\n  border-color: #080808;\\n}\\n.navbar-inverse .navbar-brand {\\n  color: #9d9d9d;\\n}\\n.navbar-inverse .navbar-brand:hover,\\n.navbar-inverse .navbar-brand:focus {\\n  color: #fff;\\n  background-color: transparent;\\n}\\n.navbar-inverse .navbar-text {\\n  color: #9d9d9d;\\n}\\n.navbar-inverse .navbar-nav > li > a {\\n  color: #9d9d9d;\\n}\\n.navbar-inverse .navbar-nav > li > a:hover,\\n.navbar-inverse .navbar-nav > li > a:focus {\\n  color: #fff;\\n  background-color: transparent;\\n}\\n.navbar-inverse .navbar-nav > .active > a,\\n.navbar-inverse .navbar-nav > .active > a:hover,\\n.navbar-inverse .navbar-nav > .active > a:focus {\\n  color: #fff;\\n  background-color: #080808;\\n}\\n.navbar-inverse .navbar-nav > .disabled > a,\\n.navbar-inverse .navbar-nav > .disabled > a:hover,\\n.navbar-inverse .navbar-nav > .disabled > a:focus {\\n  color: #444;\\n  background-color: transparent;\\n}\\n.navbar-inverse .navbar-toggle {\\n  border-color: #333;\\n}\\n.navbar-inverse .navbar-toggle:hover,\\n.navbar-inverse .navbar-toggle:focus {\\n  background-color: #333;\\n}\\n.navbar-inverse .navbar-toggle .icon-bar {\\n  background-color: #fff;\\n}\\n.navbar-inverse .navbar-collapse,\\n.navbar-inverse .navbar-form {\\n  border-color: #101010;\\n}\\n.navbar-inverse .navbar-nav > .open > a,\\n.navbar-inverse .navbar-nav > .open > a:hover,\\n.navbar-inverse .navbar-nav > .open > a:focus {\\n  color: #fff;\\n  background-color: #080808;\\n}\\n@media (max-width: 767px) {\\n  .navbar-inverse .navbar-nav .open .dropdown-menu > .dropdown-header {\\n    border-color: #080808;\\n  }\\n  .navbar-inverse .navbar-nav .open .dropdown-menu .divider {\\n    background-color: #080808;\\n  }\\n  .navbar-inverse .navbar-nav .open .dropdown-menu > li > a {\\n    color: #9d9d9d;\\n  }\\n  .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:hover,\\n  .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:focus {\\n    color: #fff;\\n    background-color: transparent;\\n  }\\n  .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a,\\n  .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:hover,\\n  .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:focus {\\n    color: #fff;\\n    background-color: #080808;\\n  }\\n  .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a,\\n  .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:hover,\\n  .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:focus {\\n    color: #444;\\n    background-color: transparent;\\n  }\\n}\\n.navbar-inverse .navbar-link {\\n  color: #9d9d9d;\\n}\\n.navbar-inverse .navbar-link:hover {\\n  color: #fff;\\n}\\n.navbar-inverse .btn-link {\\n  color: #9d9d9d;\\n}\\n.navbar-inverse .btn-link:hover,\\n.navbar-inverse .btn-link:focus {\\n  color: #fff;\\n}\\n.navbar-inverse .btn-link[disabled]:hover,\\nfieldset[disabled] .navbar-inverse .btn-link:hover,\\n.navbar-inverse .btn-link[disabled]:focus,\\nfieldset[disabled] .navbar-inverse .btn-link:focus {\\n  color: #444;\\n}\\n.breadcrumb {\\n  padding: 8px 15px;\\n  margin-bottom: 20px;\\n  list-style: none;\\n  background-color: #f5f5f5;\\n  border-radius: 4px;\\n}\\n.breadcrumb > li {\\n  display: inline-block;\\n}\\n.breadcrumb > li + li:before {\\n  padding: 0 5px;\\n  color: #ccc;\\n  content: \\\"/\\\\A0\\\";\\n}\\n.breadcrumb > .active {\\n  color: #777;\\n}\\n.pagination {\\n  display: inline-block;\\n  padding-left: 0;\\n  margin: 20px 0;\\n  border-radius: 4px;\\n}\\n.pagination > li {\\n  display: inline;\\n}\\n.pagination > li > a,\\n.pagination > li > span {\\n  position: relative;\\n  float: left;\\n  padding: 6px 12px;\\n  margin-left: -1px;\\n  line-height: 1.42857143;\\n  color: #337ab7;\\n  text-decoration: none;\\n  background-color: #fff;\\n  border: 1px solid #ddd;\\n}\\n.pagination > li:first-child > a,\\n.pagination > li:first-child > span {\\n  margin-left: 0;\\n  border-top-left-radius: 4px;\\n  border-bottom-left-radius: 4px;\\n}\\n.pagination > li:last-child > a,\\n.pagination > li:last-child > span {\\n  border-top-right-radius: 4px;\\n  border-bottom-right-radius: 4px;\\n}\\n.pagination > li > a:hover,\\n.pagination > li > span:hover,\\n.pagination > li > a:focus,\\n.pagination > li > span:focus {\\n  z-index: 2;\\n  color: #23527c;\\n  background-color: #eee;\\n  border-color: #ddd;\\n}\\n.pagination > .active > a,\\n.pagination > .active > span,\\n.pagination > .active > a:hover,\\n.pagination > .active > span:hover,\\n.pagination > .active > a:focus,\\n.pagination > .active > span:focus {\\n  z-index: 3;\\n  color: #fff;\\n  cursor: default;\\n  background-color: #337ab7;\\n  border-color: #337ab7;\\n}\\n.pagination > .disabled > span,\\n.pagination > .disabled > span:hover,\\n.pagination > .disabled > span:focus,\\n.pagination > .disabled > a,\\n.pagination > .disabled > a:hover,\\n.pagination > .disabled > a:focus {\\n  color: #777;\\n  cursor: not-allowed;\\n  background-color: #fff;\\n  border-color: #ddd;\\n}\\n.pagination-lg > li > a,\\n.pagination-lg > li > span {\\n  padding: 10px 16px;\\n  font-size: 18px;\\n  line-height: 1.3333333;\\n}\\n.pagination-lg > li:first-child > a,\\n.pagination-lg > li:first-child > span {\\n  border-top-left-radius: 6px;\\n  border-bottom-left-radius: 6px;\\n}\\n.pagination-lg > li:last-child > a,\\n.pagination-lg > li:last-child > span {\\n  border-top-right-radius: 6px;\\n  border-bottom-right-radius: 6px;\\n}\\n.pagination-sm > li > a,\\n.pagination-sm > li > span {\\n  padding: 5px 10px;\\n  font-size: 12px;\\n  line-height: 1.5;\\n}\\n.pagination-sm > li:first-child > a,\\n.pagination-sm > li:first-child > span {\\n  border-top-left-radius: 3px;\\n  border-bottom-left-radius: 3px;\\n}\\n.pagination-sm > li:last-child > a,\\n.pagination-sm > li:last-child > span {\\n  border-top-right-radius: 3px;\\n  border-bottom-right-radius: 3px;\\n}\\n.pager {\\n  padding-left: 0;\\n  margin: 20px 0;\\n  text-align: center;\\n  list-style: none;\\n}\\n.pager li {\\n  display: inline;\\n}\\n.pager li > a,\\n.pager li > span {\\n  display: inline-block;\\n  padding: 5px 14px;\\n  background-color: #fff;\\n  border: 1px solid #ddd;\\n  border-radius: 15px;\\n}\\n.pager li > a:hover,\\n.pager li > a:focus {\\n  text-decoration: none;\\n  background-color: #eee;\\n}\\n.pager .next > a,\\n.pager .next > span {\\n  float: right;\\n}\\n.pager .previous > a,\\n.pager .previous > span {\\n  float: left;\\n}\\n.pager .disabled > a,\\n.pager .disabled > a:hover,\\n.pager .disabled > a:focus,\\n.pager .disabled > span {\\n  color: #777;\\n  cursor: not-allowed;\\n  background-color: #fff;\\n}\\n.label {\\n  display: inline;\\n  padding: .2em .6em .3em;\\n  font-size: 75%;\\n  font-weight: bold;\\n  line-height: 1;\\n  color: #fff;\\n  text-align: center;\\n  white-space: nowrap;\\n  vertical-align: baseline;\\n  border-radius: .25em;\\n}\\na.label:hover,\\na.label:focus {\\n  color: #fff;\\n  text-decoration: none;\\n  cursor: pointer;\\n}\\n.label:empty {\\n  display: none;\\n}\\n.btn .label {\\n  position: relative;\\n  top: -1px;\\n}\\n.label-default {\\n  background-color: #777;\\n}\\n.label-default[href]:hover,\\n.label-default[href]:focus {\\n  background-color: #5e5e5e;\\n}\\n.label-primary {\\n  background-color: #337ab7;\\n}\\n.label-primary[href]:hover,\\n.label-primary[href]:focus {\\n  background-color: #286090;\\n}\\n.label-success {\\n  background-color: #5cb85c;\\n}\\n.label-success[href]:hover,\\n.label-success[href]:focus {\\n  background-color: #449d44;\\n}\\n.label-info {\\n  background-color: #5bc0de;\\n}\\n.label-info[href]:hover,\\n.label-info[href]:focus {\\n  background-color: #31b0d5;\\n}\\n.label-warning {\\n  background-color: #f0ad4e;\\n}\\n.label-warning[href]:hover,\\n.label-warning[href]:focus {\\n  background-color: #ec971f;\\n}\\n.label-danger {\\n  background-color: #d9534f;\\n}\\n.label-danger[href]:hover,\\n.label-danger[href]:focus {\\n  background-color: #c9302c;\\n}\\n.badge {\\n  display: inline-block;\\n  min-width: 10px;\\n  padding: 3px 7px;\\n  font-size: 12px;\\n  font-weight: bold;\\n  line-height: 1;\\n  color: #fff;\\n  text-align: center;\\n  white-space: nowrap;\\n  vertical-align: middle;\\n  background-color: #777;\\n  border-radius: 10px;\\n}\\n.badge:empty {\\n  display: none;\\n}\\n.btn .badge {\\n  position: relative;\\n  top: -1px;\\n}\\n.btn-xs .badge,\\n.btn-group-xs > .btn .badge {\\n  top: 0;\\n  padding: 1px 5px;\\n}\\na.badge:hover,\\na.badge:focus {\\n  color: #fff;\\n  text-decoration: none;\\n  cursor: pointer;\\n}\\n.list-group-item.active > .badge,\\n.nav-pills > .active > a > .badge {\\n  color: #337ab7;\\n  background-color: #fff;\\n}\\n.list-group-item > .badge {\\n  float: right;\\n}\\n.list-group-item > .badge + .badge {\\n  margin-right: 5px;\\n}\\n.nav-pills > li > a > .badge {\\n  margin-left: 3px;\\n}\\n.jumbotron {\\n  padding-top: 30px;\\n  padding-bottom: 30px;\\n  margin-bottom: 30px;\\n  color: inherit;\\n  background-color: #eee;\\n}\\n.jumbotron h1,\\n.jumbotron .h1 {\\n  color: inherit;\\n}\\n.jumbotron p {\\n  margin-bottom: 15px;\\n  font-size: 21px;\\n  font-weight: 200;\\n}\\n.jumbotron > hr {\\n  border-top-color: #d5d5d5;\\n}\\n.container .jumbotron,\\n.container-fluid .jumbotron {\\n  padding-right: 15px;\\n  padding-left: 15px;\\n  border-radius: 6px;\\n}\\n.jumbotron .container {\\n  max-width: 100%;\\n}\\n@media screen and (min-width: 768px) {\\n  .jumbotron {\\n    padding-top: 48px;\\n    padding-bottom: 48px;\\n  }\\n  .container .jumbotron,\\n  .container-fluid .jumbotron {\\n    padding-right: 60px;\\n    padding-left: 60px;\\n  }\\n  .jumbotron h1,\\n  .jumbotron .h1 {\\n    font-size: 63px;\\n  }\\n}\\n.thumbnail {\\n  display: block;\\n  padding: 4px;\\n  margin-bottom: 20px;\\n  line-height: 1.42857143;\\n  background-color: #fff;\\n  border: 1px solid #ddd;\\n  border-radius: 4px;\\n  -webkit-transition: border .2s ease-in-out;\\n       -o-transition: border .2s ease-in-out;\\n          transition: border .2s ease-in-out;\\n}\\n.thumbnail > img,\\n.thumbnail a > img {\\n  margin-right: auto;\\n  margin-left: auto;\\n}\\na.thumbnail:hover,\\na.thumbnail:focus,\\na.thumbnail.active {\\n  border-color: #337ab7;\\n}\\n.thumbnail .caption {\\n  padding: 9px;\\n  color: #333;\\n}\\n.alert {\\n  padding: 15px;\\n  margin-bottom: 20px;\\n  border: 1px solid transparent;\\n  border-radius: 4px;\\n}\\n.alert h4 {\\n  margin-top: 0;\\n  color: inherit;\\n}\\n.alert .alert-link {\\n  font-weight: bold;\\n}\\n.alert > p,\\n.alert > ul {\\n  margin-bottom: 0;\\n}\\n.alert > p + p {\\n  margin-top: 5px;\\n}\\n.alert-dismissable,\\n.alert-dismissible {\\n  padding-right: 35px;\\n}\\n.alert-dismissable .close,\\n.alert-dismissible .close {\\n  position: relative;\\n  top: -2px;\\n  right: -21px;\\n  color: inherit;\\n}\\n.alert-success {\\n  color: #3c763d;\\n  background-color: #dff0d8;\\n  border-color: #d6e9c6;\\n}\\n.alert-success hr {\\n  border-top-color: #c9e2b3;\\n}\\n.alert-success .alert-link {\\n  color: #2b542c;\\n}\\n.alert-info {\\n  color: #31708f;\\n  background-color: #d9edf7;\\n  border-color: #bce8f1;\\n}\\n.alert-info hr {\\n  border-top-color: #a6e1ec;\\n}\\n.alert-info .alert-link {\\n  color: #245269;\\n}\\n.alert-warning {\\n  color: #8a6d3b;\\n  background-color: #fcf8e3;\\n  border-color: #faebcc;\\n}\\n.alert-warning hr {\\n  border-top-color: #f7e1b5;\\n}\\n.alert-warning .alert-link {\\n  color: #66512c;\\n}\\n.alert-danger {\\n  color: #a94442;\\n  background-color: #f2dede;\\n  border-color: #ebccd1;\\n}\\n.alert-danger hr {\\n  border-top-color: #e4b9c0;\\n}\\n.alert-danger .alert-link {\\n  color: #843534;\\n}\\n@-webkit-keyframes progress-bar-stripes {\\n  from {\\n    background-position: 40px 0;\\n  }\\n  to {\\n    background-position: 0 0;\\n  }\\n}\\n@-o-keyframes progress-bar-stripes {\\n  from {\\n    background-position: 40px 0;\\n  }\\n  to {\\n    background-position: 0 0;\\n  }\\n}\\n@keyframes progress-bar-stripes {\\n  from {\\n    background-position: 40px 0;\\n  }\\n  to {\\n    background-position: 0 0;\\n  }\\n}\\n.progress {\\n  height: 20px;\\n  margin-bottom: 20px;\\n  overflow: hidden;\\n  background-color: #f5f5f5;\\n  border-radius: 4px;\\n  -webkit-box-shadow: inset 0 1px 2px rgba(0, 0, 0, .1);\\n          box-shadow: inset 0 1px 2px rgba(0, 0, 0, .1);\\n}\\n.progress-bar {\\n  float: left;\\n  width: 0;\\n  height: 100%;\\n  font-size: 12px;\\n  line-height: 20px;\\n  color: #fff;\\n  text-align: center;\\n  background-color: #337ab7;\\n  -webkit-box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .15);\\n          box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .15);\\n  -webkit-transition: width .6s ease;\\n       -o-transition: width .6s ease;\\n          transition: width .6s ease;\\n}\\n.progress-striped .progress-bar,\\n.progress-bar-striped {\\n  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  background-image:      -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  background-image:         linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  -webkit-background-size: 40px 40px;\\n          background-size: 40px 40px;\\n}\\n.progress.active .progress-bar,\\n.progress-bar.active {\\n  -webkit-animation: progress-bar-stripes 2s linear infinite;\\n       -o-animation: progress-bar-stripes 2s linear infinite;\\n          animation: progress-bar-stripes 2s linear infinite;\\n}\\n.progress-bar-success {\\n  background-color: #5cb85c;\\n}\\n.progress-striped .progress-bar-success {\\n  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  background-image:      -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  background-image:         linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n}\\n.progress-bar-info {\\n  background-color: #5bc0de;\\n}\\n.progress-striped .progress-bar-info {\\n  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  background-image:      -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  background-image:         linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n}\\n.progress-bar-warning {\\n  background-color: #f0ad4e;\\n}\\n.progress-striped .progress-bar-warning {\\n  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  background-image:      -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  background-image:         linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n}\\n.progress-bar-danger {\\n  background-color: #d9534f;\\n}\\n.progress-striped .progress-bar-danger {\\n  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  background-image:      -o-linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n  background-image:         linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);\\n}\\n.media {\\n  margin-top: 15px;\\n}\\n.media:first-child {\\n  margin-top: 0;\\n}\\n.media,\\n.media-body {\\n  overflow: hidden;\\n  zoom: 1;\\n}\\n.media-body {\\n  width: 10000px;\\n}\\n.media-object {\\n  display: block;\\n}\\n.media-object.img-thumbnail {\\n  max-width: none;\\n}\\n.media-right,\\n.media > .pull-right {\\n  padding-left: 10px;\\n}\\n.media-left,\\n.media > .pull-left {\\n  padding-right: 10px;\\n}\\n.media-left,\\n.media-right,\\n.media-body {\\n  display: table-cell;\\n  vertical-align: top;\\n}\\n.media-middle {\\n  vertical-align: middle;\\n}\\n.media-bottom {\\n  vertical-align: bottom;\\n}\\n.media-heading {\\n  margin-top: 0;\\n  margin-bottom: 5px;\\n}\\n.media-list {\\n  padding-left: 0;\\n  list-style: none;\\n}\\n.list-group {\\n  padding-left: 0;\\n  margin-bottom: 20px;\\n}\\n.list-group-item {\\n  position: relative;\\n  display: block;\\n  padding: 10px 15px;\\n  margin-bottom: -1px;\\n  background-color: #fff;\\n  border: 1px solid #ddd;\\n}\\n.list-group-item:first-child {\\n  border-top-left-radius: 4px;\\n  border-top-right-radius: 4px;\\n}\\n.list-group-item:last-child {\\n  margin-bottom: 0;\\n  border-bottom-right-radius: 4px;\\n  border-bottom-left-radius: 4px;\\n}\\na.list-group-item,\\nbutton.list-group-item {\\n  color: #555;\\n}\\na.list-group-item .list-group-item-heading,\\nbutton.list-group-item .list-group-item-heading {\\n  color: #333;\\n}\\na.list-group-item:hover,\\nbutton.list-group-item:hover,\\na.list-group-item:focus,\\nbutton.list-group-item:focus {\\n  color: #555;\\n  text-decoration: none;\\n  background-color: #f5f5f5;\\n}\\nbutton.list-group-item {\\n  width: 100%;\\n  text-align: left;\\n}\\n.list-group-item.disabled,\\n.list-group-item.disabled:hover,\\n.list-group-item.disabled:focus {\\n  color: #777;\\n  cursor: not-allowed;\\n  background-color: #eee;\\n}\\n.list-group-item.disabled .list-group-item-heading,\\n.list-group-item.disabled:hover .list-group-item-heading,\\n.list-group-item.disabled:focus .list-group-item-heading {\\n  color: inherit;\\n}\\n.list-group-item.disabled .list-group-item-text,\\n.list-group-item.disabled:hover .list-group-item-text,\\n.list-group-item.disabled:focus .list-group-item-text {\\n  color: #777;\\n}\\n.list-group-item.active,\\n.list-group-item.active:hover,\\n.list-group-item.active:focus {\\n  z-index: 2;\\n  color: #fff;\\n  background-color: #337ab7;\\n  border-color: #337ab7;\\n}\\n.list-group-item.active .list-group-item-heading,\\n.list-group-item.active:hover .list-group-item-heading,\\n.list-group-item.active:focus .list-group-item-heading,\\n.list-group-item.active .list-group-item-heading > small,\\n.list-group-item.active:hover .list-group-item-heading > small,\\n.list-group-item.active:focus .list-group-item-heading > small,\\n.list-group-item.active .list-group-item-heading > .small,\\n.list-group-item.active:hover .list-group-item-heading > .small,\\n.list-group-item.active:focus .list-group-item-heading > .small {\\n  color: inherit;\\n}\\n.list-group-item.active .list-group-item-text,\\n.list-group-item.active:hover .list-group-item-text,\\n.list-group-item.active:focus .list-group-item-text {\\n  color: #c7ddef;\\n}\\n.list-group-item-success {\\n  color: #3c763d;\\n  background-color: #dff0d8;\\n}\\na.list-group-item-success,\\nbutton.list-group-item-success {\\n  color: #3c763d;\\n}\\na.list-group-item-success .list-group-item-heading,\\nbutton.list-group-item-success .list-group-item-heading {\\n  color: inherit;\\n}\\na.list-group-item-success:hover,\\nbutton.list-group-item-success:hover,\\na.list-group-item-success:focus,\\nbutton.list-group-item-success:focus {\\n  color: #3c763d;\\n  background-color: #d0e9c6;\\n}\\na.list-group-item-success.active,\\nbutton.list-group-item-success.active,\\na.list-group-item-success.active:hover,\\nbutton.list-group-item-success.active:hover,\\na.list-group-item-success.active:focus,\\nbutton.list-group-item-success.active:focus {\\n  color: #fff;\\n  background-color: #3c763d;\\n  border-color: #3c763d;\\n}\\n.list-group-item-info {\\n  color: #31708f;\\n  background-color: #d9edf7;\\n}\\na.list-group-item-info,\\nbutton.list-group-item-info {\\n  color: #31708f;\\n}\\na.list-group-item-info .list-group-item-heading,\\nbutton.list-group-item-info .list-group-item-heading {\\n  color: inherit;\\n}\\na.list-group-item-info:hover,\\nbutton.list-group-item-info:hover,\\na.list-group-item-info:focus,\\nbutton.list-group-item-info:focus {\\n  color: #31708f;\\n  background-color: #c4e3f3;\\n}\\na.list-group-item-info.active,\\nbutton.list-group-item-info.active,\\na.list-group-item-info.active:hover,\\nbutton.list-group-item-info.active:hover,\\na.list-group-item-info.active:focus,\\nbutton.list-group-item-info.active:focus {\\n  color: #fff;\\n  background-color: #31708f;\\n  border-color: #31708f;\\n}\\n.list-group-item-warning {\\n  color: #8a6d3b;\\n  background-color: #fcf8e3;\\n}\\na.list-group-item-warning,\\nbutton.list-group-item-warning {\\n  color: #8a6d3b;\\n}\\na.list-group-item-warning .list-group-item-heading,\\nbutton.list-group-item-warning .list-group-item-heading {\\n  color: inherit;\\n}\\na.list-group-item-warning:hover,\\nbutton.list-group-item-warning:hover,\\na.list-group-item-warning:focus,\\nbutton.list-group-item-warning:focus {\\n  color: #8a6d3b;\\n  background-color: #faf2cc;\\n}\\na.list-group-item-warning.active,\\nbutton.list-group-item-warning.active,\\na.list-group-item-warning.active:hover,\\nbutton.list-group-item-warning.active:hover,\\na.list-group-item-warning.active:focus,\\nbutton.list-group-item-warning.active:focus {\\n  color: #fff;\\n  background-color: #8a6d3b;\\n  border-color: #8a6d3b;\\n}\\n.list-group-item-danger {\\n  color: #a94442;\\n  background-color: #f2dede;\\n}\\na.list-group-item-danger,\\nbutton.list-group-item-danger {\\n  color: #a94442;\\n}\\na.list-group-item-danger .list-group-item-heading,\\nbutton.list-group-item-danger .list-group-item-heading {\\n  color: inherit;\\n}\\na.list-group-item-danger:hover,\\nbutton.list-group-item-danger:hover,\\na.list-group-item-danger:focus,\\nbutton.list-group-item-danger:focus {\\n  color: #a94442;\\n  background-color: #ebcccc;\\n}\\na.list-group-item-danger.active,\\nbutton.list-group-item-danger.active,\\na.list-group-item-danger.active:hover,\\nbutton.list-group-item-danger.active:hover,\\na.list-group-item-danger.active:focus,\\nbutton.list-group-item-danger.active:focus {\\n  color: #fff;\\n  background-color: #a94442;\\n  border-color: #a94442;\\n}\\n.list-group-item-heading {\\n  margin-top: 0;\\n  margin-bottom: 5px;\\n}\\n.list-group-item-text {\\n  margin-bottom: 0;\\n  line-height: 1.3;\\n}\\n.panel {\\n  margin-bottom: 20px;\\n  background-color: #fff;\\n  border: 1px solid transparent;\\n  border-radius: 4px;\\n  -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, .05);\\n          box-shadow: 0 1px 1px rgba(0, 0, 0, .05);\\n}\\n.panel-body {\\n  padding: 15px;\\n}\\n.panel-heading {\\n  padding: 10px 15px;\\n  border-bottom: 1px solid transparent;\\n  border-top-left-radius: 3px;\\n  border-top-right-radius: 3px;\\n}\\n.panel-heading > .dropdown .dropdown-toggle {\\n  color: inherit;\\n}\\n.panel-title {\\n  margin-top: 0;\\n  margin-bottom: 0;\\n  font-size: 16px;\\n  color: inherit;\\n}\\n.panel-title > a,\\n.panel-title > small,\\n.panel-title > .small,\\n.panel-title > small > a,\\n.panel-title > .small > a {\\n  color: inherit;\\n}\\n.panel-footer {\\n  padding: 10px 15px;\\n  background-color: #f5f5f5;\\n  border-top: 1px solid #ddd;\\n  border-bottom-right-radius: 3px;\\n  border-bottom-left-radius: 3px;\\n}\\n.panel > .list-group,\\n.panel > .panel-collapse > .list-group {\\n  margin-bottom: 0;\\n}\\n.panel > .list-group .list-group-item,\\n.panel > .panel-collapse > .list-group .list-group-item {\\n  border-width: 1px 0;\\n  border-radius: 0;\\n}\\n.panel > .list-group:first-child .list-group-item:first-child,\\n.panel > .panel-collapse > .list-group:first-child .list-group-item:first-child {\\n  border-top: 0;\\n  border-top-left-radius: 3px;\\n  border-top-right-radius: 3px;\\n}\\n.panel > .list-group:last-child .list-group-item:last-child,\\n.panel > .panel-collapse > .list-group:last-child .list-group-item:last-child {\\n  border-bottom: 0;\\n  border-bottom-right-radius: 3px;\\n  border-bottom-left-radius: 3px;\\n}\\n.panel > .panel-heading + .panel-collapse > .list-group .list-group-item:first-child {\\n  border-top-left-radius: 0;\\n  border-top-right-radius: 0;\\n}\\n.panel-heading + .list-group .list-group-item:first-child {\\n  border-top-width: 0;\\n}\\n.list-group + .panel-footer {\\n  border-top-width: 0;\\n}\\n.panel > .table,\\n.panel > .table-responsive > .table,\\n.panel > .panel-collapse > .table {\\n  margin-bottom: 0;\\n}\\n.panel > .table caption,\\n.panel > .table-responsive > .table caption,\\n.panel > .panel-collapse > .table caption {\\n  padding-right: 15px;\\n  padding-left: 15px;\\n}\\n.panel > .table:first-child,\\n.panel > .table-responsive:first-child > .table:first-child {\\n  border-top-left-radius: 3px;\\n  border-top-right-radius: 3px;\\n}\\n.panel > .table:first-child > thead:first-child > tr:first-child,\\n.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child,\\n.panel > .table:first-child > tbody:first-child > tr:first-child,\\n.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child {\\n  border-top-left-radius: 3px;\\n  border-top-right-radius: 3px;\\n}\\n.panel > .table:first-child > thead:first-child > tr:first-child td:first-child,\\n.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child td:first-child,\\n.panel > .table:first-child > tbody:first-child > tr:first-child td:first-child,\\n.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child td:first-child,\\n.panel > .table:first-child > thead:first-child > tr:first-child th:first-child,\\n.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child th:first-child,\\n.panel > .table:first-child > tbody:first-child > tr:first-child th:first-child,\\n.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child th:first-child {\\n  border-top-left-radius: 3px;\\n}\\n.panel > .table:first-child > thead:first-child > tr:first-child td:last-child,\\n.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child td:last-child,\\n.panel > .table:first-child > tbody:first-child > tr:first-child td:last-child,\\n.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child td:last-child,\\n.panel > .table:first-child > thead:first-child > tr:first-child th:last-child,\\n.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child th:last-child,\\n.panel > .table:first-child > tbody:first-child > tr:first-child th:last-child,\\n.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child th:last-child {\\n  border-top-right-radius: 3px;\\n}\\n.panel > .table:last-child,\\n.panel > .table-responsive:last-child > .table:last-child {\\n  border-bottom-right-radius: 3px;\\n  border-bottom-left-radius: 3px;\\n}\\n.panel > .table:last-child > tbody:last-child > tr:last-child,\\n.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child,\\n.panel > .table:last-child > tfoot:last-child > tr:last-child,\\n.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child {\\n  border-bottom-right-radius: 3px;\\n  border-bottom-left-radius: 3px;\\n}\\n.panel > .table:last-child > tbody:last-child > tr:last-child td:first-child,\\n.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child td:first-child,\\n.panel > .table:last-child > tfoot:last-child > tr:last-child td:first-child,\\n.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child td:first-child,\\n.panel > .table:last-child > tbody:last-child > tr:last-child th:first-child,\\n.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child th:first-child,\\n.panel > .table:last-child > tfoot:last-child > tr:last-child th:first-child,\\n.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child th:first-child {\\n  border-bottom-left-radius: 3px;\\n}\\n.panel > .table:last-child > tbody:last-child > tr:last-child td:last-child,\\n.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child td:last-child,\\n.panel > .table:last-child > tfoot:last-child > tr:last-child td:last-child,\\n.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child td:last-child,\\n.panel > .table:last-child > tbody:last-child > tr:last-child th:last-child,\\n.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child th:last-child,\\n.panel > .table:last-child > tfoot:last-child > tr:last-child th:last-child,\\n.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child th:last-child {\\n  border-bottom-right-radius: 3px;\\n}\\n.panel > .panel-body + .table,\\n.panel > .panel-body + .table-responsive,\\n.panel > .table + .panel-body,\\n.panel > .table-responsive + .panel-body {\\n  border-top: 1px solid #ddd;\\n}\\n.panel > .table > tbody:first-child > tr:first-child th,\\n.panel > .table > tbody:first-child > tr:first-child td {\\n  border-top: 0;\\n}\\n.panel > .table-bordered,\\n.panel > .table-responsive > .table-bordered {\\n  border: 0;\\n}\\n.panel > .table-bordered > thead > tr > th:first-child,\\n.panel > .table-responsive > .table-bordered > thead > tr > th:first-child,\\n.panel > .table-bordered > tbody > tr > th:first-child,\\n.panel > .table-responsive > .table-bordered > tbody > tr > th:first-child,\\n.panel > .table-bordered > tfoot > tr > th:first-child,\\n.panel > .table-responsive > .table-bordered > tfoot > tr > th:first-child,\\n.panel > .table-bordered > thead > tr > td:first-child,\\n.panel > .table-responsive > .table-bordered > thead > tr > td:first-child,\\n.panel > .table-bordered > tbody > tr > td:first-child,\\n.panel > .table-responsive > .table-bordered > tbody > tr > td:first-child,\\n.panel > .table-bordered > tfoot > tr > td:first-child,\\n.panel > .table-responsive > .table-bordered > tfoot > tr > td:first-child {\\n  border-left: 0;\\n}\\n.panel > .table-bordered > thead > tr > th:last-child,\\n.panel > .table-responsive > .table-bordered > thead > tr > th:last-child,\\n.panel > .table-bordered > tbody > tr > th:last-child,\\n.panel > .table-responsive > .table-bordered > tbody > tr > th:last-child,\\n.panel > .table-bordered > tfoot > tr > th:last-child,\\n.panel > .table-responsive > .table-bordered > tfoot > tr > th:last-child,\\n.panel > .table-bordered > thead > tr > td:last-child,\\n.panel > .table-responsive > .table-bordered > thead > tr > td:last-child,\\n.panel > .table-bordered > tbody > tr > td:last-child,\\n.panel > .table-responsive > .table-bordered > tbody > tr > td:last-child,\\n.panel > .table-bordered > tfoot > tr > td:last-child,\\n.panel > .table-responsive > .table-bordered > tfoot > tr > td:last-child {\\n  border-right: 0;\\n}\\n.panel > .table-bordered > thead > tr:first-child > td,\\n.panel > .table-responsive > .table-bordered > thead > tr:first-child > td,\\n.panel > .table-bordered > tbody > tr:first-child > td,\\n.panel > .table-responsive > .table-bordered > tbody > tr:first-child > td,\\n.panel > .table-bordered > thead > tr:first-child > th,\\n.panel > .table-responsive > .table-bordered > thead > tr:first-child > th,\\n.panel > .table-bordered > tbody > tr:first-child > th,\\n.panel > .table-responsive > .table-bordered > tbody > tr:first-child > th {\\n  border-bottom: 0;\\n}\\n.panel > .table-bordered > tbody > tr:last-child > td,\\n.panel > .table-responsive > .table-bordered > tbody > tr:last-child > td,\\n.panel > .table-bordered > tfoot > tr:last-child > td,\\n.panel > .table-responsive > .table-bordered > tfoot > tr:last-child > td,\\n.panel > .table-bordered > tbody > tr:last-child > th,\\n.panel > .table-responsive > .table-bordered > tbody > tr:last-child > th,\\n.panel > .table-bordered > tfoot > tr:last-child > th,\\n.panel > .table-responsive > .table-bordered > tfoot > tr:last-child > th {\\n  border-bottom: 0;\\n}\\n.panel > .table-responsive {\\n  margin-bottom: 0;\\n  border: 0;\\n}\\n.panel-group {\\n  margin-bottom: 20px;\\n}\\n.panel-group .panel {\\n  margin-bottom: 0;\\n  border-radius: 4px;\\n}\\n.panel-group .panel + .panel {\\n  margin-top: 5px;\\n}\\n.panel-group .panel-heading {\\n  border-bottom: 0;\\n}\\n.panel-group .panel-heading + .panel-collapse > .panel-body,\\n.panel-group .panel-heading + .panel-collapse > .list-group {\\n  border-top: 1px solid #ddd;\\n}\\n.panel-group .panel-footer {\\n  border-top: 0;\\n}\\n.panel-group .panel-footer + .panel-collapse .panel-body {\\n  border-bottom: 1px solid #ddd;\\n}\\n.panel-default {\\n  border-color: #ddd;\\n}\\n.panel-default > .panel-heading {\\n  color: #333;\\n  background-color: #f5f5f5;\\n  border-color: #ddd;\\n}\\n.panel-default > .panel-heading + .panel-collapse > .panel-body {\\n  border-top-color: #ddd;\\n}\\n.panel-default > .panel-heading .badge {\\n  color: #f5f5f5;\\n  background-color: #333;\\n}\\n.panel-default > .panel-footer + .panel-collapse > .panel-body {\\n  border-bottom-color: #ddd;\\n}\\n.panel-primary {\\n  border-color: #337ab7;\\n}\\n.panel-primary > .panel-heading {\\n  color: #fff;\\n  background-color: #337ab7;\\n  border-color: #337ab7;\\n}\\n.panel-primary > .panel-heading + .panel-collapse > .panel-body {\\n  border-top-color: #337ab7;\\n}\\n.panel-primary > .panel-heading .badge {\\n  color: #337ab7;\\n  background-color: #fff;\\n}\\n.panel-primary > .panel-footer + .panel-collapse > .panel-body {\\n  border-bottom-color: #337ab7;\\n}\\n.panel-success {\\n  border-color: #d6e9c6;\\n}\\n.panel-success > .panel-heading {\\n  color: #3c763d;\\n  background-color: #dff0d8;\\n  border-color: #d6e9c6;\\n}\\n.panel-success > .panel-heading + .panel-collapse > .panel-body {\\n  border-top-color: #d6e9c6;\\n}\\n.panel-success > .panel-heading .badge {\\n  color: #dff0d8;\\n  background-color: #3c763d;\\n}\\n.panel-success > .panel-footer + .panel-collapse > .panel-body {\\n  border-bottom-color: #d6e9c6;\\n}\\n.panel-info {\\n  border-color: #bce8f1;\\n}\\n.panel-info > .panel-heading {\\n  color: #31708f;\\n  background-color: #d9edf7;\\n  border-color: #bce8f1;\\n}\\n.panel-info > .panel-heading + .panel-collapse > .panel-body {\\n  border-top-color: #bce8f1;\\n}\\n.panel-info > .panel-heading .badge {\\n  color: #d9edf7;\\n  background-color: #31708f;\\n}\\n.panel-info > .panel-footer + .panel-collapse > .panel-body {\\n  border-bottom-color: #bce8f1;\\n}\\n.panel-warning {\\n  border-color: #faebcc;\\n}\\n.panel-warning > .panel-heading {\\n  color: #8a6d3b;\\n  background-color: #fcf8e3;\\n  border-color: #faebcc;\\n}\\n.panel-warning > .panel-heading + .panel-collapse > .panel-body {\\n  border-top-color: #faebcc;\\n}\\n.panel-warning > .panel-heading .badge {\\n  color: #fcf8e3;\\n  background-color: #8a6d3b;\\n}\\n.panel-warning > .panel-footer + .panel-collapse > .panel-body {\\n  border-bottom-color: #faebcc;\\n}\\n.panel-danger {\\n  border-color: #ebccd1;\\n}\\n.panel-danger > .panel-heading {\\n  color: #a94442;\\n  background-color: #f2dede;\\n  border-color: #ebccd1;\\n}\\n.panel-danger > .panel-heading + .panel-collapse > .panel-body {\\n  border-top-color: #ebccd1;\\n}\\n.panel-danger > .panel-heading .badge {\\n  color: #f2dede;\\n  background-color: #a94442;\\n}\\n.panel-danger > .panel-footer + .panel-collapse > .panel-body {\\n  border-bottom-color: #ebccd1;\\n}\\n.embed-responsive {\\n  position: relative;\\n  display: block;\\n  height: 0;\\n  padding: 0;\\n  overflow: hidden;\\n}\\n.embed-responsive .embed-responsive-item,\\n.embed-responsive iframe,\\n.embed-responsive embed,\\n.embed-responsive object,\\n.embed-responsive video {\\n  position: absolute;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  border: 0;\\n}\\n.embed-responsive-16by9 {\\n  padding-bottom: 56.25%;\\n}\\n.embed-responsive-4by3 {\\n  padding-bottom: 75%;\\n}\\n.well {\\n  min-height: 20px;\\n  padding: 19px;\\n  margin-bottom: 20px;\\n  background-color: #f5f5f5;\\n  border: 1px solid #e3e3e3;\\n  border-radius: 4px;\\n  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05);\\n          box-shadow: inset 0 1px 1px rgba(0, 0, 0, .05);\\n}\\n.well blockquote {\\n  border-color: #ddd;\\n  border-color: rgba(0, 0, 0, .15);\\n}\\n.well-lg {\\n  padding: 24px;\\n  border-radius: 6px;\\n}\\n.well-sm {\\n  padding: 9px;\\n  border-radius: 3px;\\n}\\n.close {\\n  float: right;\\n  font-size: 21px;\\n  font-weight: bold;\\n  line-height: 1;\\n  color: #000;\\n  text-shadow: 0 1px 0 #fff;\\n  filter: alpha(opacity=20);\\n  opacity: .2;\\n}\\n.close:hover,\\n.close:focus {\\n  color: #000;\\n  text-decoration: none;\\n  cursor: pointer;\\n  filter: alpha(opacity=50);\\n  opacity: .5;\\n}\\nbutton.close {\\n  -webkit-appearance: none;\\n  padding: 0;\\n  cursor: pointer;\\n  background: transparent;\\n  border: 0;\\n}\\n.modal-open {\\n  overflow: hidden;\\n}\\n.modal {\\n  position: fixed;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  z-index: 1050;\\n  display: none;\\n  overflow: hidden;\\n  -webkit-overflow-scrolling: touch;\\n  outline: 0;\\n}\\n.modal.fade .modal-dialog {\\n  -webkit-transition: -webkit-transform .3s ease-out;\\n       -o-transition:      -o-transform .3s ease-out;\\n          transition:         transform .3s ease-out;\\n  -webkit-transform: translate(0, -25%);\\n      -ms-transform: translate(0, -25%);\\n       -o-transform: translate(0, -25%);\\n          transform: translate(0, -25%);\\n}\\n.modal.in .modal-dialog {\\n  -webkit-transform: translate(0, 0);\\n      -ms-transform: translate(0, 0);\\n       -o-transform: translate(0, 0);\\n          transform: translate(0, 0);\\n}\\n.modal-open .modal {\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n}\\n.modal-dialog {\\n  position: relative;\\n  width: auto;\\n  margin: 10px;\\n}\\n.modal-content {\\n  position: relative;\\n  background-color: #fff;\\n  -webkit-background-clip: padding-box;\\n          background-clip: padding-box;\\n  border: 1px solid #999;\\n  border: 1px solid rgba(0, 0, 0, .2);\\n  border-radius: 6px;\\n  outline: 0;\\n  -webkit-box-shadow: 0 3px 9px rgba(0, 0, 0, .5);\\n          box-shadow: 0 3px 9px rgba(0, 0, 0, .5);\\n}\\n.modal-backdrop {\\n  position: fixed;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  z-index: 1040;\\n  background-color: #000;\\n}\\n.modal-backdrop.fade {\\n  filter: alpha(opacity=0);\\n  opacity: 0;\\n}\\n.modal-backdrop.in {\\n  filter: alpha(opacity=50);\\n  opacity: .5;\\n}\\n.modal-header {\\n  padding: 15px;\\n  border-bottom: 1px solid #e5e5e5;\\n}\\n.modal-header .close {\\n  margin-top: -2px;\\n}\\n.modal-title {\\n  margin: 0;\\n  line-height: 1.42857143;\\n}\\n.modal-body {\\n  position: relative;\\n  padding: 15px;\\n}\\n.modal-footer {\\n  padding: 15px;\\n  text-align: right;\\n  border-top: 1px solid #e5e5e5;\\n}\\n.modal-footer .btn + .btn {\\n  margin-bottom: 0;\\n  margin-left: 5px;\\n}\\n.modal-footer .btn-group .btn + .btn {\\n  margin-left: -1px;\\n}\\n.modal-footer .btn-block + .btn-block {\\n  margin-left: 0;\\n}\\n.modal-scrollbar-measure {\\n  position: absolute;\\n  top: -9999px;\\n  width: 50px;\\n  height: 50px;\\n  overflow: scroll;\\n}\\n@media (min-width: 768px) {\\n  .modal-dialog {\\n    width: 600px;\\n    margin: 30px auto;\\n  }\\n  .modal-content {\\n    -webkit-box-shadow: 0 5px 15px rgba(0, 0, 0, .5);\\n            box-shadow: 0 5px 15px rgba(0, 0, 0, .5);\\n  }\\n  .modal-sm {\\n    width: 300px;\\n  }\\n}\\n@media (min-width: 992px) {\\n  .modal-lg {\\n    width: 900px;\\n  }\\n}\\n.tooltip {\\n  position: absolute;\\n  z-index: 1070;\\n  display: block;\\n  font-family: \\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif;\\n  font-size: 12px;\\n  font-style: normal;\\n  font-weight: normal;\\n  line-height: 1.42857143;\\n  text-align: left;\\n  text-align: start;\\n  text-decoration: none;\\n  text-shadow: none;\\n  text-transform: none;\\n  letter-spacing: normal;\\n  word-break: normal;\\n  word-spacing: normal;\\n  word-wrap: normal;\\n  white-space: normal;\\n  filter: alpha(opacity=0);\\n  opacity: 0;\\n\\n  line-break: auto;\\n}\\n.tooltip.in {\\n  filter: alpha(opacity=90);\\n  opacity: .9;\\n}\\n.tooltip.top {\\n  padding: 5px 0;\\n  margin-top: -3px;\\n}\\n.tooltip.right {\\n  padding: 0 5px;\\n  margin-left: 3px;\\n}\\n.tooltip.bottom {\\n  padding: 5px 0;\\n  margin-top: 3px;\\n}\\n.tooltip.left {\\n  padding: 0 5px;\\n  margin-left: -3px;\\n}\\n.tooltip-inner {\\n  max-width: 200px;\\n  padding: 3px 8px;\\n  color: #fff;\\n  text-align: center;\\n  background-color: #000;\\n  border-radius: 4px;\\n}\\n.tooltip-arrow {\\n  position: absolute;\\n  width: 0;\\n  height: 0;\\n  border-color: transparent;\\n  border-style: solid;\\n}\\n.tooltip.top .tooltip-arrow {\\n  bottom: 0;\\n  left: 50%;\\n  margin-left: -5px;\\n  border-width: 5px 5px 0;\\n  border-top-color: #000;\\n}\\n.tooltip.top-left .tooltip-arrow {\\n  right: 5px;\\n  bottom: 0;\\n  margin-bottom: -5px;\\n  border-width: 5px 5px 0;\\n  border-top-color: #000;\\n}\\n.tooltip.top-right .tooltip-arrow {\\n  bottom: 0;\\n  left: 5px;\\n  margin-bottom: -5px;\\n  border-width: 5px 5px 0;\\n  border-top-color: #000;\\n}\\n.tooltip.right .tooltip-arrow {\\n  top: 50%;\\n  left: 0;\\n  margin-top: -5px;\\n  border-width: 5px 5px 5px 0;\\n  border-right-color: #000;\\n}\\n.tooltip.left .tooltip-arrow {\\n  top: 50%;\\n  right: 0;\\n  margin-top: -5px;\\n  border-width: 5px 0 5px 5px;\\n  border-left-color: #000;\\n}\\n.tooltip.bottom .tooltip-arrow {\\n  top: 0;\\n  left: 50%;\\n  margin-left: -5px;\\n  border-width: 0 5px 5px;\\n  border-bottom-color: #000;\\n}\\n.tooltip.bottom-left .tooltip-arrow {\\n  top: 0;\\n  right: 5px;\\n  margin-top: -5px;\\n  border-width: 0 5px 5px;\\n  border-bottom-color: #000;\\n}\\n.tooltip.bottom-right .tooltip-arrow {\\n  top: 0;\\n  left: 5px;\\n  margin-top: -5px;\\n  border-width: 0 5px 5px;\\n  border-bottom-color: #000;\\n}\\n.popover {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  z-index: 1060;\\n  display: none;\\n  max-width: 276px;\\n  padding: 1px;\\n  font-family: \\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif;\\n  font-size: 14px;\\n  font-style: normal;\\n  font-weight: normal;\\n  line-height: 1.42857143;\\n  text-align: left;\\n  text-align: start;\\n  text-decoration: none;\\n  text-shadow: none;\\n  text-transform: none;\\n  letter-spacing: normal;\\n  word-break: normal;\\n  word-spacing: normal;\\n  word-wrap: normal;\\n  white-space: normal;\\n  background-color: #fff;\\n  -webkit-background-clip: padding-box;\\n          background-clip: padding-box;\\n  border: 1px solid #ccc;\\n  border: 1px solid rgba(0, 0, 0, .2);\\n  border-radius: 6px;\\n  -webkit-box-shadow: 0 5px 10px rgba(0, 0, 0, .2);\\n          box-shadow: 0 5px 10px rgba(0, 0, 0, .2);\\n\\n  line-break: auto;\\n}\\n.popover.top {\\n  margin-top: -10px;\\n}\\n.popover.right {\\n  margin-left: 10px;\\n}\\n.popover.bottom {\\n  margin-top: 10px;\\n}\\n.popover.left {\\n  margin-left: -10px;\\n}\\n.popover-title {\\n  padding: 8px 14px;\\n  margin: 0;\\n  font-size: 14px;\\n  background-color: #f7f7f7;\\n  border-bottom: 1px solid #ebebeb;\\n  border-radius: 5px 5px 0 0;\\n}\\n.popover-content {\\n  padding: 9px 14px;\\n}\\n.popover > .arrow,\\n.popover > .arrow:after {\\n  position: absolute;\\n  display: block;\\n  width: 0;\\n  height: 0;\\n  border-color: transparent;\\n  border-style: solid;\\n}\\n.popover > .arrow {\\n  border-width: 11px;\\n}\\n.popover > .arrow:after {\\n  content: \\\"\\\";\\n  border-width: 10px;\\n}\\n.popover.top > .arrow {\\n  bottom: -11px;\\n  left: 50%;\\n  margin-left: -11px;\\n  border-top-color: #999;\\n  border-top-color: rgba(0, 0, 0, .25);\\n  border-bottom-width: 0;\\n}\\n.popover.top > .arrow:after {\\n  bottom: 1px;\\n  margin-left: -10px;\\n  content: \\\" \\\";\\n  border-top-color: #fff;\\n  border-bottom-width: 0;\\n}\\n.popover.right > .arrow {\\n  top: 50%;\\n  left: -11px;\\n  margin-top: -11px;\\n  border-right-color: #999;\\n  border-right-color: rgba(0, 0, 0, .25);\\n  border-left-width: 0;\\n}\\n.popover.right > .arrow:after {\\n  bottom: -10px;\\n  left: 1px;\\n  content: \\\" \\\";\\n  border-right-color: #fff;\\n  border-left-width: 0;\\n}\\n.popover.bottom > .arrow {\\n  top: -11px;\\n  left: 50%;\\n  margin-left: -11px;\\n  border-top-width: 0;\\n  border-bottom-color: #999;\\n  border-bottom-color: rgba(0, 0, 0, .25);\\n}\\n.popover.bottom > .arrow:after {\\n  top: 1px;\\n  margin-left: -10px;\\n  content: \\\" \\\";\\n  border-top-width: 0;\\n  border-bottom-color: #fff;\\n}\\n.popover.left > .arrow {\\n  top: 50%;\\n  right: -11px;\\n  margin-top: -11px;\\n  border-right-width: 0;\\n  border-left-color: #999;\\n  border-left-color: rgba(0, 0, 0, .25);\\n}\\n.popover.left > .arrow:after {\\n  right: 1px;\\n  bottom: -10px;\\n  content: \\\" \\\";\\n  border-right-width: 0;\\n  border-left-color: #fff;\\n}\\n.carousel {\\n  position: relative;\\n}\\n.carousel-inner {\\n  position: relative;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n.carousel-inner > .item {\\n  position: relative;\\n  display: none;\\n  -webkit-transition: .6s ease-in-out left;\\n       -o-transition: .6s ease-in-out left;\\n          transition: .6s ease-in-out left;\\n}\\n.carousel-inner > .item > img,\\n.carousel-inner > .item > a > img {\\n  line-height: 1;\\n}\\n@media all and (transform-3d), (-webkit-transform-3d) {\\n  .carousel-inner > .item {\\n    -webkit-transition: -webkit-transform .6s ease-in-out;\\n         -o-transition:      -o-transform .6s ease-in-out;\\n            transition:         transform .6s ease-in-out;\\n\\n    -webkit-backface-visibility: hidden;\\n            backface-visibility: hidden;\\n    -webkit-perspective: 1000px;\\n            perspective: 1000px;\\n  }\\n  .carousel-inner > .item.next,\\n  .carousel-inner > .item.active.right {\\n    left: 0;\\n    -webkit-transform: translate3d(100%, 0, 0);\\n            transform: translate3d(100%, 0, 0);\\n  }\\n  .carousel-inner > .item.prev,\\n  .carousel-inner > .item.active.left {\\n    left: 0;\\n    -webkit-transform: translate3d(-100%, 0, 0);\\n            transform: translate3d(-100%, 0, 0);\\n  }\\n  .carousel-inner > .item.next.left,\\n  .carousel-inner > .item.prev.right,\\n  .carousel-inner > .item.active {\\n    left: 0;\\n    -webkit-transform: translate3d(0, 0, 0);\\n            transform: translate3d(0, 0, 0);\\n  }\\n}\\n.carousel-inner > .active,\\n.carousel-inner > .next,\\n.carousel-inner > .prev {\\n  display: block;\\n}\\n.carousel-inner > .active {\\n  left: 0;\\n}\\n.carousel-inner > .next,\\n.carousel-inner > .prev {\\n  position: absolute;\\n  top: 0;\\n  width: 100%;\\n}\\n.carousel-inner > .next {\\n  left: 100%;\\n}\\n.carousel-inner > .prev {\\n  left: -100%;\\n}\\n.carousel-inner > .next.left,\\n.carousel-inner > .prev.right {\\n  left: 0;\\n}\\n.carousel-inner > .active.left {\\n  left: -100%;\\n}\\n.carousel-inner > .active.right {\\n  left: 100%;\\n}\\n.carousel-control {\\n  position: absolute;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  width: 15%;\\n  font-size: 20px;\\n  color: #fff;\\n  text-align: center;\\n  text-shadow: 0 1px 2px rgba(0, 0, 0, .6);\\n  background-color: rgba(0, 0, 0, 0);\\n  filter: alpha(opacity=50);\\n  opacity: .5;\\n}\\n.carousel-control.left {\\n  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%);\\n  background-image:      -o-linear-gradient(left, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%);\\n  background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, .5)), to(rgba(0, 0, 0, .0001)));\\n  background-image:         linear-gradient(to right, rgba(0, 0, 0, .5) 0%, rgba(0, 0, 0, .0001) 100%);\\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);\\n  background-repeat: repeat-x;\\n}\\n.carousel-control.right {\\n  right: 0;\\n  left: auto;\\n  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, .0001) 0%, rgba(0, 0, 0, .5) 100%);\\n  background-image:      -o-linear-gradient(left, rgba(0, 0, 0, .0001) 0%, rgba(0, 0, 0, .5) 100%);\\n  background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, .0001)), to(rgba(0, 0, 0, .5)));\\n  background-image:         linear-gradient(to right, rgba(0, 0, 0, .0001) 0%, rgba(0, 0, 0, .5) 100%);\\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);\\n  background-repeat: repeat-x;\\n}\\n.carousel-control:hover,\\n.carousel-control:focus {\\n  color: #fff;\\n  text-decoration: none;\\n  filter: alpha(opacity=90);\\n  outline: 0;\\n  opacity: .9;\\n}\\n.carousel-control .icon-prev,\\n.carousel-control .icon-next,\\n.carousel-control .glyphicon-chevron-left,\\n.carousel-control .glyphicon-chevron-right {\\n  position: absolute;\\n  top: 50%;\\n  z-index: 5;\\n  display: inline-block;\\n  margin-top: -10px;\\n}\\n.carousel-control .icon-prev,\\n.carousel-control .glyphicon-chevron-left {\\n  left: 50%;\\n  margin-left: -10px;\\n}\\n.carousel-control .icon-next,\\n.carousel-control .glyphicon-chevron-right {\\n  right: 50%;\\n  margin-right: -10px;\\n}\\n.carousel-control .icon-prev,\\n.carousel-control .icon-next {\\n  width: 20px;\\n  height: 20px;\\n  font-family: serif;\\n  line-height: 1;\\n}\\n.carousel-control .icon-prev:before {\\n  content: '\\\\2039';\\n}\\n.carousel-control .icon-next:before {\\n  content: '\\\\203A';\\n}\\n.carousel-indicators {\\n  position: absolute;\\n  bottom: 10px;\\n  left: 50%;\\n  z-index: 15;\\n  width: 60%;\\n  padding-left: 0;\\n  margin-left: -30%;\\n  text-align: center;\\n  list-style: none;\\n}\\n.carousel-indicators li {\\n  display: inline-block;\\n  width: 10px;\\n  height: 10px;\\n  margin: 1px;\\n  text-indent: -999px;\\n  cursor: pointer;\\n  background-color: #000 \\\\9;\\n  background-color: rgba(0, 0, 0, 0);\\n  border: 1px solid #fff;\\n  border-radius: 10px;\\n}\\n.carousel-indicators .active {\\n  width: 12px;\\n  height: 12px;\\n  margin: 0;\\n  background-color: #fff;\\n}\\n.carousel-caption {\\n  position: absolute;\\n  right: 15%;\\n  bottom: 20px;\\n  left: 15%;\\n  z-index: 10;\\n  padding-top: 20px;\\n  padding-bottom: 20px;\\n  color: #fff;\\n  text-align: center;\\n  text-shadow: 0 1px 2px rgba(0, 0, 0, .6);\\n}\\n.carousel-caption .btn {\\n  text-shadow: none;\\n}\\n@media screen and (min-width: 768px) {\\n  .carousel-control .glyphicon-chevron-left,\\n  .carousel-control .glyphicon-chevron-right,\\n  .carousel-control .icon-prev,\\n  .carousel-control .icon-next {\\n    width: 30px;\\n    height: 30px;\\n    margin-top: -10px;\\n    font-size: 30px;\\n  }\\n  .carousel-control .glyphicon-chevron-left,\\n  .carousel-control .icon-prev {\\n    margin-left: -10px;\\n  }\\n  .carousel-control .glyphicon-chevron-right,\\n  .carousel-control .icon-next {\\n    margin-right: -10px;\\n  }\\n  .carousel-caption {\\n    right: 20%;\\n    left: 20%;\\n    padding-bottom: 30px;\\n  }\\n  .carousel-indicators {\\n    bottom: 20px;\\n  }\\n}\\n.clearfix:before,\\n.clearfix:after,\\n.dl-horizontal dd:before,\\n.dl-horizontal dd:after,\\n.container:before,\\n.container:after,\\n.container-fluid:before,\\n.container-fluid:after,\\n.row:before,\\n.row:after,\\n.form-horizontal .form-group:before,\\n.form-horizontal .form-group:after,\\n.btn-toolbar:before,\\n.btn-toolbar:after,\\n.btn-group-vertical > .btn-group:before,\\n.btn-group-vertical > .btn-group:after,\\n.nav:before,\\n.nav:after,\\n.navbar:before,\\n.navbar:after,\\n.navbar-header:before,\\n.navbar-header:after,\\n.navbar-collapse:before,\\n.navbar-collapse:after,\\n.pager:before,\\n.pager:after,\\n.panel-body:before,\\n.panel-body:after,\\n.modal-header:before,\\n.modal-header:after,\\n.modal-footer:before,\\n.modal-footer:after {\\n  display: table;\\n  content: \\\" \\\";\\n}\\n.clearfix:after,\\n.dl-horizontal dd:after,\\n.container:after,\\n.container-fluid:after,\\n.row:after,\\n.form-horizontal .form-group:after,\\n.btn-toolbar:after,\\n.btn-group-vertical > .btn-group:after,\\n.nav:after,\\n.navbar:after,\\n.navbar-header:after,\\n.navbar-collapse:after,\\n.pager:after,\\n.panel-body:after,\\n.modal-header:after,\\n.modal-footer:after {\\n  clear: both;\\n}\\n.center-block {\\n  display: block;\\n  margin-right: auto;\\n  margin-left: auto;\\n}\\n.pull-right {\\n  float: right !important;\\n}\\n.pull-left {\\n  float: left !important;\\n}\\n.hide {\\n  display: none !important;\\n}\\n.show {\\n  display: block !important;\\n}\\n.invisible {\\n  visibility: hidden;\\n}\\n.text-hide {\\n  font: 0/0 a;\\n  color: transparent;\\n  text-shadow: none;\\n  background-color: transparent;\\n  border: 0;\\n}\\n.hidden {\\n  display: none !important;\\n}\\n.affix {\\n  position: fixed;\\n}\\n@-ms-viewport {\\n  width: device-width;\\n}\\n.visible-xs,\\n.visible-sm,\\n.visible-md,\\n.visible-lg {\\n  display: none !important;\\n}\\n.visible-xs-block,\\n.visible-xs-inline,\\n.visible-xs-inline-block,\\n.visible-sm-block,\\n.visible-sm-inline,\\n.visible-sm-inline-block,\\n.visible-md-block,\\n.visible-md-inline,\\n.visible-md-inline-block,\\n.visible-lg-block,\\n.visible-lg-inline,\\n.visible-lg-inline-block {\\n  display: none !important;\\n}\\n@media (max-width: 767px) {\\n  .visible-xs {\\n    display: block !important;\\n  }\\n  table.visible-xs {\\n    display: table !important;\\n  }\\n  tr.visible-xs {\\n    display: table-row !important;\\n  }\\n  th.visible-xs,\\n  td.visible-xs {\\n    display: table-cell !important;\\n  }\\n}\\n@media (max-width: 767px) {\\n  .visible-xs-block {\\n    display: block !important;\\n  }\\n}\\n@media (max-width: 767px) {\\n  .visible-xs-inline {\\n    display: inline !important;\\n  }\\n}\\n@media (max-width: 767px) {\\n  .visible-xs-inline-block {\\n    display: inline-block !important;\\n  }\\n}\\n@media (min-width: 768px) and (max-width: 991px) {\\n  .visible-sm {\\n    display: block !important;\\n  }\\n  table.visible-sm {\\n    display: table !important;\\n  }\\n  tr.visible-sm {\\n    display: table-row !important;\\n  }\\n  th.visible-sm,\\n  td.visible-sm {\\n    display: table-cell !important;\\n  }\\n}\\n@media (min-width: 768px) and (max-width: 991px) {\\n  .visible-sm-block {\\n    display: block !important;\\n  }\\n}\\n@media (min-width: 768px) and (max-width: 991px) {\\n  .visible-sm-inline {\\n    display: inline !important;\\n  }\\n}\\n@media (min-width: 768px) and (max-width: 991px) {\\n  .visible-sm-inline-block {\\n    display: inline-block !important;\\n  }\\n}\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  .visible-md {\\n    display: block !important;\\n  }\\n  table.visible-md {\\n    display: table !important;\\n  }\\n  tr.visible-md {\\n    display: table-row !important;\\n  }\\n  th.visible-md,\\n  td.visible-md {\\n    display: table-cell !important;\\n  }\\n}\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  .visible-md-block {\\n    display: block !important;\\n  }\\n}\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  .visible-md-inline {\\n    display: inline !important;\\n  }\\n}\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  .visible-md-inline-block {\\n    display: inline-block !important;\\n  }\\n}\\n@media (min-width: 1200px) {\\n  .visible-lg {\\n    display: block !important;\\n  }\\n  table.visible-lg {\\n    display: table !important;\\n  }\\n  tr.visible-lg {\\n    display: table-row !important;\\n  }\\n  th.visible-lg,\\n  td.visible-lg {\\n    display: table-cell !important;\\n  }\\n}\\n@media (min-width: 1200px) {\\n  .visible-lg-block {\\n    display: block !important;\\n  }\\n}\\n@media (min-width: 1200px) {\\n  .visible-lg-inline {\\n    display: inline !important;\\n  }\\n}\\n@media (min-width: 1200px) {\\n  .visible-lg-inline-block {\\n    display: inline-block !important;\\n  }\\n}\\n@media (max-width: 767px) {\\n  .hidden-xs {\\n    display: none !important;\\n  }\\n}\\n@media (min-width: 768px) and (max-width: 991px) {\\n  .hidden-sm {\\n    display: none !important;\\n  }\\n}\\n@media (min-width: 992px) and (max-width: 1199px) {\\n  .hidden-md {\\n    display: none !important;\\n  }\\n}\\n@media (min-width: 1200px) {\\n  .hidden-lg {\\n    display: none !important;\\n  }\\n}\\n.visible-print {\\n  display: none !important;\\n}\\n@media print {\\n  .visible-print {\\n    display: block !important;\\n  }\\n  table.visible-print {\\n    display: table !important;\\n  }\\n  tr.visible-print {\\n    display: table-row !important;\\n  }\\n  th.visible-print,\\n  td.visible-print {\\n    display: table-cell !important;\\n  }\\n}\\n.visible-print-block {\\n  display: none !important;\\n}\\n@media print {\\n  .visible-print-block {\\n    display: block !important;\\n  }\\n}\\n.visible-print-inline {\\n  display: none !important;\\n}\\n@media print {\\n  .visible-print-inline {\\n    display: inline !important;\\n  }\\n}\\n.visible-print-inline-block {\\n  display: none !important;\\n}\\n@media print {\\n  .visible-print-inline-block {\\n    display: inline-block !important;\\n  }\\n}\\n@media print {\\n  .hidden-print {\\n    display: none !important;\\n  }\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./build/pkg-only/bundle/programs/web.browser/merged-stylesheets.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./meteor-app/client/main.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader!./meteor-app/client/main.css ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"body {\\n    padding: 10px;\\n    font-family: sans-serif;\\n}\\n\\n.logos {\\n    font-size: 20px;\\n}\\n\\n.logos img {\\n    width: 200px;\\n    vertical-align: middle;\\n}\\n\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./meteor-app/client/main.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/css-loader/lib/url/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/css-loader/lib/url/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/url/escape.js?");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v1.12.4\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-05-20T17:17Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Support: Firefox 18+\n// Can't be in strict mode, several libs including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n//\"use strict\";\nvar deletedIds = [];\n\nvar document = window.document;\n\nvar slice = deletedIds.slice;\n\nvar concat = deletedIds.concat;\n\nvar push = deletedIds.push;\n\nvar indexOf = deletedIds.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\tversion = \"1.12.4\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1, IE<9\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: deletedIds.sort,\n\tsplice: deletedIds.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar src, copyIsArray, copy, name, options, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === \"function\";\n\t},\n\n\tisArray: Array.isArray || function( obj ) {\n\t\treturn jQuery.type( obj ) === \"array\";\n\t},\n\n\tisWindow: function( obj ) {\n\t\t/* jshint eqeqeq: false */\n\t\treturn obj != null && obj == obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\tvar realStringObj = obj && obj.toString();\n\t\treturn !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar key;\n\n\t\t// Must be an Object.\n\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\tif ( !obj || jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Not own constructor property must be Object\n\t\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call( obj, \"constructor\" ) &&\n\t\t\t\t!hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\n\t\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n\t\t\treturn false;\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Handle iteration over inherited properties before own properties.\n\t\tif ( !support.ownFirst ) {\n\t\t\tfor ( key in obj ) {\n\t\t\t\treturn hasOwn.call( obj, key );\n\t\t\t}\n\t\t}\n\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tfor ( key in obj ) {}\n\n\t\treturn key === undefined || hasOwn.call( obj, key );\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Workarounds based on findings by Jim Driscoll\n\t// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n\tglobalEval: function( data ) {\n\t\tif ( data && jQuery.trim( data ) ) {\n\n\t\t\t// We use execScript on Internet Explorer\n\t\t\t// We use an anonymous function so that context is window\n\t\t\t// rather than jQuery in Firefox\n\t\t\t( window.execScript || function( data ) {\n\t\t\t\twindow[ \"eval\" ].call( window, data ); // jscs:ignore requireDotNotation\n\t\t\t} )( data );\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1, IE<9\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\tvar len;\n\n\t\tif ( arr ) {\n\t\t\tif ( indexOf ) {\n\t\t\t\treturn indexOf.call( arr, elem, i );\n\t\t\t}\n\n\t\t\tlen = arr.length;\n\t\t\ti = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n\t\t\tfor ( ; i < len; i++ ) {\n\n\t\t\t\t// Skip accessing in sparse arrays\n\t\t\t\tif ( i in arr && arr[ i ] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\twhile ( j < len ) {\n\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)\n\t\tif ( len !== len ) {\n\t\t\twhile ( second[ j ] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar args, proxy, tmp;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: function() {\n\t\treturn +( new Date() );\n\t},\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\n// JSHint would error on this code due to the Symbol not being defined in ES5.\n// Defining this global in .jshintrc would create a danger of using the global\n// unguarded in another place, it seems safer to just disable JSHint for these\n// three lines.\n/* jshint ignore: start */\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = deletedIds[ Symbol.iterator ];\n}\n/* jshint ignore: end */\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.1\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-10-17\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, nidselect, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rescape, \"\\\\$&\" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\tnidselect = ridentifier.test( nid ) ? \"#\" + nid : \"[id='\" + nid + \"']\";\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = nidselect + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( (parent = document.defaultView) && parent.top !== parent ) {\n\t\t// Support: IE 11\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( document.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\treturn m ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( (oldCache = uniqueCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/ );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( jQuery.inArray( elem, qualifier ) > -1 ) !== not;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tret = [],\n\t\t\tself = this,\n\t\t\tlen = self.length;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// init accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector.charAt( 0 ) === \"<\" &&\n\t\t\t\tselector.charAt( selector.length - 1 ) === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id !== match[ 2 ] ) {\n\t\t\t\t\t\t\treturn rootjQuery.find( selector );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof root.ready !== \"undefined\" ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar i,\n\t\t\ttargets = jQuery( target, this ),\n\t\t\tlen = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && ( pos ?\n\t\t\t\t\tpos.index( cur ) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn jQuery.inArray( this[ 0 ], jQuery( elem ) );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn jQuery.inArray(\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem, this );\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\tdo {\n\t\tcur = cur[ dir ];\n\t} while ( cur && cur.nodeType !== 1 );\n\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\n\t\t\telem.contentDocument || elem.contentWindow.document :\n\t\t\tjQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tret = jQuery.uniqueSort( ret );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tret = ret.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnotwhite = ( /\\S+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = true;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ) ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis === promise ? newDefer.promise() : this,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add( function() {\n\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 ||\n\t\t\t\t( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred.\n\t\t\t// If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) )\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n} );\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\tjQuery( document ).off( \"ready\" );\n\t\t}\n\t}\n} );\n\n/**\n * Clean-up method for dom ready events\n */\nfunction detach() {\n\tif ( document.addEventListener ) {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\t\twindow.removeEventListener( \"load\", completed );\n\n\t} else {\n\t\tdocument.detachEvent( \"onreadystatechange\", completed );\n\t\twindow.detachEvent( \"onload\", completed );\n\t}\n}\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\n\t// readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\tif ( document.addEventListener ||\n\t\twindow.event.type === \"load\" ||\n\t\tdocument.readyState === \"complete\" ) {\n\n\t\tdetach();\n\t\tjQuery.ready();\n\t}\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called\n\t\t// after the browser event has already occurred.\n\t\t// Support: IE6-10\n\t\t// Older IE sometimes signals \"interactive\" too soon\n\t\tif ( document.readyState === \"complete\" ||\n\t\t\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\twindow.setTimeout( jQuery.ready );\n\n\t\t// Standards-based browsers support DOMContentLoaded\n\t\t} else if ( document.addEventListener ) {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed );\n\n\t\t// If IE event model is used\n\t\t} else {\n\n\t\t\t// Ensure firing before onload, maybe late but safe also for iframes\n\t\t\tdocument.attachEvent( \"onreadystatechange\", completed );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.attachEvent( \"onload\", completed );\n\n\t\t\t// If IE and not a frame\n\t\t\t// continually check to see if the document is ready\n\t\t\tvar top = false;\n\n\t\t\ttry {\n\t\t\t\ttop = window.frameElement == null && document.documentElement;\n\t\t\t} catch ( e ) {}\n\n\t\t\tif ( top && top.doScroll ) {\n\t\t\t\t( function doScrollCheck() {\n\t\t\t\t\tif ( !jQuery.isReady ) {\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\t// Use the trick by Diego Perini\n\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\t\t\t\ttop.doScroll( \"left\" );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn window.setTimeout( doScrollCheck, 50 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// detach all dom ready events\n\t\t\t\t\t\tdetach();\n\n\t\t\t\t\t\t// and execute any waiting functions\n\t\t\t\t\t\tjQuery.ready();\n\t\t\t\t\t}\n\t\t\t\t} )();\n\t\t\t}\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Support: IE<9\n// Iteration over object's inherited properties before its own\nvar i;\nfor ( i in jQuery( support ) ) {\n\tbreak;\n}\nsupport.ownFirst = i === \"0\";\n\n// Note: most support tests are defined in their respective modules.\n// false until the test is run\nsupport.inlineBlockNeedsLayout = false;\n\n// Execute ASAP in case we need to set body.style.zoom\njQuery( function() {\n\n\t// Minified: var a,b,c,d\n\tvar val, div, body, container;\n\n\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\tif ( !body || !body.style ) {\n\n\t\t// Return for frameset docs that don't have a body\n\t\treturn;\n\t}\n\n\t// Setup\n\tdiv = document.createElement( \"div\" );\n\tcontainer = document.createElement( \"div\" );\n\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\tbody.appendChild( container ).appendChild( div );\n\n\tif ( typeof div.style.zoom !== \"undefined\" ) {\n\n\t\t// Support: IE<8\n\t\t// Check if natively block-level elements act like inline-block\n\t\t// elements when setting their display to 'inline' and giving\n\t\t// them layout\n\t\tdiv.style.cssText = \"display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1\";\n\n\t\tsupport.inlineBlockNeedsLayout = val = div.offsetWidth === 3;\n\t\tif ( val ) {\n\n\t\t\t// Prevent IE 6 from affecting layout for positioned elements #11048\n\t\t\t// Prevent IE from shrinking the body in IE 7 mode #12869\n\t\t\t// Support: IE<8\n\t\t\tbody.style.zoom = 1;\n\t\t}\n\t}\n\n\tbody.removeChild( container );\n} );\n\n\n( function() {\n\tvar div = document.createElement( \"div\" );\n\n\t// Support: IE<9\n\tsupport.deleteExpando = true;\n\ttry {\n\t\tdelete div.test;\n\t} catch ( e ) {\n\t\tsupport.deleteExpando = false;\n\t}\n\n\t// Null elements to avoid leaks in IE.\n\tdiv = null;\n} )();\nvar acceptData = function( elem ) {\n\tvar noData = jQuery.noData[ ( elem.nodeName + \" \" ).toLowerCase() ],\n\t\tnodeType = +elem.nodeType || 1;\n\n\t// Do not set data on non-element DOM nodes because it will not be cleared (#8335).\n\treturn nodeType !== 1 && nodeType !== 9 ?\n\t\tfalse :\n\n\t\t// Nodes accept data unless otherwise specified; rejection can be conditional\n\t\t!noData || noData !== true && elem.getAttribute( \"classid\" ) === noData;\n};\n\n\n\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\n\t\tvar name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tjQuery.data( elem, key, data );\n\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\n\treturn data;\n}\n\n// checks a cache object for emptiness\nfunction isEmptyDataObject( obj ) {\n\tvar name;\n\tfor ( name in obj ) {\n\n\t\t// if the public data object is empty, the private is still empty\n\t\tif ( name === \"data\" && jQuery.isEmptyObject( obj[ name ] ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( name !== \"toJSON\" ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction internalData( elem, name, data, pvt /* Internal Use Only */ ) {\n\tif ( !acceptData( elem ) ) {\n\t\treturn;\n\t}\n\n\tvar ret, thisCache,\n\t\tinternalKey = jQuery.expando,\n\n\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n\t\t// can't GC object references properly across the DOM-JS boundary\n\t\tisNode = elem.nodeType,\n\n\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n\t\t// attached directly to the object so GC can occur automatically\n\t\tcache = isNode ? jQuery.cache : elem,\n\n\t\t// Only defining an ID for JS objects if its cache already exists allows\n\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t\tid = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n\t// Avoid doing any more work than we need to when trying to get data on an\n\t// object that has no data at all\n\tif ( ( !id || !cache[ id ] || ( !pvt && !cache[ id ].data ) ) &&\n\t\tdata === undefined && typeof name === \"string\" ) {\n\t\treturn;\n\t}\n\n\tif ( !id ) {\n\n\t\t// Only DOM nodes need a new unique ID for each element since their data\n\t\t// ends up in the global cache\n\t\tif ( isNode ) {\n\t\t\tid = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;\n\t\t} else {\n\t\t\tid = internalKey;\n\t\t}\n\t}\n\n\tif ( !cache[ id ] ) {\n\n\t\t// Avoid exposing jQuery metadata on plain JS objects when the object\n\t\t// is serialized using JSON.stringify\n\t\tcache[ id ] = isNode ? {} : { toJSON: jQuery.noop };\n\t}\n\n\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\t// shallow copied over onto the existing cache\n\tif ( typeof name === \"object\" || typeof name === \"function\" ) {\n\t\tif ( pvt ) {\n\t\t\tcache[ id ] = jQuery.extend( cache[ id ], name );\n\t\t} else {\n\t\t\tcache[ id ].data = jQuery.extend( cache[ id ].data, name );\n\t\t}\n\t}\n\n\tthisCache = cache[ id ];\n\n\t// jQuery data() is stored in a separate object inside the object's internal data\n\t// cache in order to avoid key collisions between internal data and user-defined\n\t// data.\n\tif ( !pvt ) {\n\t\tif ( !thisCache.data ) {\n\t\t\tthisCache.data = {};\n\t\t}\n\n\t\tthisCache = thisCache.data;\n\t}\n\n\tif ( data !== undefined ) {\n\t\tthisCache[ jQuery.camelCase( name ) ] = data;\n\t}\n\n\t// Check for both converted-to-camel and non-converted data property names\n\t// If a data property was specified\n\tif ( typeof name === \"string\" ) {\n\n\t\t// First Try to find as-is property data\n\t\tret = thisCache[ name ];\n\n\t\t// Test for null|undefined property data\n\t\tif ( ret == null ) {\n\n\t\t\t// Try to find the camelCased property\n\t\t\tret = thisCache[ jQuery.camelCase( name ) ];\n\t\t}\n\t} else {\n\t\tret = thisCache;\n\t}\n\n\treturn ret;\n}\n\nfunction internalRemoveData( elem, name, pvt ) {\n\tif ( !acceptData( elem ) ) {\n\t\treturn;\n\t}\n\n\tvar thisCache, i,\n\t\tisNode = elem.nodeType,\n\n\t\t// See jQuery.data for more information\n\t\tcache = isNode ? jQuery.cache : elem,\n\t\tid = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n\t// If there is already no cache entry for this object, there is no\n\t// purpose in continuing\n\tif ( !cache[ id ] ) {\n\t\treturn;\n\t}\n\n\tif ( name ) {\n\n\t\tthisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n\t\tif ( thisCache ) {\n\n\t\t\t// Support array or space separated string names for data keys\n\t\t\tif ( !jQuery.isArray( name ) ) {\n\n\t\t\t\t// try the string as a key before any manipulation\n\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\tname = [ name ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// split the camel cased version by spaces unless a key with the spaces exists\n\t\t\t\t\tname = jQuery.camelCase( name );\n\t\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\t\tname = [ name ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname = name.split( \" \" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = name.concat( jQuery.map( name, jQuery.camelCase ) );\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete thisCache[ name[ i ] ];\n\t\t\t}\n\n\t\t\t// If there is no data left in the cache, we want to continue\n\t\t\t// and let the cache object itself get destroyed\n\t\t\tif ( pvt ? !isEmptyDataObject( thisCache ) : !jQuery.isEmptyObject( thisCache ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// See jQuery.data for more information\n\tif ( !pvt ) {\n\t\tdelete cache[ id ].data;\n\n\t\t// Don't destroy the parent cache unless the internal data object\n\t\t// had been the only thing left in it\n\t\tif ( !isEmptyDataObject( cache[ id ] ) ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Destroy the cache\n\tif ( isNode ) {\n\t\tjQuery.cleanData( [ elem ], true );\n\n\t// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n\t/* jshint eqeqeq: false */\n\t} else if ( support.deleteExpando || cache != cache.window ) {\n\t\t/* jshint eqeqeq: true */\n\t\tdelete cache[ id ];\n\n\t// When all else fails, undefined\n\t} else {\n\t\tcache[ id ] = undefined;\n\t}\n}\n\njQuery.extend( {\n\tcache: {},\n\n\t// The following elements (space-suffixed to avoid Object.prototype collisions)\n\t// throw uncatchable exceptions if you attempt to set expando properties\n\tnoData: {\n\t\t\"applet \": true,\n\t\t\"embed \": true,\n\n\t\t// ...but Flash objects (which have this classid) *can* handle expandos\n\t\t\"object \": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n\t},\n\n\thasData: function( elem ) {\n\t\telem = elem.nodeType ? jQuery.cache[ elem[ jQuery.expando ] ] : elem[ jQuery.expando ];\n\t\treturn !!elem && !isEmptyDataObject( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn internalData( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\treturn internalRemoveData( elem, name );\n\t},\n\n\t// For internal use only.\n\t_data: function( elem, name, data ) {\n\t\treturn internalData( elem, name, data, true );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\treturn internalRemoveData( elem, name, true );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Special expections of .data basically thwart jQuery.access,\n\t\t// so implement the relevant behavior ourselves\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = jQuery.data( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !jQuery._data( elem, \"parsedAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tjQuery._data( elem, \"parsedAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.data( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn arguments.length > 1 ?\n\n\t\t\t// Sets one value\n\t\t\tthis.each( function() {\n\t\t\t\tjQuery.data( this, key, value );\n\t\t\t} ) :\n\n\t\t\t// Gets one value\n\t\t\t// Try to fetch any internally stored data first\n\t\t\telem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeData( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = jQuery._data( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = jQuery._data( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object,\n\t// or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn jQuery._data( elem, key ) || jQuery._data( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tjQuery._removeData( elem, type + \"queue\" );\n\t\t\t\tjQuery._removeData( elem, key );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = jQuery._data( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\n\n\n( function() {\n\tvar shrinkWrapBlocksVal;\n\n\tsupport.shrinkWrapBlocks = function() {\n\t\tif ( shrinkWrapBlocksVal != null ) {\n\t\t\treturn shrinkWrapBlocksVal;\n\t\t}\n\n\t\t// Will be changed later if needed.\n\t\tshrinkWrapBlocksVal = false;\n\n\t\t// Minified: var b,c,d\n\t\tvar div, body, container;\n\n\t\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\t\tif ( !body || !body.style ) {\n\n\t\t\t// Test fired too early or in an unsupported environment, exit.\n\t\t\treturn;\n\t\t}\n\n\t\t// Setup\n\t\tdiv = document.createElement( \"div\" );\n\t\tcontainer = document.createElement( \"div\" );\n\t\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\t\tbody.appendChild( container ).appendChild( div );\n\n\t\t// Support: IE6\n\t\t// Check if elements with layout shrink-wrap their children\n\t\tif ( typeof div.style.zoom !== \"undefined\" ) {\n\n\t\t\t// Reset CSS: box-sizing; display; margin; border\n\t\t\tdiv.style.cssText =\n\n\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;\" +\n\t\t\t\t\"padding:1px;width:1px;zoom:1\";\n\t\t\tdiv.appendChild( document.createElement( \"div\" ) ).style.width = \"5px\";\n\t\t\tshrinkWrapBlocksVal = div.offsetWidth !== 3;\n\t\t}\n\n\t\tbody.removeChild( container );\n\n\t\treturn shrinkWrapBlocksVal;\n\t};\n\n} )();\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" ||\n\t\t\t!jQuery.contains( elem.ownerDocument, elem );\n\t};\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() { return tween.cur(); } :\n\t\t\tfunction() { return jQuery.css( elem, prop, \"\" ); },\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\tscale = scale || \".5\";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlength = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ],\n\t\t\t\t\tkey,\n\t\t\t\t\traw ? value : value.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlength ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([\\w:-]+)/ );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\nvar rleadingWhitespace = ( /^\\s+/ );\n\nvar nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|\" +\n\t\t\"details|dialog|figcaption|figure|footer|header|hgroup|main|\" +\n\t\t\"mark|meter|nav|output|picture|progress|section|summary|template|time|video\";\n\n\n\nfunction createSafeFragment( document ) {\n\tvar list = nodeNames.split( \"|\" ),\n\t\tsafeFrag = document.createDocumentFragment();\n\n\tif ( safeFrag.createElement ) {\n\t\twhile ( list.length ) {\n\t\t\tsafeFrag.createElement(\n\t\t\t\tlist.pop()\n\t\t\t);\n\t\t}\n\t}\n\treturn safeFrag;\n}\n\n\n( function() {\n\tvar div = document.createElement( \"div\" ),\n\t\tfragment = document.createDocumentFragment(),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Setup\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\n\t// IE strips leading whitespace when .innerHTML is used\n\tsupport.leadingWhitespace = div.firstChild.nodeType === 3;\n\n\t// Make sure that tbody elements aren't automatically inserted\n\t// IE will insert them into empty tables\n\tsupport.tbody = !div.getElementsByTagName( \"tbody\" ).length;\n\n\t// Make sure that link elements get serialized correctly by innerHTML\n\t// This requires a wrapper element in IE\n\tsupport.htmlSerialize = !!div.getElementsByTagName( \"link\" ).length;\n\n\t// Makes sure cloning an html5 element does not cause problems\n\t// Where outerHTML is undefined, this still works\n\tsupport.html5Clone =\n\t\tdocument.createElement( \"nav\" ).cloneNode( true ).outerHTML !== \"<:nav></:nav>\";\n\n\t// Check if a disconnected checkbox will retain its checked\n\t// value of true after appended to the DOM (IE6/7)\n\tinput.type = \"checkbox\";\n\tinput.checked = true;\n\tfragment.appendChild( input );\n\tsupport.appendChecked = input.checked;\n\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t// Support: IE6-IE11+\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tfragment.appendChild( div );\n\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput = document.createElement( \"input\" );\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t// old WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<9\n\t// Cloned elements keep attachEvent handlers, we use addEventListener on IE9+\n\tsupport.noCloneEvent = !!div.addEventListener;\n\n\t// Support: IE<9\n\t// Since attributes and properties are the same in IE,\n\t// cleanData must set properties to undefined rather than use removeAttribute\n\tdiv[ jQuery.expando ] = 1;\n\tsupport.attributes = !div.getAttribute( jQuery.expando );\n} )();\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\tlegend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n\tarea: [ 1, \"<map>\", \"</map>\" ],\n\n\t// Support: IE8\n\tparam: [ 1, \"<object>\", \"</object>\" ],\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\tcol: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n\t// unless wrapped in a div with non-breaking characters in front of it.\n\t_default: support.htmlSerialize ? [ 0, \"\", \"\" ] : [ 1, \"X<div>\", \"</div>\" ]\n};\n\n// Support: IE8-IE9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\tvar elems, elem,\n\t\ti = 0,\n\t\tfound = typeof context.getElementsByTagName !== \"undefined\" ?\n\t\t\tcontext.getElementsByTagName( tag || \"*\" ) :\n\t\t\ttypeof context.querySelectorAll !== \"undefined\" ?\n\t\t\t\tcontext.querySelectorAll( tag || \"*\" ) :\n\t\t\t\tundefined;\n\n\tif ( !found ) {\n\t\tfor ( found = [], elems = context.childNodes || context;\n\t\t\t( elem = elems[ i ] ) != null;\n\t\t\ti++\n\t\t) {\n\t\t\tif ( !tag || jQuery.nodeName( elem, tag ) ) {\n\t\t\t\tfound.push( elem );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( found, getAll( elem, tag ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], found ) :\n\t\tfound;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar elem,\n\t\ti = 0;\n\tfor ( ; ( elem = elems[ i ] ) != null; i++ ) {\n\t\tjQuery._data(\n\t\t\telem,\n\t\t\t\"globalEval\",\n\t\t\t!refElements || jQuery._data( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/,\n\trtbody = /<tbody/i;\n\nfunction fixDefaultChecked( elem ) {\n\tif ( rcheckableType.test( elem.type ) ) {\n\t\telem.defaultChecked = elem.checked;\n\t}\n}\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar j, elem, contains,\n\t\ttmp, tag, tbody, wrap,\n\t\tl = elems.length,\n\n\t\t// Ensure a safe fragment\n\t\tsafe = createSafeFragment( context ),\n\n\t\tnodes = [],\n\t\ti = 0;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || safe.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Manually add leading whitespace removed by IE\n\t\t\t\tif ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[ 0 ] ) );\n\t\t\t\t}\n\n\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\tif ( !support.tbody ) {\n\n\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\telem = tag === \"table\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\ttmp.firstChild :\n\n\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\twrap[ 1 ] === \"<table>\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\ttmp :\n\t\t\t\t\t\t\t0;\n\n\t\t\t\t\tj = elem && elem.childNodes.length;\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\tif ( jQuery.nodeName( ( tbody = elem.childNodes[ j ] ), \"tbody\" ) &&\n\t\t\t\t\t\t\t!tbody.childNodes.length ) {\n\n\t\t\t\t\t\t\telem.removeChild( tbody );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Fix #12392 for WebKit and IE > 9\n\t\t\t\ttmp.textContent = \"\";\n\n\t\t\t\t// Fix #12392 for oldIE\n\t\t\t\twhile ( tmp.firstChild ) {\n\t\t\t\t\ttmp.removeChild( tmp.firstChild );\n\t\t\t\t}\n\n\t\t\t\t// Remember the top-level container for proper cleanup\n\t\t\t\ttmp = safe.lastChild;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fix #11356: Clear elements from fragment\n\tif ( tmp ) {\n\t\tsafe.removeChild( tmp );\n\t}\n\n\t// Reset defaultChecked for any radios and checkboxes\n\t// about to be appended to the DOM in IE 6/7 (#8060)\n\tif ( !support.appendChecked ) {\n\t\tjQuery.grep( getAll( nodes, \"input\" ), fixDefaultChecked );\n\t}\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( safe.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttmp = null;\n\n\treturn safe;\n}\n\n\n( function() {\n\tvar i, eventName,\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Support: IE<9 (lack submit/change bubble), Firefox (lack focus(in | out) events)\n\tfor ( i in { submit: true, change: true, focusin: true } ) {\n\t\teventName = \"on\" + i;\n\n\t\tif ( !( support[ i ] = eventName in window ) ) {\n\n\t\t\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n\t\t\tdiv.setAttribute( eventName, \"t\" );\n\t\t\tsupport[ i ] = div.attributes[ eventName ].expando === false;\n\t\t}\n\t}\n\n\t// Null elements to avoid leaks in IE.\n\tdiv = null;\n} )();\n\n\nvar rformElems = /^(?:input|select|textarea)$/i,\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE9\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\t\tvar tmp, events, t, handleObjIn,\n\t\t\tspecial, eventHandle, handleObj,\n\t\t\thandlers, type, namespaces, origType,\n\t\t\telemData = jQuery._data( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" &&\n\t\t\t\t\t( !e || jQuery.event.triggered !== e.type ) ?\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak\n\t\t\t// with IE non-native events\n\t\t\teventHandle.elem = elem;\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener/attachEvent if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\n\t\t\t\t\t} else if ( elem.attachEvent ) {\n\t\t\t\t\t\telem.attachEvent( \"on\" + type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\tvar j, handleObj, tmp,\n\t\t\torigCount, t, events,\n\t\t\tspecial, handlers, type,\n\t\t\tnamespaces, origType,\n\t\t\telemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\n\t\t\t// removeData also checks for emptiness and clears the expando if empty\n\t\t\t// so use it instead of delete\n\t\t\tjQuery._removeData( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\tvar handle, ontype, cur,\n\t\t\tbubbleType, special, tmp, i,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tjQuery._data( cur, \"handle\" );\n\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif (\n\t\t\t\t( !special._default ||\n\t\t\t\t special._default.apply( eventPath.pop(), data ) === false\n\t\t\t\t) && acceptData( elem )\n\t\t\t) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Can't use an .isFunction() check here because IE6/7 fails that test.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\ttry {\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n\t\t\t\t\t\t// only reproducible on winXP IE8 native, not IE9 in IE8 mode\n\t\t\t\t\t}\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( jQuery._data( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Support (at least): Chrome, IE9\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t//\n\t\t// Support: Firefox<=42+\n\t\t// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)\n\t\tif ( delegateCount && cur.nodeType &&\n\t\t\t( event.type !== \"click\" || isNaN( event.button ) || event.button < 1 ) ) {\n\n\t\t\t/* jshint eqeqeq: false */\n\t\t\tfor ( ; cur != this; cur = cur.parentNode || this ) {\n\t\t\t\t/* jshint eqeqeq: true */\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== \"click\" ) ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matches } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Fix target property (#1925)\n\t\tif ( !event.target ) {\n\t\t\tevent.target = originalEvent.srcElement || document;\n\t\t}\n\n\t\t// Support: Safari 6-8+\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\t\tevent.metaKey = !!event.metaKey;\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: ( \"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase \" +\n\t\t\"metaKey relatedTarget shiftKey target timeStamp view which\" ).split( \" \" ),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split( \" \" ),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: ( \"button buttons clientX clientY fromElement offsetX offsetY \" +\n\t\t\t\"pageX pageY screenX screenY toElement\" ).split( \" \" ),\n\t\tfilter: function( event, original ) {\n\t\t\tvar body, eventDoc, doc,\n\t\t\t\tbutton = original.button,\n\t\t\t\tfromElement = original.fromElement;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX +\n\t\t\t\t\t( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -\n\t\t\t\t\t( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY +\n\t\t\t\t\t( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -\n\t\t\t\t\t( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add relatedTarget, if necessary\n\t\t\tif ( !event.relatedTarget && fromElement ) {\n\t\t\t\tevent.relatedTarget = fromElement === event.target ?\n\t\t\t\t\toriginal.toElement :\n\t\t\t\t\tfromElement;\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t// If we error on focus to hidden element (#1486, #12518),\n\t\t\t\t\t\t// let .trigger() run the handlers\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( jQuery.nodeName( this, \"input\" ) && this.type === \"checkbox\" && this.click ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\n\t\t\t\t// Previously, `originalEvent: {}` was set here, so stopPropagation call\n\t\t\t\t// would not be triggered on donor event, since in our own\n\t\t\t\t// jQuery.event.stopPropagation function we had a check for existence of\n\t\t\t\t// originalEvent.stopPropagation method, so, consequently it would be a noop.\n\t\t\t\t//\n\t\t\t\t// Guard for simulated events was moved to jQuery.event.stopPropagation function\n\t\t\t\t// since `originalEvent` should point to the original event for the\n\t\t\t\t// constancy with other events and for more focused logic\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = document.removeEventListener ?\n\tfunction( elem, type, handle ) {\n\n\t\t// This \"if\" is needed for plain objects\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle );\n\t\t}\n\t} :\n\tfunction( elem, type, handle ) {\n\t\tvar name = \"on\" + type;\n\n\t\tif ( elem.detachEvent ) {\n\n\t\t\t// #8545, #7054, preventing memory leaks for custom events in IE6-8\n\t\t\t// detachEvent needed property on element, by name of that event,\n\t\t\t// to properly expose it to GC\n\t\t\tif ( typeof elem[ name ] === \"undefined\" ) {\n\t\t\t\telem[ name ] = null;\n\t\t\t}\n\n\t\t\telem.detachEvent( name, handle );\n\t\t}\n\t};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: IE < 9, Android < 4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If preventDefault exists, run it on the original event\n\t\tif ( e.preventDefault ) {\n\t\t\te.preventDefault();\n\n\t\t// Support: IE\n\t\t// Otherwise set the returnValue property of the original event to false\n\t\t} else {\n\t\t\te.returnValue = false;\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( !e || this.isSimulated ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If stopPropagation exists, run it on the original event\n\t\tif ( e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\n\t\t// Support: IE\n\t\t// Set the cancelBubble property of the original event to true\n\t\te.cancelBubble = true;\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://code.google.com/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\n// IE submit delegation\nif ( !support.submit ) {\n\n\tjQuery.event.special.submit = {\n\t\tsetup: function() {\n\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Lazy-add a submit handler when a descendant form may potentially be submitted\n\t\t\tjQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n\n\t\t\t\t// Node name check avoids a VML-related crash in IE (#9807)\n\t\t\t\tvar elem = e.target,\n\t\t\t\t\tform = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ?\n\n\t\t\t\t\t\t// Support: IE <=8\n\t\t\t\t\t\t// We use jQuery.prop instead of elem.form\n\t\t\t\t\t\t// to allow fixing the IE8 delegated submit issue (gh-2332)\n\t\t\t\t\t\t// by 3rd party polyfills/workarounds.\n\t\t\t\t\t\tjQuery.prop( elem, \"form\" ) :\n\t\t\t\t\t\tundefined;\n\n\t\t\t\tif ( form && !jQuery._data( form, \"submit\" ) ) {\n\t\t\t\t\tjQuery.event.add( form, \"submit._submit\", function( event ) {\n\t\t\t\t\t\tevent._submitBubble = true;\n\t\t\t\t\t} );\n\t\t\t\t\tjQuery._data( form, \"submit\", true );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// return undefined since we don't need an event listener\n\t\t},\n\n\t\tpostDispatch: function( event ) {\n\n\t\t\t// If form was submitted by the user, bubble the event up the tree\n\t\t\tif ( event._submitBubble ) {\n\t\t\t\tdelete event._submitBubble;\n\t\t\t\tif ( this.parentNode && !event.isTrigger ) {\n\t\t\t\t\tjQuery.event.simulate( \"submit\", this.parentNode, event );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\t\t\tjQuery.event.remove( this, \"._submit\" );\n\t\t}\n\t};\n}\n\n// IE change delegation and checkbox/radio fix\nif ( !support.change ) {\n\n\tjQuery.event.special.change = {\n\n\t\tsetup: function() {\n\n\t\t\tif ( rformElems.test( this.nodeName ) ) {\n\n\t\t\t\t// IE doesn't fire change on a check/radio until blur; trigger it on click\n\t\t\t\t// after a propertychange. Eat the blur-change in special.change.handle.\n\t\t\t\t// This still fires onchange a second time for check/radio after blur.\n\t\t\t\tif ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n\t\t\t\t\tjQuery.event.add( this, \"propertychange._change\", function( event ) {\n\t\t\t\t\t\tif ( event.originalEvent.propertyName === \"checked\" ) {\n\t\t\t\t\t\t\tthis._justChanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\tjQuery.event.add( this, \"click._change\", function( event ) {\n\t\t\t\t\t\tif ( this._justChanged && !event.isTrigger ) {\n\t\t\t\t\t\t\tthis._justChanged = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Allow triggered, simulated change events (#11500)\n\t\t\t\t\t\tjQuery.event.simulate( \"change\", this, event );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Delegated event; lazy-add a change handler on descendant inputs\n\t\t\tjQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n\t\t\t\tvar elem = e.target;\n\n\t\t\t\tif ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, \"change\" ) ) {\n\t\t\t\t\tjQuery.event.add( elem, \"change._change\", function( event ) {\n\t\t\t\t\t\tif ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n\t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this.parentNode, event );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\tjQuery._data( elem, \"change\", true );\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\n\t\thandle: function( event ) {\n\t\t\tvar elem = event.target;\n\n\t\t\t// Swallow native change events from checkbox/radio, we already triggered them above\n\t\t\tif ( this !== elem || event.isSimulated || event.isTrigger ||\n\t\t\t\t( elem.type !== \"radio\" && elem.type !== \"checkbox\" ) ) {\n\n\t\t\t\treturn event.handleObj.handler.apply( this, arguments );\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\tjQuery.event.remove( this, \"._change\" );\n\n\t\t\treturn !rformElems.test( this.nodeName );\n\t\t}\n\t};\n}\n\n// Support: Firefox\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome, Safari\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = jQuery._data( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tjQuery._data( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = jQuery._data( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tjQuery._removeData( doc, fix );\n\t\t\t\t} else {\n\t\t\t\t\tjQuery._data( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\nvar rinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n\trnoshimcache = new RegExp( \"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\" ),\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n\n\t// Support: IE 10-11, Edge 10240+\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\tsafeFragment = createSafeFragment( document ),\n\tfragmentDiv = safeFragment.appendChild( document.createElement( \"div\" ) );\n\n// Support: IE<8\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName( \"tbody\" )[ 0 ] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement( \"tbody\" ) ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( jQuery.find.attr( elem, \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tif ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n\t\treturn;\n\t}\n\n\tvar type, i, l,\n\t\toldData = jQuery._data( src ),\n\t\tcurData = jQuery._data( dest, oldData ),\n\t\tevents = oldData.events;\n\n\tif ( events ) {\n\t\tdelete curData.handle;\n\t\tcurData.events = {};\n\n\t\tfor ( type in events ) {\n\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t// make the cloned public data object a copy from the original\n\tif ( curData.data ) {\n\t\tcurData.data = jQuery.extend( {}, curData.data );\n\t}\n}\n\nfunction fixCloneNodeIssues( src, dest ) {\n\tvar nodeName, e, data;\n\n\t// We do not need to do anything for non-Elements\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\tnodeName = dest.nodeName.toLowerCase();\n\n\t// IE6-8 copies events bound via attachEvent when using cloneNode.\n\tif ( !support.noCloneEvent && dest[ jQuery.expando ] ) {\n\t\tdata = jQuery._data( dest );\n\n\t\tfor ( e in data.events ) {\n\t\t\tjQuery.removeEvent( dest, e, data.handle );\n\t\t}\n\n\t\t// Event data gets referenced instead of copied if the expando gets copied too\n\t\tdest.removeAttribute( jQuery.expando );\n\t}\n\n\t// IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\tif ( nodeName === \"script\" && dest.text !== src.text ) {\n\t\tdisableScript( dest ).text = src.text;\n\t\trestoreScript( dest );\n\n\t// IE6-10 improperly clones children of object elements using classid.\n\t// IE10 throws NoModificationAllowedError if parent is null, #12132.\n\t} else if ( nodeName === \"object\" ) {\n\t\tif ( dest.parentNode ) {\n\t\t\tdest.outerHTML = src.outerHTML;\n\t\t}\n\n\t\t// This path appears unavoidable for IE9. When cloning an object\n\t\t// element in IE9, the outerHTML strategy above is not sufficient.\n\t\t// If the src has innerHTML and the destination does not,\n\t\t// copy the src.innerHTML into the dest.innerHTML. #10324\n\t\tif ( support.html5Clone && ( src.innerHTML && !jQuery.trim( dest.innerHTML ) ) ) {\n\t\t\tdest.innerHTML = src.innerHTML;\n\t\t}\n\n\t} else if ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\n\t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n\t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n\t\t// a checked appearance if the defaultChecked value isn't also set\n\n\t\tdest.defaultChecked = dest.checked = src.checked;\n\n\t\t// IE6-7 get confused and end up setting the value of a cloned\n\t\t// checkbox/radio button to an empty string instead of \"on\"\n\t\tif ( dest.value !== src.value ) {\n\t\t\tdest.value = src.value;\n\t\t}\n\n\t// IE6-8 fails to return the selected option to the default selected\n\t// state when cloning options\n\t} else if ( nodeName === \"option\" ) {\n\t\tdest.defaultSelected = dest.selected = src.defaultSelected;\n\n\t// IE6-8 fails to set the defaultValue to the correct value when\n\t// cloning other types of input fields\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar first, node, hasScripts,\n\t\tscripts, doc, fragment,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android<4.1, PhantomJS<2\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!jQuery._data( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjQuery.globalEval(\n\t\t\t\t\t\t\t\t( node.text || node.textContent || node.innerHTML || \"\" )\n\t\t\t\t\t\t\t\t\t.replace( rcleanScript, \"\" )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fix #11809: Avoid leaking memory\n\t\t\tfragment = first = null;\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\telems = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = elems[ i ] ) != null; i++ ) {\n\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar destElements, node, clone, i, srcElements,\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\tif ( support.html5Clone || jQuery.isXMLDoc( elem ) ||\n\t\t\t!rnoshimcache.test( \"<\" + elem.nodeName + \">\" ) ) {\n\n\t\t\tclone = elem.cloneNode( true );\n\n\t\t// IE<=8 does not properly clone detached, unknown element nodes\n\t\t} else {\n\t\t\tfragmentDiv.innerHTML = elem.outerHTML;\n\t\t\tfragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n\t\t}\n\n\t\tif ( ( !support.noCloneEvent || !support.noCloneChecked ) &&\n\t\t\t\t( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\t// Fix all IE cloning issues\n\t\t\tfor ( i = 0; ( node = srcElements[ i ] ) != null; ++i ) {\n\n\t\t\t\t// Ensure that the destination node is not null; Fixes #9587\n\t\t\t\tif ( destElements[ i ] ) {\n\t\t\t\t\tfixCloneNodeIssues( node, destElements[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0; ( node = srcElements[ i ] ) != null; i++ ) {\n\t\t\t\t\tcloneCopyEvent( node, destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\tdestElements = srcElements = node = null;\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems, /* internal */ forceAcceptData ) {\n\t\tvar elem, type, id, data,\n\t\t\ti = 0,\n\t\t\tinternalKey = jQuery.expando,\n\t\t\tcache = jQuery.cache,\n\t\t\tattributes = support.attributes,\n\t\t\tspecial = jQuery.event.special;\n\n\t\tfor ( ; ( elem = elems[ i ] ) != null; i++ ) {\n\t\t\tif ( forceAcceptData || acceptData( elem ) ) {\n\n\t\t\t\tid = elem[ internalKey ];\n\t\t\t\tdata = id && cache[ id ];\n\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove cache only if it was not already removed by jQuery.event.remove\n\t\t\t\t\tif ( cache[ id ] ) {\n\n\t\t\t\t\t\tdelete cache[ id ];\n\n\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t// IE does not allow us to delete expando properties from nodes\n\t\t\t\t\t\t// IE creates expando attributes along with the property\n\t\t\t\t\t\t// IE does not have a removeAttribute function on Document nodes\n\t\t\t\t\t\tif ( !attributes && typeof elem.removeAttribute !== \"undefined\" ) {\n\t\t\t\t\t\t\telem.removeAttribute( internalKey );\n\n\t\t\t\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t\t\t\t// https://code.google.com/p/chromium/issues/detail?id=378607\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telem[ internalKey ] = undefined;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdeletedIds.push( id );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\n\t// Keep domManip exposed until 3.0 (gh-2225)\n\tdomManip: domManip,\n\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().append(\n\t\t\t\t\t( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value )\n\t\t\t\t);\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\n\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t}\n\n\t\t\t// Remove any remaining nodes\n\t\t\twhile ( elem.firstChild ) {\n\t\t\t\telem.removeChild( elem.firstChild );\n\t\t\t}\n\n\t\t\t// If this is a select, ensure that it displays empty (#12336)\n\t\t\t// Support: IE<9\n\t\t\tif ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\telem.options.length = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\treturn elem.nodeType === 1 ?\n\t\t\t\t\telem.innerHTML.replace( rinlinejQuery, \"\" ) :\n\t\t\t\t\tundefined;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t( support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n\t\t\t\t( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\telem = this[ i ] || {};\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\ti = 0,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\n\n\nvar iframe,\n\telemdisplay = {\n\n\t\t// Support: Firefox\n\t\t// We have to pre-define these values for FF (#10227)\n\t\tHTML: \"block\",\n\t\tBODY: \"block\"\n\t};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\tdisplay = jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = ( iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" ) )\n\t\t\t\t.appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar documentElement = document.documentElement;\n\n\n\n( function() {\n\tvar pixelPositionVal, pixelMarginRightVal, boxSizingReliableVal,\n\t\treliableHiddenOffsetsVal, reliableMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\tdiv.style.cssText = \"float:left;opacity:.5\";\n\n\t// Support: IE<9\n\t// Make sure that element opacity exists (as opposed to filter)\n\tsupport.opacity = div.style.opacity === \"0.5\";\n\n\t// Verify style float existence\n\t// (IE uses styleFloat instead of cssFloat)\n\tsupport.cssFloat = !!div.style.cssFloat;\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer = document.createElement( \"div\" );\n\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\"padding:0;margin-top:1px;position:absolute\";\n\tdiv.innerHTML = \"\";\n\tcontainer.appendChild( div );\n\n\t// Support: Firefox<29, Android 2.3\n\t// Vendor-prefix box-sizing\n\tsupport.boxSizing = div.style.boxSizing === \"\" || div.style.MozBoxSizing === \"\" ||\n\t\tdiv.style.WebkitBoxSizing === \"\";\n\n\tjQuery.extend( support, {\n\t\treliableHiddenOffsets: function() {\n\t\t\tif ( pixelPositionVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn reliableHiddenOffsetsVal;\n\t\t},\n\n\t\tboxSizingReliable: function() {\n\n\t\t\t// We're checking for pixelPositionVal here instead of boxSizingReliableVal\n\t\t\t// since that compresses better and they're computed together anyway.\n\t\t\tif ( pixelPositionVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\n\t\tpixelMarginRight: function() {\n\n\t\t\t// Support: Android 4.0-4.3\n\t\t\tif ( pixelPositionVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\n\t\tpixelPosition: function() {\n\t\t\tif ( pixelPositionVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn pixelPositionVal;\n\t\t},\n\n\t\treliableMarginRight: function() {\n\n\t\t\t// Support: Android 2.3\n\t\t\tif ( pixelPositionVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn reliableMarginRightVal;\n\t\t},\n\n\t\treliableMarginLeft: function() {\n\n\t\t\t// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37\n\t\t\tif ( pixelPositionVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n\n\tfunction computeStyleTests() {\n\t\tvar contents, divStyle,\n\t\t\tdocumentElement = document.documentElement;\n\n\t\t// Setup\n\t\tdocumentElement.appendChild( container );\n\n\t\tdiv.style.cssText =\n\n\t\t\t// Support: Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t\"-webkit-box-sizing:border-box;box-sizing:border-box;\" +\n\t\t\t\"position:relative;display:block;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"top:1%;width:50%\";\n\n\t\t// Support: IE<9\n\t\t// Assume reasonable values in the absence of getComputedStyle\n\t\tpixelPositionVal = boxSizingReliableVal = reliableMarginLeftVal = false;\n\t\tpixelMarginRightVal = reliableMarginRightVal = true;\n\n\t\t// Check for getComputedStyle so that this code is not run in IE<9.\n\t\tif ( window.getComputedStyle ) {\n\t\t\tdivStyle = window.getComputedStyle( div );\n\t\t\tpixelPositionVal = ( divStyle || {} ).top !== \"1%\";\n\t\t\treliableMarginLeftVal = ( divStyle || {} ).marginLeft === \"2px\";\n\t\t\tboxSizingReliableVal = ( divStyle || { width: \"4px\" } ).width === \"4px\";\n\n\t\t\t// Support: Android 4.0 - 4.3 only\n\t\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\t\tdiv.style.marginRight = \"50%\";\n\t\t\tpixelMarginRightVal = ( divStyle || { marginRight: \"4px\" } ).marginRight === \"4px\";\n\n\t\t\t// Support: Android 2.3 only\n\t\t\t// Div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container (#3333)\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\tcontents = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\tcontents.style.cssText = div.style.cssText =\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\tcontents.style.marginRight = contents.style.width = \"0\";\n\t\t\tdiv.style.width = \"1px\";\n\n\t\t\treliableMarginRightVal =\n\t\t\t\t!parseFloat( ( window.getComputedStyle( contents ) || {} ).marginRight );\n\n\t\t\tdiv.removeChild( contents );\n\t\t}\n\n\t\t// Support: IE6-8\n\t\t// First check that getClientRects works as expected\n\t\t// Check if table cells still have offsetWidth/Height when they are set\n\t\t// to display:none and there are still other visible table cells in a\n\t\t// table row; if so, offsetWidth/Height are not reliable for use when\n\t\t// determining if an element has been hidden directly using\n\t\t// display:none (it is still safe to use offsets if a parent element is\n\t\t// hidden; don safety goggles and see bug #4512 for more information).\n\t\tdiv.style.display = \"none\";\n\t\treliableHiddenOffsetsVal = div.getClientRects().length === 0;\n\t\tif ( reliableHiddenOffsetsVal ) {\n\t\t\tdiv.style.display = \"\";\n\t\t\tdiv.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n\t\t\tdiv.childNodes[ 0 ].style.borderCollapse = \"separate\";\n\t\t\tcontents = div.getElementsByTagName( \"td\" );\n\t\t\tcontents[ 0 ].style.cssText = \"margin:0;border:0;padding:0;display:none\";\n\t\t\treliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n\t\t\tif ( reliableHiddenOffsetsVal ) {\n\t\t\t\tcontents[ 0 ].style.display = \"\";\n\t\t\t\tcontents[ 1 ].style.display = \"none\";\n\t\t\t\treliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n\t\t\t}\n\t\t}\n\n\t\t// Teardown\n\t\tdocumentElement.removeChild( container );\n\t}\n\n} )();\n\n\nvar getStyles, curCSS,\n\trposition = /^(top|right|bottom|left)$/;\n\nif ( window.getComputedStyle ) {\n\tgetStyles = function( elem ) {\n\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\tcurCSS = function( elem, name, computed ) {\n\t\tvar width, minWidth, maxWidth, ret,\n\t\t\tstyle = elem.style;\n\n\t\tcomputed = computed || getStyles( elem );\n\n\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;\n\n\t\t// Support: Opera 12.1x only\n\t\t// Fall back to style even without computed\n\t\t// computed is undefined for elems on document fragments\n\t\tif ( ( ret === \"\" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\tif ( computed ) {\n\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Chrome < 17 and Safari 5.0 uses \"computed value\"\n\t\t\t// instead of \"used value\" for margin-right\n\t\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values,\n\t\t\t// but width seems to be reliably pixels\n\t\t\t// this is against the CSSOM draft spec:\n\t\t\t// http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\treturn ret === undefined ?\n\t\t\tret :\n\t\t\tret + \"\";\n\t};\n} else if ( documentElement.currentStyle ) {\n\tgetStyles = function( elem ) {\n\t\treturn elem.currentStyle;\n\t};\n\n\tcurCSS = function( elem, name, computed ) {\n\t\tvar left, rs, rsLeft, ret,\n\t\t\tstyle = elem.style;\n\n\t\tcomputed = computed || getStyles( elem );\n\t\tret = computed ? computed[ name ] : undefined;\n\n\t\t// Avoid setting ret to empty string here\n\t\t// so we don't default to auto\n\t\tif ( ret == null && style && style[ name ] ) {\n\t\t\tret = style[ name ];\n\t\t}\n\n\t\t// From the awesome hack by Dean Edwards\n\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t// If we're not dealing with a regular pixel number\n\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t// but not position css attributes, as those are\n\t\t// proportional to the parent element instead\n\t\t// and we can't measure the parent instead because it\n\t\t// might trigger a \"stacking dolls\" problem\n\t\tif ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\tleft = style.left;\n\t\t\trs = elem.runtimeStyle;\n\t\t\trsLeft = rs && rs.left;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tif ( rsLeft ) {\n\t\t\t\trs.left = elem.currentStyle.left;\n\t\t\t}\n\t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : ret;\n\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.left = left;\n\t\t\tif ( rsLeft ) {\n\t\t\t\trs.left = rsLeft;\n\t\t\t}\n\t\t}\n\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\treturn ret === undefined ?\n\t\t\tret :\n\t\t\tret + \"\" || \"auto\";\n\t};\n}\n\n\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t\tralpha = /alpha\\([^)]*\\)/i,\n\tropacity = /opacity\\s*=\\s*([^)]*)/i,\n\n\t// swappable if display is none or starts with table except\n\t// \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values:\n\t// https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name.charAt( 0 ).toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] =\n\t\t\t\t\tjQuery._data( elem, \"olddisplay\", defaultDisplay( elem.nodeName ) );\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\tjQuery._data(\n\t\t\t\t\telem,\n\t\t\t\t\t\"olddisplay\",\n\t\t\t\t\thidden ? display : jQuery.css( elem, \"display\" )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = support.boxSizing &&\n\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\n\t\t// normalize float css property\n\t\t\"float\": support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set. See: #7116\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n\t\t\t// but it would mean to define eight\n\t\t\t// (for every problematic property) identical functions\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\t// Support: IE\n\t\t\t\t// Swallow errors from 'invalid' CSS values (#5509)\n\t\t\t\ttry {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar num, val, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\t\t\t\t\telem.offsetWidth === 0 ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tsupport.boxSizing &&\n\t\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n} );\n\nif ( !support.opacity ) {\n\tjQuery.cssHooks.opacity = {\n\t\tget: function( elem, computed ) {\n\n\t\t\t// IE uses filters for opacity\n\t\t\treturn ropacity.test( ( computed && elem.currentStyle ?\n\t\t\t\telem.currentStyle.filter :\n\t\t\t\telem.style.filter ) || \"\" ) ?\n\t\t\t\t\t( 0.01 * parseFloat( RegExp.$1 ) ) + \"\" :\n\t\t\t\t\tcomputed ? \"1\" : \"\";\n\t\t},\n\n\t\tset: function( elem, value ) {\n\t\t\tvar style = elem.style,\n\t\t\t\tcurrentStyle = elem.currentStyle,\n\t\t\t\topacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n\t\t\t\tfilter = currentStyle && currentStyle.filter || style.filter || \"\";\n\n\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t// Force it by setting the zoom level\n\t\t\tstyle.zoom = 1;\n\n\t\t\t// if setting opacity to 1, and no other filters exist -\n\t\t\t// attempt to remove filter attribute #6652\n\t\t\t// if value === \"\", then remove inline opacity #12685\n\t\t\tif ( ( value >= 1 || value === \"\" ) &&\n\t\t\t\t\tjQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" &&\n\t\t\t\t\tstyle.removeAttribute ) {\n\n\t\t\t\t// Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n\t\t\t\t// if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n\t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\t\t\t\tstyle.removeAttribute( \"filter\" );\n\n\t\t\t\t// if there is no filter style applied in a css rule\n\t\t\t\t// or unset inline opacity, we are done\n\t\t\t\tif ( value === \"\" || currentStyle && !currentStyle.filter ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// otherwise, set new filter values\n\t\t\tstyle.filter = ralpha.test( filter ) ?\n\t\t\t\tfilter.replace( ralpha, opacity ) :\n\t\t\t\tfilter + \" \" + opacity;\n\t\t}\n\t};\n}\n\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn (\n\t\t\t\tparseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\n\t\t\t\t// Support: IE<=11+\n\t\t\t\t// Running getBoundingClientRect on a disconnected node in IE throws an error\n\t\t\t\t// Support: IE8 only\n\t\t\t\t// getClientRects() errors on disconnected elems\n\t\t\t\t( jQuery.contains( elem.ownerDocument, elem ) ?\n\t\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t0\n\t\t\t\t)\n\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\tattrs = { height: type },\n\t\ti = 0;\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// we're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = jQuery._data( elem, \"fxshow\" );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE does not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t// Test default display if display is currently \"none\"\n\t\tcheckDisplay = display === \"none\" ?\n\t\t\tjQuery._data( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t// inline-level elements accept inline-block;\n\t\t\t// block-level elements need to be inline with layout\n\t\t\tif ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === \"inline\" ) {\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t} else {\n\t\t\t\tstyle.zoom = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tif ( !support.shrinkWrapBlocks() ) {\n\t\t\tanim.always( function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t} );\n\t\t}\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show\n\t\t\t\t// and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = jQuery._data( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done( function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t} );\n\t\t}\n\t\tanim.done( function() {\n\t\t\tvar prop;\n\t\t\tjQuery._removeData( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t} );\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( ( display === \"none\" ? defaultDisplay( elem.nodeName ) : display ) === \"inline\" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnotwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ?\n\t\t\tjQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || jQuery._data( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = jQuery._data( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = jQuery._data( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ttimers = jQuery.timers,\n\t\ti = 0;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\twindow.clearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar a,\n\t\tinput = document.createElement( \"input\" ),\n\t\tdiv = document.createElement( \"div\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\t// Setup\n\tdiv = document.createElement( \"div\" );\n\tdiv.setAttribute( \"className\", \"t\" );\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\ta = div.getElementsByTagName( \"a\" )[ 0 ];\n\n\t// Support: Windows Web Apps (WWA)\n\t// `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"checkbox\" );\n\tdiv.appendChild( input );\n\n\ta = div.getElementsByTagName( \"a\" )[ 0 ];\n\n\t// First batch of tests.\n\ta.style.cssText = \"top:1px\";\n\n\t// Test setAttribute on camelCase class.\n\t// If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\tsupport.getSetAttribute = div.className !== \"t\";\n\n\t// Get the style information from getAttribute\n\t// (IE uses .cssText instead)\n\tsupport.style = /top/.test( a.getAttribute( \"style\" ) );\n\n\t// Make sure that URLs aren't manipulated\n\t// (IE normalizes it by default)\n\tsupport.hrefNormalized = a.getAttribute( \"href\" ) === \"/a\";\n\n\t// Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n\tsupport.checkOn = !!input.value;\n\n\t// Make sure that a selected-by-default option has a working selected property.\n\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\tsupport.optSelected = opt.selected;\n\n\t// Tests for enctype support on a form (#6743)\n\tsupport.enctype = !!document.createElement( \"form\" ).enctype;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE8 only\n\t// Check if we can trust getAttribute(\"value\")\n\tinput = document.createElement( \"input\" );\n\tinput.setAttribute( \"value\", \"\" );\n\tsupport.input = input.getAttribute( \"value\" ) === \"\";\n\n\t// Check if an input maintains its value after becoming a radio\n\tinput.value = \"t\";\n\tinput.setAttribute( \"type\", \"radio\" );\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar rreturn = /\\r/g,\n\trspaces = /[\\x20\\t\\r\\n\\f]+/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif (\n\t\t\t\t\thooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace( rreturn, \"\" ) :\n\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) ).replace( rspaces, \" \" );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// oldIE doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ?\n\t\t\t\t\t\t\t\t!option.disabled :\n\t\t\t\t\t\t\t\toption.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\tif ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1 ) {\n\n\t\t\t\t\t\t// Support: IE6\n\t\t\t\t\t\t// When new option element is added to select box we need to\n\t\t\t\t\t\t// force reflow of newly added node in order to workaround delay\n\t\t\t\t\t\t// of initialization properties\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\toption.selected = optionSet = true;\n\n\t\t\t\t\t\t} catch ( _ ) {\n\n\t\t\t\t\t\t\t// Will be executed only in IE6\n\t\t\t\t\t\t\toption.scrollHeight;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\toption.selected = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\n\t\t\t\treturn options;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle,\n\truseDefault = /^(?:checked|selected)$/i,\n\tgetSetAttribute = support.getSetAttribute,\n\tgetSetInput = support.input;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE8-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\tif ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\t\t\t\t\t\telem[ propName ] = false;\n\n\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t// Also clear defaultChecked/defaultSelected (if appropriate)\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] =\n\t\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t}\n\n\t\t\t\t// See #9699 for explanation of this approach (setting first, then removal)\n\t\t\t\t} else {\n\t\t\t\t\tjQuery.attr( elem, name, \"\" );\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( getSetAttribute ? name : propName );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\n\t\t\t// IE<8 needs the *property* name\n\t\t\telem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\n\t\t} else {\n\n\t\t\t// Support: IE<9\n\t\t\t// Use defaultChecked and defaultSelected for oldIE\n\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] = elem[ name ] = true;\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tif ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\t\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\t\tvar ret, handle;\n\t\t\tif ( !isXML ) {\n\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[ name ];\n\t\t\t\tattrHandle[ name ] = ret;\n\t\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\t\t\t\tattrHandle[ name ] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t} else {\n\t\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem[ jQuery.camelCase( \"default-\" + name ) ] ?\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t};\n\t}\n} );\n\n// fix oldIE attroperties\nif ( !getSetInput || !getSetAttribute ) {\n\tjQuery.attrHooks.value = {\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( jQuery.nodeName( elem, \"input\" ) ) {\n\n\t\t\t\t// Does not return so that setAttribute is also used\n\t\t\t\telem.defaultValue = value;\n\t\t\t} else {\n\n\t\t\t\t// Use nodeHook if defined (#1954); otherwise setAttribute is fine\n\t\t\t\treturn nodeHook && nodeHook.set( elem, value, name );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// IE6/7 do not support getting/setting some attributes with get/setAttribute\nif ( !getSetAttribute ) {\n\n\t// Use this for any attribute in IE6/7\n\t// This fixes almost every IE6/7 issue\n\tnodeHook = {\n\t\tset: function( elem, value, name ) {\n\n\t\t\t// Set the existing or create a new attribute node\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\tif ( !ret ) {\n\t\t\t\telem.setAttributeNode(\n\t\t\t\t\t( ret = elem.ownerDocument.createAttribute( name ) )\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tret.value = value += \"\";\n\n\t\t\t// Break association with cloned elements by also using setAttribute (#9646)\n\t\t\tif ( name === \"value\" || value === elem.getAttribute( name ) ) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Some attributes are constructed with empty-string values when not defined\n\tattrHandle.id = attrHandle.name = attrHandle.coords =\n\t\tfunction( elem, name, isXML ) {\n\t\t\tvar ret;\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn ( ret = elem.getAttributeNode( name ) ) && ret.value !== \"\" ?\n\t\t\t\t\tret.value :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t};\n\n\t// Fixing value retrieval on a button requires this module\n\tjQuery.valHooks.button = {\n\t\tget: function( elem, name ) {\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\tif ( ret && ret.specified ) {\n\t\t\t\treturn ret.value;\n\t\t\t}\n\t\t},\n\t\tset: nodeHook.set\n\t};\n\n\t// Set contenteditable to false on removals(#10429)\n\t// Setting to empty string throws an error as an invalid value\n\tjQuery.attrHooks.contenteditable = {\n\t\tset: function( elem, value, name ) {\n\t\t\tnodeHook.set( elem, value === \"\" ? false : value, name );\n\t\t}\n\t};\n\n\t// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n\t// This is for removals\n\tjQuery.each( [ \"width\", \"height\" ], function( i, name ) {\n\t\tjQuery.attrHooks[ name ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( value === \"\" ) {\n\t\t\t\t\telem.setAttribute( name, \"auto\" );\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\n\nif ( !support.style ) {\n\tjQuery.attrHooks.style = {\n\t\tget: function( elem ) {\n\n\t\t\t// Return undefined in the case of empty string\n\t\t\t// Note: IE uppercases css property names, but if we were to .toLowerCase()\n\t\t\t// .cssText, that would destroy case sensitivity in URL's, like in \"background\"\n\t\t\treturn elem.style.cssText || undefined;\n\t\t},\n\t\tset: function( elem, value ) {\n\t\t\treturn ( elem.style.cssText = value + \"\" );\n\t\t}\n\t};\n}\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button|object)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\tname = jQuery.propFix[ name ] || name;\n\t\treturn this.each( function() {\n\n\t\t\t// try/catch handles cases where IE balks (such as removing a property on window)\n\t\t\ttry {\n\t\t\t\tthis[ name ] = undefined;\n\t\t\t\tdelete this[ name ];\n\t\t\t} catch ( e ) {}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\treturn tabindex ?\n\t\t\t\t\tparseInt( tabindex, 10 ) :\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\t\trclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t\t0 :\n\t\t\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Some attributes require a special call on IE\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !support.hrefNormalized ) {\n\n\t// href/src property should get the full normalized URL (#10299/#12915)\n\tjQuery.each( [ \"href\", \"src\" ], function( i, name ) {\n\t\tjQuery.propHooks[ name ] = {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.getAttribute( name, 4 );\n\t\t\t}\n\t\t};\n\t} );\n}\n\n// Support: Safari, IE9+\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t// Make sure that it also works with optgroups, see #5701\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n// IE6/7 call enctype encoding\nif ( !support.enctype ) {\n\tjQuery.propFix.enctype = \"encoding\";\n}\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\nfunction getClass( elem ) {\n\treturn jQuery.attr( elem, \"class\" ) || \"\";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnotwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 &&\n\t\t\t\t\t( \" \" + curValue + \" \" ).replace( rclass, \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\tjQuery.attr( elem, \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnotwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 &&\n\t\t\t\t\t( \" \" + curValue + \" \" ).replace( rclass, \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\tjQuery.attr( elem, \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === \"string\" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// store className if set\n\t\t\t\t\tjQuery._data( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tjQuery.attr( this, \"class\",\n\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\"\" :\n\t\t\t\t\tjQuery._data( this, \"__className__\" ) || \"\"\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + getClass( elem ) + \" \" ).replace( rclass, \" \" )\n\t\t\t\t\t.indexOf( className ) > -1\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( ( \"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\nvar rvalidtokens = /(,)|(\\[|{)|(}|])|\"(?:[^\"\\\\\\r\\n]|\\\\[\"\\\\\\/bfnrt]|\\\\u[\\da-fA-F]{4})*\"\\s*:?|true|false|null|-?(?!0\\d)\\d+(?:\\.\\d+|)(?:[eE][+-]?\\d+|)/g;\n\njQuery.parseJSON = function( data ) {\n\n\t// Attempt to parse using the native JSON parser first\n\tif ( window.JSON && window.JSON.parse ) {\n\n\t\t// Support: Android 2.3\n\t\t// Workaround failure to string-cast null input\n\t\treturn window.JSON.parse( data + \"\" );\n\t}\n\n\tvar requireNonComma,\n\t\tdepth = null,\n\t\tstr = jQuery.trim( data + \"\" );\n\n\t// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains\n\t// after removing valid tokens\n\treturn str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {\n\n\t\t// Force termination if we see a misplaced comma\n\t\tif ( requireNonComma && comma ) {\n\t\t\tdepth = 0;\n\t\t}\n\n\t\t// Perform no more replacements after returning to outermost depth\n\t\tif ( depth === 0 ) {\n\t\t\treturn token;\n\t\t}\n\n\t\t// Commas must not follow \"[\", \"{\", or \",\"\n\t\trequireNonComma = open || comma;\n\n\t\t// Determine new depth\n\t\t// array/object open (\"[\" or \"{\"): depth += true - false (increment)\n\t\t// array/object close (\"]\" or \"}\"): depth += false - true (decrement)\n\t\t// other cases (\",\" or primitive): depth += true - true (numeric cast)\n\t\tdepth += !close - !open;\n\n\t\t// Remove this token\n\t\treturn \"\";\n\t} ) ) ?\n\t\t( Function( \"return \" + str ) )() :\n\t\tjQuery.error( \"Invalid JSON: \" + data );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\ttry {\n\t\tif ( window.DOMParser ) { // Standard\n\t\t\ttmp = new window.DOMParser();\n\t\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t\t} else { // IE\n\t\t\txml = new window.ActiveXObject( \"Microsoft.XMLDOM\" );\n\t\t\txml.async = \"false\";\n\t\t\txml.loadXML( data );\n\t\t}\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\tif ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\n\t// IE leaves an \\r character at EOL\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Document location\n\tajaxLocation = location.href,\n\n\t// Segment location into parts\n\tajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType.charAt( 0 ) === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar deep, key,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\tvar firstDataType, ct, finalDataType, type,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) { // jscs:ignore requireDotNotation\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar\n\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers as string\n\t\t\tresponseHeadersString,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\ttransport,\n\n\t\t\t// Response headers\n\t\t\tresponseHeaders,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" )\n\t\t\t.replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\tvar wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n\t\t\t\t\telem = elem.firstChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each( function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t} ).end();\n\t}\n} );\n\n\nfunction getDisplay( elem ) {\n\treturn elem.style && elem.style.display || jQuery.css( elem, \"display\" );\n}\n\nfunction filterHidden( elem ) {\n\n\t// Disconnected elements are considered hidden\n\tif ( !jQuery.contains( elem.ownerDocument || document, elem ) ) {\n\t\treturn true;\n\t}\n\twhile ( elem && elem.nodeType === 1 ) {\n\t\tif ( getDisplay( elem ) === \"none\" || elem.type === \"hidden\" ) {\n\t\t\treturn true;\n\t\t}\n\t\telem = elem.parentNode;\n\t}\n\treturn false;\n}\n\njQuery.expr.filters.hidden = function( elem ) {\n\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn support.reliableHiddenOffsets() ?\n\t\t( elem.offsetWidth <= 0 && elem.offsetHeight <= 0 &&\n\t\t\t!elem.getClientRects().length ) :\n\t\t\tfilterHidden( elem );\n};\n\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t} ) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\njQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?\n\n\t// Support: IE6-IE8\n\tfunction() {\n\n\t\t// XHR cannot access local files, always use ActiveX for that case\n\t\tif ( this.isLocal ) {\n\t\t\treturn createActiveXHR();\n\t\t}\n\n\t\t// Support: IE 9-11\n\t\t// IE seems to error on cross-domain PATCH requests when ActiveX XHR\n\t\t// is used. In IE 9+ always use the native XHR.\n\t\t// Note: this condition won't catch Edge as it doesn't define\n\t\t// document.documentMode but it also doesn't support ActiveX so it won't\n\t\t// reach this code.\n\t\tif ( document.documentMode > 8 ) {\n\t\t\treturn createStandardXHR();\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// oldIE XHR does not support non-RFC2616 methods (#13240)\n\t\t// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx\n\t\t// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9\n\t\t// Although this check for six methods instead of eight\n\t\t// since IE also does not support \"trace\" and \"connect\"\n\t\treturn /^(get|post|head|put|delete|options)$/i.test( this.type ) &&\n\t\t\tcreateStandardXHR() || createActiveXHR();\n\t} :\n\n\t// For all other browsers, use the standard XMLHttpRequest object\n\tcreateStandardXHR;\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE<10\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n\twindow.attachEvent( \"onunload\", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]( undefined, true );\n\t\t}\n\t} );\n}\n\n// Determine support properties\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nxhrSupported = support.ajax = !!xhrSupported;\n\n// Create transport if the browser can provide an xhr\nif ( xhrSupported ) {\n\n\tjQuery.ajaxTransport( function( options ) {\n\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( !options.crossDomain || support.cors ) {\n\n\t\t\tvar callback;\n\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\t\t// Open the socket\n\t\t\t\t\txhr.open(\n\t\t\t\t\t\toptions.type,\n\t\t\t\t\t\toptions.url,\n\t\t\t\t\t\toptions.async,\n\t\t\t\t\t\toptions.username,\n\t\t\t\t\t\toptions.password\n\t\t\t\t\t);\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t\t}\n\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor ( i in headers ) {\n\n\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t// IE's ActiveXObject throws a 'Type Mismatch' exception when setting\n\t\t\t\t\t\t// request header to a null-value.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// To keep consistent with other XHR implementations, cast the value\n\t\t\t\t\t\t// to string and ignore `undefined`.\n\t\t\t\t\t\tif ( headers[ i ] !== undefined ) {\n\t\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] + \"\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Do send the request\n\t\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\t\txhr.send( ( options.hasContent && options.data ) || null );\n\n\t\t\t\t\t// Listener\n\t\t\t\t\tcallback = function( _, isAbort ) {\n\t\t\t\t\t\tvar status, statusText, responses;\n\n\t\t\t\t\t\t// Was never called and is aborted or complete\n\t\t\t\t\t\tif ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\n\t\t\t\t\t\t\t// Clean up\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = undefined;\n\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n\n\t\t\t\t\t\t\t// Abort manually if needed\n\t\t\t\t\t\t\tif ( isAbort ) {\n\t\t\t\t\t\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresponses = {};\n\t\t\t\t\t\t\t\tstatus = xhr.status;\n\n\t\t\t\t\t\t\t\t// Support: IE<10\n\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\tif ( typeof xhr.responseText === \"string\" ) {\n\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n\t\t\t\t\t\t\t\t\tstatusText = \"\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n\n\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n\t\t\t\t\t\t\t\t// can do given current implementations)\n\t\t\t\t\t\t\t\tif ( !status && options.isLocal && !options.crossDomain ) {\n\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n\n\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n\t\t\t\t\t\t\t\t} else if ( status === 1223 ) {\n\t\t\t\t\t\t\t\t\tstatus = 204;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Call complete if needed\n\t\t\t\t\t\tif ( responses ) {\n\t\t\t\t\t\t\tcomplete( status, statusText, responses, xhr.getAllResponseHeaders() );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Do send the request\n\t\t\t\t\t// `xhr.send` may raise an exception, but it will be\n\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\t\tif ( !options.async ) {\n\n\t\t\t\t\t\t// If we're in sync mode we fire the callback\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t} else if ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t// (IE6 & IE7) if it's in cache and has been\n\t\t\t\t\t\t// retrieved directly we need to fire the callback\n\t\t\t\t\t\twindow.setTimeout( callback );\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Register the callback, but delay it in case `xhr.send` throws\n\t\t\t\t\t\t// Add to the list of active xhr callbacks\n\t\t\t\t\t\txhr.onreadystatechange = xhrCallbacks[ id ] = callback;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback( undefined, true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} );\n}\n\n// Functions to create xhrs\nfunction createStandardXHR() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n}\n\nfunction createActiveXHR() {\n\ttry {\n\t\treturn new window.ActiveXObject( \"Microsoft.XMLHTTP\" );\n\t} catch ( e ) {}\n}\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and global\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t\ts.global = false;\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\n\t\tvar script,\n\t\t\thead = document.head || jQuery( \"head\" )[ 0 ] || document.documentElement;\n\n\t\treturn {\n\n\t\t\tsend: function( _, callback ) {\n\n\t\t\t\tscript = document.createElement( \"script\" );\n\n\t\t\t\tscript.async = true;\n\n\t\t\t\tif ( s.scriptCharset ) {\n\t\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t\t}\n\n\t\t\t\tscript.src = s.url;\n\n\t\t\t\t// Attach handlers for all browsers\n\t\t\t\tscript.onload = script.onreadystatechange = function( _, isAbort ) {\n\n\t\t\t\t\tif ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\n\t\t\t\t\t\t// Remove the script\n\t\t\t\t\t\tif ( script.parentNode ) {\n\t\t\t\t\t\t\tscript.parentNode.removeChild( script );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Dereference the script\n\t\t\t\t\t\tscript = null;\n\n\t\t\t\t\t\t// Callback if not abort\n\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\tcallback( 200, \"success\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( script ) {\n\t\t\t\t\tscript.onload( undefined, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = jQuery.trim( url.slice( off, url.length ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ?\n\t\telem :\n\t\telem.nodeType === 9 ?\n\t\t\telem.defaultView || elem.parentWindow :\n\t\t\tfalse;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\tjQuery.inArray( \"auto\", [ curCSSTop, curCSSLeft ] ) > -1;\n\n\t\t// need to be able to calculate position if either top or left\n\t\t// is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\telem = this[ 0 ],\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t// BlackBerry 5, iOS 3 (original iPhone)\n\t\tif ( typeof elem.getBoundingClientRect !== \"undefined\" ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n\t\t\tleft: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\tparentOffset = { top: 0, left: 0 },\n\t\t\telem = this[ 0 ];\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// we assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top  += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\treturn {\n\t\t\ttop:  offset.top  - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = /Y/.test( prop );\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? ( prop in win ) ? win[ prop ] :\n\t\t\t\t\twin.document.documentElement[ method ] :\n\t\t\t\t\telem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : jQuery( win ).scrollLeft(),\n\t\t\t\t\ttop ? val : jQuery( win ).scrollTop()\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n} );\n\n// Support: Safari<7-8+, Chrome<37-44+\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// getComputedStyle returns percent when specified for top/left/bottom/right\n// rather than make the css module depend on the offset module, we just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\tfunction( defaultExtra, funcName ) {\n\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\t// unfortunately, this causes bug #3838 in IE6/8 only,\n\t\t\t\t\t// but there is currently no good, small way to fix it.\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in\n// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\nreturn jQuery;\n}));\n\n\n//# sourceURL=webpack:///./node_modules/jquery/dist/jquery.js?");

/***/ }),

/***/ "./node_modules/meteor-imports-webpack-plugin/meteor-config.js":
/*!*********************************************************************!*\
  !*** ./node_modules/meteor-imports-webpack-plugin/meteor-config.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config = window.__meteor_runtime_config__ || (window.__meteor_runtime_config__ = {});\nObject.assign(config, {\"meteorProgramsFolder\":\"build/pkg-only/bundle/programs\",\"meteorEnv\":{},\"PUBLIC_SETTINGS\":{}});\nconfig.DDP_DEFAULT_CONNECTION_URL = window.location.protocol + \"//\" + window.location.hostname + \":\" + 3000;\nconfig.ROOT_URL = window.location.protocol + \"//\" + window.location.host;\nif (false) {}\n\n\n//# sourceURL=webpack:///./node_modules/meteor-imports-webpack-plugin/meteor-config.js?");

/***/ }),

/***/ "./node_modules/meteor-imports-webpack-plugin/meteor-imports.js":
/*!**********************************************************************!*\
  !*** ./node_modules/meteor-imports-webpack-plugin/meteor-imports.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! meteor-config */ \"./node_modules/meteor-imports-webpack-plugin/meteor-config.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/meteor.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/meteor.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/meteor-base.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/meteor-base.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/mobile-experience.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/mobile-experience.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/modules-runtime.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/modules-runtime.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/modules.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/modules.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/modern-browsers.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/modern-browsers.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/babel-compiler.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/babel-compiler.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/ecmascript.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/ecmascript.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/ecmascript-runtime.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/ecmascript-runtime.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/babel-runtime.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/babel-runtime.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/promise.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/promise.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/url.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/url.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/http.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/http.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/dynamic-import.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/dynamic-import.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/es5-shim.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/es5-shim.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/ecmascript-runtime-client.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/ecmascript-runtime-client.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/base64.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/base64.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/ejson.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/ejson.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/diff-sequence.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/diff-sequence.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/geojson-utils.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/geojson-utils.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/id-map.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/id-map.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/random.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/random.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/mongo-id.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/mongo-id.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/ordered-dict.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/ordered-dict.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/tracker.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/tracker.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/minimongo.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/minimongo.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/check.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/check.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/retry.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/retry.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/callback-hook.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/callback-hook.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/ddp-common.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/ddp-common.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/reload.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/reload.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/socket-stream-client.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/socket-stream-client.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/ddp-client.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/ddp-client.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/ddp.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/ddp.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/ddp-server.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/ddp-server.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/allow-deny.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/allow-deny.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/mongo-dev-server.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/mongo-dev-server.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/insecure.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/insecure.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/mongo.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/mongo.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/reactive-var.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/reactive-var.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/standard-minifier-css.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/standard-minifier-css.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/standard-minifier-js.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/standard-minifier-js.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/shell-server.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/shell-server.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/autopublish.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/autopublish.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/static-html.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/static-html.js\");\nPackage._define(\"jquery\", {jQuery: __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")});\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/twbs_bootstrap.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/demo-pkg.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/demo-pkg.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/webapp.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/webapp.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/livedata.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/livedata.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/hot-code-push.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/hot-code-push.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/launch-screen.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/launch-screen.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/packages/autoupdate.js */ \"./build/pkg-only/bundle/programs/web.browser/packages/autoupdate.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/app/global-imports.js */ \"./build/pkg-only/bundle/programs/web.browser/app/global-imports.js\");\n__webpack_require__(/*! ./build/pkg-only/bundle/programs/web.browser/merged-stylesheets.css */ \"./build/pkg-only/bundle/programs/web.browser/merged-stylesheets.css\");\nvar mr = Package[\"modules-runtime\"];\nmodule.exports = mr && mr.meteorInstall();;\n\n//# sourceURL=webpack:///./node_modules/meteor-imports-webpack-plugin/meteor-imports.js?");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack:///./node_modules/object-assign/index.js?");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          )\n\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/checkPropTypes.js?");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n\n\n//# sourceURL=webpack:///./node_modules/prop-types/lib/ReactPropTypesSecret.js?");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.5.1\n * react-dom.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\nvar schedule = __webpack_require__(/*! schedule */ \"./node_modules/schedule/index.js\");\nvar tracking = __webpack_require__(/*! schedule/tracking */ \"./node_modules/schedule/tracking.js\");\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function () {};\n\n{\n  validateFormat = function (format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error = void 0;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\n// Relying on the `invariant()` implementation lets us\n// preserve the format and params in the www builds.\n\n!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;\n\nvar invokeGuardedCallbackImpl = function (name, func, context, a, b, c, d, e, f) {\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this.onError(error);\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      !(typeof document !== 'undefined') ? invariant(false, 'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.') : void 0;\n      var evt = document.createEvent('Event');\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Keeps track of the value of window.event so that we can reset it\n      // during the callback to let user code access window.event in the\n      // browsers that support it.\n      var windowEvent = window.event;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n\n        // We check for window.hasOwnProperty('event') to prevent the\n        // window.event assignment in both IE <= 10 as they throw an error\n        // \"Member not found\" in strict mode, and in Firefox which does not\n        // support window.event.\n        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {\n          window.event = windowEvent;\n        }\n\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function handleWindowError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n        if (event.defaultPrevented) {\n          // Some other error handler has prevented default.\n          // Browsers silence the error report if this happens.\n          // We'll remember this to later decide whether to log it or not.\n          if (error != null && typeof error === 'object') {\n            try {\n              error._suppressLogging = true;\n            } catch (inner) {\n              // Ignore.\n            }\n          }\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', handleWindowError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        this.onError(error);\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', handleWindowError);\n    };\n\n    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;\n  }\n}\n\nvar invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n\n// Used by Fiber to simulate a try-catch.\nvar hasError = false;\nvar caughtError = null;\n\n// Used by event system to capture/rethrow the first error.\nvar hasRethrowError = false;\nvar rethrowError = null;\n\nvar reporter = {\n  onError: function (error) {\n    hasError = true;\n    caughtError = error;\n  }\n};\n\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nfunction invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n  hasError = false;\n  caughtError = null;\n  invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n}\n\n/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nfunction invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\n  invokeGuardedCallback.apply(this, arguments);\n  if (hasError) {\n    var error = clearCaughtError();\n    if (!hasRethrowError) {\n      hasRethrowError = true;\n      rethrowError = error;\n    }\n  }\n}\n\n/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */\nfunction rethrowCaughtError() {\n  if (hasRethrowError) {\n    var error = rethrowError;\n    hasRethrowError = false;\n    rethrowError = null;\n    throw error;\n  }\n}\n\nfunction hasCaughtError() {\n  return hasError;\n}\n\nfunction clearCaughtError() {\n  if (hasError) {\n    var error = caughtError;\n    hasError = false;\n    caughtError = null;\n    return error;\n  } else {\n    invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n    possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\nvar possibleRegistrationNames = {};\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warningWithoutStack = function () {};\n\n{\n  warningWithoutStack = function (condition, format) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (format === undefined) {\n      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (args.length > 8) {\n      // Check before the condition to catch violations early.\n      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n    }\n    if (condition) {\n      return;\n    }\n    if (typeof console !== 'undefined') {\n      var _args$map = args.map(function (item) {\n        return '' + item;\n      }),\n          a = _args$map[0],\n          b = _args$map[1],\n          c = _args$map[2],\n          d = _args$map[3],\n          e = _args$map[4],\n          f = _args$map[5],\n          g = _args$map[6],\n          h = _args$map[7];\n\n      var message = 'Warning: ' + format;\n\n      // We intentionally don't use spread (or .apply) because it breaks IE9:\n      // https://github.com/facebook/react/issues/13610\n      switch (args.length) {\n        case 0:\n          console.error(message);\n          break;\n        case 1:\n          console.error(message, a);\n          break;\n        case 2:\n          console.error(message, a, b);\n          break;\n        case 3:\n          console.error(message, a, b, c);\n          break;\n        case 4:\n          console.error(message, a, b, c, d);\n          break;\n        case 5:\n          console.error(message, a, b, c, d, e);\n          break;\n        case 6:\n          console.error(message, a, b, c, d, e, f);\n          break;\n        case 7:\n          console.error(message, a, b, c, d, e, f, g);\n          break;\n        case 8:\n          console.error(message, a, b, c, d, e, f, g, h);\n          break;\n        default:\n          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n      }\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var _message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      throw new Error(_message);\n    } catch (x) {}\n  };\n}\n\nvar warningWithoutStack$1 = warningWithoutStack;\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nfunction setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n  getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n  getInstanceFromNode = getInstanceFromNodeImpl;\n  getNodeFromInstance = getNodeFromInstanceImpl;\n  {\n    !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;\n  }\n}\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, 'EventPluginUtils: Invalid `event`.') : void 0;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = getNodeFromInstance(inst);\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = null;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runEventsInBatch(events, simulated) {\n  if (events !== null) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n  } else {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n  }\n  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;\n  // This would be a good time to rethrow if any of the event handlers threw.\n  rethrowCaughtError();\n}\n\nfunction runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n  runEventsInBatch(events, false);\n}\n\nvar FunctionalComponent = 0;\nvar FunctionalComponentLazy = 1;\nvar ClassComponent = 2;\nvar ClassComponentLazy = 3;\nvar IndeterminateComponent = 4; // Before we know whether it is functional or class\nvar HostRoot = 5; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 6; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 7;\nvar HostText = 8;\nvar Fragment = 9;\nvar Mode = 10;\nvar ContextConsumer = 11;\nvar ContextProvider = 12;\nvar ForwardRef = 13;\nvar ForwardRefLazy = 14;\nvar Profiler = 15;\nvar PlaceholderComponent = 16;\n\nvar randomKey = Math.random().toString(36).slice(2);\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\nvar internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n\nfunction precacheFiberNode(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\n/**\n * Given a DOM node, return the closest ReactDOMComponent or\n * ReactDOMTextComponent instance ancestor.\n */\nfunction getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  while (!node[internalInstanceKey]) {\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n\n  return null;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nfunction getInstanceFromNode$1(node) {\n  var inst = node[internalInstanceKey];\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nfunction getNodeFromInstance$1(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\n\nfunction getFiberCurrentPropsFromNode$1(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nfunction updateFiberProps(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return;\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\n\n\n/**\n * Return the parent instance of the passed-in instance.\n */\n\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (true) {\n    if (!from) {\n      break;\n    }\n    if (from === common) {\n      break;\n    }\n    var alternate = from.alternate;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  var pathTo = [];\n  while (true) {\n    if (!to) {\n      break;\n    }\n    if (to === common) {\n      break;\n    }\n    var _alternate = to.alternate;\n    if (_alternate !== null && _alternate === common) {\n      break;\n    }\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  for (var i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (var _i = pathTo.length; _i-- > 0;) {\n    fn(pathTo[_i], 'captured', argTo);\n  }\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst ? warningWithoutStack$1(false, 'Dispatching inst must not be null') : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\n\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n// Do not uses the below two methods directly!\n// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.\n// (It is the only module that is allowed to access these methods.)\n\nfunction unsafeCastStringToDOMTopLevelType(topLevelType) {\n  return topLevelType;\n}\n\nfunction unsafeCastDOMTopLevelTypeToString(topLevelType) {\n  return topLevelType;\n}\n\n/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n  prefixes['Moz' + styleProp] = 'moz' + eventName;\n\n  return prefixes;\n}\n\n/**\n * A list of event names to a configurable list of vendor prefixes.\n */\nvar vendorPrefixes = {\n  animationend: makePrefixMap('Animation', 'AnimationEnd'),\n  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n  animationstart: makePrefixMap('Animation', 'AnimationStart'),\n  transitionend: makePrefixMap('Transition', 'TransitionEnd')\n};\n\n/**\n * Event names that have already been detected and prefixed (if applicable).\n */\nvar prefixedEventNames = {};\n\n/**\n * Element to check for prefixes on.\n */\nvar style = {};\n\n/**\n * Bootstrap if a DOM exists.\n */\nif (canUseDOM) {\n  style = document.createElement('div').style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are usable, and if not remove them from the map.\n  if (!('AnimationEvent' in window)) {\n    delete vendorPrefixes.animationend.animation;\n    delete vendorPrefixes.animationiteration.animation;\n    delete vendorPrefixes.animationstart.animation;\n  }\n\n  // Same as above\n  if (!('TransitionEvent' in window)) {\n    delete vendorPrefixes.transitionend.transition;\n  }\n}\n\n/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  } else if (!vendorPrefixes[eventName]) {\n    return eventName;\n  }\n\n  var prefixMap = vendorPrefixes[eventName];\n\n  for (var styleProp in prefixMap) {\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n      return prefixedEventNames[eventName] = prefixMap[styleProp];\n    }\n  }\n\n  return eventName;\n}\n\n/**\n * To identify top level events in ReactDOM, we use constants defined by this\n * module. This is the only module that uses the unsafe* methods to express\n * that the constants actually correspond to the browser event names. This lets\n * us save some bundle size by avoiding a top level type -> event name map.\n * The rest of ReactDOM code should import top level types from this file.\n */\nvar TOP_ABORT = unsafeCastStringToDOMTopLevelType('abort');\nvar TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationend'));\nvar TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationiteration'));\nvar TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationstart'));\nvar TOP_BLUR = unsafeCastStringToDOMTopLevelType('blur');\nvar TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType('canplay');\nvar TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType('canplaythrough');\nvar TOP_CANCEL = unsafeCastStringToDOMTopLevelType('cancel');\nvar TOP_CHANGE = unsafeCastStringToDOMTopLevelType('change');\nvar TOP_CLICK = unsafeCastStringToDOMTopLevelType('click');\nvar TOP_CLOSE = unsafeCastStringToDOMTopLevelType('close');\nvar TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType('compositionend');\nvar TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType('compositionstart');\nvar TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType('compositionupdate');\nvar TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType('contextmenu');\nvar TOP_COPY = unsafeCastStringToDOMTopLevelType('copy');\nvar TOP_CUT = unsafeCastStringToDOMTopLevelType('cut');\nvar TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType('dblclick');\nvar TOP_AUX_CLICK = unsafeCastStringToDOMTopLevelType('auxclick');\nvar TOP_DRAG = unsafeCastStringToDOMTopLevelType('drag');\nvar TOP_DRAG_END = unsafeCastStringToDOMTopLevelType('dragend');\nvar TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType('dragenter');\nvar TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType('dragexit');\nvar TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType('dragleave');\nvar TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType('dragover');\nvar TOP_DRAG_START = unsafeCastStringToDOMTopLevelType('dragstart');\nvar TOP_DROP = unsafeCastStringToDOMTopLevelType('drop');\nvar TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType('durationchange');\nvar TOP_EMPTIED = unsafeCastStringToDOMTopLevelType('emptied');\nvar TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType('encrypted');\nvar TOP_ENDED = unsafeCastStringToDOMTopLevelType('ended');\nvar TOP_ERROR = unsafeCastStringToDOMTopLevelType('error');\nvar TOP_FOCUS = unsafeCastStringToDOMTopLevelType('focus');\nvar TOP_GOT_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType('gotpointercapture');\nvar TOP_INPUT = unsafeCastStringToDOMTopLevelType('input');\nvar TOP_INVALID = unsafeCastStringToDOMTopLevelType('invalid');\nvar TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType('keydown');\nvar TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType('keypress');\nvar TOP_KEY_UP = unsafeCastStringToDOMTopLevelType('keyup');\nvar TOP_LOAD = unsafeCastStringToDOMTopLevelType('load');\nvar TOP_LOAD_START = unsafeCastStringToDOMTopLevelType('loadstart');\nvar TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType('loadeddata');\nvar TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType('loadedmetadata');\nvar TOP_LOST_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType('lostpointercapture');\nvar TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType('mousedown');\nvar TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType('mousemove');\nvar TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType('mouseout');\nvar TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType('mouseover');\nvar TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType('mouseup');\nvar TOP_PASTE = unsafeCastStringToDOMTopLevelType('paste');\nvar TOP_PAUSE = unsafeCastStringToDOMTopLevelType('pause');\nvar TOP_PLAY = unsafeCastStringToDOMTopLevelType('play');\nvar TOP_PLAYING = unsafeCastStringToDOMTopLevelType('playing');\nvar TOP_POINTER_CANCEL = unsafeCastStringToDOMTopLevelType('pointercancel');\nvar TOP_POINTER_DOWN = unsafeCastStringToDOMTopLevelType('pointerdown');\n\n\nvar TOP_POINTER_MOVE = unsafeCastStringToDOMTopLevelType('pointermove');\nvar TOP_POINTER_OUT = unsafeCastStringToDOMTopLevelType('pointerout');\nvar TOP_POINTER_OVER = unsafeCastStringToDOMTopLevelType('pointerover');\nvar TOP_POINTER_UP = unsafeCastStringToDOMTopLevelType('pointerup');\nvar TOP_PROGRESS = unsafeCastStringToDOMTopLevelType('progress');\nvar TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType('ratechange');\nvar TOP_RESET = unsafeCastStringToDOMTopLevelType('reset');\nvar TOP_SCROLL = unsafeCastStringToDOMTopLevelType('scroll');\nvar TOP_SEEKED = unsafeCastStringToDOMTopLevelType('seeked');\nvar TOP_SEEKING = unsafeCastStringToDOMTopLevelType('seeking');\nvar TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType('selectionchange');\nvar TOP_STALLED = unsafeCastStringToDOMTopLevelType('stalled');\nvar TOP_SUBMIT = unsafeCastStringToDOMTopLevelType('submit');\nvar TOP_SUSPEND = unsafeCastStringToDOMTopLevelType('suspend');\nvar TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType('textInput');\nvar TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType('timeupdate');\nvar TOP_TOGGLE = unsafeCastStringToDOMTopLevelType('toggle');\nvar TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType('touchcancel');\nvar TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType('touchend');\nvar TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType('touchmove');\nvar TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType('touchstart');\nvar TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('transitionend'));\nvar TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType('volumechange');\nvar TOP_WAITING = unsafeCastStringToDOMTopLevelType('waiting');\nvar TOP_WHEEL = unsafeCastStringToDOMTopLevelType('wheel');\n\n// List of events that need to be individually attached to media elements.\n// Note that events in this list will *not* be listened to at the top level\n// unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.\nvar mediaEventTypes = [TOP_ABORT, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_VOLUME_CHANGE, TOP_WAITING];\n\nfunction getRawEventName(topLevelType) {\n  return unsafeCastDOMTopLevelTypeToString(topLevelType);\n}\n\n/**\n * These variables store information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */\n\nvar root = null;\nvar startText = null;\nvar fallbackText = null;\n\nfunction initialize(nativeEventTarget) {\n  root = nativeEventTarget;\n  startText = getText();\n  return true;\n}\n\nfunction reset() {\n  root = null;\n  startText = null;\n  fallbackText = null;\n}\n\nfunction getData() {\n  if (fallbackText) {\n    return fallbackText;\n  }\n\n  var start = void 0;\n  var startValue = startText;\n  var startLength = startValue.length;\n  var end = void 0;\n  var endValue = getText();\n  var endLength = endValue.length;\n\n  for (start = 0; start < startLength; start++) {\n    if (startValue[start] !== endValue[start]) {\n      break;\n    }\n  }\n\n  var minEnd = startLength - start;\n  for (end = 1; end <= minEnd; end++) {\n    if (startValue[startLength - end] !== endValue[endLength - end]) {\n      break;\n    }\n  }\n\n  var sliceTail = end > 1 ? 1 - end : undefined;\n  fallbackText = endValue.slice(start, sliceTail);\n  return fallbackText;\n}\n\nfunction getText() {\n  if ('value' in root) {\n    return root.value;\n  }\n  return root.textContent;\n}\n\n/* eslint valid-typeof: 0 */\n\nvar EVENT_POOL_SIZE = 10;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: function () {\n    return null;\n  },\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\nfunction functionThatReturnsTrue() {\n  return true;\n}\n\nfunction functionThatReturnsFalse() {\n  return false;\n}\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n    delete this.isDefaultPrevented;\n    delete this.isPropagationStopped;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = functionThatReturnsFalse;\n  }\n  this.isPropagationStopped = functionThatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = functionThatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = functionThatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: functionThatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    this.dispatchConfig = null;\n    this._targetInst = null;\n    this.nativeEvent = null;\n    this.isDefaultPrevented = functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    this._dispatchListeners = null;\n    this._dispatchInstances = null;\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n      Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function (Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition ? warningWithoutStack$1(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar SyntheticCompositionEvent = SyntheticEvent.extend({\n  data: null\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar SyntheticInputEvent = SyntheticEvent.extend({\n  data: null\n});\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;\n\nvar documentMode = null;\nif (canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode;\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture'\n    },\n    dependencies: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_START:\n      return eventTypes.compositionStart;\n    case TOP_COMPOSITION_END:\n      return eventTypes.compositionEnd;\n    case TOP_COMPOSITION_UPDATE:\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_KEY_UP:\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case TOP_KEY_DOWN:\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case TOP_KEY_PRESS:\n    case TOP_MOUSE_DOWN:\n    case TOP_BLUR:\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isUsingKoreanIME(nativeEvent) {\n  return nativeEvent.locale === 'ko';\n}\n\n// Track the current IME composition status, if any.\nvar isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var eventType = void 0;\n  var fallbackData = void 0;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = initialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {TopLevelType} topLevelType Number from `TopLevelType`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_END:\n      return getDataFromCustomEvent(nativeEvent);\n    case TOP_KEY_PRESS:\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case TOP_TEXT_INPUT:\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to ignore it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (topLevelType === TOP_COMPOSITION_END || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      var chars = getData();\n      reset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case TOP_PASTE:\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case TOP_KEY_PRESS:\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case TOP_COMPOSITION_END:\n      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var chars = void 0;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n\n  event.data = chars;\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    var beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    if (composition === null) {\n      return beforeInput;\n    }\n\n    if (beforeInput === null) {\n      return composition;\n    }\n\n    return [composition, beforeInput];\n  }\n};\n\n// Use to restore controlled state after a change event has fired.\n\nvar restoreImpl = null;\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  !(typeof restoreImpl === 'function') ? invariant(false, 'setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  restoreImpl(internalInstance.stateNode, internalInstance.type, props);\n}\n\nfunction setRestoreImplementation(impl) {\n  restoreImpl = impl;\n}\n\nfunction enqueueStateRestore(target) {\n  if (restoreTarget) {\n    if (restoreQueue) {\n      restoreQueue.push(target);\n    } else {\n      restoreQueue = [target];\n    }\n  } else {\n    restoreTarget = target;\n  }\n}\n\nfunction needsStateRestore() {\n  return restoreTarget !== null || restoreQueue !== null;\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar _batchedUpdatesImpl = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nvar _interactiveUpdatesImpl = function (fn, a, b) {\n  return fn(a, b);\n};\nvar _flushInteractiveUpdatesImpl = function () {};\n\nvar isBatching = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isBatching) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isBatching = true;\n  try {\n    return _batchedUpdatesImpl(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isBatching = false;\n    var controlledComponentsHavePendingUpdates = needsStateRestore();\n    if (controlledComponentsHavePendingUpdates) {\n      // If a controlled event was fired, we may need to restore the state of\n      // the DOM node back to the controlled value. This is necessary when React\n      // bails out of the update without touching the DOM.\n      _flushInteractiveUpdatesImpl();\n      restoreStateIfNeeded();\n    }\n  }\n}\n\nfunction interactiveUpdates(fn, a, b) {\n  return _interactiveUpdatesImpl(fn, a, b);\n}\n\n\n\nfunction setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {\n  _batchedUpdatesImpl = batchedUpdatesImpl;\n  _interactiveUpdatesImpl = interactiveUpdatesImpl;\n  _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;\n}\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  color: true,\n  date: true,\n  datetime: true,\n  'datetime-local': true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  time: true,\n  url: true,\n  week: true\n};\n\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n  if (nodeName === 'input') {\n    return !!supportedInputTypes[elem.type];\n  }\n\n  if (nodeName === 'textarea') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * HTML nodeType values that represent the type of the node\n */\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  // Fallback to nativeEvent.srcElement for IE9\n  // https://github.com/facebook/react/issues/12506\n  var target = nativeEvent.target || nativeEvent.srcElement || window;\n\n  // Normalize SVG <use> element events #4963\n  if (target.correspondingUseElement) {\n    target = target.correspondingUseElement;\n  }\n\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === TEXT_NODE ? target.parentNode : target;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix) {\n  if (!canUseDOM) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n}\n\nfunction isCheckable(elem) {\n  var type = elem.type;\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n}\n\nfunction getTracker(node) {\n  return node._valueTracker;\n}\n\nfunction detachTracker(node) {\n  node._valueTracker = null;\n}\n\nfunction getValueFromNode(node) {\n  var value = '';\n  if (!node) {\n    return value;\n  }\n\n  if (isCheckable(node)) {\n    value = node.checked ? 'true' : 'false';\n  } else {\n    value = node.value;\n  }\n\n  return value;\n}\n\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? 'checked' : 'value';\n  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n\n  var currentValue = '' + node[valueField];\n\n  // if someone has already defined a value or Safari, then bail\n  // and don't track value will cause over reporting of changes,\n  // but it's better then a hard failure\n  // (needed for certain tests that spyOn input values and Safari)\n  if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n    return;\n  }\n  var get = descriptor.get,\n      set = descriptor.set;\n\n  Object.defineProperty(node, valueField, {\n    configurable: true,\n    get: function () {\n      return get.call(this);\n    },\n    set: function (value) {\n      currentValue = '' + value;\n      set.call(this, value);\n    }\n  });\n  // We could've passed this the first time\n  // but it triggers a bug in IE11 and Edge 14/15.\n  // Calling defineProperty() again should be equivalent.\n  // https://github.com/facebook/react/issues/11768\n  Object.defineProperty(node, valueField, {\n    enumerable: descriptor.enumerable\n  });\n\n  var tracker = {\n    getValue: function () {\n      return currentValue;\n    },\n    setValue: function (value) {\n      currentValue = '' + value;\n    },\n    stopTracking: function () {\n      detachTracker(node);\n      delete node[valueField];\n    }\n  };\n  return tracker;\n}\n\nfunction track(node) {\n  if (getTracker(node)) {\n    return;\n  }\n\n  // TODO: Once it's just Fiber we can move this to node._wrapperState\n  node._valueTracker = trackValueOnNode(node);\n}\n\nfunction updateValueIfChanged(node) {\n  if (!node) {\n    return false;\n  }\n\n  var tracker = getTracker(node);\n  // if there is no tracker at this point it's unlikely\n  // that trying again will succeed\n  if (!tracker) {\n    return true;\n  }\n\n  var lastValue = tracker.getValue();\n  var nextValue = getValueFromNode(node);\n  if (nextValue !== lastValue) {\n    tracker.setValue(nextValue);\n    return true;\n  }\n  return false;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  var sourceInfo = '';\n  if (source) {\n    var path = source.fileName;\n    var fileName = path.replace(BEFORE_SLASH_RE, '');\n    {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        var match = path.match(BEFORE_SLASH_RE);\n        if (match) {\n          var pathBeforeSlash = match[1];\n          if (pathBeforeSlash) {\n            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n            fileName = folderName + '/' + fileName;\n          }\n        }\n      }\n    }\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n};\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for('react.placeholder') : 0xead1;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nvar Pending = 0;\nvar Resolved = 1;\nvar Rejected = 2;\n\nfunction getResultFromResolvedThenable(thenable) {\n  return thenable._reactResult;\n}\n\nfunction refineResolvedThenable(thenable) {\n  return thenable._reactStatus === Resolved ? thenable._reactResult : null;\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  {\n    if (typeof type.tag === 'number') {\n      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_ASYNC_MODE_TYPE:\n      return 'AsyncMode';\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_PLACEHOLDER_TYPE:\n      return 'Placeholder';\n  }\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return 'Context.Consumer';\n      case REACT_PROVIDER_TYPE:\n        return 'Context.Provider';\n      case REACT_FORWARD_REF_TYPE:\n        var renderFn = type.render;\n        var functionName = renderFn.displayName || renderFn.name || '';\n        return type.displayName || (functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef');\n    }\n    if (typeof type.then === 'function') {\n      var thenable = type;\n      var resolvedThenable = refineResolvedThenable(thenable);\n      if (resolvedThenable) {\n        return getComponentName(resolvedThenable);\n      }\n    }\n  }\n  return null;\n}\n\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case FunctionalComponentLazy:\n    case ClassComponent:\n    case ClassComponentLazy:\n    case HostComponent:\n    case Mode:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber.type);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner.type);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    node = node.return;\n  } while (node);\n  return info;\n}\n\nvar current = null;\nvar phase = null;\n\nfunction getCurrentFiberOwnerNameInDevOrNull() {\n  {\n    if (current === null) {\n      return null;\n    }\n    var owner = current._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner.type);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackInDev() {\n  {\n    if (current === null) {\n      return '';\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackByFiberInDevAndProd(current);\n  }\n  return '';\n}\n\nfunction resetCurrentFiber() {\n  {\n    ReactDebugCurrentFrame.getCurrentStack = null;\n    current = null;\n    phase = null;\n  }\n}\n\nfunction setCurrentFiber(fiber) {\n  {\n    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;\n    current = fiber;\n    phase = null;\n  }\n}\n\nfunction setCurrentPhase(lifeCyclePhase) {\n  {\n    phase = lifeCyclePhase;\n  }\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = warningWithoutStack$1;\n\n{\n  warning = function (condition, format) {\n    if (condition) {\n      return;\n    }\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n    // eslint-disable-next-line react-internal/warning-and-invariant-args\n\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));\n  };\n}\n\nvar warning$1 = warning;\n\n// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED = 0;\n\n// A simple string attribute.\n// Attributes that aren't in the whitelist are presumed to have this type.\nvar STRING = 1;\n\n// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING = 2;\n\n// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN = 3;\n\n// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN = 4;\n\n// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC = 5;\n\n// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC = 6;\n\n/* eslint-disable max-len */\nvar ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\n/* eslint-enable max-len */\nvar ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + '\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\n\n\nvar ROOT_ATTRIBUTE_NAME = 'data-reactroot';\nvar VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar illegalAttributeNameCache = {};\nvar validatedAttributeNameCache = {};\n\nfunction isAttributeNameSafe(attributeName) {\n  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n    return true;\n  }\n  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  {\n    warning$1(false, 'Invalid attribute name: `%s`', attributeName);\n  }\n  return false;\n}\n\nfunction shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\n  if (propertyInfo !== null) {\n    return propertyInfo.type === RESERVED;\n  }\n  if (isCustomComponentTag) {\n    return false;\n  }\n  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n    return true;\n  }\n  return false;\n}\n\nfunction shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\n  if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n    return false;\n  }\n  switch (typeof value) {\n    case 'function':\n    // $FlowIssue symbol is perfectly valid here\n    case 'symbol':\n      // eslint-disable-line\n      return true;\n    case 'boolean':\n      {\n        if (isCustomComponentTag) {\n          return false;\n        }\n        if (propertyInfo !== null) {\n          return !propertyInfo.acceptsBooleans;\n        } else {\n          var prefix = name.toLowerCase().slice(0, 5);\n          return prefix !== 'data-' && prefix !== 'aria-';\n        }\n      }\n    default:\n      return false;\n  }\n}\n\nfunction shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\n  if (value === null || typeof value === 'undefined') {\n    return true;\n  }\n  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\n    return true;\n  }\n  if (isCustomComponentTag) {\n    return false;\n  }\n  if (propertyInfo !== null) {\n    switch (propertyInfo.type) {\n      case BOOLEAN:\n        return !value;\n      case OVERLOADED_BOOLEAN:\n        return value === false;\n      case NUMERIC:\n        return isNaN(value);\n      case POSITIVE_NUMERIC:\n        return isNaN(value) || value < 1;\n    }\n  }\n  return false;\n}\n\nfunction getPropertyInfo(name) {\n  return properties.hasOwnProperty(name) ? properties[name] : null;\n}\n\nfunction PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace) {\n  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n  this.attributeName = attributeName;\n  this.attributeNamespace = attributeNamespace;\n  this.mustUseProperty = mustUseProperty;\n  this.propertyName = name;\n  this.type = type;\n}\n\n// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties = {};\n\n// These props are reserved by React. They shouldn't be written to the DOM.\n['children', 'dangerouslySetInnerHTML',\n// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {\n  var name = _ref[0],\n      attributeName = _ref[1];\n\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML boolean attributes.\n['allowFullScreen', 'async',\n// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',\n// Microdata\n'itemScope'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',\n// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple', 'muted', 'selected'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture', 'download'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML attributes that must be positive numbers.\n['cols', 'rows', 'size', 'span'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML attributes that must be numbers.\n['rowSpan', 'start'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\nvar CAMELIZE = /[\\-\\:]([a-z])/g;\nvar capitalize = function (token) {\n  return token[1].toUpperCase();\n};\n\n// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML whitelist.\n// Some of these attributes can be hard to find. This list was created by\n// scrapping the MDN documentation.\n['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, null);\n} // attributeNamespace\n);\n\n// String SVG attributes with the xlink namespace.\n['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, 'http://www.w3.org/1999/xlink');\n});\n\n// String SVG attributes with the xml namespace.\n['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, 'http://www.w3.org/XML/1998/namespace');\n});\n\n// Special case: this attribute exists both in HTML and SVG.\n// Its \"tabindex\" attribute name is case-sensitive in SVG so we can't just use\n// its React `tabIndex` name, like we do for attributes that exist only in HTML.\nproperties.tabIndex = new PropertyInfoRecord('tabIndex', STRING, false, // mustUseProperty\n'tabindex', // attributeName\nnull);\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nfunction getValueForProperty(node, name, expected, propertyInfo) {\n  {\n    if (propertyInfo.mustUseProperty) {\n      var propertyName = propertyInfo.propertyName;\n\n      return node[propertyName];\n    } else {\n      var attributeName = propertyInfo.attributeName;\n\n      var stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          var value = node.getAttribute(attributeName);\n          if (value === '') {\n            return true;\n          }\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          }\n          if (value === '' + expected) {\n            return expected;\n          }\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        }\n        // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue;\n      } else if (stringValue === '' + expected) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}\n\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\nfunction getValueForAttribute(node, name, expected) {\n  {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n    var value = node.getAttribute(name);\n    if (value === '' + expected) {\n      return expected;\n    }\n    return value;\n  }\n}\n\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\nfunction setValueForProperty(node, name, value, isCustomComponentTag) {\n  var propertyInfo = getPropertyInfo(name);\n  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n    return;\n  }\n  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n    value = null;\n  }\n  // If the prop isn't in the special list, treat it as a simple attribute.\n  if (isCustomComponentTag || propertyInfo === null) {\n    if (isAttributeNameSafe(name)) {\n      var _attributeName = name;\n      if (value === null) {\n        node.removeAttribute(_attributeName);\n      } else {\n        node.setAttribute(_attributeName, '' + value);\n      }\n    }\n    return;\n  }\n  var mustUseProperty = propertyInfo.mustUseProperty;\n\n  if (mustUseProperty) {\n    var propertyName = propertyInfo.propertyName;\n\n    if (value === null) {\n      var type = propertyInfo.type;\n\n      node[propertyName] = type === BOOLEAN ? false : '';\n    } else {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      node[propertyName] = value;\n    }\n    return;\n  }\n  // The rest are treated as attributes with special cases.\n  var attributeName = propertyInfo.attributeName,\n      attributeNamespace = propertyInfo.attributeNamespace;\n\n  if (value === null) {\n    node.removeAttribute(attributeName);\n  } else {\n    var _type = propertyInfo.type;\n\n    var attributeValue = void 0;\n    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\n      attributeValue = '';\n    } else {\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      attributeValue = '' + value;\n    }\n    if (attributeNamespace) {\n      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\n    } else {\n      node.setAttribute(attributeName, attributeValue);\n    }\n  }\n}\n\n// Flow does not allow string concatenation of most non-string types. To work\n// around this limitation, we use an opaque type that can only be obtained by\n// passing the value through getToStringValue first.\nfunction toString(value) {\n  return '' + value;\n}\n\nfunction getToStringValue(value) {\n  switch (typeof value) {\n    case 'boolean':\n    case 'number':\n    case 'object':\n    case 'string':\n    case 'undefined':\n      return value;\n    default:\n      // function, symbol are assigned as empty strings\n      return '';\n  }\n}\n\nvar ReactDebugCurrentFrame$1 = null;\n\nvar ReactControlledValuePropTypes = {\n  checkPropTypes: null\n};\n\n{\n  ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n  var hasReadOnlyValue = {\n    button: true,\n    checkbox: true,\n    image: true,\n    hidden: true,\n    radio: true,\n    reset: true,\n    submit: true\n  };\n\n  var propTypes = {\n    value: function (props, propName, componentName) {\n      if (hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == null) {\n        return null;\n      }\n      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    },\n    checked: function (props, propName, componentName) {\n      if (props.onChange || props.readOnly || props.disabled || props[propName] == null) {\n        return null;\n      }\n      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    }\n  };\n\n  /**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */\n  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props) {\n    checkPropTypes(propTypes, props, 'prop', tagName, ReactDebugCurrentFrame$1.getStackAddendum);\n  };\n}\n\n// Exports ReactDOM.createRoot\nvar enableUserTimingAPI = true;\n\n// Experimental error-boundary API that can recover from errors within a single\n// render phase\nvar enableGetDerivedStateFromCatch = false;\n// Suspense\nvar enableSuspense = false;\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\nvar debugRenderPhaseSideEffects = false;\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\nvar debugRenderPhaseSideEffectsForStrictMode = true;\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback = true;\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\nvar warnAboutDeprecatedLifecycles = false;\n\n// Warn about legacy context API\nvar warnAboutLegacyContextAPI = false;\n\n// Gather advanced timing metrics for Profiler subtrees.\nvar enableProfilerTimer = true;\n\n// Track which interactions trigger each commit.\nvar enableSchedulerTracking = true;\n\n// Only used in www builds.\n\n\n// Only used in www builds.\n\n\n// React Fire: prevent the value and checked attributes from syncing\n// with their related DOM properties\nvar disableInputAttributeSyncing = false;\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar didWarnValueDefaultValue = false;\nvar didWarnCheckedDefaultChecked = false;\nvar didWarnControlledToUncontrolled = false;\nvar didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n\n/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\n\nfunction getHostProps(element, props) {\n  var node = element;\n  var checked = props.checked;\n\n  var hostProps = _assign({}, props, {\n    defaultChecked: undefined,\n    defaultValue: undefined,\n    value: undefined,\n    checked: checked != null ? checked : node._wrapperState.initialChecked\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState(element, props) {\n  {\n    ReactControlledValuePropTypes.checkPropTypes('input', props);\n\n    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n      warning$1(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);\n      didWarnCheckedDefaultChecked = true;\n    }\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n      warning$1(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);\n      didWarnValueDefaultValue = true;\n    }\n  }\n\n  var node = element;\n  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;\n\n  node._wrapperState = {\n    initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n    initialValue: getToStringValue(props.value != null ? props.value : defaultValue),\n    controlled: isControlled(props)\n  };\n}\n\nfunction updateChecked(element, props) {\n  var node = element;\n  var checked = props.checked;\n  if (checked != null) {\n    setValueForProperty(node, 'checked', checked, false);\n  }\n}\n\nfunction updateWrapper(element, props) {\n  var node = element;\n  {\n    var _controlled = isControlled(props);\n\n    if (!node._wrapperState.controlled && _controlled && !didWarnUncontrolledToControlled) {\n      warning$1(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', props.type);\n      didWarnUncontrolledToControlled = true;\n    }\n    if (node._wrapperState.controlled && !_controlled && !didWarnControlledToUncontrolled) {\n      warning$1(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', props.type);\n      didWarnControlledToUncontrolled = true;\n    }\n  }\n\n  updateChecked(element, props);\n\n  var value = getToStringValue(props.value);\n  var type = props.type;\n\n  if (value != null) {\n    if (type === 'number') {\n      if (value === 0 && node.value === '' ||\n      // We explicitly want to coerce to number here if possible.\n      // eslint-disable-next-line\n      node.value != value) {\n        node.value = toString(value);\n      }\n    } else if (node.value !== toString(value)) {\n      node.value = toString(value);\n    }\n  } else if (type === 'submit' || type === 'reset') {\n    // Submit/reset inputs need the attribute removed completely to avoid\n    // blank-text buttons.\n    node.removeAttribute('value');\n    return;\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the value attribute, React only assigns a new value\n    // whenever the defaultValue React prop has changed. When not present,\n    // React does nothing\n    if (props.hasOwnProperty('defaultValue')) {\n      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n    }\n  } else {\n    // When syncing the value attribute, the value comes from a cascade of\n    // properties:\n    //  1. The value React property\n    //  2. The defaultValue React property\n    //  3. Otherwise there should be no change\n    if (props.hasOwnProperty('value')) {\n      setDefaultValue(node, props.type, value);\n    } else if (props.hasOwnProperty('defaultValue')) {\n      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n    }\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the checked attribute, the attribute is directly\n    // controllable from the defaultValue React property. It needs to be\n    // updated as new props come in.\n    if (props.defaultChecked == null) {\n      node.removeAttribute('checked');\n    } else {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  } else {\n    // When syncing the checked attribute, it only changes when it needs\n    // to be removed, such as transitioning from a checkbox into a text input\n    if (props.checked == null && props.defaultChecked != null) {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  }\n}\n\nfunction postMountWrapper(element, props, isHydrating) {\n  var node = element;\n\n  // Do not assign value if it is already set. This prevents user text input\n  // from being lost during SSR hydration.\n  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {\n    var type = props.type;\n    var isButton = type === 'submit' || type === 'reset';\n\n    // Avoid setting value attribute on submit/reset inputs as it overrides the\n    // default value provided by the browser. See: #12872\n    if (isButton && (props.value === undefined || props.value === null)) {\n      return;\n    }\n\n    var _initialValue = toString(node._wrapperState.initialValue);\n\n    // Do not assign value if it is already set. This prevents user text input\n    // from being lost during SSR hydration.\n    if (!isHydrating) {\n      if (disableInputAttributeSyncing) {\n        var value = getToStringValue(props.value);\n\n        // When not syncing the value attribute, the value property points\n        // directly to the React prop. Only assign it if it exists.\n        if (value != null) {\n          // Always assign on buttons so that it is possible to assign an\n          // empty string to clear button text.\n          //\n          // Otherwise, do not re-assign the value property if is empty. This\n          // potentially avoids a DOM write and prevents Firefox (~60.0.1) from\n          // prematurely marking required inputs as invalid. Equality is compared\n          // to the current value in case the browser provided value is not an\n          // empty string.\n          if (isButton || value !== node.value) {\n            node.value = toString(value);\n          }\n        }\n      } else {\n        // When syncing the value attribute, the value property should use\n        // the the wrapperState._initialValue property. This uses:\n        //\n        //   1. The value React property when present\n        //   2. The defaultValue React property when present\n        //   3. An empty string\n        if (_initialValue !== node.value) {\n          node.value = _initialValue;\n        }\n      }\n    }\n\n    if (disableInputAttributeSyncing) {\n      // When not syncing the value attribute, assign the value attribute\n      // directly from the defaultValue React property (when present)\n      var defaultValue = getToStringValue(props.defaultValue);\n      if (defaultValue != null) {\n        node.defaultValue = toString(defaultValue);\n      }\n    } else {\n      // Otherwise, the value attribute is synchronized to the property,\n      // so we assign defaultValue to the same thing as the value property\n      // assignment step above.\n      node.defaultValue = _initialValue;\n    }\n  }\n\n  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n  // this is needed to work around a chrome bug where setting defaultChecked\n  // will sometimes influence the value of checked (even after detachment).\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n  // We need to temporarily unset name to avoid disrupting radio button groups.\n  var name = node.name;\n  if (name !== '') {\n    node.name = '';\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the checked attribute, the checked property\n    // never gets assigned. It must be manually set. We don't want\n    // to do this when hydrating so that existing user input isn't\n    // modified\n    if (!isHydrating) {\n      updateChecked(element, props);\n    }\n\n    // Only assign the checked attribute if it is defined. This saves\n    // a DOM write when controlling the checked attribute isn't needed\n    // (text inputs, submit/reset)\n    if (props.hasOwnProperty('defaultChecked')) {\n      node.defaultChecked = !node.defaultChecked;\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  } else {\n    // When syncing the checked attribute, both the the checked property and\n    // attribute are assigned at the same time using defaultChecked. This uses:\n    //\n    //   1. The checked React property when present\n    //   2. The defaultChecked React property when present\n    //   3. Otherwise, false\n    node.defaultChecked = !node.defaultChecked;\n    node.defaultChecked = !!node._wrapperState.initialChecked;\n  }\n\n  if (name !== '') {\n    node.name = name;\n  }\n}\n\nfunction restoreControlledState(element, props) {\n  var node = element;\n  updateWrapper(node, props);\n  updateNamedCousins(node, props);\n}\n\nfunction updateNamedCousins(rootNode, props) {\n  var name = props.name;\n  if (props.type === 'radio' && name != null) {\n    var queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (var i = 0; i < group.length; i++) {\n      var otherNode = group[i];\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);\n      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;\n\n      // We need update the tracked value on the named cousin since the value\n      // was changed but the input saw no event or value set\n      updateValueIfChanged(otherNode);\n\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      updateWrapper(otherNode, otherProps);\n    }\n  }\n}\n\n// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node, type, value) {\n  if (\n  // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\n  type !== 'number' || node.ownerDocument.activeElement !== node) {\n    if (value == null) {\n      node.defaultValue = toString(node._wrapperState.initialValue);\n    } else if (node.defaultValue !== toString(value)) {\n      node.defaultValue = toString(value);\n    }\n  }\n}\n\nvar eventTypes$1 = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE]\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n  event.type = 'change';\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  runEventsInBatch(event, false);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance$1(targetInst);\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_CHANGE) {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === TOP_FOCUS) {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === TOP_BLUR) {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_CLICK) {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(node) {\n  var state = node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  if (!disableInputAttributeSyncing) {\n    // If controlled, assign the value attribute to the current value on blur\n    setDefaultValue(node, 'number', node.value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes$1,\n\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    var getTargetInstFunc = void 0,\n        handleEventFunc = void 0;\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === TOP_BLUR) {\n      handleControlledInputBlur(targetNode);\n    }\n  }\n};\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n\nvar SyntheticUIEvent = SyntheticEvent.extend({\n  view: null,\n  detail: null\n});\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  Alt: 'altKey',\n  Control: 'ctrlKey',\n  Meta: 'metaKey',\n  Shift: 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\nvar previousScreenX = 0;\nvar previousScreenY = 0;\n// Use flags to signal movementX/Y has already been set\nvar isMovementXSet = false;\nvar isMovementYSet = false;\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticMouseEvent = SyntheticUIEvent.extend({\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  pageX: null,\n  pageY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: null,\n  buttons: null,\n  relatedTarget: function (event) {\n    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n  },\n  movementX: function (event) {\n    if ('movementX' in event) {\n      return event.movementX;\n    }\n\n    var screenX = previousScreenX;\n    previousScreenX = event.screenX;\n\n    if (!isMovementXSet) {\n      isMovementXSet = true;\n      return 0;\n    }\n\n    return event.type === 'mousemove' ? event.screenX - screenX : 0;\n  },\n  movementY: function (event) {\n    if ('movementY' in event) {\n      return event.movementY;\n    }\n\n    var screenY = previousScreenY;\n    previousScreenY = event.screenY;\n\n    if (!isMovementYSet) {\n      isMovementYSet = true;\n      return 0;\n    }\n\n    return event.type === 'mousemove' ? event.screenY - screenY : 0;\n  }\n});\n\n/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */\nvar SyntheticPointerEvent = SyntheticMouseEvent.extend({\n  pointerId: null,\n  width: null,\n  height: null,\n  pressure: null,\n  tangentialPressure: null,\n  tiltX: null,\n  tiltY: null,\n  twist: null,\n  pointerType: null,\n  isPrimary: null\n});\n\nvar eventTypes$2 = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]\n  },\n  pointerEnter: {\n    registrationName: 'onPointerEnter',\n    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]\n  },\n  pointerLeave: {\n    registrationName: 'onPointerLeave',\n    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]\n  }\n};\n\nvar EnterLeaveEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;\n    var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;\n\n    if (isOverEvent && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n\n    if (!isOutEvent && !isOverEvent) {\n      // Must not be a mouse or pointer in or out - ignoring.\n      return null;\n    }\n\n    var win = void 0;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from = void 0;\n    var to = void 0;\n    if (isOutEvent) {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var eventInterface = void 0,\n        leaveEventType = void 0,\n        enterEventType = void 0,\n        eventTypePrefix = void 0;\n\n    if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {\n      eventInterface = SyntheticMouseEvent;\n      leaveEventType = eventTypes$2.mouseLeave;\n      enterEventType = eventTypes$2.mouseEnter;\n      eventTypePrefix = 'mouse';\n    } else if (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {\n      eventInterface = SyntheticPointerEvent;\n      leaveEventType = eventTypes$2.pointerLeave;\n      enterEventType = eventTypes$2.pointerEnter;\n      eventTypePrefix = 'pointer';\n    }\n\n    var fromNode = from == null ? win : getNodeFromInstance$1(from);\n    var toNode = to == null ? win : getNodeFromInstance$1(to);\n\n    var leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);\n    leave.type = eventTypePrefix + 'leave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);\n    enter.type = eventTypePrefix + 'enter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }\n};\n\n/*eslint-disable no-self-compare */\n\nvar hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty$1.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction has(key) {\n  return key._reactInternalFiber !== undefined;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect = /*              */0;\nvar PerformedWork = /*         */1;\n\n// You can change the rest (and add more).\nvar Placement = /*             */2;\nvar Update = /*                */4;\nvar PlacementAndUpdate = /*    */6;\nvar Deletion = /*              */8;\nvar ContentReset = /*          */16;\nvar Callback = /*              */32;\nvar DidCapture = /*            */64;\nvar Ref = /*                   */128;\nvar Snapshot = /*              */256;\n\n// Update & Callback & Ref & Snapshot\nvar LifecycleEffectMask = /*   */420;\n\n// Union of all host effects\nvar HostEffectMask = /*        */511;\n\nvar Incomplete = /*            */512;\nvar ShouldCapture = /*         */1024;\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node.return) {\n      node = node.return;\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner$1.current;\n    if (owner !== null && (owner.tag === ClassComponent || owner.tag === ClassComponentLazy)) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber.type) || 'A component') : void 0;\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a.return;\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction addEventBubbleListener(element, eventType, listener) {\n  element.addEventListener(eventType, listener, false);\n}\n\nfunction addEventCaptureListener(element, eventType, listener) {\n  element.addEventListener(eventType, listener, true);\n}\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */\nvar SyntheticAnimationEvent = SyntheticEvent.extend({\n  animationName: null,\n  elapsedTime: null,\n  pseudoElement: null\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar SyntheticClipboardEvent = SyntheticEvent.extend({\n  clipboardData: function (event) {\n    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n  }\n});\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticFocusEvent = SyntheticUIEvent.extend({\n  relatedTarget: null\n});\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode = void 0;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n  // report Enter as charCode 10 when ctrl is pressed.\n  if (charCode === 10) {\n    charCode = 13;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  Esc: 'Escape',\n  Spacebar: ' ',\n  Left: 'ArrowLeft',\n  Up: 'ArrowUp',\n  Right: 'ArrowRight',\n  Down: 'ArrowDown',\n  Del: 'Delete',\n  Win: 'OS',\n  Menu: 'ContextMenu',\n  Apps: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  MozPrintableKey: 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  '8': 'Backspace',\n  '9': 'Tab',\n  '12': 'Clear',\n  '13': 'Enter',\n  '16': 'Shift',\n  '17': 'Control',\n  '18': 'Alt',\n  '19': 'Pause',\n  '20': 'CapsLock',\n  '27': 'Escape',\n  '32': ' ',\n  '33': 'PageUp',\n  '34': 'PageDown',\n  '35': 'End',\n  '36': 'Home',\n  '37': 'ArrowLeft',\n  '38': 'ArrowUp',\n  '39': 'ArrowRight',\n  '40': 'ArrowDown',\n  '45': 'Insert',\n  '46': 'Delete',\n  '112': 'F1',\n  '113': 'F2',\n  '114': 'F3',\n  '115': 'F4',\n  '116': 'F5',\n  '117': 'F6',\n  '118': 'F7',\n  '119': 'F8',\n  '120': 'F9',\n  '121': 'F10',\n  '122': 'F11',\n  '123': 'F12',\n  '144': 'NumLock',\n  '145': 'ScrollLock',\n  '224': 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticKeyboardEvent = SyntheticUIEvent.extend({\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function (event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function (event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function (event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n});\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticDragEvent = SyntheticMouseEvent.extend({\n  dataTransfer: null\n});\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar SyntheticTouchEvent = SyntheticUIEvent.extend({\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */\nvar SyntheticTransitionEvent = SyntheticEvent.extend({\n  propertyName: null,\n  elapsedTime: null,\n  pseudoElement: null\n});\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticWheelEvent = SyntheticMouseEvent.extend({\n  deltaX: function (event) {\n    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n  },\n  deltaY: function (event) {\n    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n    'wheelDelta' in event ? -event.wheelDelta : 0;\n  },\n\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n});\n\n/**\n * Turns\n * ['abort', ...]\n * into\n * eventTypes = {\n *   'abort': {\n *     phasedRegistrationNames: {\n *       bubbled: 'onAbort',\n *       captured: 'onAbortCapture',\n *     },\n *     dependencies: [TOP_ABORT],\n *   },\n *   ...\n * };\n * topLevelEventsToDispatchConfig = new Map([\n *   [TOP_ABORT, { sameConfig }],\n * ]);\n */\n\nvar interactiveEventTypeNames = [[TOP_BLUR, 'blur'], [TOP_CANCEL, 'cancel'], [TOP_CLICK, 'click'], [TOP_CLOSE, 'close'], [TOP_CONTEXT_MENU, 'contextMenu'], [TOP_COPY, 'copy'], [TOP_CUT, 'cut'], [TOP_AUX_CLICK, 'auxClick'], [TOP_DOUBLE_CLICK, 'doubleClick'], [TOP_DRAG_END, 'dragEnd'], [TOP_DRAG_START, 'dragStart'], [TOP_DROP, 'drop'], [TOP_FOCUS, 'focus'], [TOP_INPUT, 'input'], [TOP_INVALID, 'invalid'], [TOP_KEY_DOWN, 'keyDown'], [TOP_KEY_PRESS, 'keyPress'], [TOP_KEY_UP, 'keyUp'], [TOP_MOUSE_DOWN, 'mouseDown'], [TOP_MOUSE_UP, 'mouseUp'], [TOP_PASTE, 'paste'], [TOP_PAUSE, 'pause'], [TOP_PLAY, 'play'], [TOP_POINTER_CANCEL, 'pointerCancel'], [TOP_POINTER_DOWN, 'pointerDown'], [TOP_POINTER_UP, 'pointerUp'], [TOP_RATE_CHANGE, 'rateChange'], [TOP_RESET, 'reset'], [TOP_SEEKED, 'seeked'], [TOP_SUBMIT, 'submit'], [TOP_TOUCH_CANCEL, 'touchCancel'], [TOP_TOUCH_END, 'touchEnd'], [TOP_TOUCH_START, 'touchStart'], [TOP_VOLUME_CHANGE, 'volumeChange']];\nvar nonInteractiveEventTypeNames = [[TOP_ABORT, 'abort'], [TOP_ANIMATION_END, 'animationEnd'], [TOP_ANIMATION_ITERATION, 'animationIteration'], [TOP_ANIMATION_START, 'animationStart'], [TOP_CAN_PLAY, 'canPlay'], [TOP_CAN_PLAY_THROUGH, 'canPlayThrough'], [TOP_DRAG, 'drag'], [TOP_DRAG_ENTER, 'dragEnter'], [TOP_DRAG_EXIT, 'dragExit'], [TOP_DRAG_LEAVE, 'dragLeave'], [TOP_DRAG_OVER, 'dragOver'], [TOP_DURATION_CHANGE, 'durationChange'], [TOP_EMPTIED, 'emptied'], [TOP_ENCRYPTED, 'encrypted'], [TOP_ENDED, 'ended'], [TOP_ERROR, 'error'], [TOP_GOT_POINTER_CAPTURE, 'gotPointerCapture'], [TOP_LOAD, 'load'], [TOP_LOADED_DATA, 'loadedData'], [TOP_LOADED_METADATA, 'loadedMetadata'], [TOP_LOAD_START, 'loadStart'], [TOP_LOST_POINTER_CAPTURE, 'lostPointerCapture'], [TOP_MOUSE_MOVE, 'mouseMove'], [TOP_MOUSE_OUT, 'mouseOut'], [TOP_MOUSE_OVER, 'mouseOver'], [TOP_PLAYING, 'playing'], [TOP_POINTER_MOVE, 'pointerMove'], [TOP_POINTER_OUT, 'pointerOut'], [TOP_POINTER_OVER, 'pointerOver'], [TOP_PROGRESS, 'progress'], [TOP_SCROLL, 'scroll'], [TOP_SEEKING, 'seeking'], [TOP_STALLED, 'stalled'], [TOP_SUSPEND, 'suspend'], [TOP_TIME_UPDATE, 'timeUpdate'], [TOP_TOGGLE, 'toggle'], [TOP_TOUCH_MOVE, 'touchMove'], [TOP_TRANSITION_END, 'transitionEnd'], [TOP_WAITING, 'waiting'], [TOP_WHEEL, 'wheel']];\n\nvar eventTypes$4 = {};\nvar topLevelEventsToDispatchConfig = {};\n\nfunction addEventTypeNameToConfig(_ref, isInteractive) {\n  var topEvent = _ref[0],\n      event = _ref[1];\n\n  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n  var onEvent = 'on' + capitalizedEvent;\n\n  var type = {\n    phasedRegistrationNames: {\n      bubbled: onEvent,\n      captured: onEvent + 'Capture'\n    },\n    dependencies: [topEvent],\n    isInteractive: isInteractive\n  };\n  eventTypes$4[event] = type;\n  topLevelEventsToDispatchConfig[topEvent] = type;\n}\n\ninteractiveEventTypeNames.forEach(function (eventTuple) {\n  addEventTypeNameToConfig(eventTuple, true);\n});\nnonInteractiveEventTypeNames.forEach(function (eventTuple) {\n  addEventTypeNameToConfig(eventTuple, false);\n});\n\n// Only used in DEV for exhaustiveness validation.\nvar knownHTMLTopLevelTypes = [TOP_ABORT, TOP_CANCEL, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_CLOSE, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_INPUT, TOP_INVALID, TOP_LOAD, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_RESET, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUBMIT, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_TOGGLE, TOP_VOLUME_CHANGE, TOP_WAITING];\n\nvar SimpleEventPlugin = {\n  eventTypes: eventTypes$4,\n\n  isInteractiveTopLevelEventType: function (topLevelType) {\n    var config = topLevelEventsToDispatchConfig[topLevelType];\n    return config !== undefined && config.isInteractive === true;\n  },\n\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor = void 0;\n    switch (topLevelType) {\n      case TOP_KEY_PRESS:\n        // Firefox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n      /* falls through */\n      case TOP_KEY_DOWN:\n      case TOP_KEY_UP:\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case TOP_BLUR:\n      case TOP_FOCUS:\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case TOP_CLICK:\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n      /* falls through */\n      case TOP_AUX_CLICK:\n      case TOP_DOUBLE_CLICK:\n      case TOP_MOUSE_DOWN:\n      case TOP_MOUSE_MOVE:\n      case TOP_MOUSE_UP:\n      // TODO: Disabled elements should not respond to mouse events\n      /* falls through */\n      case TOP_MOUSE_OUT:\n      case TOP_MOUSE_OVER:\n      case TOP_CONTEXT_MENU:\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case TOP_DRAG:\n      case TOP_DRAG_END:\n      case TOP_DRAG_ENTER:\n      case TOP_DRAG_EXIT:\n      case TOP_DRAG_LEAVE:\n      case TOP_DRAG_OVER:\n      case TOP_DRAG_START:\n      case TOP_DROP:\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case TOP_TOUCH_CANCEL:\n      case TOP_TOUCH_END:\n      case TOP_TOUCH_MOVE:\n      case TOP_TOUCH_START:\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case TOP_ANIMATION_END:\n      case TOP_ANIMATION_ITERATION:\n      case TOP_ANIMATION_START:\n        EventConstructor = SyntheticAnimationEvent;\n        break;\n      case TOP_TRANSITION_END:\n        EventConstructor = SyntheticTransitionEvent;\n        break;\n      case TOP_SCROLL:\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case TOP_WHEEL:\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case TOP_COPY:\n      case TOP_CUT:\n      case TOP_PASTE:\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n      case TOP_GOT_POINTER_CAPTURE:\n      case TOP_LOST_POINTER_CAPTURE:\n      case TOP_POINTER_CANCEL:\n      case TOP_POINTER_DOWN:\n      case TOP_POINTER_MOVE:\n      case TOP_POINTER_OUT:\n      case TOP_POINTER_OVER:\n      case TOP_POINTER_UP:\n        EventConstructor = SyntheticPointerEvent;\n        break;\n      default:\n        {\n          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {\n            warningWithoutStack$1(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);\n          }\n        }\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent;\n        break;\n    }\n    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n    accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nvar isInteractiveTopLevelEventType = SimpleEventPlugin.isInteractiveTopLevelEventType;\n\n\nvar CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nvar callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst.return) {\n    inst = inst.return;\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n  if (callbackBookkeepingPool.length) {\n    var instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType: topLevelType,\n    nativeEvent: nativeEvent,\n    targetInst: targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevel(bookKeeping) {\n  var targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      bookKeeping.ancestors.push(ancestor);\n      break;\n    }\n    var root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    runExtractedEventsInBatch(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\n// TODO: can we stop exporting these?\nvar _enabled = true;\n\nfunction setEnabled(enabled) {\n  _enabled = !!enabled;\n}\n\nfunction isEnabled() {\n  return _enabled;\n}\n\n/**\n * Traps top-level events by using event bubbling.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapBubbledEvent(topLevelType, element) {\n  if (!element) {\n    return null;\n  }\n  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\n\n  addEventBubbleListener(element, getRawEventName(topLevelType),\n  // Check if interactive and wrap in interactiveUpdates\n  dispatch.bind(null, topLevelType));\n}\n\n/**\n * Traps a top-level event by using event capturing.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapCapturedEvent(topLevelType, element) {\n  if (!element) {\n    return null;\n  }\n  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\n\n  addEventCaptureListener(element, getRawEventName(topLevelType),\n  // Check if interactive and wrap in interactiveUpdates\n  dispatch.bind(null, topLevelType));\n}\n\nfunction dispatchInteractiveEvent(topLevelType, nativeEvent) {\n  interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);\n}\n\nfunction dispatchEvent(topLevelType, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  var nativeEventTarget = getEventTarget(nativeEvent);\n  var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {\n    // If we get an event (ex: img onload) before committing that\n    // component's mount, ignore it for now (that is, treat it as if it was an\n    // event on a non-React tree). We might also consider queueing events and\n    // dispatching them after the mount.\n    targetInst = null;\n  }\n\n  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar reactTopListenersCounter = 0;\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} mountAt Container where to mount the listener\n */\nfunction listenTo(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      switch (dependency) {\n        case TOP_SCROLL:\n          trapCapturedEvent(TOP_SCROLL, mountAt);\n          break;\n        case TOP_FOCUS:\n        case TOP_BLUR:\n          trapCapturedEvent(TOP_FOCUS, mountAt);\n          trapCapturedEvent(TOP_BLUR, mountAt);\n          // We set the flag for a single dependency later in this function,\n          // but this ensures we mark both as attached rather than just one.\n          isListening[TOP_BLUR] = true;\n          isListening[TOP_FOCUS] = true;\n          break;\n        case TOP_CANCEL:\n        case TOP_CLOSE:\n          if (isEventSupported(getRawEventName(dependency))) {\n            trapCapturedEvent(dependency, mountAt);\n          }\n          break;\n        case TOP_INVALID:\n        case TOP_SUBMIT:\n        case TOP_RESET:\n          // We listen to them on the target DOM elements.\n          // Some of them bubble so we don't want them to fire twice.\n          break;\n        default:\n          // By default, listen on the top level to all non-media events.\n          // Media events don't bubble so adding the listener wouldn't do anything.\n          var isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;\n          if (!isMediaEvent) {\n            trapBubbledEvent(dependency, mountAt);\n          }\n          break;\n      }\n      isListening[dependency] = true;\n    }\n  }\n}\n\nfunction isListeningToAllDependencies(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getActiveElement(doc) {\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === TEXT_NODE) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\nfunction getOffsets(outerNode) {\n  var ownerDocument = outerNode.ownerDocument;\n\n  var win = ownerDocument && ownerDocument.defaultView || window;\n  var selection = win.getSelection && win.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode,\n      anchorOffset = selection.anchorOffset,\n      focusNode = selection.focusNode,\n      focusOffset = selection.focusOffset;\n\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\n}\n\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\nfunction getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var length = 0;\n  var start = -1;\n  var end = -1;\n  var indexWithinAnchor = 0;\n  var indexWithinFocus = 0;\n  var node = outerNode;\n  var parentNode = null;\n\n  outer: while (true) {\n    var next = null;\n\n    while (true) {\n      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n        start = length + anchorOffset;\n      }\n      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      }\n      // Moving from `node` to its first child `next`.\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n      node = parentNode;\n      parentNode = node.parentNode;\n    }\n\n    // Moving from `node` to its next sibling `next`.\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setOffsets(node, offsets) {\n  var doc = node.ownerDocument || document;\n  var win = doc ? doc.defaultView : window;\n  var selection = win.getSelection();\n  var length = node.textContent.length;\n  var start = Math.min(offsets.start, length);\n  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n      return;\n    }\n    var range = doc.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nfunction isTextNode(node) {\n  return node && node.nodeType === TEXT_NODE;\n}\n\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nfunction isInDocument(node) {\n  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);\n}\n\nfunction getActiveElementDeep() {\n  var win = window;\n  var element = getActiveElement();\n  while (element instanceof win.HTMLIFrameElement) {\n    // Accessing the contentDocument of a HTMLIframeElement can cause the browser\n    // to throw, e.g. if it has a cross-origin src attribute\n    try {\n      win = element.contentDocument.defaultView;\n    } catch (e) {\n      return element;\n    }\n    element = getActiveElement(win.document);\n  }\n  return element;\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\n\n/**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');\n}\n\nfunction getSelectionInformation() {\n  var focusedElem = getActiveElementDeep();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null\n  };\n}\n\n/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */\nfunction restoreSelection(priorSelectionInformation) {\n  var curFocusedElem = getActiveElementDeep();\n  var priorFocusedElem = priorSelectionInformation.focusedElem;\n  var priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    }\n\n    // Focusing a node can change the scroll position, which is undesirable\n    var ancestors = [];\n    var ancestor = priorFocusedElem;\n    while (ancestor = ancestor.parentNode) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop\n        });\n      }\n    }\n\n    if (typeof priorFocusedElem.focus === 'function') {\n      priorFocusedElem.focus();\n    }\n\n    for (var i = 0; i < ancestors.length; i++) {\n      var info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n\n/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */\nfunction getSelection$1(input) {\n  var selection = void 0;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || { start: 0, end: 0 };\n}\n\n/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */\nfunction setSelection(input, offsets) {\n  var start = offsets.start,\n      end = offsets.end;\n\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}\n\nvar skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nvar eventTypes$3 = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_CONTEXT_MENU, TOP_DRAG_END, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE]\n  }\n};\n\nvar activeElement$1 = null;\nvar activeElementInst$1 = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else {\n    var win = node.ownerDocument && node.ownerDocument.defaultView || window;\n    var selection = win.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n\n/**\n * Get document associated with the event target.\n *\n * @param {object} nativeEventTarget\n * @return {Document}\n */\nfunction getEventTargetDocument(eventTarget) {\n  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  var doc = getEventTargetDocument(nativeEventTarget);\n\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n  eventTypes: eventTypes$3,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var doc = getEventTargetDocument(nativeEventTarget);\n    // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case TOP_FOCUS:\n        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n          activeElement$1 = targetNode;\n          activeElementInst$1 = targetInst;\n          lastSelection = null;\n        }\n        break;\n      case TOP_BLUR:\n        activeElement$1 = null;\n        activeElementInst$1 = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case TOP_MOUSE_DOWN:\n        mouseDown = true;\n        break;\n      case TOP_CONTEXT_MENU:\n      case TOP_MOUSE_UP:\n      case TOP_DRAG_END:\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case TOP_SELECTION_CHANGE:\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case TOP_KEY_DOWN:\n      case TOP_KEY_UP:\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  }\n};\n\n/**\n * Inject modules for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(DOMEventPluginOrder);\nsetComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  SimpleEventPlugin: SimpleEventPlugin,\n  EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n  ChangeEventPlugin: ChangeEventPlugin,\n  SelectEventPlugin: SelectEventPlugin,\n  BeforeInputEventPlugin: BeforeInputEventPlugin\n});\n\nvar didWarnSelectedSetOnOption = false;\nvar didWarnInvalidChild = false;\n\nfunction flattenChildren(children) {\n  var content = '';\n\n  // Flatten children. We'll warn if they are invalid\n  // during validateProps() which runs for hydration too.\n  // Note that this would throw on non-element objects.\n  // Elements are stringified (which is normally irrelevant\n  // but matters for <fbt>).\n  React.Children.forEach(children, function (child) {\n    if (child == null) {\n      return;\n    }\n    content += child;\n    // Note: we don't warn about invalid children here.\n    // Instead, this is done separately below so that\n    // it happens during the hydration codepath too.\n  });\n\n  return content;\n}\n\n/**\n * Implements an <option> host component that warns when `selected` is set.\n */\n\nfunction validateProps(element, props) {\n  {\n    // This mirrors the codepath above, but runs for hydration too.\n    // Warn about invalid children here so that client and hydration are consistent.\n    // TODO: this seems like it could cause a DEV-only throw for hydration\n    // if children contains a non-element object. We should try to avoid that.\n    if (typeof props.children === 'object' && props.children !== null) {\n      React.Children.forEach(props.children, function (child) {\n        if (child == null) {\n          return;\n        }\n        if (typeof child === 'string' || typeof child === 'number') {\n          return;\n        }\n        if (typeof child.type !== 'string') {\n          return;\n        }\n        if (!didWarnInvalidChild) {\n          didWarnInvalidChild = true;\n          warning$1(false, 'Only strings and numbers are supported as <option> children.');\n        }\n      });\n    }\n\n    // TODO: Remove support for `selected` in <option>.\n    if (props.selected != null && !didWarnSelectedSetOnOption) {\n      warning$1(false, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n      didWarnSelectedSetOnOption = true;\n    }\n  }\n}\n\nfunction postMountWrapper$1(element, props) {\n  // value=\"\" should make a value attribute (#6219)\n  if (props.value != null) {\n    element.setAttribute('value', toString(getToStringValue(props.value)));\n  }\n}\n\nfunction getHostProps$1(element, props) {\n  var hostProps = _assign({ children: undefined }, props);\n  var content = flattenChildren(props.children);\n\n  if (content) {\n    hostProps.children = content;\n  }\n\n  return hostProps;\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar didWarnValueDefaultValue$1 = void 0;\n\n{\n  didWarnValueDefaultValue$1 = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n  if (ownerName) {\n    return '\\n\\nCheck the render method of `' + ownerName + '`.';\n  }\n  return '';\n}\n\nvar valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n */\nfunction checkSelectPropTypes(props) {\n  ReactControlledValuePropTypes.checkPropTypes('select', props);\n\n  for (var i = 0; i < valuePropNames.length; i++) {\n    var propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    var isArray = Array.isArray(props[propName]);\n    if (props.multiple && !isArray) {\n      warning$1(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n    } else if (!props.multiple && isArray) {\n      warning$1(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n    }\n  }\n}\n\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  var options = node.options;\n\n  if (multiple) {\n    var selectedValues = propValue;\n    var selectedValue = {};\n    for (var i = 0; i < selectedValues.length; i++) {\n      // Prefix to avoid chaos with special keys.\n      selectedValue['$' + selectedValues[i]] = true;\n    }\n    for (var _i = 0; _i < options.length; _i++) {\n      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n      if (options[_i].selected !== selected) {\n        options[_i].selected = selected;\n      }\n      if (selected && setDefaultSelected) {\n        options[_i].defaultSelected = true;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    var _selectedValue = toString(getToStringValue(propValue));\n    var defaultSelected = null;\n    for (var _i2 = 0; _i2 < options.length; _i2++) {\n      if (options[_i2].value === _selectedValue) {\n        options[_i2].selected = true;\n        if (setDefaultSelected) {\n          options[_i2].defaultSelected = true;\n        }\n        return;\n      }\n      if (defaultSelected === null && !options[_i2].disabled) {\n        defaultSelected = options[_i2];\n      }\n    }\n    if (defaultSelected !== null) {\n      defaultSelected.selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\n\nfunction getHostProps$2(element, props) {\n  return _assign({}, props, {\n    value: undefined\n  });\n}\n\nfunction initWrapperState$1(element, props) {\n  var node = element;\n  {\n    checkSelectPropTypes(props);\n  }\n\n  node._wrapperState = {\n    wasMultiple: !!props.multiple\n  };\n\n  {\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n      warning$1(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValueDefaultValue$1 = true;\n    }\n  }\n}\n\nfunction postMountWrapper$2(element, props) {\n  var node = element;\n  node.multiple = !!props.multiple;\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (props.defaultValue != null) {\n    updateOptions(node, !!props.multiple, props.defaultValue, true);\n  }\n}\n\nfunction postUpdateWrapper(element, props) {\n  var node = element;\n  var wasMultiple = node._wrapperState.wasMultiple;\n  node._wrapperState.wasMultiple = !!props.multiple;\n\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (wasMultiple !== !!props.multiple) {\n    // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n    if (props.defaultValue != null) {\n      updateOptions(node, !!props.multiple, props.defaultValue, true);\n    } else {\n      // Revert the select back to its default unselected state.\n      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\n    }\n  }\n}\n\nfunction restoreControlledState$2(element, props) {\n  var node = element;\n  var value = props.value;\n\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  }\n}\n\nvar didWarnValDefaultVal = false;\n\n/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\n\nfunction getHostProps$3(element, props) {\n  var node = element;\n  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;\n\n  // Always set children to the same thing. In IE9, the selection range will\n  // get reset if `textContent` is mutated.  We could add a check in setTextContent\n  // to only set the value if/when the value differs from the node value (which would\n  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n  // solution. The value can be a boolean or object so that's why it's forced\n  // to be a string.\n  var hostProps = _assign({}, props, {\n    value: undefined,\n    defaultValue: undefined,\n    children: toString(node._wrapperState.initialValue)\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState$2(element, props) {\n  var node = element;\n  {\n    ReactControlledValuePropTypes.checkPropTypes('textarea', props);\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n      warning$1(false, '%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');\n      didWarnValDefaultVal = true;\n    }\n  }\n\n  var initialValue = props.value;\n\n  // Only bother fetching default value if we're going to use it\n  if (initialValue == null) {\n    var defaultValue = props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = props.children;\n    if (children != null) {\n      {\n        warning$1(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n      }\n      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n      if (Array.isArray(children)) {\n        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n        children = children[0];\n      }\n\n      defaultValue = children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    initialValue = defaultValue;\n  }\n\n  node._wrapperState = {\n    initialValue: getToStringValue(initialValue)\n  };\n}\n\nfunction updateWrapper$1(element, props) {\n  var node = element;\n  var value = getToStringValue(props.value);\n  if (value != null) {\n    // Cast `value` to a string to ensure the value is set correctly. While\n    // browsers typically do this as necessary, jsdom doesn't.\n    var newValue = toString(value);\n    // To avoid side effects (such as losing text selection), only set value if changed\n    if (newValue !== node.value) {\n      node.value = newValue;\n    }\n    if (props.defaultValue == null) {\n      node.defaultValue = newValue;\n    }\n  }\n  if (props.defaultValue != null) {\n    node.defaultValue = toString(getToStringValue(props.defaultValue));\n  }\n}\n\nfunction postMountWrapper$3(element, props) {\n  var node = element;\n  // This is in postMount because we need access to the DOM node, which is not\n  // available until after the component has mounted.\n  var textContent = node.textContent;\n\n  // Only set node.value if textContent is equal to the expected\n  // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n  // will populate textContent as well.\n  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n  if (textContent === node._wrapperState.initialValue) {\n    node.value = textContent;\n  }\n}\n\nfunction restoreControlledState$3(element, props) {\n  // DOM component is still mounted; update\n  updateWrapper$1(element, props);\n}\n\nvar HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';\nvar MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nvar Namespaces = {\n  html: HTML_NAMESPACE$1,\n  mathml: MATH_NAMESPACE,\n  svg: SVG_NAMESPACE\n};\n\n// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type) {\n  switch (type) {\n    case 'svg':\n      return SVG_NAMESPACE;\n    case 'math':\n      return MATH_NAMESPACE;\n    default:\n      return HTML_NAMESPACE$1;\n  }\n}\n\nfunction getChildNamespace(parentNamespace, type) {\n  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {\n    // No (or default) parent namespace: potential entry point.\n    return getIntrinsicNamespace(type);\n  }\n  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n    // We're leaving SVG.\n    return HTML_NAMESPACE$1;\n  }\n  // By default, pass namespace below.\n  return parentNamespace;\n}\n\n/* globals MSApp */\n\n/**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */\nvar createMicrosoftUnsafeLocalFunction = function (func) {\n  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n    return function (arg0, arg1, arg2, arg3) {\n      MSApp.execUnsafeLocalFunction(function () {\n        return func(arg0, arg1, arg2, arg3);\n      });\n    };\n  } else {\n    return func;\n  }\n};\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer = void 0;\n\n/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n\n  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\n/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\nvar setTextContent = function (node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n\n    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n};\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridArea: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function (prop) {\n  prefixes.forEach(function (prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return ('' + value).trim();\n}\n\nvar uppercasePattern = /([A-Z])/g;\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */\nfunction hyphenateStyleName(name) {\n  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');\n}\n\nvar warnValidStyle = function () {};\n\n{\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n  var msPattern$1 = /^-ms-/;\n  var hyphenPattern = /-(.)/g;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n  var warnedForNaNValue = false;\n  var warnedForInfinityValue = false;\n\n  var camelize = function (string) {\n    return string.replace(hyphenPattern, function (_, character) {\n      return character.toUpperCase();\n    });\n  };\n\n  var warnHyphenatedStyleName = function (name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning$1(false, 'Unsupported style property %s. Did you mean %s?', name,\n    // As Andi Smith suggests\n    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n    // is converted to lowercase `ms`.\n    camelize(name.replace(msPattern$1, 'ms-')));\n  };\n\n  var warnBadVendoredStyleName = function (name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning$1(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));\n  };\n\n  var warnStyleValueWithSemicolon = function (name, value) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    warning$1(false, \"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));\n  };\n\n  var warnStyleValueIsNaN = function (name, value) {\n    if (warnedForNaNValue) {\n      return;\n    }\n\n    warnedForNaNValue = true;\n    warning$1(false, '`NaN` is an invalid value for the `%s` css style property.', name);\n  };\n\n  var warnStyleValueIsInfinity = function (name, value) {\n    if (warnedForInfinityValue) {\n      return;\n    }\n\n    warnedForInfinityValue = true;\n    warning$1(false, '`Infinity` is an invalid value for the `%s` css style property.', name);\n  };\n\n  warnValidStyle = function (name, value) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value);\n    }\n\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        warnStyleValueIsNaN(name, value);\n      } else if (!isFinite(value)) {\n        warnStyleValueIsInfinity(name, value);\n      }\n    }\n  };\n}\n\nvar warnValidStyle$1 = warnValidStyle;\n\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\nfunction createDangerousStringForStyles(styles) {\n  {\n    var serialized = '';\n    var delimiter = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var styleValue = styles[styleName];\n      if (styleValue != null) {\n        var isCustomProperty = styleName.indexOf('--') === 0;\n        serialized += delimiter + hyphenateStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n\n        delimiter = ';';\n      }\n    }\n    return serialized || null;\n  }\n}\n\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\nfunction setValueForStyles(node, styles) {\n  var style = node.style;\n  for (var styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    var isCustomProperty = styleName.indexOf('--') === 0;\n    {\n      if (!isCustomProperty) {\n        warnValidStyle$1(styleName, styles[styleName]);\n      }\n    }\n    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special-case tags.\n\nvar omittedCloseTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n  // NOTE: menuitem's close tag should be omitted, but that causes problems.\n};\n\n// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\nvar voidElementTags = _assign({\n  menuitem: true\n}, omittedCloseTags);\n\n// TODO: We can remove this if we add invariantWithStack()\n// or add stack by default to invariants where possible.\nvar HTML$1 = '__html';\n\nvar ReactDebugCurrentFrame$2 = null;\n{\n  ReactDebugCurrentFrame$2 = ReactSharedInternals.ReactDebugCurrentFrame;\n}\n\nfunction assertValidProps(tag, props) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (voidElementTags[tag]) {\n    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, ReactDebugCurrentFrame$2.getStackAddendum()) : void 0;\n  }\n  if (props.dangerouslySetInnerHTML != null) {\n    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n  }\n  {\n    !(props.suppressContentEditableWarning || !props.contentEditable || props.children == null) ? warning$1(false, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;\n  }\n  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', ReactDebugCurrentFrame$2.getStackAddendum()) : void 0;\n}\n\nfunction isCustomComponent(tagName, props) {\n  if (tagName.indexOf('-') === -1) {\n    return typeof props.is === 'string';\n  }\n  switch (tagName) {\n    // These are reserved SVG and MathML elements.\n    // We don't mind this whitelist too much because we expect it to never grow.\n    // The alternative is to track the namespace in a few places which is convoluted.\n    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n    case 'annotation-xml':\n    case 'color-profile':\n    case 'font-face':\n    case 'font-face-src':\n    case 'font-face-uri':\n    case 'font-face-format':\n    case 'font-face-name':\n    case 'missing-glyph':\n      return false;\n    default:\n      return true;\n  }\n}\n\n// When adding attributes to the HTML or SVG whitelist, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames = {\n  // HTML\n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  challenge: 'challenge',\n  charset: 'charSet',\n  checked: 'checked',\n  children: 'children',\n  cite: 'cite',\n  class: 'className',\n  classid: 'classID',\n  classname: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlslist: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n  data: 'data',\n  datetime: 'dateTime',\n  default: 'default',\n  defaultchecked: 'defaultChecked',\n  defaultvalue: 'defaultValue',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  for: 'htmlFor',\n  form: 'form',\n  formmethod: 'formMethod',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  htmlfor: 'htmlFor',\n  httpequiv: 'httpEquiv',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  innerhtml: 'innerHTML',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  itemid: 'itemID',\n  itemprop: 'itemProp',\n  itemref: 'itemRef',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginwidth: 'marginWidth',\n  marginheight: 'marginHeight',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nomodule: 'noModule',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n  // SVG\n  about: 'about',\n  accentheight: 'accentHeight',\n  'accent-height': 'accentHeight',\n  accumulate: 'accumulate',\n  additive: 'additive',\n  alignmentbaseline: 'alignmentBaseline',\n  'alignment-baseline': 'alignmentBaseline',\n  allowreorder: 'allowReorder',\n  alphabetic: 'alphabetic',\n  amplitude: 'amplitude',\n  arabicform: 'arabicForm',\n  'arabic-form': 'arabicForm',\n  ascent: 'ascent',\n  attributename: 'attributeName',\n  attributetype: 'attributeType',\n  autoreverse: 'autoReverse',\n  azimuth: 'azimuth',\n  basefrequency: 'baseFrequency',\n  baselineshift: 'baselineShift',\n  'baseline-shift': 'baselineShift',\n  baseprofile: 'baseProfile',\n  bbox: 'bbox',\n  begin: 'begin',\n  bias: 'bias',\n  by: 'by',\n  calcmode: 'calcMode',\n  capheight: 'capHeight',\n  'cap-height': 'capHeight',\n  clip: 'clip',\n  clippath: 'clipPath',\n  'clip-path': 'clipPath',\n  clippathunits: 'clipPathUnits',\n  cliprule: 'clipRule',\n  'clip-rule': 'clipRule',\n  color: 'color',\n  colorinterpolation: 'colorInterpolation',\n  'color-interpolation': 'colorInterpolation',\n  colorinterpolationfilters: 'colorInterpolationFilters',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  colorprofile: 'colorProfile',\n  'color-profile': 'colorProfile',\n  colorrendering: 'colorRendering',\n  'color-rendering': 'colorRendering',\n  contentscripttype: 'contentScriptType',\n  contentstyletype: 'contentStyleType',\n  cursor: 'cursor',\n  cx: 'cx',\n  cy: 'cy',\n  d: 'd',\n  datatype: 'datatype',\n  decelerate: 'decelerate',\n  descent: 'descent',\n  diffuseconstant: 'diffuseConstant',\n  direction: 'direction',\n  display: 'display',\n  divisor: 'divisor',\n  dominantbaseline: 'dominantBaseline',\n  'dominant-baseline': 'dominantBaseline',\n  dur: 'dur',\n  dx: 'dx',\n  dy: 'dy',\n  edgemode: 'edgeMode',\n  elevation: 'elevation',\n  enablebackground: 'enableBackground',\n  'enable-background': 'enableBackground',\n  end: 'end',\n  exponent: 'exponent',\n  externalresourcesrequired: 'externalResourcesRequired',\n  fill: 'fill',\n  fillopacity: 'fillOpacity',\n  'fill-opacity': 'fillOpacity',\n  fillrule: 'fillRule',\n  'fill-rule': 'fillRule',\n  filter: 'filter',\n  filterres: 'filterRes',\n  filterunits: 'filterUnits',\n  floodopacity: 'floodOpacity',\n  'flood-opacity': 'floodOpacity',\n  floodcolor: 'floodColor',\n  'flood-color': 'floodColor',\n  focusable: 'focusable',\n  fontfamily: 'fontFamily',\n  'font-family': 'fontFamily',\n  fontsize: 'fontSize',\n  'font-size': 'fontSize',\n  fontsizeadjust: 'fontSizeAdjust',\n  'font-size-adjust': 'fontSizeAdjust',\n  fontstretch: 'fontStretch',\n  'font-stretch': 'fontStretch',\n  fontstyle: 'fontStyle',\n  'font-style': 'fontStyle',\n  fontvariant: 'fontVariant',\n  'font-variant': 'fontVariant',\n  fontweight: 'fontWeight',\n  'font-weight': 'fontWeight',\n  format: 'format',\n  from: 'from',\n  fx: 'fx',\n  fy: 'fy',\n  g1: 'g1',\n  g2: 'g2',\n  glyphname: 'glyphName',\n  'glyph-name': 'glyphName',\n  glyphorientationhorizontal: 'glyphOrientationHorizontal',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  glyphorientationvertical: 'glyphOrientationVertical',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  glyphref: 'glyphRef',\n  gradienttransform: 'gradientTransform',\n  gradientunits: 'gradientUnits',\n  hanging: 'hanging',\n  horizadvx: 'horizAdvX',\n  'horiz-adv-x': 'horizAdvX',\n  horizoriginx: 'horizOriginX',\n  'horiz-origin-x': 'horizOriginX',\n  ideographic: 'ideographic',\n  imagerendering: 'imageRendering',\n  'image-rendering': 'imageRendering',\n  in2: 'in2',\n  in: 'in',\n  inlist: 'inlist',\n  intercept: 'intercept',\n  k1: 'k1',\n  k2: 'k2',\n  k3: 'k3',\n  k4: 'k4',\n  k: 'k',\n  kernelmatrix: 'kernelMatrix',\n  kernelunitlength: 'kernelUnitLength',\n  kerning: 'kerning',\n  keypoints: 'keyPoints',\n  keysplines: 'keySplines',\n  keytimes: 'keyTimes',\n  lengthadjust: 'lengthAdjust',\n  letterspacing: 'letterSpacing',\n  'letter-spacing': 'letterSpacing',\n  lightingcolor: 'lightingColor',\n  'lighting-color': 'lightingColor',\n  limitingconeangle: 'limitingConeAngle',\n  local: 'local',\n  markerend: 'markerEnd',\n  'marker-end': 'markerEnd',\n  markerheight: 'markerHeight',\n  markermid: 'markerMid',\n  'marker-mid': 'markerMid',\n  markerstart: 'markerStart',\n  'marker-start': 'markerStart',\n  markerunits: 'markerUnits',\n  markerwidth: 'markerWidth',\n  mask: 'mask',\n  maskcontentunits: 'maskContentUnits',\n  maskunits: 'maskUnits',\n  mathematical: 'mathematical',\n  mode: 'mode',\n  numoctaves: 'numOctaves',\n  offset: 'offset',\n  opacity: 'opacity',\n  operator: 'operator',\n  order: 'order',\n  orient: 'orient',\n  orientation: 'orientation',\n  origin: 'origin',\n  overflow: 'overflow',\n  overlineposition: 'overlinePosition',\n  'overline-position': 'overlinePosition',\n  overlinethickness: 'overlineThickness',\n  'overline-thickness': 'overlineThickness',\n  paintorder: 'paintOrder',\n  'paint-order': 'paintOrder',\n  panose1: 'panose1',\n  'panose-1': 'panose1',\n  pathlength: 'pathLength',\n  patterncontentunits: 'patternContentUnits',\n  patterntransform: 'patternTransform',\n  patternunits: 'patternUnits',\n  pointerevents: 'pointerEvents',\n  'pointer-events': 'pointerEvents',\n  points: 'points',\n  pointsatx: 'pointsAtX',\n  pointsaty: 'pointsAtY',\n  pointsatz: 'pointsAtZ',\n  prefix: 'prefix',\n  preservealpha: 'preserveAlpha',\n  preserveaspectratio: 'preserveAspectRatio',\n  primitiveunits: 'primitiveUnits',\n  property: 'property',\n  r: 'r',\n  radius: 'radius',\n  refx: 'refX',\n  refy: 'refY',\n  renderingintent: 'renderingIntent',\n  'rendering-intent': 'renderingIntent',\n  repeatcount: 'repeatCount',\n  repeatdur: 'repeatDur',\n  requiredextensions: 'requiredExtensions',\n  requiredfeatures: 'requiredFeatures',\n  resource: 'resource',\n  restart: 'restart',\n  result: 'result',\n  results: 'results',\n  rotate: 'rotate',\n  rx: 'rx',\n  ry: 'ry',\n  scale: 'scale',\n  security: 'security',\n  seed: 'seed',\n  shaperendering: 'shapeRendering',\n  'shape-rendering': 'shapeRendering',\n  slope: 'slope',\n  spacing: 'spacing',\n  specularconstant: 'specularConstant',\n  specularexponent: 'specularExponent',\n  speed: 'speed',\n  spreadmethod: 'spreadMethod',\n  startoffset: 'startOffset',\n  stddeviation: 'stdDeviation',\n  stemh: 'stemh',\n  stemv: 'stemv',\n  stitchtiles: 'stitchTiles',\n  stopcolor: 'stopColor',\n  'stop-color': 'stopColor',\n  stopopacity: 'stopOpacity',\n  'stop-opacity': 'stopOpacity',\n  strikethroughposition: 'strikethroughPosition',\n  'strikethrough-position': 'strikethroughPosition',\n  strikethroughthickness: 'strikethroughThickness',\n  'strikethrough-thickness': 'strikethroughThickness',\n  string: 'string',\n  stroke: 'stroke',\n  strokedasharray: 'strokeDasharray',\n  'stroke-dasharray': 'strokeDasharray',\n  strokedashoffset: 'strokeDashoffset',\n  'stroke-dashoffset': 'strokeDashoffset',\n  strokelinecap: 'strokeLinecap',\n  'stroke-linecap': 'strokeLinecap',\n  strokelinejoin: 'strokeLinejoin',\n  'stroke-linejoin': 'strokeLinejoin',\n  strokemiterlimit: 'strokeMiterlimit',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  strokewidth: 'strokeWidth',\n  'stroke-width': 'strokeWidth',\n  strokeopacity: 'strokeOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  suppresscontenteditablewarning: 'suppressContentEditableWarning',\n  suppresshydrationwarning: 'suppressHydrationWarning',\n  surfacescale: 'surfaceScale',\n  systemlanguage: 'systemLanguage',\n  tablevalues: 'tableValues',\n  targetx: 'targetX',\n  targety: 'targetY',\n  textanchor: 'textAnchor',\n  'text-anchor': 'textAnchor',\n  textdecoration: 'textDecoration',\n  'text-decoration': 'textDecoration',\n  textlength: 'textLength',\n  textrendering: 'textRendering',\n  'text-rendering': 'textRendering',\n  to: 'to',\n  transform: 'transform',\n  typeof: 'typeof',\n  u1: 'u1',\n  u2: 'u2',\n  underlineposition: 'underlinePosition',\n  'underline-position': 'underlinePosition',\n  underlinethickness: 'underlineThickness',\n  'underline-thickness': 'underlineThickness',\n  unicode: 'unicode',\n  unicodebidi: 'unicodeBidi',\n  'unicode-bidi': 'unicodeBidi',\n  unicoderange: 'unicodeRange',\n  'unicode-range': 'unicodeRange',\n  unitsperem: 'unitsPerEm',\n  'units-per-em': 'unitsPerEm',\n  unselectable: 'unselectable',\n  valphabetic: 'vAlphabetic',\n  'v-alphabetic': 'vAlphabetic',\n  values: 'values',\n  vectoreffect: 'vectorEffect',\n  'vector-effect': 'vectorEffect',\n  version: 'version',\n  vertadvy: 'vertAdvY',\n  'vert-adv-y': 'vertAdvY',\n  vertoriginx: 'vertOriginX',\n  'vert-origin-x': 'vertOriginX',\n  vertoriginy: 'vertOriginY',\n  'vert-origin-y': 'vertOriginY',\n  vhanging: 'vHanging',\n  'v-hanging': 'vHanging',\n  videographic: 'vIdeographic',\n  'v-ideographic': 'vIdeographic',\n  viewbox: 'viewBox',\n  viewtarget: 'viewTarget',\n  visibility: 'visibility',\n  vmathematical: 'vMathematical',\n  'v-mathematical': 'vMathematical',\n  vocab: 'vocab',\n  widths: 'widths',\n  wordspacing: 'wordSpacing',\n  'word-spacing': 'wordSpacing',\n  writingmode: 'writingMode',\n  'writing-mode': 'writingMode',\n  x1: 'x1',\n  x2: 'x2',\n  x: 'x',\n  xchannelselector: 'xChannelSelector',\n  xheight: 'xHeight',\n  'x-height': 'xHeight',\n  xlinkactuate: 'xlinkActuate',\n  'xlink:actuate': 'xlinkActuate',\n  xlinkarcrole: 'xlinkArcrole',\n  'xlink:arcrole': 'xlinkArcrole',\n  xlinkhref: 'xlinkHref',\n  'xlink:href': 'xlinkHref',\n  xlinkrole: 'xlinkRole',\n  'xlink:role': 'xlinkRole',\n  xlinkshow: 'xlinkShow',\n  'xlink:show': 'xlinkShow',\n  xlinktitle: 'xlinkTitle',\n  'xlink:title': 'xlinkTitle',\n  xlinktype: 'xlinkType',\n  'xlink:type': 'xlinkType',\n  xmlbase: 'xmlBase',\n  'xml:base': 'xmlBase',\n  xmllang: 'xmlLang',\n  'xml:lang': 'xmlLang',\n  xmlns: 'xmlns',\n  'xml:space': 'xmlSpace',\n  xmlnsxlink: 'xmlnsXlink',\n  'xmlns:xlink': 'xmlnsXlink',\n  xmlspace: 'xmlSpace',\n  y1: 'y1',\n  y2: 'y2',\n  y: 'y',\n  ychannelselector: 'yChannelSelector',\n  z: 'z',\n  zoomandpan: 'zoomAndPan'\n};\n\nvar ariaProperties = {\n  'aria-current': 0, // state\n  'aria-details': 0,\n  'aria-disabled': 0, // state\n  'aria-hidden': 0, // state\n  'aria-invalid': 0, // state\n  'aria-keyshortcuts': 0,\n  'aria-label': 0,\n  'aria-roledescription': 0,\n  // Widget Attributes\n  'aria-autocomplete': 0,\n  'aria-checked': 0,\n  'aria-expanded': 0,\n  'aria-haspopup': 0,\n  'aria-level': 0,\n  'aria-modal': 0,\n  'aria-multiline': 0,\n  'aria-multiselectable': 0,\n  'aria-orientation': 0,\n  'aria-placeholder': 0,\n  'aria-pressed': 0,\n  'aria-readonly': 0,\n  'aria-required': 0,\n  'aria-selected': 0,\n  'aria-sort': 0,\n  'aria-valuemax': 0,\n  'aria-valuemin': 0,\n  'aria-valuenow': 0,\n  'aria-valuetext': 0,\n  // Live Region Attributes\n  'aria-atomic': 0,\n  'aria-busy': 0,\n  'aria-live': 0,\n  'aria-relevant': 0,\n  // Drag-and-Drop Attributes\n  'aria-dropeffect': 0,\n  'aria-grabbed': 0,\n  // Relationship Attributes\n  'aria-activedescendant': 0,\n  'aria-colcount': 0,\n  'aria-colindex': 0,\n  'aria-colspan': 0,\n  'aria-controls': 0,\n  'aria-describedby': 0,\n  'aria-errormessage': 0,\n  'aria-flowto': 0,\n  'aria-labelledby': 0,\n  'aria-owns': 0,\n  'aria-posinset': 0,\n  'aria-rowcount': 0,\n  'aria-rowindex': 0,\n  'aria-rowspan': 0,\n  'aria-setsize': 0\n};\n\nvar warnedProperties = {};\nvar rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\nfunction validateProperty(tagName, name) {\n  if (hasOwnProperty$2.call(warnedProperties, name) && warnedProperties[name]) {\n    return true;\n  }\n\n  if (rARIACamel.test(name)) {\n    var ariaName = 'aria-' + name.slice(4).toLowerCase();\n    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (correctName == null) {\n      warning$1(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);\n      warnedProperties[name] = true;\n      return true;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== correctName) {\n      warning$1(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  if (rARIA.test(name)) {\n    var lowerCasedName = name.toLowerCase();\n    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (standardName == null) {\n      warnedProperties[name] = true;\n      return false;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== standardName) {\n      warning$1(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  return true;\n}\n\nfunction warnInvalidARIAProps(type, props) {\n  var invalidProps = [];\n\n  for (var key in props) {\n    var isValid = validateProperty(type, key);\n    if (!isValid) {\n      invalidProps.push(key);\n    }\n  }\n\n  var unknownPropString = invalidProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n\n  if (invalidProps.length === 1) {\n    warning$1(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);\n  } else if (invalidProps.length > 1) {\n    warning$1(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);\n  }\n}\n\nfunction validateProperties(type, props) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnInvalidARIAProps(type, props);\n}\n\nvar didWarnValueNull = false;\n\nfunction validateProperties$1(type, props) {\n  if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n    return;\n  }\n\n  if (props != null && props.value === null && !didWarnValueNull) {\n    didWarnValueNull = true;\n    if (type === 'select' && props.multiple) {\n      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);\n    } else {\n      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);\n    }\n  }\n}\n\nvar validateProperty$1 = function () {};\n\n{\n  var warnedProperties$1 = {};\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n  var EVENT_NAME_REGEX = /^on./;\n  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\n  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\n  validateProperty$1 = function (tagName, name, value, canUseEventSystem) {\n    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n      return true;\n    }\n\n    var lowerCasedName = name.toLowerCase();\n    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n      warning$1(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // We can't rely on the event system being injected on the server.\n    if (canUseEventSystem) {\n      if (registrationNameModules.hasOwnProperty(name)) {\n        return true;\n      }\n      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n      if (registrationName != null) {\n        warning$1(false, 'Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);\n        warnedProperties$1[name] = true;\n        return true;\n      }\n      if (EVENT_NAME_REGEX.test(name)) {\n        warning$1(false, 'Unknown event handler property `%s`. It will be ignored.', name);\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (EVENT_NAME_REGEX.test(name)) {\n      // If no event plugins have been injected, we are in a server environment.\n      // So we can't tell if the event name is correct for sure, but we can filter\n      // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n      if (INVALID_EVENT_NAME_REGEX.test(name)) {\n        warning$1(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Let the ARIA attribute hook validate ARIA attributes\n    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n      return true;\n    }\n\n    if (lowerCasedName === 'innerhtml') {\n      warning$1(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'aria') {\n      warning$1(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n      warning$1(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'number' && isNaN(value)) {\n      warning$1(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    var propertyInfo = getPropertyInfo(name);\n    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;\n\n    // Known attributes should match the casing specified in the property config.\n    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      var standardName = possibleStandardNames[lowerCasedName];\n      if (standardName !== name) {\n        warning$1(false, 'Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (!isReserved && name !== lowerCasedName) {\n      // Unknown attributes should have lowercase casing since that's how they\n      // will be cased anyway with server rendering.\n      warning$1(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n      if (value) {\n        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n      } else {\n        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Now that we've validated casing, do not validate\n    // data types for reserved props\n    if (isReserved) {\n      return true;\n    }\n\n    // Warn when a known attribute is a bad type\n    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n      warnedProperties$1[name] = true;\n      return false;\n    }\n\n    // Warn when passing the strings 'false' or 'true' into a boolean prop\n    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {\n      warning$1(false, 'Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    return true;\n  };\n}\n\nvar warnUnknownProperties = function (type, props, canUseEventSystem) {\n  var unknownProps = [];\n  for (var key in props) {\n    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);\n    if (!isValid) {\n      unknownProps.push(key);\n    }\n  }\n\n  var unknownPropString = unknownProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n  if (unknownProps.length === 1) {\n    warning$1(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);\n  } else if (unknownProps.length > 1) {\n    warning$1(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);\n  }\n};\n\nfunction validateProperties$2(type, props, canUseEventSystem) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnUnknownProperties(type, props, canUseEventSystem);\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar didWarnInvalidHydration = false;\nvar didWarnShadyDOM = false;\n\nvar DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\nvar SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\nvar SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';\nvar AUTOFOCUS = 'autoFocus';\nvar CHILDREN = 'children';\nvar STYLE = 'style';\nvar HTML = '__html';\n\nvar HTML_NAMESPACE = Namespaces.html;\n\n\nvar warnedUnknownTags = void 0;\nvar suppressHydrationWarning = void 0;\n\nvar validatePropertiesInDevelopment = void 0;\nvar warnForTextDifference = void 0;\nvar warnForPropDifference = void 0;\nvar warnForExtraAttributes = void 0;\nvar warnForInvalidEventListener = void 0;\nvar canDiffStyleForHydrationWarning = void 0;\n\nvar normalizeMarkupForTextOrAttribute = void 0;\nvar normalizeHTML = void 0;\n\n{\n  warnedUnknownTags = {\n    // Chrome is the only major browser not shipping <time>. But as of July\n    // 2017 it intends to ship it due to widespread usage. We intentionally\n    // *don't* warn for <time> even if it's unrecognized by Chrome because\n    // it soon will be, and many apps have been using it anyway.\n    time: true,\n    // There are working polyfills for <dialog>. Let people use it.\n    dialog: true,\n    // Electron ships a custom <webview> tag to display external web content in\n    // an isolated frame and process.\n    // This tag is not present in non Electron environments such as JSDom which\n    // is often used for testing purposes.\n    // @see https://electronjs.org/docs/api/webview-tag\n    webview: true\n  };\n\n  validatePropertiesInDevelopment = function (type, props) {\n    validateProperties(type, props);\n    validateProperties$1(type, props);\n    validateProperties$2(type, props, /* canUseEventSystem */true);\n  };\n\n  // IE 11 parses & normalizes the style attribute as opposed to other\n  // browsers. It adds spaces and sorts the properties in some\n  // non-alphabetical order. Handling that would require sorting CSS\n  // properties in the client & server versions or applying\n  // `expectedStyle` to a temporary DOM node to read its `style` attribute\n  // normalized. Since it only affects IE, we're skipping style warnings\n  // in that browser completely in favor of doing all that work.\n  // See https://github.com/facebook/react/issues/11807\n  canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;\n\n  // HTML parsing normalizes CR and CRLF to LF.\n  // It also can turn \\u0000 into \\uFFFD inside attributes.\n  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n  // If we have a mismatch, it might be caused by that.\n  // We will still patch up in this case but not fire the warning.\n  var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n\n  normalizeMarkupForTextOrAttribute = function (markup) {\n    var markupString = typeof markup === 'string' ? markup : '' + markup;\n    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');\n  };\n\n  warnForTextDifference = function (serverText, clientText) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n    if (normalizedServerText === normalizedClientText) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n  };\n\n  warnForPropDifference = function (propName, serverValue, clientValue) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n    if (normalizedServerValue === normalizedClientValue) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n  };\n\n  warnForExtraAttributes = function (attributeNames) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    var names = [];\n    attributeNames.forEach(function (name) {\n      names.push(name);\n    });\n    warningWithoutStack$1(false, 'Extra attributes from the server: %s', names);\n  };\n\n  warnForInvalidEventListener = function (registrationName, listener) {\n    if (listener === false) {\n      warning$1(false, 'Expected `%s` listener to be a function, instead got `false`.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);\n    } else {\n      warning$1(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);\n    }\n  };\n\n  // Parse the HTML and read it back to normalize the HTML string so that it\n  // can be used for comparison.\n  normalizeHTML = function (parent, html) {\n    // We could have created a separate document here to avoid\n    // re-initializing custom elements if they exist. But this breaks\n    // how <noscript> is being handled. So we use the same document.\n    // See the discussion in https://github.com/facebook/react/pull/11157.\n    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n    testElement.innerHTML = html;\n    return testElement.innerHTML;\n  };\n}\n\nfunction ensureListeningTo(rootContainerElement, registrationName) {\n  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\n  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n  listenTo(registrationName, doc);\n}\n\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n}\n\nfunction noop() {}\n\nfunction trapClickOnNonInteractiveElement(node) {\n  // Mobile Safari does not fire properly bubble click events on\n  // non-interactive elements, which means delegated click listeners do not\n  // fire. The workaround for this bug involves attaching an empty click\n  // listener on the target node.\n  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n  // Just set it using the onclick property so that we don't have to manage any\n  // bookkeeping for it. Not sure if we need to clear it when the listener is\n  // removed.\n  // TODO: Only do this for the relevant Safaris maybe?\n  node.onclick = noop;\n}\n\nfunction setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n  for (var propKey in nextProps) {\n    if (!nextProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = nextProps[propKey];\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      // Relies on `updateStylesByID` not mutating `styleUpdates`.\n      setValueForStyles(domElement, nextProp);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      if (nextHtml != null) {\n        setInnerHTML(domElement, nextHtml);\n      }\n    } else if (propKey === CHILDREN) {\n      if (typeof nextProp === 'string') {\n        // Avoid setting initial textContent when the text is empty. In IE11 setting\n        // textContent on a <textarea> will cause the placeholder to not\n        // show within the <textarea> until it has been focused and blurred again.\n        // https://github.com/facebook/react/issues/6731#issuecomment-254874553\n        var canSetTextContent = tag !== 'textarea' || nextProp !== '';\n        if (canSetTextContent) {\n          setTextContent(domElement, nextProp);\n        }\n      } else if (typeof nextProp === 'number') {\n        setTextContent(domElement, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // We polyfill it separately on the client during commit.\n      // We could have excluded it in the property list instead of\n      // adding a special case here, but then it wouldn't be emitted\n      // on server rendering (but we *do* want to emit it in SSR).\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (nextProp != null) {\n      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);\n    }\n  }\n}\n\nfunction updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n  // TODO: Handle wasCustomComponentTag\n  for (var i = 0; i < updatePayload.length; i += 2) {\n    var propKey = updatePayload[i];\n    var propValue = updatePayload[i + 1];\n    if (propKey === STYLE) {\n      setValueForStyles(domElement, propValue);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      setInnerHTML(domElement, propValue);\n    } else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    } else {\n      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n    }\n  }\n}\n\nfunction createElement(type, props, rootContainerElement, parentNamespace) {\n  var isCustomComponentTag = void 0;\n\n  // We create tags in the namespace of their parent container, except HTML\n  // tags get no namespace.\n  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n  var domElement = void 0;\n  var namespaceURI = parentNamespace;\n  if (namespaceURI === HTML_NAMESPACE) {\n    namespaceURI = getIntrinsicNamespace(type);\n  }\n  if (namespaceURI === HTML_NAMESPACE) {\n    {\n      isCustomComponentTag = isCustomComponent(type, props);\n      // Should this check be gated by parent namespace? Not sure we want to\n      // allow <SVG> or <mATH>.\n      !(isCustomComponentTag || type === type.toLowerCase()) ? warning$1(false, '<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type) : void 0;\n    }\n\n    if (type === 'script') {\n      // Create the script via .innerHTML so its \"parser-inserted\" flag is\n      // set to true and it does not execute\n      var div = ownerDocument.createElement('div');\n      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n      // This is guaranteed to yield a script element.\n      var firstChild = div.firstChild;\n      domElement = div.removeChild(firstChild);\n    } else if (typeof props.is === 'string') {\n      // $FlowIssue `createElement` should be updated for Web Components\n      domElement = ownerDocument.createElement(type, { is: props.is });\n    } else {\n      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n      // See discussion in https://github.com/facebook/react/pull/6896\n      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n      domElement = ownerDocument.createElement(type);\n      // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple`\n      // attribute on `select`s needs to be added before `option`s are inserted. This prevents\n      // a bug where the `select` does not scroll to the correct option because singular\n      // `select` elements automatically pick the first item.\n      // See https://github.com/facebook/react/issues/13222\n      if (type === 'select' && props.multiple) {\n        var node = domElement;\n        node.multiple = true;\n      }\n    }\n  } else {\n    domElement = ownerDocument.createElementNS(namespaceURI, type);\n  }\n\n  {\n    if (namespaceURI === HTML_NAMESPACE) {\n      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n        warnedUnknownTags[type] = true;\n        warning$1(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n      }\n    }\n  }\n\n  return domElement;\n}\n\nfunction createTextNode(text, rootContainerElement) {\n  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n}\n\nfunction setInitialProperties(domElement, tag, rawProps, rootContainerElement) {\n  var isCustomComponentTag = isCustomComponent(tag, rawProps);\n  {\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning$1(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerNameInDevOrNull() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  var props = void 0;\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent(TOP_LOAD, domElement);\n      props = rawProps;\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var i = 0; i < mediaEventTypes.length; i++) {\n        trapBubbledEvent(mediaEventTypes[i], domElement);\n      }\n      props = rawProps;\n      break;\n    case 'source':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      props = rawProps;\n      break;\n    case 'img':\n    case 'image':\n    case 'link':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      trapBubbledEvent(TOP_LOAD, domElement);\n      props = rawProps;\n      break;\n    case 'form':\n      trapBubbledEvent(TOP_RESET, domElement);\n      trapBubbledEvent(TOP_SUBMIT, domElement);\n      props = rawProps;\n      break;\n    case 'details':\n      trapBubbledEvent(TOP_TOGGLE, domElement);\n      props = rawProps;\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      props = getHostProps(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      props = getHostProps$1(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      props = getHostProps$2(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      props = getHostProps$3(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    default:\n      props = rawProps;\n  }\n\n  assertValidProps(tag, props);\n\n  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps, false);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'option':\n      postMountWrapper$1(domElement, rawProps);\n      break;\n    case 'select':\n      postMountWrapper$2(domElement, rawProps);\n      break;\n    default:\n      if (typeof props.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n}\n\n// Calculate the diff between the two objects.\nfunction diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n  {\n    validatePropertiesInDevelopment(tag, nextRawProps);\n  }\n\n  var updatePayload = null;\n\n  var lastProps = void 0;\n  var nextProps = void 0;\n  switch (tag) {\n    case 'input':\n      lastProps = getHostProps(domElement, lastRawProps);\n      nextProps = getHostProps(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'option':\n      lastProps = getHostProps$1(domElement, lastRawProps);\n      nextProps = getHostProps$1(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'select':\n      lastProps = getHostProps$2(domElement, lastRawProps);\n      nextProps = getHostProps$2(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'textarea':\n      lastProps = getHostProps$3(domElement, lastRawProps);\n      nextProps = getHostProps$3(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    default:\n      lastProps = lastRawProps;\n      nextProps = nextRawProps;\n      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  assertValidProps(tag, nextProps);\n\n  var propKey = void 0;\n  var styleName = void 0;\n  var styleUpdates = null;\n  for (propKey in lastProps) {\n    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      var lastStyle = lastProps[propKey];\n      for (styleName in lastStyle) {\n        if (lastStyle.hasOwnProperty(styleName)) {\n          if (!styleUpdates) {\n            styleUpdates = {};\n          }\n          styleUpdates[styleName] = '';\n        }\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {\n      // Noop. This is handled by the clear text mechanism.\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // Noop. It doesn't work on updates anyway.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      // This is a special case. If any listener updates we need to ensure\n      // that the \"current\" fiber pointer gets updated so we need a commit\n      // to update this element.\n      if (!updatePayload) {\n        updatePayload = [];\n      }\n    } else {\n      // For all other deleted properties we add it to the queue. We use\n      // the whitelist in the commit phase instead.\n      (updatePayload = updatePayload || []).push(propKey, null);\n    }\n  }\n  for (propKey in nextProps) {\n    var nextProp = nextProps[propKey];\n    var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      if (lastProp) {\n        // Unset styles on `lastProp` but not on `nextProp`.\n        for (styleName in lastProp) {\n          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = '';\n          }\n        }\n        // Update styles that changed since `lastProp`.\n        for (styleName in nextProp) {\n          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = nextProp[styleName];\n          }\n        }\n      } else {\n        // Relies on `updateStylesByID` not mutating `styleUpdates`.\n        if (!styleUpdates) {\n          if (!updatePayload) {\n            updatePayload = [];\n          }\n          updatePayload.push(propKey, styleUpdates);\n        }\n        styleUpdates = nextProp;\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      var lastHtml = lastProp ? lastProp[HTML] : undefined;\n      if (nextHtml != null) {\n        if (lastHtml !== nextHtml) {\n          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n        }\n      } else {\n        // TODO: It might be too late to clear this if we have children\n        // inserted already.\n      }\n    } else if (propKey === CHILDREN) {\n      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        // We eagerly listen to this even though we haven't committed yet.\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n      if (!updatePayload && lastProp !== nextProp) {\n        // This is a special case. If any listener updates we need to ensure\n        // that the \"current\" props pointer gets updated so we need a commit\n        // to update this element.\n        updatePayload = [];\n      }\n    } else {\n      // For any other property we always add it to the queue and then we\n      // filter it out using the whitelist during the commit.\n      (updatePayload = updatePayload || []).push(propKey, nextProp);\n    }\n  }\n  if (styleUpdates) {\n    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n  }\n  return updatePayload;\n}\n\n// Apply the diff.\nfunction updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n  // Update checked *before* name.\n  // In the middle of an update, it is possible to have multiple checked.\n  // When a checked radio tries to change name, browser makes another radio's checked false.\n  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {\n    updateChecked(domElement, nextRawProps);\n  }\n\n  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n  // Apply the diff.\n  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n\n  // TODO: Ensure that an update gets scheduled if any of the special props\n  // changed.\n  switch (tag) {\n    case 'input':\n      // Update the wrapper around inputs *after* updating props. This has to\n      // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n      // raise warnings and prevent the new value from being assigned.\n      updateWrapper(domElement, nextRawProps);\n      break;\n    case 'textarea':\n      updateWrapper$1(domElement, nextRawProps);\n      break;\n    case 'select':\n      // <select> value update needs to occur after <option> children\n      // reconciliation\n      postUpdateWrapper(domElement, nextRawProps);\n      break;\n  }\n}\n\nfunction getPossibleStandardName(propName) {\n  {\n    var lowerCasedName = propName.toLowerCase();\n    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      return null;\n    }\n    return possibleStandardNames[lowerCasedName] || null;\n  }\n  return null;\n}\n\nfunction diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n  var isCustomComponentTag = void 0;\n  var extraAttributeNames = void 0;\n\n  {\n    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;\n    isCustomComponentTag = isCustomComponent(tag, rawProps);\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning$1(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerNameInDevOrNull() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent(TOP_LOAD, domElement);\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var i = 0; i < mediaEventTypes.length; i++) {\n        trapBubbledEvent(mediaEventTypes[i], domElement);\n      }\n      break;\n    case 'source':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      break;\n    case 'img':\n    case 'image':\n    case 'link':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      trapBubbledEvent(TOP_LOAD, domElement);\n      break;\n    case 'form':\n      trapBubbledEvent(TOP_RESET, domElement);\n      trapBubbledEvent(TOP_SUBMIT, domElement);\n      break;\n    case 'details':\n      trapBubbledEvent(TOP_TOGGLE, domElement);\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n  }\n\n  assertValidProps(tag, rawProps);\n\n  {\n    extraAttributeNames = new Set();\n    var attributes = domElement.attributes;\n    for (var _i = 0; _i < attributes.length; _i++) {\n      var name = attributes[_i].name.toLowerCase();\n      switch (name) {\n        // Built-in SSR attribute is whitelisted\n        case 'data-reactroot':\n          break;\n        // Controlled attributes are not validated\n        // TODO: Only ignore them on controlled tags.\n        case 'value':\n          break;\n        case 'checked':\n          break;\n        case 'selected':\n          break;\n        default:\n          // Intentionally use the original name.\n          // See discussion in https://github.com/facebook/react/pull/10676.\n          extraAttributeNames.add(attributes[_i].name);\n      }\n    }\n  }\n\n  var updatePayload = null;\n  for (var propKey in rawProps) {\n    if (!rawProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = rawProps[propKey];\n    if (propKey === CHILDREN) {\n      // For text content children we compare against textContent. This\n      // might match additional HTML that is hidden when we read it using\n      // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n      // satisfies our requirement. Our requirement is not to produce perfect\n      // HTML and attributes. Ideally we should preserve structure but it's\n      // ok not to if the visible content is still enough to indicate what\n      // even listeners these nodes might be wired up to.\n      // TODO: Warn if there is more than a single textNode as a child.\n      // TODO: Should we use domElement.firstChild.nodeValue to compare?\n      if (typeof nextProp === 'string') {\n        if (domElement.textContent !== nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, nextProp];\n        }\n      } else if (typeof nextProp === 'number') {\n        if (domElement.textContent !== '' + nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, '' + nextProp];\n        }\n      }\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (true &&\n    // Convince Flow we've calculated it (it's DEV-only in this method.)\n    typeof isCustomComponentTag === 'boolean') {\n      // Validate that the properties correspond to their expected values.\n      var serverValue = void 0;\n      var propertyInfo = getPropertyInfo(propKey);\n      if (suppressHydrationWarning) {\n        // Don't bother comparing. We're ignoring all these warnings.\n      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||\n      // Controlled attributes are not validated\n      // TODO: Only ignore them on controlled tags.\n      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {\n        // Noop\n      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n        var serverHTML = domElement.innerHTML;\n        var nextHtml = nextProp ? nextProp[HTML] : undefined;\n        var expectedHTML = normalizeHTML(domElement, nextHtml != null ? nextHtml : '');\n        if (expectedHTML !== serverHTML) {\n          warnForPropDifference(propKey, serverHTML, expectedHTML);\n        }\n      } else if (propKey === STYLE) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames.delete(propKey);\n\n        if (canDiffStyleForHydrationWarning) {\n          var expectedStyle = createDangerousStringForStyles(nextProp);\n          serverValue = domElement.getAttribute('style');\n          if (expectedStyle !== serverValue) {\n            warnForPropDifference(propKey, serverValue, expectedStyle);\n          }\n        }\n      } else if (isCustomComponentTag) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames.delete(propKey.toLowerCase());\n        serverValue = getValueForAttribute(domElement, propKey, nextProp);\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {\n        var isMismatchDueToBadCasing = false;\n        if (propertyInfo !== null) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          extraAttributeNames.delete(propertyInfo.attributeName);\n          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);\n        } else {\n          var ownNamespace = parentNamespace;\n          if (ownNamespace === HTML_NAMESPACE) {\n            ownNamespace = getIntrinsicNamespace(tag);\n          }\n          if (ownNamespace === HTML_NAMESPACE) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames.delete(propKey.toLowerCase());\n          } else {\n            var standardName = getPossibleStandardName(propKey);\n            if (standardName !== null && standardName !== propKey) {\n              // If an SVG prop is supplied with bad casing, it will\n              // be successfully parsed from HTML, but will produce a mismatch\n              // (and would be incorrectly rendered on the client).\n              // However, we already warn about bad casing elsewhere.\n              // So we'll skip the misleading extra mismatch warning in this case.\n              isMismatchDueToBadCasing = true;\n              // $FlowFixMe - Should be inferred as not undefined.\n              extraAttributeNames.delete(standardName);\n            }\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames.delete(propKey);\n          }\n          serverValue = getValueForAttribute(domElement, propKey, nextProp);\n        }\n\n        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      }\n    }\n  }\n\n  {\n    // $FlowFixMe - Should be inferred as not undefined.\n    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {\n      // $FlowFixMe - Should be inferred as not undefined.\n      warnForExtraAttributes(extraAttributeNames);\n    }\n  }\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps, true);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'select':\n    case 'option':\n      // For input and textarea we current always set the value property at\n      // post mount to force it to diverge from attributes. However, for\n      // option and select we don't quite do the same thing and select\n      // is not resilient to the DOM state changing so we don't do that here.\n      // TODO: Consider not doing this for input and textarea.\n      break;\n    default:\n      if (typeof rawProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  return updatePayload;\n}\n\nfunction diffHydratedText(textNode, text) {\n  var isDifferent = textNode.nodeValue !== text;\n  return isDifferent;\n}\n\nfunction warnForUnmatchedText(textNode, text) {\n  {\n    warnForTextDifference(textNode.nodeValue, text);\n  }\n}\n\nfunction warnForDeletedHydratableElement(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForDeletedHydratableText(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedElement(parentNode, tag, props) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedText(parentNode, text) {\n  {\n    if (text === '') {\n      // We expect to insert empty text nodes since they're not represented in\n      // the HTML.\n      // TODO: Remove this special case if we can just avoid inserting empty\n      // text nodes.\n      return;\n    }\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction restoreControlledState$1(domElement, tag, props) {\n  switch (tag) {\n    case 'input':\n      restoreControlledState(domElement, props);\n      return;\n    case 'textarea':\n      restoreControlledState$3(domElement, props);\n      return;\n    case 'select':\n      restoreControlledState$2(domElement, props);\n      return;\n  }\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar validateDOMNesting = function () {};\nvar updatedAncestorInfo = function () {};\n\n{\n  // This validation code was written based on the HTML5 parsing spec:\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  //\n  // Note: this does not catch all invalid nesting, nor does it try to (as it's\n  // not clear what practical benefit doing so provides); instead, we warn only\n  // for cases where the parser will give a parse tree differing from what React\n  // intended. For example, <b><div></div></b> is invalid but we don't warn\n  // because it still parses correctly; we do warn for other cases like nested\n  // <p> tags where the beginning of the second element implicitly closes the\n  // first, causing a confusing mess.\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#special\n  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n  // TODO: Distinguish by namespace here -- for <title>, including it here\n  // errs on the side of fewer warnings\n  'foreignObject', 'desc', 'title'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n  var buttonScopeTags = inScopeTags.concat(['button']);\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n  var emptyAncestorInfo = {\n    current: null,\n\n    formTag: null,\n    aTagInScope: null,\n    buttonTagInScope: null,\n    nobrTagInScope: null,\n    pTagInButtonScope: null,\n\n    listItemTagAutoclosing: null,\n    dlItemTagAutoclosing: null\n  };\n\n  updatedAncestorInfo = function (oldInfo, tag) {\n    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n    var info = { tag: tag };\n\n    if (inScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.aTagInScope = null;\n      ancestorInfo.buttonTagInScope = null;\n      ancestorInfo.nobrTagInScope = null;\n    }\n    if (buttonScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.pTagInButtonScope = null;\n    }\n\n    // See rules for 'li', 'dd', 'dt' start tags in\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n      ancestorInfo.listItemTagAutoclosing = null;\n      ancestorInfo.dlItemTagAutoclosing = null;\n    }\n\n    ancestorInfo.current = info;\n\n    if (tag === 'form') {\n      ancestorInfo.formTag = info;\n    }\n    if (tag === 'a') {\n      ancestorInfo.aTagInScope = info;\n    }\n    if (tag === 'button') {\n      ancestorInfo.buttonTagInScope = info;\n    }\n    if (tag === 'nobr') {\n      ancestorInfo.nobrTagInScope = info;\n    }\n    if (tag === 'p') {\n      ancestorInfo.pTagInButtonScope = info;\n    }\n    if (tag === 'li') {\n      ancestorInfo.listItemTagAutoclosing = info;\n    }\n    if (tag === 'dd' || tag === 'dt') {\n      ancestorInfo.dlItemTagAutoclosing = info;\n    }\n\n    return ancestorInfo;\n  };\n\n  /**\n   * Returns whether\n   */\n  var isTagValidWithParent = function (tag, parentTag) {\n    // First, let's check if we're in an unusual parsing mode...\n    switch (parentTag) {\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n      case 'select':\n        return tag === 'option' || tag === 'optgroup' || tag === '#text';\n      case 'optgroup':\n        return tag === 'option' || tag === '#text';\n      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n      // but\n      case 'option':\n        return tag === '#text';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n      // No special behavior since these rules fall back to \"in body\" mode for\n      // all except special table nodes which cause bad parsing behavior anyway.\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n      case 'tr':\n        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n      case 'tbody':\n      case 'thead':\n      case 'tfoot':\n        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n      case 'colgroup':\n        return tag === 'col' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n      case 'table':\n        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n      case 'head':\n        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n      case 'html':\n        return tag === 'head' || tag === 'body';\n      case '#document':\n        return tag === 'html';\n    }\n\n    // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n    // where the parsing rules cause implicit opens or closes to be added.\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    switch (tag) {\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n      case 'rp':\n      case 'rt':\n        return impliedEndTags.indexOf(parentTag) === -1;\n\n      case 'body':\n      case 'caption':\n      case 'col':\n      case 'colgroup':\n      case 'frame':\n      case 'head':\n      case 'html':\n      case 'tbody':\n      case 'td':\n      case 'tfoot':\n      case 'th':\n      case 'thead':\n      case 'tr':\n        // These tags are only valid with a few parents that have special child\n        // parsing rules -- if we're down here, then none of those matched and\n        // so we allow it only if we don't know what the parent is, as all other\n        // cases are invalid.\n        return parentTag == null;\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns whether\n   */\n  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n    switch (tag) {\n      case 'address':\n      case 'article':\n      case 'aside':\n      case 'blockquote':\n      case 'center':\n      case 'details':\n      case 'dialog':\n      case 'dir':\n      case 'div':\n      case 'dl':\n      case 'fieldset':\n      case 'figcaption':\n      case 'figure':\n      case 'footer':\n      case 'header':\n      case 'hgroup':\n      case 'main':\n      case 'menu':\n      case 'nav':\n      case 'ol':\n      case 'p':\n      case 'section':\n      case 'summary':\n      case 'ul':\n      case 'pre':\n      case 'listing':\n      case 'table':\n      case 'hr':\n      case 'xmp':\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return ancestorInfo.pTagInButtonScope;\n\n      case 'form':\n        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n      case 'li':\n        return ancestorInfo.listItemTagAutoclosing;\n\n      case 'dd':\n      case 'dt':\n        return ancestorInfo.dlItemTagAutoclosing;\n\n      case 'button':\n        return ancestorInfo.buttonTagInScope;\n\n      case 'a':\n        // Spec says something about storing a list of markers, but it sounds\n        // equivalent to this check.\n        return ancestorInfo.aTagInScope;\n\n      case 'nobr':\n        return ancestorInfo.nobrTagInScope;\n    }\n\n    return null;\n  };\n\n  var didWarn = {};\n\n  validateDOMNesting = function (childTag, childText, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n\n    if (childText != null) {\n      !(childTag == null) ? warningWithoutStack$1(false, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;\n      childTag = '#text';\n    }\n\n    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n    var invalidParentOrAncestor = invalidParent || invalidAncestor;\n    if (!invalidParentOrAncestor) {\n      return;\n    }\n\n    var ancestorTag = invalidParentOrAncestor.tag;\n    var addendum = getCurrentFiberStackInDev();\n\n    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n    if (didWarn[warnKey]) {\n      return;\n    }\n    didWarn[warnKey] = true;\n\n    var tagDisplayName = childTag;\n    var whitespaceInfo = '';\n    if (childTag === '#text') {\n      if (/\\S/.test(childText)) {\n        tagDisplayName = 'Text nodes';\n      } else {\n        tagDisplayName = 'Whitespace text nodes';\n        whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n      }\n    } else {\n      tagDisplayName = '<' + childTag + '>';\n    }\n\n    if (invalidParent) {\n      var info = '';\n      if (ancestorTag === 'table' && childTag === 'tr') {\n        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n      }\n      warningWithoutStack$1(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n    } else {\n      warningWithoutStack$1(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n    }\n  };\n}\n\n// Renderers that don't support persistence\n// can re-export everything from this module.\n\nfunction shim() {\n  invariant(false, 'The current renderer does not support persistence. This error is likely caused by a bug in React. Please file an issue.');\n}\n\n// Persistence (when unsupported)\nvar supportsPersistence = false;\nvar cloneInstance = shim;\nvar createContainerChildSet = shim;\nvar appendChildToContainerChildSet = shim;\nvar finalizeContainerChildren = shim;\nvar replaceContainerChildren = shim;\n\nvar SUPPRESS_HYDRATION_WARNING = void 0;\n{\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n}\n\nvar eventsEnabled = null;\nvar selectionInformation = null;\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nfunction getRootHostContext(rootContainerInstance) {\n  var type = void 0;\n  var namespace = void 0;\n  var nodeType = rootContainerInstance.nodeType;\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      {\n        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n        var root = rootContainerInstance.documentElement;\n        namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n        break;\n      }\n    default:\n      {\n        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n        var ownNamespace = container.namespaceURI || null;\n        type = container.tagName;\n        namespace = getChildNamespace(ownNamespace, type);\n        break;\n      }\n  }\n  {\n    var validatedTag = type.toLowerCase();\n    var _ancestorInfo = updatedAncestorInfo(null, validatedTag);\n    return { namespace: namespace, ancestorInfo: _ancestorInfo };\n  }\n  return namespace;\n}\n\nfunction getChildHostContext(parentHostContext, type, rootContainerInstance) {\n  {\n    var parentHostContextDev = parentHostContext;\n    var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\n    return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };\n  }\n  var parentNamespace = parentHostContext;\n  return getChildNamespace(parentNamespace, type);\n}\n\nfunction getPublicInstance(instance) {\n  return instance;\n}\n\nfunction prepareForCommit(containerInfo) {\n  eventsEnabled = isEnabled();\n  selectionInformation = getSelectionInformation();\n  setEnabled(false);\n}\n\nfunction resetAfterCommit(containerInfo) {\n  restoreSelection(selectionInformation);\n  selectionInformation = null;\n  setEnabled(eventsEnabled);\n  eventsEnabled = null;\n}\n\nfunction createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  var parentNamespace = void 0;\n  {\n    // TODO: take namespace into account when validating.\n    var hostContextDev = hostContext;\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n    if (typeof props.children === 'string' || typeof props.children === 'number') {\n      var string = '' + props.children;\n      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n    parentNamespace = hostContextDev.namespace;\n  }\n  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\n\nfunction appendInitialChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\n\nfunction finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n  return shouldAutoFocusHostComponent(type, props);\n}\n\nfunction prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n  {\n    var hostContextDev = hostContext;\n    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n      var string = '' + newProps.children;\n      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n  return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n}\n\nfunction shouldSetTextContent(type, props) {\n  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\n}\n\nfunction shouldDeprioritizeSubtree(type, props) {\n  return !!props.hidden;\n}\n\nfunction createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n  {\n    var hostContextDev = hostContext;\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n  var textNode = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\n\nvar isPrimaryRenderer = true;\nvar scheduleTimeout = setTimeout;\nvar cancelTimeout = clearTimeout;\nvar noTimeout = -1;\n\n// -------------------\n//     Mutation\n// -------------------\n\nvar supportsMutation = true;\n\nfunction commitMount(domElement, type, newProps, internalInstanceHandle) {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  if (shouldAutoFocusHostComponent(type, newProps)) {\n    domElement.focus();\n  }\n}\n\nfunction commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps);\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\n\nfunction resetTextContent(domElement) {\n  setTextContent(domElement, '');\n}\n\nfunction commitTextUpdate(textInstance, oldText, newText) {\n  textInstance.nodeValue = newText;\n}\n\nfunction appendChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\n\nfunction appendChildToContainer(container, child) {\n  var parentNode = void 0;\n  if (container.nodeType === COMMENT_NODE) {\n    parentNode = container.parentNode;\n    parentNode.insertBefore(child, container);\n  } else {\n    parentNode = container;\n    parentNode.appendChild(child);\n  }\n  // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that containers have inline onclick defined.\n  // https://github.com/facebook/react/issues/11918\n  if (parentNode.onclick === null) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(parentNode);\n  }\n}\n\nfunction insertBefore(parentInstance, child, beforeChild) {\n  parentInstance.insertBefore(child, beforeChild);\n}\n\nfunction insertInContainerBefore(container, child, beforeChild) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nfunction removeChild(parentInstance, child) {\n  parentInstance.removeChild(child);\n}\n\nfunction removeChildFromContainer(container, child) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\n\n// -------------------\n//     Hydration\n// -------------------\n\nvar supportsHydration = true;\n\nfunction canHydrateInstance(instance, type, props) {\n  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n    return null;\n  }\n  // This has now been refined to an element node.\n  return instance;\n}\n\nfunction canHydrateTextInstance(instance, text) {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a text node.\n  return instance;\n}\n\nfunction getNextHydratableSibling(instance) {\n  var node = instance.nextSibling;\n  // Skip non-hydratable nodes.\n  while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n    node = node.nextSibling;\n  }\n  return node;\n}\n\nfunction getFirstHydratableChild(parentInstance) {\n  var next = parentInstance.firstChild;\n  // Skip non-hydratable nodes.\n  while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n    next = next.nextSibling;\n  }\n  return next;\n}\n\nfunction hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, instance);\n  // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n  updateFiberProps(instance, props);\n  var parentNamespace = void 0;\n  {\n    var hostContextDev = hostContext;\n    parentNamespace = hostContextDev.namespace;\n  }\n  return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n}\n\nfunction hydrateTextInstance(textInstance, text, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, textInstance);\n  return diffHydratedText(textInstance, text);\n}\n\nfunction didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {\n  {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nfunction didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nfunction didNotHydrateContainerInstance(parentContainer, instance) {\n  {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, instance);\n    } else {\n      warnForDeletedHydratableText(parentContainer, instance);\n    }\n  }\n}\n\nfunction didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentInstance, instance);\n    } else {\n      warnForDeletedHydratableText(parentInstance, instance);\n    }\n  }\n}\n\nfunction didNotFindHydratableContainerInstance(parentContainer, type, props) {\n  {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\n\nfunction didNotFindHydratableContainerTextInstance(parentContainer, text) {\n  {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\n\nfunction didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  }\n}\n\nfunction didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedText(parentInstance, text);\n  }\n}\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = '\\u269B';\nvar warningEmoji = '\\u26D4';\nvar supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function (markName) {\n  return reactEmoji + ' ' + markName;\n};\n\nvar formatLabel = function (label, warning) {\n  var prefix = warning ? warningEmoji + ' ' : reactEmoji + ' ';\n  var suffix = warning ? ' Warning: ' + warning : '';\n  return '' + prefix + label + suffix;\n};\n\nvar beginMark = function (markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function (markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function (label, markName, warning) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function (label, debugID) {\n  return label + ' (#' + debugID + ')';\n};\n\nvar getFiberLabel = function (componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n  } else {\n    // Composite component methods.\n    return componentName + '.' + phase;\n  }\n};\n\nvar beginFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber.type) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber.type) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function (fiber, phase, warning) {\n  var componentName = getComponentName(fiber.type) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning);\n};\n\nvar shouldIgnoreFiber = function (fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n    case Mode:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function () {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function () {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber.return;\n  }\n};\n\nvar resumeTimersRecursively = function (fiber) {\n  if (fiber.return !== null) {\n    resumeTimersRecursively(fiber.return);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function () {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire, expirationTime) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning = didExpire ? 'React was blocked by main thread' : null;\n      endMark('(Waiting for async callback... will force flush in ' + expirationTime + ' ms)', '(Waiting for async callback...)', warning);\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning = 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark('(React Tree Reconciliation)');\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning = 'A top-level update interrupted the previous render';\n      } else {\n        var componentName = getComponentName(interruptedBy.type) || 'Unknown';\n        warning = 'An update to ' + componentName + ' interrupted the previous render';\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning = 'There were cascading updates';\n    }\n    commitCountInCurrentWorkLoop = 0;\n    var label = didCompleteRoot ? '(React Tree Reconciliation: Completed Root)' : '(React Tree Reconciliation: Yielded)';\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(label, '(React Tree Reconciliation)', warning);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning = 'Caused by a cascading update in earlier commit';\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark('(Committing Changes)', '(Committing Changes)', warning);\n  }\n}\n\nfunction startCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Snapshot Effects)');\n  }\n}\n\nfunction stopCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Snapshot Effects: ' + count + ' Total)', '(Committing Snapshot Effects)', null);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n  }\n}\n\nvar valueStack = [];\n\nvar fiberStack = void 0;\n\n{\n  fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warningWithoutStack$1(false, 'Unexpected pop.');\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warningWithoutStack$1(false, 'Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction checkThatStackIsEmpty() {\n  {\n    if (index !== -1) {\n      warningWithoutStack$1(false, 'Expected an empty stack. Something was not reset properly.');\n    }\n  }\n}\n\nfunction resetStackAfterFatalErrorInDev() {\n  {\n    index = -1;\n    valueStack.length = 0;\n    fiberStack.length = 0;\n  }\n}\n\nvar warnedAboutMissingGetChildContext = void 0;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\nvar emptyContextObject = {};\n{\n  Object.freeze(emptyContextObject);\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyContextObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyContextObject;\n\nfunction getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n  if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n    // If the fiber is a context provider itself, when we read its context\n    // we may have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyContextObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(type) || 'Unknown';\n    checkPropTypes(contextTypes, context, 'context', name, getCurrentFiberStackInDev);\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextProvider(type) {\n  var childContextTypes = type.childContextTypes;\n  return childContextTypes !== null && childContextTypes !== undefined;\n}\n\nfunction popContext(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  !(contextStackCursor.current === emptyContextObject) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, type, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== 'function') {\n    {\n      var componentName = getComponentName(type) || 'Unknown';\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warningWithoutStack$1(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    setCurrentPhase('getChildContext');\n  }\n  startPhaseTimer(fiber, 'getChildContext');\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(type) || 'Unknown', contextKey) : void 0;\n  }\n  {\n    var name = getComponentName(type) || 'Unknown';\n    checkPropTypes(childContextTypes, childContext, 'child context', name,\n    // In practice, there is one case in which we won't get a stack. It's when\n    // somebody calls unstable_renderSubtreeIntoContainer() and we process\n    // context from the parent component instance. The stack will be missing\n    // because it's outside of the reconciliation, and so the pointer has not\n    // been set. This is rare and doesn't matter. We'll also remove that API.\n    getCurrentFiberStackInDev);\n  }\n\n  return _assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, type, didChange) {\n  var instance = workInProgress.stateNode;\n  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, type, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  !(isFiberMounted(fiber) && (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var node = fiber;\n  do {\n    switch (node.tag) {\n      case HostRoot:\n        return node.stateNode.context;\n      case ClassComponent:\n        {\n          var Component = node.type;\n          if (isContextProvider(Component)) {\n            return node.stateNode.__reactInternalMemoizedMergedChildContext;\n          }\n          break;\n        }\n      case ClassComponentLazy:\n        {\n          var _Component = getResultFromResolvedThenable(node.type);\n          if (isContextProvider(_Component)) {\n            return node.stateNode.__reactInternalMemoizedMergedChildContext;\n          }\n          break;\n        }\n    }\n    node = node.return;\n  } while (node !== null);\n  invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.');\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function (arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warningWithoutStack$1(false, 'React DevTools encountered an error: %s', err);\n      }\n    }\n  };\n}\n\nvar isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warningWithoutStack$1(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function (root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function (fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warningWithoutStack$1(false, 'React DevTools encountered an error: %s.', err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\nvar NoWork = 0;\nvar Sync = 1;\nvar Never = maxSigned31BitInt;\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return MAGIC_NUMBER_OFFSET + ceiling(currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n}\n\nvar LOW_PRIORITY_EXPIRATION = 5000;\nvar LOW_PRIORITY_BATCH_SIZE = 250;\n\nfunction computeAsyncExpiration(currentTime) {\n  return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);\n}\n\n// We intentionally set a higher expiration time for interactive updates in\n// dev than in production.\n//\n// If the main thread is being blocked so long that you hit the expiration,\n// it's a problem that could be solved with better scheduling.\n//\n// People will be more likely to notice this and fix it with the long\n// expiration time in development.\n//\n// In production we opt for better UX at the risk of masking scheduling\n// problems, by expiring fast.\nvar HIGH_PRIORITY_EXPIRATION = 500;\nvar HIGH_PRIORITY_BATCH_SIZE = 100;\n\nfunction computeInteractiveExpiration(currentTime) {\n  return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);\n}\n\nvar NoContext = 0;\nvar AsyncMode = 1;\nvar StrictMode = 2;\nvar ProfileMode = 4;\n\nvar hasBadMapPolyfill = void 0;\n\n{\n  hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    var testMap = new Map([[nonExtensibleObject, null]]);\n    var testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\nvar debugCounter = void 0;\n\n{\n  debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.firstContextDependency = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n  this.childExpirationTime = NoWork;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction resolveLazyComponentTag(fiber, Component) {\n  if (typeof Component === 'function') {\n    return shouldConstruct(Component) ? ClassComponentLazy : FunctionalComponentLazy;\n  } else if (Component !== undefined && Component !== null && Component.$$typeof) {\n    return ForwardRefLazy;\n  }\n  return IndeterminateComponent;\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    if (enableProfilerTimer) {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = -1;\n    }\n  }\n\n  // Don't touching the subtree's expiration time, which has not changed.\n  workInProgress.childExpirationTime = current.childExpirationTime;\n  if (pendingProps !== current.pendingProps) {\n    // This fiber has new props.\n    workInProgress.expirationTime = expirationTime;\n  } else {\n    // This fiber's props have not changed.\n    workInProgress.expirationTime = current.expirationTime;\n  }\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.firstContextDependency = current.firstContextDependency;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  if (enableProfilerTimer) {\n    workInProgress.selfBaseDuration = current.selfBaseDuration;\n    workInProgress.treeBaseDuration = current.treeBaseDuration;\n  }\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber(isAsync) {\n  var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n\nfunction createFiberFromElement(element, mode, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n\n  var fiberTag = void 0;\n  if (typeof type === 'function') {\n    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n  } else if (typeof type === 'string') {\n    fiberTag = HostComponent;\n  } else {\n    getTag: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);\n      case REACT_ASYNC_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= AsyncMode | StrictMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);\n      case REACT_PLACEHOLDER_TYPE:\n        fiberTag = PlaceholderComponent;\n        break;\n      default:\n        {\n          if (typeof type === 'object' && type !== null) {\n            switch (type.$$typeof) {\n              case REACT_PROVIDER_TYPE:\n                fiberTag = ContextProvider;\n                break getTag;\n              case REACT_CONTEXT_TYPE:\n                // This is a consumer\n                fiberTag = ContextConsumer;\n                break getTag;\n              case REACT_FORWARD_REF_TYPE:\n                fiberTag = ForwardRef;\n                break getTag;\n              default:\n                {\n                  if (typeof type.then === 'function') {\n                    fiberTag = IndeterminateComponent;\n                    break getTag;\n                  }\n                }\n            }\n          }\n          var info = '';\n          {\n            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n              info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\n            }\n            var ownerName = owner ? getComponentName(owner.type) : null;\n            if (ownerName) {\n              info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n            }\n          }\n          invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n        }\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.type = type;\n  fiber.expirationTime = expirationTime;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n\nfunction createFiberFromFragment(elements, mode, expirationTime, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromProfiler(pendingProps, mode, expirationTime, key) {\n  {\n    if (typeof pendingProps.id !== 'string' || typeof pendingProps.onRender !== 'function') {\n      warningWithoutStack$1(false, 'Profiler must specify an \"id\" string and \"onRender\" function as props');\n    }\n  }\n\n  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n  fiber.type = REACT_PROFILER_TYPE;\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromText(content, mode, expirationTime) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, mode, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n\n  // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.firstContextDependency = source.firstContextDependency;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.childExpirationTime = source.childExpirationTime;\n  target.alternate = source.alternate;\n  if (enableProfilerTimer) {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseDuration = source.selfBaseDuration;\n    target.treeBaseDuration = source.treeBaseDuration;\n  }\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  return target;\n}\n\n/* eslint-disable no-use-before-define */\n// TODO: This should be lifted into the renderer.\n\n\n// The following attributes are only used by interaction tracking builds.\n// They enable interactions to be associated with their async work,\n// And expose interaction metadata to the React DevTools Profiler plugin.\n// Note that these attributes are only defined when the enableSchedulerTracking flag is enabled.\n\n\n// Exported FiberRoot type includes all properties,\n// To avoid requiring potentially error-prone :any casts throughout the project.\n// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracking is true).\n// The types are defined separately within this file to ensure they stay in sync.\n// (We don't have to use an inline :any cast when enableSchedulerTracking is disabled.)\n\n/* eslint-enable no-use-before-define */\n\nfunction createFiberRoot(containerInfo, isAsync, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber(isAsync);\n\n  var root = void 0;\n  if (enableSchedulerTracking) {\n    root = {\n      current: uninitializedFiber,\n      containerInfo: containerInfo,\n      pendingChildren: null,\n\n      earliestPendingTime: NoWork,\n      latestPendingTime: NoWork,\n      earliestSuspendedTime: NoWork,\n      latestSuspendedTime: NoWork,\n      latestPingedTime: NoWork,\n\n      didError: false,\n\n      pendingCommitExpirationTime: NoWork,\n      finishedWork: null,\n      timeoutHandle: noTimeout,\n      context: null,\n      pendingContext: null,\n      hydrate: hydrate,\n      nextExpirationTimeToWorkOn: NoWork,\n      expirationTime: NoWork,\n      firstBatch: null,\n      nextScheduledRoot: null,\n\n      interactionThreadID: tracking.unstable_getThreadID(),\n      memoizedInteractions: new Set(),\n      pendingInteractionMap: new Map()\n    };\n  } else {\n    root = {\n      current: uninitializedFiber,\n      containerInfo: containerInfo,\n      pendingChildren: null,\n\n      earliestPendingTime: NoWork,\n      latestPendingTime: NoWork,\n      earliestSuspendedTime: NoWork,\n      latestSuspendedTime: NoWork,\n      latestPingedTime: NoWork,\n\n      didError: false,\n\n      pendingCommitExpirationTime: NoWork,\n      finishedWork: null,\n      timeoutHandle: noTimeout,\n      context: null,\n      pendingContext: null,\n      hydrate: hydrate,\n      nextExpirationTimeToWorkOn: NoWork,\n      expirationTime: NoWork,\n      firstBatch: null,\n      nextScheduledRoot: null\n    };\n  }\n\n  uninitializedFiber.stateNode = root;\n\n  // The reason for the way the Flow types are structured in this file,\n  // Is to avoid needing :any casts everywhere interaction tracking fields are used.\n  // Unfortunately that requires an :any cast for non-interaction tracking capable builds.\n  // $FlowFixMe Remove this :any cast and replace it with something better.\n  return root;\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar ReactStrictModeWarnings = {\n  discardPendingWarnings: function () {},\n  flushPendingDeprecationWarnings: function () {},\n  flushPendingUnsafeLifecycleWarnings: function () {},\n  recordDeprecationWarnings: function (fiber, instance) {},\n  recordUnsafeLifecycleWarnings: function (fiber, instance) {},\n  recordLegacyContextWarning: function (fiber, instance) {},\n  flushLegacyContextWarning: function () {}\n};\n\n{\n  var LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: 'componentDidMount',\n    UNSAFE_componentWillReceiveProps: 'static getDerivedStateFromProps',\n    UNSAFE_componentWillUpdate: 'componentDidUpdate'\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUnsafeLifecycleWarnings = new Map();\n  var pendingLegacyContextWarning = new Map();\n\n  // Tracks components we have already warned about.\n  var didWarnAboutDeprecatedLifecycles = new Set();\n  var didWarnAboutUnsafeLifecycles = new Set();\n  var didWarnAboutLegacyContext = new Set();\n\n  var setToSortedString = function (set) {\n    var array = [];\n    set.forEach(function (value) {\n      array.push(value);\n    });\n    return array.sort().join(', ');\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function () {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n    pendingLegacyContextWarning = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\n    pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {\n      var lifecyclesWarningMesages = [];\n\n      Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {\n        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n        if (lifecycleWarnings.length > 0) {\n          var componentNames = new Set();\n          lifecycleWarnings.forEach(function (fiber) {\n            componentNames.add(getComponentName(fiber.type) || 'Component');\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n          });\n\n          var formatted = lifecycle.replace('UNSAFE_', '');\n          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n          var sortedComponentNames = setToSortedString(componentNames);\n\n          lifecyclesWarningMesages.push(formatted + ': Please update the following components to use ' + (suggestion + ' instead: ' + sortedComponentNames));\n        }\n      });\n\n      if (lifecyclesWarningMesages.length > 0) {\n        var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\n\n        warningWithoutStack$1(false, 'Unsafe lifecycle methods were found within a strict-mode tree:%s' + '\\n\\n%s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, lifecyclesWarningMesages.join('\\n\\n'));\n      }\n    });\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  var findStrictRoot = function (fiber) {\n    var maybeStrictRoot = null;\n\n    var node = fiber;\n    while (node !== null) {\n      if (node.mode & StrictMode) {\n        maybeStrictRoot = node;\n      }\n      node = node.return;\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      var uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(function (fiber) {\n        uniqueNames.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning$1(false, 'componentWillMount is deprecated and will be removed in the next major version. ' + 'Use componentDidMount instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillMount.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', sortedNames);\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      var _uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        _uniqueNames.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames = setToSortedString(_uniqueNames);\n\n      lowPriorityWarning$1(false, 'componentWillReceiveProps is deprecated and will be removed in the next major version. ' + 'Use static getDerivedStateFromProps instead.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames);\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      var _uniqueNames2 = new Set();\n      pendingComponentWillUpdateWarnings.forEach(function (fiber) {\n        _uniqueNames2.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames2 = setToSortedString(_uniqueNames2);\n\n      lowPriorityWarning$1(false, 'componentWillUpdate is deprecated and will be removed in the next major version. ' + 'Use componentDidUpdate instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillUpdate.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames2);\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warningWithoutStack$1(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = void 0;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: []\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    var unsafeLifecycles = [];\n    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillMount');\n    }\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');\n    }\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillUpdate');\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(function (lifecycle) {\n        warningsForRoot[lifecycle].push(fiber);\n      });\n    }\n  };\n\n  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warningWithoutStack$1(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutLegacyContext.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n      if (warningsForRoot === undefined) {\n        warningsForRoot = [];\n        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n      }\n      warningsForRoot.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushLegacyContextWarning = function () {\n    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {\n      var uniqueNames = new Set();\n      fiberArray.forEach(function (fiber) {\n        uniqueNames.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutLegacyContext.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n      var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\n\n      warningWithoutStack$1(false, 'Legacy context API has been detected within a strict-mode tree: %s' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, sortedNames);\n    });\n  };\n}\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\n// TODO: Offscreen updates should never suspend. However, a promise that\n// suspended inside an offscreen subtree should be able to ping at the priority\n// of the outer render.\n\nfunction markPendingPriorityLevel(root, expirationTime) {\n  // If there's a gap between completing a failed root and retrying it,\n  // additional updates may be scheduled. Clear `didError`, in case the update\n  // is sufficient to fix the error.\n  root.didError = false;\n\n  // Update the latest and earliest pending times\n  var earliestPendingTime = root.earliestPendingTime;\n  if (earliestPendingTime === NoWork) {\n    // No other pending updates.\n    root.earliestPendingTime = root.latestPendingTime = expirationTime;\n  } else {\n    if (earliestPendingTime > expirationTime) {\n      // This is the earliest pending update.\n      root.earliestPendingTime = expirationTime;\n    } else {\n      var latestPendingTime = root.latestPendingTime;\n      if (latestPendingTime < expirationTime) {\n        // This is the latest pending update\n        root.latestPendingTime = expirationTime;\n      }\n    }\n  }\n  findNextExpirationTimeToWorkOn(expirationTime, root);\n}\n\nfunction markCommittedPriorityLevels(root, earliestRemainingTime) {\n  root.didError = false;\n\n  if (earliestRemainingTime === NoWork) {\n    // Fast path. There's no remaining work. Clear everything.\n    root.earliestPendingTime = NoWork;\n    root.latestPendingTime = NoWork;\n    root.earliestSuspendedTime = NoWork;\n    root.latestSuspendedTime = NoWork;\n    root.latestPingedTime = NoWork;\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  // Let's see if the previous latest known pending level was just flushed.\n  var latestPendingTime = root.latestPendingTime;\n  if (latestPendingTime !== NoWork) {\n    if (latestPendingTime < earliestRemainingTime) {\n      // We've flushed all the known pending levels.\n      root.earliestPendingTime = root.latestPendingTime = NoWork;\n    } else {\n      var earliestPendingTime = root.earliestPendingTime;\n      if (earliestPendingTime < earliestRemainingTime) {\n        // We've flushed the earliest known pending level. Set this to the\n        // latest pending time.\n        root.earliestPendingTime = root.latestPendingTime;\n      }\n    }\n  }\n\n  // Now let's handle the earliest remaining level in the whole tree. We need to\n  // decide whether to treat it as a pending level or as suspended. Check\n  // it falls within the range of known suspended levels.\n\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  if (earliestSuspendedTime === NoWork) {\n    // There's no suspended work. Treat the earliest remaining level as a\n    // pending level.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (earliestRemainingTime > latestSuspendedTime) {\n    // The earliest remaining level is later than all the suspended work. That\n    // means we've flushed all the suspended work.\n    root.earliestSuspendedTime = NoWork;\n    root.latestSuspendedTime = NoWork;\n    root.latestPingedTime = NoWork;\n\n    // There's no suspended work. Treat the earliest remaining level as a\n    // pending level.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  if (earliestRemainingTime < earliestSuspendedTime) {\n    // The earliest remaining time is earlier than all the suspended work.\n    // Treat it as a pending update.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  // The earliest remaining time falls within the range of known suspended\n  // levels. We should treat this as suspended work.\n  findNextExpirationTimeToWorkOn(NoWork, root);\n}\n\nfunction hasLowerPriorityWork(root, erroredExpirationTime) {\n  var latestPendingTime = root.latestPendingTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  var latestPingedTime = root.latestPingedTime;\n  return latestPendingTime !== NoWork && latestPendingTime > erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime > erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime > erroredExpirationTime;\n}\n\nfunction isPriorityLevelSuspended(root, expirationTime) {\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  return earliestSuspendedTime !== NoWork && expirationTime >= earliestSuspendedTime && expirationTime <= latestSuspendedTime;\n}\n\nfunction markSuspendedPriorityLevel(root, suspendedTime) {\n  root.didError = false;\n  clearPing(root, suspendedTime);\n\n  // First, check the known pending levels and update them if needed.\n  var earliestPendingTime = root.earliestPendingTime;\n  var latestPendingTime = root.latestPendingTime;\n  if (earliestPendingTime === suspendedTime) {\n    if (latestPendingTime === suspendedTime) {\n      // Both known pending levels were suspended. Clear them.\n      root.earliestPendingTime = root.latestPendingTime = NoWork;\n    } else {\n      // The earliest pending level was suspended. Clear by setting it to the\n      // latest pending level.\n      root.earliestPendingTime = latestPendingTime;\n    }\n  } else if (latestPendingTime === suspendedTime) {\n    // The latest pending level was suspended. Clear by setting it to the\n    // latest pending level.\n    root.latestPendingTime = earliestPendingTime;\n  }\n\n  // Finally, update the known suspended levels.\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (earliestSuspendedTime === NoWork) {\n    // No other suspended levels.\n    root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;\n  } else {\n    if (earliestSuspendedTime > suspendedTime) {\n      // This is the earliest suspended level.\n      root.earliestSuspendedTime = suspendedTime;\n    } else if (latestSuspendedTime < suspendedTime) {\n      // This is the latest suspended level\n      root.latestSuspendedTime = suspendedTime;\n    }\n  }\n\n  findNextExpirationTimeToWorkOn(suspendedTime, root);\n}\n\nfunction markPingedPriorityLevel(root, pingedTime) {\n  root.didError = false;\n\n  // TODO: When we add back resuming, we need to ensure the progressed work\n  // is thrown out and not reused during the restarted render. One way to\n  // invalidate the progressed work is to restart at expirationTime + 1.\n  var latestPingedTime = root.latestPingedTime;\n  if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {\n    root.latestPingedTime = pingedTime;\n  }\n  findNextExpirationTimeToWorkOn(pingedTime, root);\n}\n\nfunction clearPing(root, completedTime) {\n  // TODO: Track whether the root was pinged during the render phase. If so,\n  // we need to make sure we don't lose track of it.\n  var latestPingedTime = root.latestPingedTime;\n  if (latestPingedTime !== NoWork && latestPingedTime <= completedTime) {\n    root.latestPingedTime = NoWork;\n  }\n}\n\nfunction findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {\n  var earliestExpirationTime = renderExpirationTime;\n\n  var earliestPendingTime = root.earliestPendingTime;\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  if (earliestExpirationTime === NoWork || earliestPendingTime !== NoWork && earliestPendingTime < earliestExpirationTime) {\n    earliestExpirationTime = earliestPendingTime;\n  }\n  if (earliestExpirationTime === NoWork || earliestSuspendedTime !== NoWork && earliestSuspendedTime < earliestExpirationTime) {\n    earliestExpirationTime = earliestSuspendedTime;\n  }\n  return earliestExpirationTime;\n}\n\nfunction didExpireAtExpirationTime(root, currentTime) {\n  var expirationTime = root.expirationTime;\n  if (expirationTime !== NoWork && currentTime >= expirationTime) {\n    // The root has expired. Flush all work up to the current time.\n    root.nextExpirationTimeToWorkOn = currentTime;\n  }\n}\n\nfunction findNextExpirationTimeToWorkOn(completedExpirationTime, root) {\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  var earliestPendingTime = root.earliestPendingTime;\n  var latestPingedTime = root.latestPingedTime;\n\n  // Work on the earliest pending time. Failing that, work on the latest\n  // pinged time.\n  var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;\n\n  // If there is no pending or pinged work, check if there's suspended work\n  // that's lower priority than what we just completed.\n  if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime > completedExpirationTime)) {\n    // The lowest priority suspended work is the work most likely to be\n    // committed next. Let's start rendering it again, so that if it times out,\n    // it's ready to commit.\n    nextExpirationTimeToWorkOn = latestSuspendedTime;\n  }\n\n  var expirationTime = nextExpirationTimeToWorkOn;\n  if (expirationTime !== NoWork && earliestSuspendedTime !== NoWork && earliestSuspendedTime < expirationTime) {\n    // Expire using the earliest known expiration time.\n    expirationTime = earliestSuspendedTime;\n  }\n\n  root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;\n  root.expirationTime = expirationTime;\n}\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which is\n// can be mutated and processed asynchronously before it is committed  a form\n// of double buffering. If a work-in-progress render is discarded before\n// finishing, we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nvar UpdateState = 0;\nvar ReplaceState = 1;\nvar ForceUpdate = 2;\nvar CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate = false;\n\nvar didWarnUpdateInsideUpdate = void 0;\nvar currentlyProcessingQueue = void 0;\nvar resetCurrentlyProcessingQueue = void 0;\n{\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = function () {\n    currentlyProcessingQueue = null;\n  };\n}\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    firstUpdate: null,\n    lastUpdate: null,\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction cloneUpdateQueue(currentQueue) {\n  var queue = {\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n\n    firstEffect: null,\n    lastEffect: null,\n\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction createUpdate(expirationTime) {\n  return {\n    expirationTime: expirationTime,\n\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n\n    next: null,\n    nextEffect: null\n  };\n}\n\nfunction appendUpdateToQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n}\n\nfunction enqueueUpdate(fiber, update) {\n  // Update queues are created lazily.\n  var alternate = fiber.alternate;\n  var queue1 = void 0;\n  var queue2 = void 0;\n  if (alternate === null) {\n    // There's only one fiber.\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n    if (queue1 === null) {\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {\n        // Both owners have an update queue.\n      }\n    }\n  }\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list  we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update);\n      appendUpdateToQueue(queue2, update);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update);\n      // But we still need to update the `lastUpdate` pointer of queue2.\n      queue2.lastUpdate = update;\n    }\n  }\n\n  {\n    if ((fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {\n      warningWithoutStack$1(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n\nfunction enqueueCapturedUpdate(workInProgress, update) {\n  // Captured updates go into a separate list, and only on the work-in-\n  // progress queue.\n  var workInProgressQueue = workInProgress.updateQueue;\n  if (workInProgressQueue === null) {\n    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);\n  } else {\n    // TODO: I put this here rather than createWorkInProgress so that we don't\n    // clone the queue unnecessarily. There's probably a better way to\n    // structure this.\n    workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);\n  }\n\n  // Append the update to the end of the list.\n  if (workInProgressQueue.lastCapturedUpdate === null) {\n    // This is the first render phase update\n    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;\n  } else {\n    workInProgressQueue.lastCapturedUpdate.next = update;\n    workInProgressQueue.lastCapturedUpdate = update;\n  }\n}\n\nfunction ensureWorkInProgressQueueIsAClone(workInProgress, queue) {\n  var current = workInProgress.alternate;\n  if (current !== null) {\n    // If the work-in-progress queue is equal to the current queue,\n    // we need to clone it first.\n    if (queue === current.updateQueue) {\n      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);\n    }\n  }\n  return queue;\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        var _payload = update.payload;\n        if (typeof _payload === 'function') {\n          // Updater function\n          {\n            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n              _payload.call(instance, prevState, nextProps);\n            }\n          }\n          return _payload.call(instance, prevState, nextProps);\n        }\n        // State object\n        return _payload;\n      }\n    case CaptureUpdate:\n      {\n        workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n    case UpdateState:\n      {\n        var _payload2 = update.payload;\n        var partialState = void 0;\n        if (typeof _payload2 === 'function') {\n          // Updater function\n          {\n            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n              _payload2.call(instance, prevState, nextProps);\n            }\n          }\n          partialState = _payload2.call(instance, prevState, nextProps);\n        } else {\n          // Partial state object\n          partialState = _payload2;\n        }\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        }\n        // Merge the partial state and the previous state.\n        return _assign({}, prevState, partialState);\n      }\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n  return prevState;\n}\n\nfunction processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {\n  hasForceUpdate = false;\n\n  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);\n\n  {\n    currentlyProcessingQueue = queue;\n  }\n\n  // These values may change as we process the queue.\n  var newBaseState = queue.baseState;\n  var newFirstUpdate = null;\n  var newExpirationTime = NoWork;\n\n  // Iterate through the list of updates to compute the result.\n  var update = queue.firstUpdate;\n  var resultState = newBaseState;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstUpdate === null) {\n        // This is the first skipped update. It will be the first update in\n        // the new list.\n        newFirstUpdate = update;\n        // Since this is the first update that was skipped, the current result\n        // is the new base state.\n        newBaseState = resultState;\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (newExpirationTime === NoWork || newExpirationTime > updateExpirationTime) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);\n      var _callback = update.callback;\n      if (_callback !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastEffect === null) {\n          queue.firstEffect = queue.lastEffect = update;\n        } else {\n          queue.lastEffect.nextEffect = update;\n          queue.lastEffect = update;\n        }\n      }\n    }\n    // Continue to the next update.\n    update = update.next;\n  }\n\n  // Separately, iterate though the list of captured updates.\n  var newFirstCapturedUpdate = null;\n  update = queue.firstCapturedUpdate;\n  while (update !== null) {\n    var _updateExpirationTime = update.expirationTime;\n    if (_updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstCapturedUpdate === null) {\n        // This is the first skipped captured update. It will be the first\n        // update in the new list.\n        newFirstCapturedUpdate = update;\n        // If this is the first update that was skipped, the current result is\n        // the new base state.\n        if (newFirstUpdate === null) {\n          newBaseState = resultState;\n        }\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (newExpirationTime === NoWork || newExpirationTime > _updateExpirationTime) {\n        newExpirationTime = _updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);\n      var _callback2 = update.callback;\n      if (_callback2 !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastCapturedEffect === null) {\n          queue.firstCapturedEffect = queue.lastCapturedEffect = update;\n        } else {\n          queue.lastCapturedEffect.nextEffect = update;\n          queue.lastCapturedEffect = update;\n        }\n      }\n    }\n    update = update.next;\n  }\n\n  if (newFirstUpdate === null) {\n    queue.lastUpdate = null;\n  }\n  if (newFirstCapturedUpdate === null) {\n    queue.lastCapturedUpdate = null;\n  } else {\n    workInProgress.effectTag |= Callback;\n  }\n  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {\n    // We processed every update, without skipping. That means the new base\n    // state is the same as the result state.\n    newBaseState = resultState;\n  }\n\n  queue.baseState = newBaseState;\n  queue.firstUpdate = newFirstUpdate;\n  queue.firstCapturedUpdate = newFirstCapturedUpdate;\n\n  // Set the remaining expiration time to be whatever is remaining in the queue.\n  // This should be fine because the only two other things that contribute to\n  // expiration time are props and context. We're already in the middle of the\n  // begin phase by the time we start processing the queue, so we've already\n  // dealt with the props. Context in components that specify\n  // shouldComponentUpdate is tricky; but we'll have to account for\n  // that regardless.\n  workInProgress.expirationTime = newExpirationTime;\n  workInProgress.memoizedState = resultState;\n\n  {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  !(typeof callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', callback) : void 0;\n  callback.call(context);\n}\n\nfunction resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nfunction checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\n\nfunction commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {\n  // If the finished render included captured updates, and there are still\n  // lower priority updates left over, we need to keep the captured updates\n  // in the queue so that they are rebased and not dropped once we process the\n  // queue again at the lower priority.\n  if (finishedQueue.firstCapturedUpdate !== null) {\n    // Join the captured update list to the end of the normal list.\n    if (finishedQueue.lastUpdate !== null) {\n      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;\n      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;\n    }\n    // Clear the list of captured updates.\n    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;\n  }\n\n  // Commit the effects\n  commitUpdateEffects(finishedQueue.firstEffect, instance);\n  finishedQueue.firstEffect = finishedQueue.lastEffect = null;\n\n  commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);\n  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;\n}\n\nfunction commitUpdateEffects(effect, instance) {\n  while (effect !== null) {\n    var _callback3 = effect.callback;\n    if (_callback3 !== null) {\n      effect.callback = null;\n      callCallback(_callback3, instance);\n    }\n    effect = effect.nextEffect;\n  }\n}\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source)\n  };\n}\n\nvar valueCursor = createCursor(null);\n\nvar rendererSigil = void 0;\n{\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\nvar currentlyRenderingFiber = null;\nvar lastContextDependency = null;\nvar lastContextWithAllBitsObserved = null;\n\nfunction resetContextDependences() {\n  // This is called right before React yields execution, to ensure `readContext`\n  // cannot be called outside the render phase.\n  currentlyRenderingFiber = null;\n  lastContextDependency = null;\n  lastContextWithAllBitsObserved = null;\n}\n\nfunction pushProvider(providerFiber, nextValue) {\n  var context = providerFiber.type._context;\n\n  if (isPrimaryRenderer) {\n    push(valueCursor, context._currentValue, providerFiber);\n\n    context._currentValue = nextValue;\n    {\n      !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warningWithoutStack$1(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    push(valueCursor, context._currentValue2, providerFiber);\n\n    context._currentValue2 = nextValue;\n    {\n      !(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil) ? warningWithoutStack$1(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n}\n\nfunction popProvider(providerFiber) {\n  var currentValue = valueCursor.current;\n\n  pop(valueCursor, providerFiber);\n\n  var context = providerFiber.type._context;\n  if (isPrimaryRenderer) {\n    context._currentValue = currentValue;\n  } else {\n    context._currentValue2 = currentValue;\n  }\n}\n\nfunction calculateChangedBits(context, newValue, oldValue) {\n  // Use Object.is to compare the new context value to the old value. Inlined\n  // Object.is polyfill.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n  if (oldValue === newValue && (oldValue !== 0 || 1 / oldValue === 1 / newValue) || oldValue !== oldValue && newValue !== newValue // eslint-disable-line no-self-compare\n  ) {\n      // No change\n      return 0;\n    } else {\n    var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : maxSigned31BitInt;\n\n    {\n      !((changedBits & maxSigned31BitInt) === changedBits) ? warning$1(false, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits) : void 0;\n    }\n    return changedBits | 0;\n  }\n}\n\nfunction propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {\n  var fiber = workInProgress.child;\n  if (fiber !== null) {\n    // Set the return pointer of the child to the work-in-progress fiber.\n    fiber.return = workInProgress;\n  }\n  while (fiber !== null) {\n    var nextFiber = void 0;\n\n    // Visit this fiber.\n    var dependency = fiber.firstContextDependency;\n    if (dependency !== null) {\n      do {\n        // Check if the context matches.\n        if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {\n          // Match! Schedule an update on this fiber.\n\n          if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {\n            // Schedule a force update on the work-in-progress.\n            var update = createUpdate(renderExpirationTime);\n            update.tag = ForceUpdate;\n            // TODO: Because we don't have a work-in-progress, this will add the\n            // update to the current fiber, too, which means it will persist even if\n            // this render is thrown away. Since it's a race condition, not sure it's\n            // worth fixing.\n            enqueueUpdate(fiber, update);\n          }\n\n          if (fiber.expirationTime === NoWork || fiber.expirationTime > renderExpirationTime) {\n            fiber.expirationTime = renderExpirationTime;\n          }\n          var alternate = fiber.alternate;\n          if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {\n            alternate.expirationTime = renderExpirationTime;\n          }\n          // Update the child expiration time of all the ancestors, including\n          // the alternates.\n          var node = fiber.return;\n          while (node !== null) {\n            alternate = node.alternate;\n            if (node.childExpirationTime === NoWork || node.childExpirationTime > renderExpirationTime) {\n              node.childExpirationTime = renderExpirationTime;\n              if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > renderExpirationTime)) {\n                alternate.childExpirationTime = renderExpirationTime;\n              }\n            } else if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > renderExpirationTime)) {\n              alternate.childExpirationTime = renderExpirationTime;\n            } else {\n              // Neither alternate was updated, which means the rest of the\n              // ancestor path already has sufficient priority.\n              break;\n            }\n            node = node.return;\n          }\n        }\n        nextFiber = fiber.child;\n        dependency = dependency.next;\n      } while (dependency !== null);\n    } else if (fiber.tag === ContextProvider) {\n      // Don't scan deeper if this is a matching provider\n      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n    } else {\n      // Traverse down.\n      nextFiber = fiber.child;\n    }\n\n    if (nextFiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      nextFiber.return = fiber;\n    } else {\n      // No child. Traverse to next sibling.\n      nextFiber = fiber;\n      while (nextFiber !== null) {\n        if (nextFiber === workInProgress) {\n          // We're back to the root of this subtree. Exit.\n          nextFiber = null;\n          break;\n        }\n        var sibling = nextFiber.sibling;\n        if (sibling !== null) {\n          // Set the return pointer of the sibling to the work-in-progress fiber.\n          sibling.return = nextFiber.return;\n          nextFiber = sibling;\n          break;\n        }\n        // No more siblings. Traverse up.\n        nextFiber = nextFiber.return;\n      }\n    }\n    fiber = nextFiber;\n  }\n}\n\nfunction prepareToReadContext(workInProgress, renderExpirationTime) {\n  currentlyRenderingFiber = workInProgress;\n  lastContextDependency = null;\n  lastContextWithAllBitsObserved = null;\n\n  // Reset the work-in-progress list\n  workInProgress.firstContextDependency = null;\n}\n\nfunction readContext(context, observedBits) {\n  if (lastContextWithAllBitsObserved === context) {\n    // Nothing to do. We already observe everything in this context.\n  } else if (observedBits === false || observedBits === 0) {\n    // Do not observe any updates.\n  } else {\n    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.\n    if (typeof observedBits !== 'number' || observedBits === maxSigned31BitInt) {\n      // Observe all updates.\n      lastContextWithAllBitsObserved = context;\n      resolvedObservedBits = maxSigned31BitInt;\n    } else {\n      resolvedObservedBits = observedBits;\n    }\n\n    var contextItem = {\n      context: context,\n      observedBits: resolvedObservedBits,\n      next: null\n    };\n\n    if (lastContextDependency === null) {\n      !(currentlyRenderingFiber !== null) ? invariant(false, 'Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps.') : void 0;\n      // This is the first dependency in the list\n      currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;\n    } else {\n      // Append a new context item.\n      lastContextDependency = lastContextDependency.next = contextItem;\n    }\n  }\n  return isPrimaryRenderer ? context._currentValue : context._currentValue2;\n}\n\nvar NO_CONTEXT = {};\n\nvar contextStackCursor$1 = createCursor(NO_CONTEXT);\nvar contextFiberStackCursor = createCursor(NO_CONTEXT);\nvar rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  return c;\n}\n\nfunction getRootHostContainer() {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber);\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n\n  // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n  push(contextStackCursor$1, NO_CONTEXT, fiber);\n  var nextRootContext = getRootHostContext(nextRootInstance);\n  // Now that we know this function doesn't throw, replace it.\n  pop(contextStackCursor$1, fiber);\n  push(contextStackCursor$1, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  var context = requiredContext(contextStackCursor$1.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  var context = requiredContext(contextStackCursor$1.current);\n  var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n  // Don't push this Fiber's context unless it's unique.\n  if (context === nextContext) {\n    return;\n  }\n\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor$1, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nvar commitTime = 0;\nvar profilerStartTime = -1;\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  commitTime = schedule.unstable_now();\n}\n\nfunction startProfilerTimer(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  profilerStartTime = schedule.unstable_now();\n\n  if (fiber.actualStartTime < 0) {\n    fiber.actualStartTime = schedule.unstable_now();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  if (profilerStartTime >= 0) {\n    var elapsedTime = schedule.unstable_now() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n    profilerStartTime = -1;\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\n// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nvar emptyRefsObject = new React.Component().refs;\n\nvar didWarnAboutStateAssignmentForComponent = void 0;\nvar didWarnAboutUninitializedState = void 0;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\nvar didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\nvar didWarnAboutUndefinedDerivedState = void 0;\nvar warnOnUndefinedDerivedState = void 0;\nvar warnOnInvalidCallback$1 = void 0;\nvar didWarnAboutDirectlyAssigningPropsToState = void 0;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback$1 = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n    var key = callerName + '_' + callback;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warningWithoutStack$1(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  warnOnUndefinedDerivedState = function (type, partialState) {\n    if (partialState === undefined) {\n      var componentName = getComponentName(type) || 'Component';\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        warningWithoutStack$1(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n      }\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n  var prevState = workInProgress.memoizedState;\n\n  {\n    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  var partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  {\n    warnOnUndefinedDerivedState(ctor, partialState);\n  }\n  // Merge the partial state and the previous state.\n  var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState;\n\n  // Once the update queue is empty, persist the derived state onto the\n  // base state.\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nvar classComponentUpdater = {\n  isMounted: isMounted,\n  enqueueSetState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback$1(callback, 'setState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueReplaceState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback$1(callback, 'replaceState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueForceUpdate: function (inst, callback) {\n    var fiber = get(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback$1(callback, 'forceUpdate');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  }\n};\n\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext) {\n  var instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextLegacyContext);\n    stopPhaseTimer();\n\n    {\n      !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component') : void 0;\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  var instance = workInProgress.stateNode;\n  {\n    var name = getComponentName(ctor) || 'Component';\n    var renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        warningWithoutStack$1(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n      } else {\n        warningWithoutStack$1(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      }\n    }\n\n    var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n    !noGetInitialStateOnES6 ? warningWithoutStack$1(false, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name) : void 0;\n    var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n    !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name) : void 0;\n    var noInstancePropTypes = !instance.propTypes;\n    !noInstancePropTypes ? warningWithoutStack$1(false, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name) : void 0;\n    var noInstanceContextTypes = !instance.contextTypes;\n    !noInstanceContextTypes ? warningWithoutStack$1(false, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name) : void 0;\n    var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n    !noComponentShouldUpdate ? warningWithoutStack$1(false, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name) : void 0;\n    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n      warningWithoutStack$1(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');\n    }\n    var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n    !noComponentDidUnmount ? warningWithoutStack$1(false, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name) : void 0;\n    var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n    !noComponentDidReceiveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name) : void 0;\n    var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n    !noComponentWillRecieveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name) : void 0;\n    var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== 'function';\n    !noUnsafeComponentWillRecieveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name) : void 0;\n    var hasMutatedProps = instance.props !== newProps;\n    !(instance.props === undefined || !hasMutatedProps) ? warningWithoutStack$1(false, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name) : void 0;\n    var noInstanceDefaultProps = !instance.defaultProps;\n    !noInstanceDefaultProps ? warningWithoutStack$1(false, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name) : void 0;\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      warningWithoutStack$1(false, '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));\n    }\n\n    var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== 'function';\n    !noInstanceGetDerivedStateFromProps ? warningWithoutStack$1(false, '%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;\n    var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromCatch !== 'function';\n    !noInstanceGetDerivedStateFromCatch ? warningWithoutStack$1(false, '%s: getDerivedStateFromCatch() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;\n    var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== 'function';\n    !noStaticGetSnapshotBeforeUpdate ? warningWithoutStack$1(false, '%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name) : void 0;\n    var _state = instance.state;\n    if (_state && (typeof _state !== 'object' || isArray(_state))) {\n      warningWithoutStack$1(false, '%s.state: must be set to an object or null', name);\n    }\n    if (typeof instance.getChildContext === 'function') {\n      !(typeof ctor.childContextTypes === 'object') ? warningWithoutStack$1(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name) : void 0;\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  // The instance needs access to the fiber so that it can schedule updates\n  set(instance, workInProgress);\n  {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {\n  var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n  var contextTypes = ctor.contextTypes;\n  var isContextConsumer = contextTypes !== null && contextTypes !== undefined;\n  var context = isContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n\n  // Instantiate twice to help detect side-effects.\n  {\n    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  var instance = new ctor(props, context);\n  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n  adoptClassInstance(workInProgress, instance);\n\n  {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      var componentName = getComponentName(ctor) || 'Component';\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        warningWithoutStack$1(false, '`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n      var foundWillMountName = null;\n      var foundWillReceivePropsName = null;\n      var foundWillUpdateName = null;\n      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n        var _componentName = getComponentName(ctor) || 'Component';\n        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n          warningWithoutStack$1(false, 'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-async-component-lifecycle-hooks', _componentName, newApiName, foundWillMountName !== null ? '\\n  ' + foundWillMountName : '', foundWillReceivePropsName !== null ? '\\n  ' + foundWillReceivePropsName : '', foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '');\n        }\n      }\n    }\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n  if (isContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, 'componentWillMount');\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    {\n      warningWithoutStack$1(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext) {\n  var oldState = instance.state;\n  startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextLegacyContext);\n  }\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextLegacyContext);\n  }\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    {\n      var componentName = getComponentName(workInProgress.type) || 'Component';\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        warningWithoutStack$1(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n      }\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {\n  {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  var instance = workInProgress.stateNode;\n  var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n  instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n  {\n    if (instance.state === newProps) {\n      var componentName = getComponentName(ctor) || 'Component';\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        warningWithoutStack$1(false, '%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);\n    }\n  }\n\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n    callComponentWillMount(workInProgress, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n      instance.state = workInProgress.memoizedState;\n    }\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n  var nextLegacyContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextLegacyContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    newState = workInProgress.memoizedState;\n  }\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      startPhaseTimer(workInProgress, 'componentWillMount');\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextLegacyContext;\n\n  return shouldUpdate;\n}\n\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n  var nextLegacyContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextLegacyContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    newState = workInProgress.memoizedState;\n  }\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n      startPhaseTimer(workInProgress, 'componentWillUpdate');\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextLegacyContext);\n      }\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextLegacyContext);\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextLegacyContext;\n\n  return shouldUpdate;\n}\n\nvar didWarnAboutMaps = void 0;\nvar didWarnAboutGenerators = void 0;\nvar didWarnAboutStringRefInStrictMode = void 0;\nvar ownerHasKeyUseWarning = void 0;\nvar ownerHasFunctionTypeWarning = void 0;\nvar warnForMissingKey = function (child) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + getCurrentFiberStackInDev();\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning$1(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.');\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(returnFiber, current$$1, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    {\n      if (returnFiber.mode & StrictMode) {\n        var componentName = getComponentName(returnFiber.type) || 'Component';\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warningWithoutStack$1(false, 'A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using createRef() instead.' + '\\n%s' + '\\n\\nLearn more about using refs safely here:' + '\\nhttps://fb.me/react-strict-mode-string-ref', mixedRef, getStackByFiberInDevAndProd(returnFiber));\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        !(ownerFiber.tag === ClassComponent || ownerFiber.tag === ClassComponentLazy) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n        inst = ownerFiber.stateNode;\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current$$1 !== null && current$$1.ref !== null && typeof current$$1.ref === 'function' && current$$1.ref._stringRef === stringRef) {\n        return current$$1.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs;\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = inst.refs = {};\n        }\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function, a string, an object returned by React.createRef(), or null.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\\n1. You may be adding a ref to a functional component\\n2. You may be adding a ref to a component that was not created inside a component\\'s render method\\n3. You have multiple copies of React loaded\\nSee https://fb.me/react-refs-must-have-owner for more information.', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + getCurrentFiberStackInDev();\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + getCurrentFiberStackInDev();\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning$1(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current$$1 = newFiber.alternate;\n    if (current$$1 !== null) {\n      var oldIndex = current$$1.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {\n    if (current$$1 === null || current$$1.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current$$1, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current$$1, element, expirationTime) {\n    if (current$$1 !== null && current$$1.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current$$1, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current$$1, element);\n      existing.return = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      created.ref = coerceRef(returnFiber, current$$1, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current$$1, portal, expirationTime) {\n    if (current$$1 === null || current$$1.tag !== HostPortal || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current$$1, portal.children || [], expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {\n    if (current$$1 === null || current$$1.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current$$1, fragment, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);\n            _created.ref = coerceRef(returnFiber, null, newChild);\n            _created.return = returnFiber;\n            return _created;\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);\n            _created2.return = returnFiber;\n            return _created2;\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);\n        _created3.return = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning$1(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.', key);\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (typeof Symbol === 'function' &&\n      // $FlowFixMe Flow doesn't know about toStringTag\n      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n        !didWarnAboutGenerators ? warning$1(false, 'Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.') : void 0;\n        didWarnAboutGenerators = true;\n      }\n\n      // Warn about using Maps as children\n      if (newChildrenIterable.entries === iteratorFn) {\n        !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing.return = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4.return = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n        case ClassComponentLazy:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current$$1, workInProgress) {\n  !(current$$1 === null || workInProgress.child === current$$1.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nvar hydrationParentFiber = null;\nvar nextHydratableInstance = null;\nvar isHydrating = false;\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  var parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChild(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n        break;\n      case HostComponent:\n        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n        break;\n    }\n  }\n\n  var childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  childToDelete.effectTag = Deletion;\n\n  // This might seem like it belongs on progressedFirstDeletion. However,\n  // these children are not part of the reconciliation list of children.\n  // Even if we abort and rereconcile the children, that will try to hydrate\n  // again and the nodes are still in the host tree so these will be\n  // recreated.\n  if (returnFiber.lastEffect !== null) {\n    returnFiber.lastEffect.nextEffect = childToDelete;\n    returnFiber.lastEffect = childToDelete;\n  } else {\n    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.effectTag |= Placement;\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          var parentContainer = returnFiber.stateNode.containerInfo;\n          switch (fiber.tag) {\n            case HostComponent:\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              didNotFindHydratableContainerInstance(parentContainer, type, props);\n              break;\n            case HostText:\n              var text = fiber.pendingProps;\n              didNotFindHydratableContainerTextInstance(parentContainer, text);\n              break;\n          }\n          break;\n        }\n      case HostComponent:\n        {\n          var parentType = returnFiber.type;\n          var parentProps = returnFiber.memoizedProps;\n          var parentInstance = returnFiber.stateNode;\n          switch (fiber.tag) {\n            case HostComponent:\n              var _type = fiber.type;\n              var _props = fiber.pendingProps;\n              didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n              break;\n            case HostText:\n              var _text = fiber.pendingProps;\n              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n              break;\n          }\n          break;\n        }\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent:\n      {\n        var type = fiber.type;\n        var props = fiber.pendingProps;\n        var instance = canHydrateInstance(nextInstance, type, props);\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          return true;\n        }\n        return false;\n      }\n    case HostText:\n      {\n        var text = fiber.pendingProps;\n        var textInstance = canHydrateTextInstance(nextInstance, text);\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          return true;\n        }\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n  var nextInstance = nextHydratableInstance;\n  if (!nextInstance) {\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  var firstAttemptedInstance = nextInstance;\n  if (!tryHydrate(fiber, nextInstance)) {\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);\n  }\n  hydrationParentFiber = fiber;\n  nextHydratableInstance = getFirstHydratableChild(nextInstance);\n}\n\nfunction prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n  if (!supportsHydration) {\n    invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var instance = fiber.stateNode;\n  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n  // TODO: Type this specific to this type of component.\n  fiber.updateQueue = updatePayload;\n  // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n  if (updatePayload !== null) {\n    return true;\n  }\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var textInstance = fiber.stateNode;\n  var textContent = fiber.memoizedProps;\n  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n  {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      var returnFiber = hydrationParentFiber;\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot:\n            {\n              var parentContainer = returnFiber.stateNode.containerInfo;\n              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n              break;\n            }\n          case HostComponent:\n            {\n              var parentType = returnFiber.type;\n              var parentProps = returnFiber.memoizedProps;\n              var parentInstance = returnFiber.stateNode;\n              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n              break;\n            }\n        }\n      }\n    }\n  }\n  return shouldUpdate;\n}\n\nfunction popToNextHostParent(fiber) {\n  var parent = fiber.return;\n  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n    parent = parent.return;\n  }\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  var type = fiber.type;\n\n  // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them.\n  // TODO: Better heuristic.\n  if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n    var nextInstance = nextHydratableInstance;\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n  nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n  return true;\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nfunction readLazyComponentType(thenable) {\n  var status = thenable._reactStatus;\n  switch (status) {\n    case Resolved:\n      var Component = thenable._reactResult;\n      return Component;\n    case Rejected:\n      throw thenable._reactResult;\n    case Pending:\n      throw thenable;\n    default:\n      {\n        thenable._reactStatus = Pending;\n        thenable.then(function (resolvedValue) {\n          if (thenable._reactStatus === Pending) {\n            thenable._reactStatus = Resolved;\n            if (typeof resolvedValue === 'object' && resolvedValue !== null) {\n              // If the `default` property is not empty, assume it's the result\n              // of an async import() and use that. Otherwise, use the\n              // resolved value itself.\n              var defaultExport = resolvedValue.default;\n              resolvedValue = defaultExport !== undefined && defaultExport !== null ? defaultExport : resolvedValue;\n            } else {\n              resolvedValue = resolvedValue;\n            }\n            thenable._reactResult = resolvedValue;\n          }\n        }, function (error) {\n          if (thenable._reactStatus === Pending) {\n            thenable._reactStatus = Rejected;\n            thenable._reactResult = error;\n          }\n        });\n        throw thenable;\n      }\n  }\n}\n\nvar ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;\n\nvar didWarnAboutBadClass = void 0;\nvar didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\nvar didWarnAboutStatelessRefs = void 0;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n  didWarnAboutStatelessRefs = {};\n}\n\nfunction reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {\n  if (current$$1 === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);\n  }\n}\n\nfunction updateForwardRef(current$$1, workInProgress, type, nextProps, renderExpirationTime) {\n  var render = type.render;\n  var ref = workInProgress.ref;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (workInProgress.memoizedProps === nextProps) {\n    var currentRef = current$$1 !== null ? current$$1.ref : null;\n    if (ref === currentRef) {\n      return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n    }\n  }\n\n  var nextChildren = void 0;\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase('render');\n    nextChildren = render(nextProps, ref);\n    setCurrentPhase(null);\n  }\n\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateFragment(current$$1, workInProgress, renderExpirationTime) {\n  var nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateMode(current$$1, workInProgress, renderExpirationTime) {\n  var nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current$$1, workInProgress, renderExpirationTime) {\n  if (enableProfilerTimer) {\n    workInProgress.effectTag |= Update;\n  }\n  var nextProps = workInProgress.pendingProps;\n  var nextChildren = nextProps.children;\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction markRef(current$$1, workInProgress) {\n  var ref = workInProgress.ref;\n  if (current$$1 === null && ref !== null || current$$1 !== null && current$$1.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.effectTag |= Ref;\n  }\n}\n\nfunction updateFunctionalComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {\n  var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  var nextChildren = void 0;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase('render');\n    nextChildren = Component(nextProps, context);\n    setCurrentPhase(null);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  var hasContext = void 0;\n  if (isContextProvider(Component)) {\n    hasContext = true;\n    pushContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  var shouldUpdate = void 0;\n  if (current$$1 === null) {\n    if (workInProgress.stateNode === null) {\n      // In the initial pass we might need to construct the instance.\n      constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n      mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n      shouldUpdate = true;\n    } else {\n      // In a resume, we'll already have an instance we can reuse.\n      shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n    }\n  } else {\n    shouldUpdate = updateClassInstance(current$$1, workInProgress, Component, nextProps, renderExpirationTime);\n  }\n  return finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);\n}\n\nfunction finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current$$1, workInProgress);\n\n  var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n  }\n\n  var instance = workInProgress.stateNode;\n\n  // Rerender\n  ReactCurrentOwner$3.current = workInProgress;\n  var nextChildren = void 0;\n  if (didCaptureError && (!enableGetDerivedStateFromCatch || typeof Component.getDerivedStateFromCatch !== 'function')) {\n    // If we captured an error, but getDerivedStateFrom catch is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    {\n      setCurrentPhase('render');\n      nextChildren = instance.render();\n      if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n        instance.render();\n      }\n      setCurrentPhase(null);\n    }\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  if (current$$1 !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile twice: first to delete\n    // all the existing children.\n    reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);\n    workInProgress.child = null;\n    // Now we can continue reconciling like normal. This has the effect of\n    // remounting all children regardless of whether their their\n    // identity matches.\n  }\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  // Memoize props and state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n  memoizeState(workInProgress, instance.state);\n  memoizeProps(workInProgress, instance.props);\n\n  // The context might have changed so we need to recalculate it.\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  var root = workInProgress.stateNode;\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current$$1, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress);\n  var updateQueue = workInProgress.updateQueue;\n  !(updateQueue !== null) ? invariant(false, 'If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var nextProps = workInProgress.pendingProps;\n  var prevState = workInProgress.memoizedState;\n  var prevChildren = prevState !== null ? prevState.element : null;\n  processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);\n  var nextState = workInProgress.memoizedState;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  var nextChildren = nextState.element;\n  if (nextChildren === prevChildren) {\n    // If the state is the same as before, that's a bailout because we had\n    // no work that expires at this time.\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n  }\n  var root = workInProgress.stateNode;\n  if ((current$$1 === null || current$$1.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n\n    // This is a bit of a hack. We track the host root as a placement to\n    // know that we're currently in a mounting state. That way isMounted\n    // works as expected. We must reset this before committing.\n    // TODO: Delete this when we delete isMounted and findDOMNode.\n    workInProgress.effectTag |= Placement;\n\n    // Ensure that children mount into this root without tracking\n    // side-effects. This ensures that we don't store Placement effects on\n    // nodes that will be hydrated.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n  } else {\n    // Otherwise reset hydration state in case we aborted and resumed another\n    // root.\n    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n    resetHydrationState();\n  }\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current$$1, workInProgress, renderExpirationTime) {\n  pushHostContext(workInProgress);\n\n  if (current$$1 === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  var type = workInProgress.type;\n  var nextProps = workInProgress.pendingProps;\n  var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;\n\n  var nextChildren = nextProps.children;\n  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also have access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.effectTag |= ContentReset;\n  }\n\n  markRef(current$$1, workInProgress);\n\n  // Check the host config to see if the children are offscreen/hidden.\n  if (renderExpirationTime !== Never && workInProgress.mode & AsyncMode && shouldDeprioritizeSubtree(type, nextProps)) {\n    // Schedule this fiber to re-render at offscreen priority. Then bailout.\n    workInProgress.expirationTime = Never;\n    workInProgress.memoizedProps = nextProps;\n    return null;\n  }\n\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current$$1, workInProgress) {\n  if (current$$1 === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n  var nextProps = workInProgress.pendingProps;\n  memoizeProps(workInProgress, nextProps);\n  // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n  return null;\n}\n\nfunction resolveDefaultProps(Component, baseProps) {\n  if (Component && Component.defaultProps) {\n    // Resolve default props. Taken from ReactElement\n    var props = _assign({}, baseProps);\n    var defaultProps = Component.defaultProps;\n    for (var propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n    return props;\n  }\n  return baseProps;\n}\n\nfunction mountIndeterminateComponent(current$$1, workInProgress, Component, renderExpirationTime) {\n  !(current$$1 === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var props = workInProgress.pendingProps;\n  if (typeof Component === 'object' && Component !== null && typeof Component.then === 'function') {\n    Component = readLazyComponentType(Component);\n    var resolvedTag = workInProgress.tag = resolveLazyComponentTag(workInProgress, Component);\n    var resolvedProps = resolveDefaultProps(Component, props);\n    switch (resolvedTag) {\n      case FunctionalComponentLazy:\n        {\n          return updateFunctionalComponent(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);\n        }\n      case ClassComponentLazy:\n        {\n          return updateClassComponent(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);\n        }\n      case ForwardRefLazy:\n        {\n          return updateForwardRef(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);\n        }\n      default:\n        {\n          // This message intentionally doesn't metion ForwardRef because the\n          // fact that it's a separate type of work is an implementation detail.\n          invariant(false, 'Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.', Component);\n        }\n    }\n  }\n\n  var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  var value = void 0;\n\n  {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n      var componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        warningWithoutStack$1(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    ReactCurrentOwner$3.current = workInProgress;\n    value = Component(props, context);\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n\n  if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    // Proceed under the assumption that this is a class instance\n    workInProgress.tag = ClassComponent;\n\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = false;\n    if (isContextProvider(Component)) {\n      hasContext = true;\n      pushContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    if (typeof getDerivedStateFromProps === 'function') {\n      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);\n    }\n\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderExpirationTime);\n    return finishClassComponent(current$$1, workInProgress, Component, true, hasContext, renderExpirationTime);\n  } else {\n    // Proceed under the assumption that this is a functional component\n    workInProgress.tag = FunctionalComponent;\n    {\n      if (Component) {\n        !!Component.childContextTypes ? warningWithoutStack$1(false, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;\n      }\n      if (workInProgress.ref !== null) {\n        var info = '';\n        var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n        if (ownerName) {\n          info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n        }\n\n        var warningKey = ownerName || workInProgress._debugID || '';\n        var debugSource = workInProgress._debugSource;\n        if (debugSource) {\n          warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n        }\n        if (!didWarnAboutStatelessRefs[warningKey]) {\n          didWarnAboutStatelessRefs[warningKey] = true;\n          warning$1(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s', info);\n        }\n      }\n\n      if (typeof Component.getDerivedStateFromProps === 'function') {\n        var _componentName = getComponentName(Component) || 'Unknown';\n\n        if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {\n          warningWithoutStack$1(false, '%s: Stateless functional components do not support getDerivedStateFromProps.', _componentName);\n          didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName] = true;\n        }\n      }\n    }\n    reconcileChildren(current$$1, workInProgress, value, renderExpirationTime);\n    memoizeProps(workInProgress, props);\n    return workInProgress.child;\n  }\n}\n\nfunction updatePlaceholderComponent(current$$1, workInProgress, renderExpirationTime) {\n  if (enableSuspense) {\n    var nextProps = workInProgress.pendingProps;\n\n    // Check if we already attempted to render the normal state. If we did,\n    // and we timed out, render the placeholder state.\n    var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;\n\n    var nextDidTimeout = void 0;\n    if (current$$1 !== null && workInProgress.updateQueue !== null) {\n      // We're outside strict mode. Something inside this Placeholder boundary\n      // suspended during the last commit. Switch to the placholder.\n      workInProgress.updateQueue = null;\n      nextDidTimeout = true;\n      // If we're recovering from an error, reconcile twice: first to delete\n      // all the existing children.\n      reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);\n      current$$1.child = null;\n      // Now we can continue reconciling like normal. This has the effect of\n      // remounting all children regardless of whether their their\n      // identity matches.\n    } else {\n      nextDidTimeout = !alreadyCaptured;\n    }\n\n    if ((workInProgress.mode & StrictMode) !== NoEffect) {\n      if (nextDidTimeout) {\n        // If the timed-out view commits, schedule an update effect to record\n        // the committed time.\n        workInProgress.effectTag |= Update;\n      } else {\n        // The state node points to the time at which placeholder timed out.\n        // We can clear it once we switch back to the normal children.\n        workInProgress.stateNode = null;\n      }\n    }\n\n    // If the `children` prop is a function, treat it like a render prop.\n    // TODO: This is temporary until we finalize a lower level API.\n    var children = nextProps.children;\n    var nextChildren = void 0;\n    if (typeof children === 'function') {\n      nextChildren = children(nextDidTimeout);\n    } else {\n      nextChildren = nextDidTimeout ? nextProps.fallback : children;\n    }\n\n    workInProgress.memoizedProps = nextProps;\n    workInProgress.memoizedState = nextDidTimeout;\n    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n    return workInProgress.child;\n  } else {\n    return null;\n  }\n}\n\nfunction updatePortalComponent(current$$1, workInProgress, renderExpirationTime) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  var nextChildren = workInProgress.pendingProps;\n  if (current$$1 === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    memoizeProps(workInProgress, nextChildren);\n  } else {\n    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n    memoizeProps(workInProgress, nextChildren);\n  }\n  return workInProgress.child;\n}\n\nfunction updateContextProvider(current$$1, workInProgress, renderExpirationTime) {\n  var providerType = workInProgress.type;\n  var context = providerType._context;\n\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n\n  var newValue = newProps.value;\n  workInProgress.memoizedProps = newProps;\n\n  {\n    var providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider', getCurrentFiberStackInDev);\n    }\n  }\n\n  pushProvider(workInProgress, newValue);\n\n  if (oldProps !== null) {\n    var oldValue = oldProps.value;\n    var changedBits = calculateChangedBits(context, newValue, oldValue);\n    if (changedBits === 0) {\n      // No change. Bailout early if children are the same.\n      if (oldProps.children === newProps.children && !hasContextChanged()) {\n        return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n      }\n    } else {\n      // The context value changed. Search for matching consumers and schedule\n      // them to update.\n      propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n    }\n  }\n\n  var newChildren = newProps.children;\n  reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateContextConsumer(current$$1, workInProgress, renderExpirationTime) {\n  var context = workInProgress.type;\n  var newProps = workInProgress.pendingProps;\n  var render = newProps.children;\n\n  {\n    !(typeof render === 'function') ? warningWithoutStack$1(false, 'A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.') : void 0;\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  var newValue = readContext(context, newProps.unstable_observedBits);\n  var newChildren = void 0;\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase('render');\n    newChildren = render(newValue);\n    setCurrentPhase(null);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);\n  workInProgress.memoizedProps = newProps;\n  return workInProgress.child;\n}\n\n/*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\nfunction bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {\n  cancelWorkTimer(workInProgress);\n\n  if (current$$1 !== null) {\n    // Reuse previous context list\n    workInProgress.firstContextDependency = current$$1.firstContextDependency;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  // Check if the children have any pending work.\n  var childExpirationTime = workInProgress.childExpirationTime;\n  if (childExpirationTime === NoWork || childExpirationTime > renderExpirationTime) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    return null;\n  } else {\n    // This fiber doesn't have work, but its subtree does. Clone the child\n    // fibers and continue.\n    cloneChildFibers(current$$1, workInProgress);\n    return workInProgress.child;\n  }\n}\n\n// TODO: Delete memoizeProps/State and move to reconcile/bailout instead\nfunction memoizeProps(workInProgress, nextProps) {\n  workInProgress.memoizedProps = nextProps;\n}\n\nfunction memoizeState(workInProgress, nextState) {\n  workInProgress.memoizedState = nextState;\n  // Don't reset the updateQueue, in case there are pending updates. Resetting\n  // is handled by processUpdateQueue.\n}\n\nfunction beginWork(current$$1, workInProgress, renderExpirationTime) {\n  var updateExpirationTime = workInProgress.expirationTime;\n  if (!hasContextChanged() && (updateExpirationTime === NoWork || updateExpirationTime > renderExpirationTime)) {\n    // This fiber does not have any pending work. Bailout without entering\n    // the begin phase. There's still some bookkeeping we that needs to be done\n    // in this optimized path, mostly pushing stuff onto the stack.\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        resetHydrationState();\n        break;\n      case HostComponent:\n        pushHostContext(workInProgress);\n        break;\n      case ClassComponent:\n        {\n          var Component = workInProgress.type;\n          if (isContextProvider(Component)) {\n            pushContextProvider(workInProgress);\n          }\n          break;\n        }\n      case ClassComponentLazy:\n        {\n          var thenable = workInProgress.type;\n          var _Component = getResultFromResolvedThenable(thenable);\n          if (isContextProvider(_Component)) {\n            pushContextProvider(workInProgress);\n          }\n          break;\n        }\n      case HostPortal:\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        break;\n      case ContextProvider:\n        {\n          var newValue = workInProgress.memoizedProps.value;\n          pushProvider(workInProgress, newValue);\n          break;\n        }\n      case Profiler:\n        if (enableProfilerTimer) {\n          workInProgress.effectTag |= Update;\n        }\n        break;\n    }\n    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n  }\n\n  // Before entering the begin phase, clear the expiration time.\n  workInProgress.expirationTime = NoWork;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      {\n        var _Component3 = workInProgress.type;\n        return mountIndeterminateComponent(current$$1, workInProgress, _Component3, renderExpirationTime);\n      }\n    case FunctionalComponent:\n      {\n        var _Component4 = workInProgress.type;\n        var _unresolvedProps = workInProgress.pendingProps;\n        return updateFunctionalComponent(current$$1, workInProgress, _Component4, _unresolvedProps, renderExpirationTime);\n      }\n    case FunctionalComponentLazy:\n      {\n        var _thenable2 = workInProgress.type;\n        var _Component5 = getResultFromResolvedThenable(_thenable2);\n        var _unresolvedProps2 = workInProgress.pendingProps;\n        var _child = updateFunctionalComponent(current$$1, workInProgress, _Component5, resolveDefaultProps(_Component5, _unresolvedProps2), renderExpirationTime);\n        workInProgress.memoizedProps = _unresolvedProps2;\n        return _child;\n      }\n    case ClassComponent:\n      {\n        var _Component6 = workInProgress.type;\n        var _unresolvedProps3 = workInProgress.pendingProps;\n        return updateClassComponent(current$$1, workInProgress, _Component6, _unresolvedProps3, renderExpirationTime);\n      }\n    case ClassComponentLazy:\n      {\n        var _thenable3 = workInProgress.type;\n        var _Component7 = getResultFromResolvedThenable(_thenable3);\n        var _unresolvedProps4 = workInProgress.pendingProps;\n        var _child2 = updateClassComponent(current$$1, workInProgress, _Component7, resolveDefaultProps(_Component7, _unresolvedProps4), renderExpirationTime);\n        workInProgress.memoizedProps = _unresolvedProps4;\n        return _child2;\n      }\n    case HostRoot:\n      return updateHostRoot(current$$1, workInProgress, renderExpirationTime);\n    case HostComponent:\n      return updateHostComponent(current$$1, workInProgress, renderExpirationTime);\n    case HostText:\n      return updateHostText(current$$1, workInProgress);\n    case PlaceholderComponent:\n      return updatePlaceholderComponent(current$$1, workInProgress, renderExpirationTime);\n    case HostPortal:\n      return updatePortalComponent(current$$1, workInProgress, renderExpirationTime);\n    case ForwardRef:\n      {\n        var type = workInProgress.type;\n        return updateForwardRef(current$$1, workInProgress, type, workInProgress.pendingProps, renderExpirationTime);\n      }\n    case ForwardRefLazy:\n      var _thenable = workInProgress.type;\n      var _Component2 = getResultFromResolvedThenable(_thenable);\n      var unresolvedProps = workInProgress.pendingProps;\n      var child = updateForwardRef(current$$1, workInProgress, _Component2, resolveDefaultProps(_Component2, unresolvedProps), renderExpirationTime);\n      workInProgress.memoizedProps = unresolvedProps;\n      return child;\n    case Fragment:\n      return updateFragment(current$$1, workInProgress, renderExpirationTime);\n    case Mode:\n      return updateMode(current$$1, workInProgress, renderExpirationTime);\n    case Profiler:\n      return updateProfiler(current$$1, workInProgress, renderExpirationTime);\n    case ContextProvider:\n      return updateContextProvider(current$$1, workInProgress, renderExpirationTime);\n    case ContextConsumer:\n      return updateContextConsumer(current$$1, workInProgress, renderExpirationTime);\n    default:\n      invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.effectTag |= Update;\n}\n\nfunction markRef$1(workInProgress) {\n  workInProgress.effectTag |= Ref;\n}\n\nfunction appendAllChildren(parent, workInProgress) {\n  // We only have the top Fiber that was created but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = workInProgress.child;\n  while (node !== null) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      appendInitialChild(parent, node.stateNode);\n    } else if (node.tag === HostPortal) {\n      // If we have a portal child, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === workInProgress) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nvar updateHostContainer = void 0;\nvar updateHostComponent$1 = void 0;\nvar updateHostText$1 = void 0;\nif (supportsMutation) {\n  // Mutation mode\n\n  updateHostContainer = function (workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    var oldProps = current.memoizedProps;\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    }\n\n    // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n    var instance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\n  var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendChildToContainerChildSet(containerChildSet, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n  updateHostContainer = function (workInProgress) {\n    var portalOrRoot = workInProgress.stateNode;\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged) {\n      // No changes, just reuse the existing instance.\n    } else {\n      var container = portalOrRoot.containerInfo;\n      var newChildSet = createContainerChildSet(container);\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildrenToContainer(newChildSet, workInProgress);\n      portalOrRoot.pendingChildren = newChildSet;\n      // Schedule an update on the container to swap out the container.\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    var currentInstance = current.stateNode;\n    var oldProps = current.memoizedProps;\n    // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    var recyclableInstance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    var updatePayload = null;\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n    }\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n    if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n    workInProgress.stateNode = newInstance;\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress);\n    }\n  };\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      var rootContainerInstance = getRootHostContainer();\n      var currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n      // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n      markUpdate(workInProgress);\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function (workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // Noop\n  };\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    // Noop\n  };\n}\n\nfunction completeWork(current, workInProgress, renderExpirationTime) {\n  var newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case FunctionalComponent:\n    case FunctionalComponentLazy:\n      break;\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n        if (isContextProvider(Component)) {\n          popContext(workInProgress);\n        }\n        break;\n      }\n    case ClassComponentLazy:\n      {\n        var _Component = getResultFromResolvedThenable(workInProgress.type);\n        if (isContextProvider(_Component)) {\n          popContext(workInProgress);\n        }\n        break;\n      }\n    case HostRoot:\n      {\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        var fiberRoot = workInProgress.stateNode;\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          popHydrationState(workInProgress);\n          // This resets the hacky state to fix isMounted before committing.\n          // TODO: Delete this when we delete isMounted and findDOMNode.\n          workInProgress.effectTag &= ~Placement;\n        }\n        updateHostContainer(workInProgress);\n        break;\n      }\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        var rootContainerInstance = getRootHostContainer();\n        var type = workInProgress.type;\n        if (current !== null && workInProgress.stateNode != null) {\n          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);\n\n          if (current.ref !== workInProgress.ref) {\n            markRef$1(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            // This can happen when we abort work.\n            break;\n          }\n\n          var currentHostContext = getHostContext();\n          // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on we want to add then top->down or\n          // bottom->up. Top->down is faster in IE11.\n          var wasHydrated = popHydrationState(workInProgress);\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n              // If changes to the hydrated node needs to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n\n            appendAllChildren(instance, workInProgress);\n\n            // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n            workInProgress.stateNode = instance;\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef$1(workInProgress);\n          }\n        }\n        break;\n      }\n    case HostText:\n      {\n        var newText = newProps;\n        if (current && workInProgress.stateNode != null) {\n          var oldText = current.memoizedProps;\n          // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n          updateHostText$1(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            // This can happen when we abort work.\n          }\n          var _rootContainerInstance = getRootHostContainer();\n          var _currentHostContext = getHostContext();\n          var _wasHydrated = popHydrationState(workInProgress);\n          if (_wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\n          }\n        }\n        break;\n      }\n    case ForwardRef:\n    case ForwardRefLazy:\n      break;\n    case PlaceholderComponent:\n      break;\n    case Fragment:\n      break;\n    case Mode:\n      break;\n    case Profiler:\n      break;\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(workInProgress);\n      break;\n    case ContextProvider:\n      // Pop provider fiber\n      popProvider(workInProgress);\n      break;\n    case ContextConsumer:\n      break;\n    // Error cases\n    case IndeterminateComponent:\n      invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n    // eslint-disable-next-line no-fallthrough\n    default:\n      invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  return null;\n}\n\n// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(capturedError) {\n  return true;\n}\n\nfunction logCapturedError(capturedError) {\n  var logError = showErrorDialog(capturedError);\n\n  // Allow injected showErrorDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n    // Browsers support silencing uncaught errors by calling\n    // `preventDefault()` in window `error` handler.\n    // We record this information as an expando on the error.\n\n    if (error != null && error._suppressLogging) {\n      if (errorBoundaryFound && willRetry) {\n        // The error is recoverable and was silenced.\n        // Ignore it and don't print the stack addendum.\n        // This is handy for testing error boundaries without noise.\n        return;\n      }\n      // The error is fatal. Since the silencing might have\n      // been accidental, we'll surface it anyway.\n      // However, the browser would have silenced the original error\n      // so we'll print it first, and then print the stack addendum.\n      console.error(error);\n      // For a more detailed description of this block, see:\n      // https://github.com/facebook/react/pull/13384\n    }\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar emptyObject = {};\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nfunction logError(boundary, errorInfo) {\n  var source = errorInfo.source;\n  var stack = errorInfo.stack;\n  if (stack === null && source !== null) {\n    stack = getStackByFiberInDevAndProd(source);\n  }\n\n  var capturedError = {\n    componentName: source !== null ? getComponentName(source.type) : null,\n    componentStack: stack !== null ? stack : '',\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary.type);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nvar callComponentWillUnmountWithTimer = function (current$$1, instance) {\n  startPhaseTimer(current$$1, 'componentWillUnmount');\n  instance.props = current$$1.memoizedProps;\n  instance.state = current$$1.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n};\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current$$1, instance) {\n  {\n    invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current$$1, instance);\n    if (hasCaughtError()) {\n      var unmountError = clearCaughtError();\n      captureCommitPhaseError(current$$1, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current$$1) {\n  var ref = current$$1.ref;\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      {\n        invokeGuardedCallback(null, ref, null, null);\n        if (hasCaughtError()) {\n          var refError = clearCaughtError();\n          captureCommitPhaseError(current$$1, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(current$$1, finishedWork) {\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy:\n      {\n        if (finishedWork.effectTag & Snapshot) {\n          if (current$$1 !== null) {\n            var prevProps = current$$1.memoizedProps;\n            var prevState = current$$1.memoizedState;\n            startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');\n            var instance = finishedWork.stateNode;\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);\n            {\n              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n                warningWithoutStack$1(false, '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));\n              }\n            }\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n            stopPhaseTimer();\n          }\n        }\n        return;\n      }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n      // Nothing to do for these component types\n      return;\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitLifeCycles(finishedRoot, current$$1, finishedWork, committedExpirationTime) {\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy:\n      {\n        var instance = finishedWork.stateNode;\n        if (finishedWork.effectTag & Update) {\n          if (current$$1 === null) {\n            startPhaseTimer(finishedWork, 'componentDidMount');\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            instance.componentDidMount();\n            stopPhaseTimer();\n          } else {\n            var prevProps = current$$1.memoizedProps;\n            var prevState = current$$1.memoizedState;\n            startPhaseTimer(finishedWork, 'componentDidUpdate');\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n            stopPhaseTimer();\n          }\n        }\n        var updateQueue = finishedWork.updateQueue;\n        if (updateQueue !== null) {\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);\n        }\n        return;\n      }\n    case HostRoot:\n      {\n        var _updateQueue = finishedWork.updateQueue;\n        if (_updateQueue !== null) {\n          var _instance = null;\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                _instance = getPublicInstance(finishedWork.child.stateNode);\n                break;\n              case ClassComponent:\n              case ClassComponentLazy:\n                _instance = finishedWork.child.stateNode;\n                break;\n            }\n          }\n          commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);\n        }\n        return;\n      }\n    case HostComponent:\n      {\n        var _instance2 = finishedWork.stateNode;\n\n        // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n        if (current$$1 === null && finishedWork.effectTag & Update) {\n          var type = finishedWork.type;\n          var props = finishedWork.memoizedProps;\n          commitMount(_instance2, type, props, finishedWork);\n        }\n\n        return;\n      }\n    case HostText:\n      {\n        // We have no life-cycles associated with text.\n        return;\n      }\n    case HostPortal:\n      {\n        // We have no life-cycles associated with portals.\n        return;\n      }\n    case Profiler:\n      {\n        if (enableProfilerTimer) {\n          var onRender = finishedWork.memoizedProps.onRender;\n\n          if (enableSchedulerTracking) {\n            onRender(finishedWork.memoizedProps.id, current$$1 === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);\n          } else {\n            onRender(finishedWork.memoizedProps.id, current$$1 === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());\n          }\n        }\n        return;\n      }\n    case PlaceholderComponent:\n      {\n        if (enableSuspense) {\n          if ((finishedWork.mode & StrictMode) === NoEffect) {\n            // In loose mode, a placeholder times out by scheduling a synchronous\n            // update in the commit phase. Use `updateQueue` field to signal that\n            // the Timeout needs to switch to the placeholder. We don't need an\n            // entire queue. Any non-null value works.\n            // $FlowFixMe - Intentionally using a value other than an UpdateQueue.\n            finishedWork.updateQueue = emptyObject;\n            scheduleWork(finishedWork, Sync);\n          } else {\n            // In strict mode, the Update effect is used to record the time at\n            // which the placeholder timed out.\n            var currentTime = requestCurrentTime();\n            finishedWork.stateNode = { timedOutAt: currentTime };\n          }\n        }\n        return;\n      }\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  var ref = finishedWork.ref;\n  if (ref !== null) {\n    var instance = finishedWork.stateNode;\n    var instanceToUse = void 0;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    if (typeof ref === 'function') {\n      ref(instanceToUse);\n    } else {\n      {\n        if (!ref.hasOwnProperty('current')) {\n          warningWithoutStack$1(false, 'Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().%s', getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current$$1) {\n  var currentRef = current$$1.ref;\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\n// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(current$$1) {\n  onCommitUnmount(current$$1);\n\n  switch (current$$1.tag) {\n    case ClassComponent:\n    case ClassComponentLazy:\n      {\n        safelyDetachRef(current$$1);\n        var instance = current$$1.stateNode;\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(current$$1, instance);\n        }\n        return;\n      }\n    case HostComponent:\n      {\n        safelyDetachRef(current$$1);\n        return;\n      }\n    case HostPortal:\n      {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        if (supportsMutation) {\n          unmountHostComponents(current$$1);\n        } else if (supportsPersistence) {\n          emptyPortalContainer(current$$1);\n        }\n        return;\n      }\n  }\n}\n\nfunction commitNestedUnmounts(root) {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  var node = root;\n  while (true) {\n    commitUnmount(node);\n    // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n    if (node.child !== null && (\n    // If we use mutation we drill down into portals using commitUnmount above.\n    // If we don't use mutation we drill down into portals here instead.\n    !supportsMutation || node.tag !== HostPortal)) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === root) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current$$1) {\n  // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n  current$$1.return = null;\n  current$$1.child = null;\n  if (current$$1.alternate) {\n    current$$1.alternate.child = null;\n    current$$1.alternate.return = null;\n  }\n}\n\nfunction emptyPortalContainer(current$$1) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  var portal = current$$1.stateNode;\n  var containerInfo = portal.containerInfo;\n\n  var emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy:\n      {\n        return;\n      }\n    case HostComponent:\n      {\n        return;\n      }\n    case HostText:\n      {\n        return;\n      }\n    case HostRoot:\n    case HostPortal:\n      {\n        var portalOrRoot = finishedWork.stateNode;\n        var containerInfo = portalOrRoot.containerInfo,\n            _pendingChildren = portalOrRoot.pendingChildren;\n\n        replaceContainerChildren(containerInfo, _pendingChildren);\n        return;\n      }\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction getHostParentFiber(fiber) {\n  var parent = fiber.return;\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n    parent = parent.return;\n  }\n  invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n}\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  var node = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (node.tag !== HostComponent && node.tag !== HostText) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  // Recursively insert all host nodes into the parent.\n  var parentFiber = getHostParentFiber(finishedWork);\n\n  // Note: these two variables *must* always be updated together.\n  var parent = void 0;\n  var isContainer = void 0;\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentFiber.stateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    default:\n      invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n  }\n  if (parentFiber.effectTag & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    resetTextContent(parent);\n    // Clear ContentReset from the effect tag\n    parentFiber.effectTag &= ~ContentReset;\n  }\n\n  var before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = finishedWork;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      if (before) {\n        if (isContainer) {\n          insertInContainerBefore(parent, node.stateNode, before);\n        } else {\n          insertBefore(parent, node.stateNode, before);\n        }\n      } else {\n        if (isContainer) {\n          appendChildToContainer(parent, node.stateNode);\n        } else {\n          appendChild(parent, node.stateNode);\n        }\n      }\n    } else if (node.tag === HostPortal) {\n      // If the insertion itself is a portal, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === finishedWork) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction unmountHostComponents(current$$1) {\n  // We only have the top Fiber that was deleted but we need recurse down its\n  var node = current$$1;\n\n  // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n  var currentParentIsValid = false;\n\n  // Note: these two variables *must* always be updated together.\n  var currentParent = void 0;\n  var currentParentIsContainer = void 0;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      var parent = node.return;\n      findParent: while (true) {\n        !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parent.stateNode;\n            currentParentIsContainer = false;\n            break findParent;\n          case HostRoot:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case HostPortal:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n        }\n        parent = parent.return;\n      }\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(node);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, node.stateNode);\n      } else {\n        removeChild(currentParent, node.stateNode);\n      }\n      // Don't visit children because we already visited them.\n    } else if (node.tag === HostPortal) {\n      // When we go into a portal, it becomes the parent to remove from.\n      // We will reassign it back when we pop the portal on the way up.\n      currentParent = node.stateNode.containerInfo;\n      currentParentIsContainer = true;\n      // Visit children because portals might contain host components.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(node);\n      // Visit children because we may find more host components below.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    if (node === current$$1) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current$$1) {\n        return;\n      }\n      node = node.return;\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(current$$1) {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current$$1);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(current$$1);\n  }\n  detachFiber(current$$1);\n}\n\nfunction commitWork(current$$1, finishedWork) {\n  if (!supportsMutation) {\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy:\n      {\n        return;\n      }\n    case HostComponent:\n      {\n        var instance = finishedWork.stateNode;\n        if (instance != null) {\n          // Commit the work prepared earlier.\n          var newProps = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldProps = current$$1 !== null ? current$$1.memoizedProps : newProps;\n          var type = finishedWork.type;\n          // TODO: Type the updateQueue to be specific to host components.\n          var updatePayload = finishedWork.updateQueue;\n          finishedWork.updateQueue = null;\n          if (updatePayload !== null) {\n            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n          }\n        }\n        return;\n      }\n    case HostText:\n      {\n        !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var textInstance = finishedWork.stateNode;\n        var newText = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n    case HostRoot:\n      {\n        return;\n      }\n    case Profiler:\n      {\n        return;\n      }\n    case PlaceholderComponent:\n      {\n        return;\n      }\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitResetTextContent(current$$1) {\n  if (!supportsMutation) {\n    return;\n  }\n  resetTextContent(current$$1.stateNode);\n}\n\nfunction NoopComponent() {\n  return null;\n}\n\nfunction createRootErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  // Unmount the root by rendering null.\n  update.tag = CaptureUpdate;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: null };\n  var error = errorInfo.value;\n  update.callback = function () {\n    onUncaughtError(error);\n    logError(fiber, errorInfo);\n  };\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  update.tag = CaptureUpdate;\n  var getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;\n  if (enableGetDerivedStateFromCatch && typeof getDerivedStateFromCatch === 'function') {\n    var error = errorInfo.value;\n    update.payload = function () {\n      return getDerivedStateFromCatch(error);\n    };\n  }\n\n  var inst = fiber.stateNode;\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (!enableGetDerivedStateFromCatch || getDerivedStateFromCatch !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromCatch is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n      var error = errorInfo.value;\n      var stack = errorInfo.stack;\n      logError(fiber, errorInfo);\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : ''\n      });\n    };\n  }\n  return update;\n}\n\nfunction throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {\n  // The source fiber did not complete.\n  sourceFiber.effectTag |= Incomplete;\n  // Its effect list is no longer valid.\n  sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n  if (enableSuspense && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n    // This is a thenable.\n    var thenable = value;\n\n    // Find the earliest timeout threshold of all the placeholders in the\n    // ancestor path. We could avoid this traversal by storing the thresholds on\n    // the stack, but we choose not to because we only hit this path if we're\n    // IO-bound (i.e. if something suspends). Whereas the stack is used even in\n    // the non-IO- bound case.\n    var _workInProgress = returnFiber;\n    var earliestTimeoutMs = -1;\n    var startTimeMs = -1;\n    do {\n      if (_workInProgress.tag === PlaceholderComponent) {\n        var current = _workInProgress.alternate;\n        if (current !== null && current.memoizedState === true && current.stateNode !== null) {\n          // Reached a placeholder that already timed out. Each timed out\n          // placeholder acts as the root of a new suspense boundary.\n\n          // Use the time at which the placeholder timed out as the start time\n          // for the current render.\n          var timedOutAt = current.stateNode.timedOutAt;\n          startTimeMs = expirationTimeToMs(timedOutAt);\n\n          // Do not search any further.\n          break;\n        }\n        var timeoutPropMs = _workInProgress.pendingProps.delayMs;\n        if (typeof timeoutPropMs === 'number') {\n          if (timeoutPropMs <= 0) {\n            earliestTimeoutMs = 0;\n          } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {\n            earliestTimeoutMs = timeoutPropMs;\n          }\n        }\n      }\n      _workInProgress = _workInProgress.return;\n    } while (_workInProgress !== null);\n\n    // Schedule the nearest Placeholder to re-render the timed out view.\n    _workInProgress = returnFiber;\n    do {\n      if (_workInProgress.tag === PlaceholderComponent) {\n        var didTimeout = _workInProgress.memoizedState;\n        if (!didTimeout) {\n          // Found the nearest boundary.\n\n          // If the boundary is not in async mode, we should not suspend, and\n          // likewise, when the promise resolves, we should ping synchronously.\n          var pingTime = (_workInProgress.mode & AsyncMode) === NoEffect ? Sync : renderExpirationTime;\n\n          // Attach a listener to the promise to \"ping\" the root and retry.\n          var onResolveOrReject = retrySuspendedRoot.bind(null, root, _workInProgress, pingTime);\n          thenable.then(onResolveOrReject, onResolveOrReject);\n\n          // If the boundary is outside of strict mode, we should *not* suspend\n          // the commit. Pretend as if the suspended component rendered null and\n          // keep rendering. In the commit phase, we'll schedule a subsequent\n          // synchronous update to re-render the Placeholder.\n          //\n          // Note: It doesn't matter whether the component that suspended was\n          // inside a strict mode tree. If the Placeholder is outside of it, we\n          // should *not* suspend the commit.\n          if ((_workInProgress.mode & StrictMode) === NoEffect) {\n            _workInProgress.effectTag |= Update;\n\n            // Unmount the source fiber's children\n            var nextChildren = null;\n            reconcileChildren(sourceFiber.alternate, sourceFiber, nextChildren, renderExpirationTime);\n            sourceFiber.effectTag &= ~Incomplete;\n            if (sourceFiber.tag === IndeterminateComponent) {\n              // Let's just assume it's a functional component. This fiber will\n              // be unmounted in the immediate next commit, anyway.\n              sourceFiber.tag = FunctionalComponent;\n            }\n\n            if (sourceFiber.tag === ClassComponent || sourceFiber.tag === ClassComponentLazy) {\n              // We're going to commit this fiber even though it didn't\n              // complete. But we shouldn't call any lifecycle methods or\n              // callbacks. Remove all lifecycle effect tags.\n              sourceFiber.effectTag &= ~LifecycleEffectMask;\n              if (sourceFiber.alternate === null) {\n                // We're about to mount a class component that doesn't have an\n                // instance. Turn this into a dummy functional component instead,\n                // to prevent type errors. This is a bit weird but it's an edge\n                // case and we're about to synchronously delete this\n                // component, anyway.\n                sourceFiber.tag = FunctionalComponent;\n                sourceFiber.type = NoopComponent;\n              }\n            }\n\n            // Exit without suspending.\n            return;\n          }\n\n          // Confirmed that the boundary is in a strict mode tree. Continue with\n          // the normal suspend path.\n\n          var absoluteTimeoutMs = void 0;\n          if (earliestTimeoutMs === -1) {\n            // If no explicit threshold is given, default to an abitrarily large\n            // value. The actual size doesn't matter because the threshold for the\n            // whole tree will be clamped to the expiration time.\n            absoluteTimeoutMs = maxSigned31BitInt;\n          } else {\n            if (startTimeMs === -1) {\n              // This suspend happened outside of any already timed-out\n              // placeholders. We don't know exactly when the update was scheduled,\n              // but we can infer an approximate start time from the expiration\n              // time. First, find the earliest uncommitted expiration time in the\n              // tree, including work that is suspended. Then subtract the offset\n              // used to compute an async update's expiration time. This will cause\n              // high priority (interactive) work to expire earlier than necessary,\n              // but we can account for this by adjusting for the Just Noticeable\n              // Difference.\n              var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, renderExpirationTime);\n              var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);\n              startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n            }\n            absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;\n          }\n\n          // Mark the earliest timeout in the suspended fiber's ancestor path.\n          // After completing the root, we'll take the largest of all the\n          // suspended fiber's timeouts and use it to compute a timeout for the\n          // whole tree.\n          renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);\n\n          _workInProgress.effectTag |= ShouldCapture;\n          _workInProgress.expirationTime = renderExpirationTime;\n          return;\n        }\n        // This boundary already captured during this render. Continue to the\n        // next boundary.\n      }\n      _workInProgress = _workInProgress.return;\n    } while (_workInProgress !== null);\n    // No boundary was found. Fallthrough to error mode.\n    value = new Error('An update was suspended, but no placeholder UI was provided.');\n  }\n\n  // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n  renderDidError();\n  value = createCapturedValue(value, sourceFiber);\n  var workInProgress = returnFiber;\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot:\n        {\n          var _errorInfo = value;\n          workInProgress.effectTag |= ShouldCapture;\n          workInProgress.expirationTime = renderExpirationTime;\n          var update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n      case ClassComponent:\n      case ClassComponentLazy:\n        // Capture and retry\n        var errorInfo = value;\n        var ctor = workInProgress.type;\n        var instance = workInProgress.stateNode;\n        if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromCatch === 'function' && enableGetDerivedStateFromCatch || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n          workInProgress.effectTag |= ShouldCapture;\n          workInProgress.expirationTime = renderExpirationTime;\n          // Schedule the error boundary to re-render using updated state\n          var _update = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);\n          enqueueCapturedUpdate(workInProgress, _update);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nfunction unwindWork(workInProgress, renderExpirationTime) {\n  switch (workInProgress.tag) {\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n        if (isContextProvider(Component)) {\n          popContext(workInProgress);\n        }\n        var effectTag = workInProgress.effectTag;\n        if (effectTag & ShouldCapture) {\n          workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n    case ClassComponentLazy:\n      {\n        var _Component = workInProgress.type._reactResult;\n        if (isContextProvider(_Component)) {\n          popContext(workInProgress);\n        }\n        var _effectTag = workInProgress.effectTag;\n        if (_effectTag & ShouldCapture) {\n          workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n    case HostRoot:\n      {\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        var _effectTag2 = workInProgress.effectTag;\n        !((_effectTag2 & DidCapture) === NoEffect) ? invariant(false, 'The root failed to unmount after an error. This is likely a bug in React. Please file an issue.') : void 0;\n        workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;\n        return workInProgress;\n      }\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        return null;\n      }\n    case PlaceholderComponent:\n      {\n        var _effectTag3 = workInProgress.effectTag;\n        if (_effectTag3 & ShouldCapture) {\n          workInProgress.effectTag = _effectTag3 & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      popProvider(workInProgress);\n      return null;\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(interruptedWork) {\n  switch (interruptedWork.tag) {\n    case ClassComponent:\n      {\n        var childContextTypes = interruptedWork.type.childContextTypes;\n        if (childContextTypes !== null && childContextTypes !== undefined) {\n          popContext(interruptedWork);\n        }\n        break;\n      }\n    case ClassComponentLazy:\n      {\n        var _childContextTypes = interruptedWork.type._reactResult.childContextTypes;\n        if (_childContextTypes !== null && _childContextTypes !== undefined) {\n          popContext(interruptedWork);\n        }\n        break;\n      }\n    case HostRoot:\n      {\n        popHostContainer(interruptedWork);\n        popTopLevelContextObject(interruptedWork);\n        break;\n      }\n    case HostComponent:\n      {\n        popHostContext(interruptedWork);\n        break;\n      }\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n    case ContextProvider:\n      popProvider(interruptedWork);\n      break;\n    default:\n      break;\n  }\n}\n\nvar Dispatcher = {\n  readContext: readContext\n};\n\nvar ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;\n\n\nvar didWarnAboutStateTransition = void 0;\nvar didWarnSetStateChildContext = void 0;\nvar warnAboutUpdateOnUnmounted = void 0;\nvar warnAboutInvalidUpdates = void 0;\n\nif (enableSchedulerTracking) {\n  // Provide explicit error message when production+profiling bundle of e.g. react-dom\n  // is used with production (non-profiling) bundle of schedule/tracking\n  !(tracking.__interactionsRef != null && tracking.__interactionsRef.current != null) ? invariant(false, 'It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `schedule/tracking` module with `schedule/tracking-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling') : void 0;\n}\n\n{\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function (fiber) {\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    var componentName = getComponentName(fiber.type) || 'ReactClass';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warningWithoutStack$1(false, \"Can't call setState (or forceUpdate) on an unmounted component. This \" + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in the ' + 'componentWillUnmount method.%s', getStackByFiberInDevAndProd(fiber));\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function (instance) {\n    switch (phase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warningWithoutStack$1(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warningWithoutStack$1(false, 'Cannot update during an existing state transition (such as within ' + '`render`). Render methods should be a pure function of props and state.');\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\n// Used to ensure computeUniqueAsyncExpiration is monotonically increasing.\nvar lastUniqueAsyncExpiration = 0;\n\n// Represents the expiration time that incoming updates should use. (If this\n// is NoWork, use the default strategy: async updates in async mode, sync\n// updates in sync mode.)\nvar expirationContext = NoWork;\n\nvar isWorking = false;\n\n// The next work in progress fiber that we're currently working on.\nvar nextUnitOfWork = null;\nvar nextRoot = null;\n// The time at which we're currently rendering work.\nvar nextRenderExpirationTime = NoWork;\nvar nextLatestAbsoluteTimeoutMs = -1;\nvar nextRenderDidError = false;\n\n// The next fiber with an effect that we're currently committing.\nvar nextEffect = null;\n\nvar isCommitting$1 = false;\n\nvar legacyErrorBoundariesThatAlreadyFailed = null;\n\n// Used for performance tracking.\nvar interruptedBy = null;\n\n// Do not decrement interaction counts in the event of suspense timeouts.\n// This would lead to prematurely calling the interaction-complete hook.\nvar suspenseDidTimeout = false;\n\nvar stashedWorkInProgressProperties = void 0;\nvar replayUnitOfWork = void 0;\nvar isReplayingFailedUnitOfWork = void 0;\nvar originalReplayError = void 0;\nvar rethrowOriginalError = void 0;\nif (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  stashedWorkInProgressProperties = null;\n  isReplayingFailedUnitOfWork = false;\n  originalReplayError = null;\n  replayUnitOfWork = function (failedUnitOfWork, thrownValue, isYieldy) {\n    if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {\n      // Don't replay promises. Treat everything else like an error.\n      // TODO: Need to figure out a different strategy if/when we add\n      // support for catching other types.\n      return;\n    }\n\n    // Restore the original state of the work-in-progress\n    if (stashedWorkInProgressProperties === null) {\n      // This should never happen. Don't throw because this code is DEV-only.\n      warningWithoutStack$1(false, 'Could not replay rendering after an error. This is likely a bug in React. ' + 'Please file an issue.');\n      return;\n    }\n    assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);\n\n    switch (failedUnitOfWork.tag) {\n      case HostRoot:\n        popHostContainer(failedUnitOfWork);\n        popTopLevelContextObject(failedUnitOfWork);\n        break;\n      case HostComponent:\n        popHostContext(failedUnitOfWork);\n        break;\n      case ClassComponent:\n        {\n          var Component = failedUnitOfWork.type;\n          if (isContextProvider(Component)) {\n            popContext(failedUnitOfWork);\n          }\n          break;\n        }\n      case ClassComponentLazy:\n        {\n          var _Component = getResultFromResolvedThenable(failedUnitOfWork.type);\n          if (isContextProvider(_Component)) {\n            popContext(failedUnitOfWork);\n          }\n          break;\n        }\n      case HostPortal:\n        popHostContainer(failedUnitOfWork);\n        break;\n      case ContextProvider:\n        popProvider(failedUnitOfWork);\n        break;\n    }\n    // Replay the begin phase.\n    isReplayingFailedUnitOfWork = true;\n    originalReplayError = thrownValue;\n    invokeGuardedCallback(null, workLoop, null, isYieldy);\n    isReplayingFailedUnitOfWork = false;\n    originalReplayError = null;\n    if (hasCaughtError()) {\n      var replayError = clearCaughtError();\n      if (replayError != null && thrownValue != null) {\n        try {\n          // Reading the expando property is intentionally\n          // inside `try` because it might be a getter or Proxy.\n          if (replayError._suppressLogging) {\n            // Also suppress logging for the original error.\n            thrownValue._suppressLogging = true;\n          }\n        } catch (inner) {\n          // Ignore.\n        }\n      }\n    } else {\n      // If the begin phase did not fail the second time, set this pointer\n      // back to the original value.\n      nextUnitOfWork = failedUnitOfWork;\n    }\n  };\n  rethrowOriginalError = function () {\n    throw originalReplayError;\n  };\n}\n\nfunction resetStack() {\n  if (nextUnitOfWork !== null) {\n    var interruptedWork = nextUnitOfWork.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    checkThatStackIsEmpty();\n  }\n\n  nextRoot = null;\n  nextRenderExpirationTime = NoWork;\n  nextLatestAbsoluteTimeoutMs = -1;\n  nextRenderDidError = false;\n  nextUnitOfWork = null;\n}\n\nfunction commitAllHostEffects() {\n  while (nextEffect !== null) {\n    {\n      setCurrentFiber(nextEffect);\n    }\n    recordEffect();\n\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      var current$$1 = nextEffect.alternate;\n      if (current$$1 !== null) {\n        commitDetachRef(current$$1);\n      }\n    }\n\n    // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every\n    // possible bitmap value, we remove the secondary effects from the\n    // effect tag and switch on that value.\n    var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n    switch (primaryEffectTag) {\n      case Placement:\n        {\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          // TODO: findDOMNode doesn't rely on this any more but isMounted\n          // does and isMounted is deprecated anyway so we should be able\n          // to kill this.\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n      case PlacementAndUpdate:\n        {\n          // Placement\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          nextEffect.effectTag &= ~Placement;\n\n          // Update\n          var _current = nextEffect.alternate;\n          commitWork(_current, nextEffect);\n          break;\n        }\n      case Update:\n        {\n          var _current2 = nextEffect.alternate;\n          commitWork(_current2, nextEffect);\n          break;\n        }\n      case Deletion:\n        {\n          commitDeletion(nextEffect);\n          break;\n        }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitBeforeMutationLifecycles() {\n  while (nextEffect !== null) {\n    {\n      setCurrentFiber(nextEffect);\n    }\n\n    var effectTag = nextEffect.effectTag;\n    if (effectTag & Snapshot) {\n      recordEffect();\n      var current$$1 = nextEffect.alternate;\n      commitBeforeMutationLifeCycles(current$$1, nextEffect);\n    }\n\n    // Don't cleanup effects yet;\n    // This will be done by commitAllLifeCycles()\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitAllLifeCycles(finishedRoot, committedExpirationTime) {\n  {\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n    }\n\n    if (warnAboutLegacyContextAPI) {\n      ReactStrictModeWarnings.flushLegacyContextWarning();\n    }\n  }\n  while (nextEffect !== null) {\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      var current$$1 = nextEffect.alternate;\n      commitLifeCycles(finishedRoot, current$$1, nextEffect, committedExpirationTime);\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    var next = nextEffect.nextEffect;\n    // Ensure that we clean these up so that we don't accidentally keep them.\n    // I'm not actually sure this matters because we can't reset firstEffect\n    // and lastEffect since they're on every node, not just the effectful\n    // ones. So we have to clean everything as we reuse nodes anyway.\n    nextEffect.nextEffect = null;\n    // Ensure that we reset the effectTag here so that we can rely on effect\n    // tags to reason about the current life-cycle.\n    nextEffect = next;\n  }\n}\n\nfunction isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\n\nfunction markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction commitRoot(root, finishedWork) {\n  isWorking = true;\n  isCommitting$1 = true;\n  startCommitTimer();\n\n  !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var committedExpirationTime = root.pendingCommitExpirationTime;\n  !(committedExpirationTime !== NoWork) ? invariant(false, 'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  root.pendingCommitExpirationTime = NoWork;\n\n  // Update the pending priority levels to account for the work that we are\n  // about to commit. This needs to happen before calling the lifecycles, since\n  // they may schedule additional updates.\n  var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;\n  var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;\n  var earliestRemainingTimeBeforeCommit = updateExpirationTimeBeforeCommit === NoWork || childExpirationTimeBeforeCommit !== NoWork && childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;\n  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);\n\n  var prevInteractions = null;\n  var committedInteractions = enableSchedulerTracking ? [] : null;\n  if (enableSchedulerTracking) {\n    // Restore any pending interactions at this point,\n    // So that cascading work triggered during the render phase will be accounted for.\n    prevInteractions = tracking.__interactionsRef.current;\n    tracking.__interactionsRef.current = root.memoizedInteractions;\n\n    // We are potentially finished with the current batch of interactions.\n    // So we should clear them out of the pending interaction map.\n    // We do this at the start of commit in case cascading work is scheduled by commit phase lifecycles.\n    // In that event, interaction data may be added back into the pending map for a future commit.\n    // We also store the interactions we are about to commit so that we can notify subscribers after we're done.\n    // These are stored as an Array rather than a Set,\n    // Because the same interaction may be pending for multiple expiration times,\n    // In which case it's important that we decrement the count the right number of times after finishing.\n    root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {\n      if (scheduledExpirationTime <= committedExpirationTime) {\n        committedInteractions.push.apply(committedInteractions, Array.from(scheduledInteractions));\n        root.pendingInteractionMap.delete(scheduledExpirationTime);\n      }\n    });\n  }\n\n  // Reset this to null before calling lifecycles\n  ReactCurrentOwner$2.current = null;\n\n  var firstEffect = void 0;\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if\n    // it had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  prepareForCommit(root.containerInfo);\n\n  // Invoke instances of getSnapshotBeforeUpdate before mutation.\n  nextEffect = firstEffect;\n  startCommitSnapshotEffectsTimer();\n  while (nextEffect !== null) {\n    var didError = false;\n    var error = void 0;\n    {\n      invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n    if (didError) {\n      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      captureCommitPhaseError(nextEffect, error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitSnapshotEffectsTimer();\n\n  if (enableProfilerTimer) {\n    // Mark the current commit time to be shared by all Profilers in this batch.\n    // This enables them to be grouped later.\n    recordCommitTime();\n  }\n\n  // Commit all the side-effects within a tree. We'll do this in two passes.\n  // The first pass performs all the host insertions, updates, deletions and\n  // ref unmounts.\n  nextEffect = firstEffect;\n  startCommitHostEffectsTimer();\n  while (nextEffect !== null) {\n    var _didError = false;\n    var _error = void 0;\n    {\n      invokeGuardedCallback(null, commitAllHostEffects, null);\n      if (hasCaughtError()) {\n        _didError = true;\n        _error = clearCaughtError();\n      }\n    }\n    if (_didError) {\n      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      captureCommitPhaseError(nextEffect, _error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitHostEffectsTimer();\n\n  resetAfterCommit(root.containerInfo);\n\n  // The work-in-progress tree is now the current tree. This must come after\n  // the first pass of the commit phase, so that the previous tree is still\n  // current during componentWillUnmount, but before the second pass, so that\n  // the finished work is current during componentDidMount/Update.\n  root.current = finishedWork;\n\n  // In the second pass we'll perform all life-cycles and ref callbacks.\n  // Life-cycles happen as a separate pass so that all placements, updates,\n  // and deletions in the entire tree have already been invoked.\n  // This pass also triggers any renderer-specific initial effects.\n  nextEffect = firstEffect;\n  startCommitLifeCyclesTimer();\n  while (nextEffect !== null) {\n    var _didError2 = false;\n    var _error2 = void 0;\n    {\n      invokeGuardedCallback(null, commitAllLifeCycles, null, root, committedExpirationTime);\n      if (hasCaughtError()) {\n        _didError2 = true;\n        _error2 = clearCaughtError();\n      }\n    }\n    if (_didError2) {\n      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      captureCommitPhaseError(nextEffect, _error2);\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n\n  isCommitting$1 = false;\n  isWorking = false;\n  stopCommitLifeCyclesTimer();\n  stopCommitTimer();\n  onCommitRoot(finishedWork.stateNode);\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n  }\n\n  var updateExpirationTimeAfterCommit = finishedWork.expirationTime;\n  var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;\n  var earliestRemainingTimeAfterCommit = updateExpirationTimeAfterCommit === NoWork || childExpirationTimeAfterCommit !== NoWork && childExpirationTimeAfterCommit < updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;\n  if (earliestRemainingTimeAfterCommit === NoWork) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n  onCommit(root, earliestRemainingTimeAfterCommit);\n\n  if (enableSchedulerTracking) {\n    tracking.__interactionsRef.current = prevInteractions;\n\n    var subscriber = void 0;\n\n    try {\n      subscriber = tracking.__subscriberRef.current;\n      if (subscriber !== null && root.memoizedInteractions.size > 0) {\n        var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);\n        subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n      }\n    } catch (error) {\n      // It's not safe for commitRoot() to throw.\n      // Store the error for now and we'll re-throw in finishRendering().\n      if (!hasUnhandledError) {\n        hasUnhandledError = true;\n        unhandledError = error;\n      }\n    } finally {\n      // Don't update interaction counts if we're frozen due to suspense.\n      // In this case, we can skip the completed-work check entirely.\n      if (!suspenseDidTimeout) {\n        // Now that we're done, check the completed batch of interactions.\n        // If no more work is outstanding for a given interaction,\n        // We need to notify the subscribers that it's finished.\n        committedInteractions.forEach(function (interaction) {\n          interaction.__count--;\n          if (subscriber !== null && interaction.__count === 0) {\n            try {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            } catch (error) {\n              // It's not safe for commitRoot() to throw.\n              // Store the error for now and we'll re-throw in finishRendering().\n              if (!hasUnhandledError) {\n                hasUnhandledError = true;\n                unhandledError = error;\n              }\n            }\n          }\n        });\n      }\n    }\n  }\n}\n\nfunction resetChildExpirationTime(workInProgress, renderTime) {\n  if (renderTime !== Never && workInProgress.childExpirationTime === Never) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  var newChildExpirationTime = NoWork;\n\n  // Bubble up the earliest expiration time.\n  if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n    // We're in profiling mode.\n    // Let's use this same traversal to update the render durations.\n    var actualDuration = workInProgress.actualDuration;\n    var treeBaseDuration = workInProgress.selfBaseDuration;\n\n    // When a fiber is cloned, its actualDuration is reset to 0.\n    // This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration.\n    // If the fiber has not been cloned though, (meaning no work was done),\n    // Then this value will reflect the amount of time spent working on a previous render.\n    // In that case it should not bubble.\n    // We determine whether it was cloned by comparing the child pointer.\n    var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;\n\n    var child = workInProgress.child;\n    while (child !== null) {\n      var childUpdateExpirationTime = child.expirationTime;\n      var childChildExpirationTime = child.childExpirationTime;\n      if (newChildExpirationTime === NoWork || childUpdateExpirationTime !== NoWork && childUpdateExpirationTime < newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (newChildExpirationTime === NoWork || childChildExpirationTime !== NoWork && childChildExpirationTime < newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n    workInProgress.actualDuration = actualDuration;\n    workInProgress.treeBaseDuration = treeBaseDuration;\n  } else {\n    var _child = workInProgress.child;\n    while (_child !== null) {\n      var _childUpdateExpirationTime = _child.expirationTime;\n      var _childChildExpirationTime = _child.childExpirationTime;\n      if (newChildExpirationTime === NoWork || _childUpdateExpirationTime !== NoWork && _childUpdateExpirationTime < newChildExpirationTime) {\n        newChildExpirationTime = _childUpdateExpirationTime;\n      }\n      if (newChildExpirationTime === NoWork || _childChildExpirationTime !== NoWork && _childChildExpirationTime < newChildExpirationTime) {\n        newChildExpirationTime = _childChildExpirationTime;\n      }\n      _child = _child.sibling;\n    }\n  }\n\n  workInProgress.childExpirationTime = newChildExpirationTime;\n}\n\nfunction completeUnitOfWork(workInProgress) {\n  // Attempt to complete the current unit of work, then move to the\n  // next sibling. If there are no more siblings, return to the\n  // parent fiber.\n  while (true) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current$$1 = workInProgress.alternate;\n    {\n      setCurrentFiber(workInProgress);\n    }\n\n    var returnFiber = workInProgress.return;\n    var siblingFiber = workInProgress.sibling;\n\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      // This fiber completed.\n      if (enableProfilerTimer) {\n        if (workInProgress.mode & ProfileMode) {\n          startProfilerTimer(workInProgress);\n        }\n\n        nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);\n\n        if (workInProgress.mode & ProfileMode) {\n          // Update render duration assuming we didn't error.\n          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n        }\n      } else {\n        nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);\n      }\n      var next = nextUnitOfWork;\n      stopWorkTimer(workInProgress);\n      resetChildExpirationTime(workInProgress, nextRenderExpirationTime);\n      {\n        resetCurrentFiber();\n      }\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null &&\n      // Do not append effects to parents if a sibling failed to complete\n      (returnFiber.effectTag & Incomplete) === NoEffect) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        return null;\n      }\n    } else {\n      if (workInProgress.mode & ProfileMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      var _next = unwindWork(workInProgress, nextRenderExpirationTime);\n      // Because this fiber did not complete, don't reset its expiration time.\n      if (workInProgress.effectTag & DidCapture) {\n        // Restarting an error boundary\n        stopFailedWorkTimer(workInProgress);\n      } else {\n        stopWorkTimer(workInProgress);\n      }\n\n      {\n        resetCurrentFiber();\n      }\n\n      if (_next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (enableProfilerTimer) {\n          // Include the time spent working on failed children before continuing.\n          if (_next.mode & ProfileMode) {\n            var actualDuration = _next.actualDuration;\n            var child = _next.child;\n            while (child !== null) {\n              actualDuration += child.actualDuration;\n              child = child.sibling;\n            }\n            _next.actualDuration = actualDuration;\n          }\n        }\n\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        _next.effectTag &= HostEffectMask;\n        return _next;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  // Without this explicit null return Flow complains of invalid return type\n  // TODO Remove the above while(true) loop\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction performUnitOfWork(workInProgress) {\n  // The current, flushed, state of this fiber is the alternate.\n  // Ideally nothing should rely on this, but relying on it here\n  // means that we don't need an additional field on the work in\n  // progress.\n  var current$$1 = workInProgress.alternate;\n\n  // See if beginning this work spawns more work.\n  startWorkTimer(workInProgress);\n  {\n    setCurrentFiber(workInProgress);\n  }\n\n  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);\n  }\n\n  var next = void 0;\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      startProfilerTimer(workInProgress);\n    }\n\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n\n    if (workInProgress.mode & ProfileMode) {\n      // Record the render duration assuming we didn't bailout (or error).\n      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);\n    }\n  } else {\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n  }\n\n  {\n    resetCurrentFiber();\n    if (isReplayingFailedUnitOfWork) {\n      // Currently replaying a failed unit of work. This should be unreachable,\n      // because the render phase is meant to be idempotent, and it should\n      // have thrown again. Since it didn't, rethrow the original error, so\n      // React's internal stack is not misaligned.\n      rethrowOriginalError();\n    }\n  }\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n  }\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(workInProgress);\n  }\n\n  ReactCurrentOwner$2.current = null;\n\n  return next;\n}\n\nfunction workLoop(isYieldy) {\n  if (!isYieldy) {\n    // Flush work without yielding\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  } else {\n    // Flush asynchronous work until the deadline runs out of time.\n    while (nextUnitOfWork !== null && !shouldYield()) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  }\n}\n\nfunction renderRoot(root, isYieldy, isExpired) {\n  !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  isWorking = true;\n  ReactCurrentOwner$2.currentDispatcher = Dispatcher;\n\n  var expirationTime = root.nextExpirationTimeToWorkOn;\n\n  var prevInteractions = null;\n  if (enableSchedulerTracking) {\n    // We're about to start new tracked work.\n    // Restore pending interactions so cascading work triggered during the render phase will be accounted for.\n    prevInteractions = tracking.__interactionsRef.current;\n    tracking.__interactionsRef.current = root.memoizedInteractions;\n  }\n\n  // Check if we're starting from a fresh stack, or if we're resuming from\n  // previously yielded work.\n  if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {\n    // Reset the stack and start working from the root.\n    resetStack();\n    nextRoot = root;\n    nextRenderExpirationTime = expirationTime;\n    nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);\n    root.pendingCommitExpirationTime = NoWork;\n\n    if (enableSchedulerTracking) {\n      // Determine which interactions this batch of work currently includes,\n      // So that we can accurately attribute time spent working on it,\n      var interactions = new Set();\n      root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {\n        if (scheduledExpirationTime <= expirationTime) {\n          scheduledInteractions.forEach(function (interaction) {\n            return interactions.add(interaction);\n          });\n        }\n      });\n\n      // Store the current set of interactions on the FiberRoot for a few reasons:\n      // We can re-use it in hot functions like renderRoot() without having to recalculate it.\n      // We will also use it in commitWork() to pass to any Profiler onRender() hooks.\n      // This also provides DevTools with a way to access it when the onCommitRoot() hook is called.\n      root.memoizedInteractions = interactions;\n\n      if (interactions.size > 0) {\n        var subscriber = tracking.__subscriberRef.current;\n        if (subscriber !== null) {\n          var threadID = computeThreadID(expirationTime, root.interactionThreadID);\n          try {\n            subscriber.onWorkStarted(interactions, threadID);\n          } catch (error) {\n            // Work thrown by an interaction tracking subscriber should be rethrown,\n            // But only once it's safe (to avoid leaveing the scheduler in an invalid state).\n            // Store the error for now and we'll re-throw in finishRendering().\n            if (!hasUnhandledError) {\n              hasUnhandledError = true;\n              unhandledError = error;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var didFatal = false;\n\n  startWorkLoopTimer(nextUnitOfWork);\n\n  do {\n    try {\n      workLoop(isYieldy);\n    } catch (thrownValue) {\n      if (nextUnitOfWork === null) {\n        // This is a fatal error.\n        didFatal = true;\n        onUncaughtError(thrownValue);\n      } else {\n        {\n          // Reset global debug state\n          // We assume this is defined in DEV\n          resetCurrentlyProcessingQueue();\n        }\n\n        var failedUnitOfWork = nextUnitOfWork;\n        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);\n        }\n\n        // TODO: we already know this isn't true in some cases.\n        // At least this shows a nicer error message until we figure out the cause.\n        // https://github.com/facebook/react/issues/12449#issuecomment-386727431\n        !(nextUnitOfWork !== null) ? invariant(false, 'Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it.') : void 0;\n\n        var sourceFiber = nextUnitOfWork;\n        var returnFiber = sourceFiber.return;\n        if (returnFiber === null) {\n          // This is the root. The root could capture its own errors. However,\n          // we don't know if it errors before or after we pushed the host\n          // context. This information is needed to avoid a stack mismatch.\n          // Because we're not sure, treat this as a fatal error. We could track\n          // which phase it fails in, but doesn't seem worth it. At least\n          // for now.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n        } else {\n          throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);\n          nextUnitOfWork = completeUnitOfWork(sourceFiber);\n          continue;\n        }\n      }\n    }\n    break;\n  } while (true);\n\n  if (enableSchedulerTracking) {\n    // Tracked work is done for now; restore the previous interactions.\n    tracking.__interactionsRef.current = prevInteractions;\n  }\n\n  // We're done performing work. Time to clean up.\n  isWorking = false;\n  ReactCurrentOwner$2.currentDispatcher = null;\n  resetContextDependences();\n\n  // Yield back to main thread.\n  if (didFatal) {\n    var _didCompleteRoot = false;\n    stopWorkLoopTimer(interruptedBy, _didCompleteRoot);\n    interruptedBy = null;\n    // There was a fatal error.\n    {\n      resetStackAfterFatalErrorInDev();\n    }\n    // `nextRoot` points to the in-progress root. A non-null value indicates\n    // that we're in the middle of an async render. Set it to null to indicate\n    // there's no more work to be done in the current batch.\n    nextRoot = null;\n    onFatal(root);\n    return;\n  }\n\n  if (nextUnitOfWork !== null) {\n    // There's still remaining async work in this tree, but we ran out of time\n    // in the current frame. Yield back to the renderer. Unless we're\n    // interrupted by a higher priority update, we'll continue later from where\n    // we left off.\n    var _didCompleteRoot2 = false;\n    stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);\n    interruptedBy = null;\n    onYield(root);\n    return;\n  }\n\n  // We completed the whole tree.\n  var didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  var rootWorkInProgress = root.current.alternate;\n  !(rootWorkInProgress !== null) ? invariant(false, 'Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  // `nextRoot` points to the in-progress root. A non-null value indicates\n  // that we're in the middle of an async render. Set it to null to indicate\n  // there's no more work to be done in the current batch.\n  nextRoot = null;\n  interruptedBy = null;\n\n  if (nextRenderDidError) {\n    // There was an error\n    if (hasLowerPriorityWork(root, expirationTime)) {\n      // There's lower priority work. If so, it may have the effect of fixing\n      // the exception that was just thrown. Exit without committing. This is\n      // similar to a suspend, but without a timeout because we're not waiting\n      // for a promise to resolve. React will restart at the lower\n      // priority level.\n      markSuspendedPriorityLevel(root, expirationTime);\n      var suspendedExpirationTime = expirationTime;\n      var rootExpirationTime = root.expirationTime;\n      onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1 // Indicates no timeout\n      );\n      return;\n    } else if (\n    // There's no lower priority work, but we're rendering asynchronously.\n    // Synchronsouly attempt to render the same level one more time. This is\n    // similar to a suspend, but without a timeout because we're not waiting\n    // for a promise to resolve.\n    !root.didError && !isExpired) {\n      root.didError = true;\n      var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;\n      var _rootExpirationTime = root.expirationTime = Sync;\n      onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1 // Indicates no timeout\n      );\n      return;\n    }\n  }\n\n  if (enableSuspense && !isExpired && nextLatestAbsoluteTimeoutMs !== -1) {\n    // The tree was suspended.\n    var _suspendedExpirationTime2 = expirationTime;\n    markSuspendedPriorityLevel(root, _suspendedExpirationTime2);\n\n    // Find the earliest uncommitted expiration time in the tree, including\n    // work that is suspended. The timeout threshold cannot be longer than\n    // the overall expiration.\n    var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, expirationTime);\n    var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);\n    if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {\n      nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;\n    }\n\n    // Subtract the current time from the absolute timeout to get the number\n    // of milliseconds until the timeout. In other words, convert an absolute\n    // timestamp to a relative time. This is the value that is passed\n    // to `setTimeout`.\n    var currentTimeMs = expirationTimeToMs(requestCurrentTime());\n    var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;\n    msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;\n\n    // TODO: Account for the Just Noticeable Difference\n\n    var _rootExpirationTime2 = root.expirationTime;\n    onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);\n    return;\n  }\n\n  // Ready to commit.\n  onComplete(root, rootWorkInProgress, expirationTime);\n}\n\nfunction dispatch(sourceFiber, value, expirationTime) {\n  !(!isWorking || isCommitting$1) ? invariant(false, 'dispatch: Cannot dispatch during the render phase.') : void 0;\n\n  var fiber = sourceFiber.return;\n  while (fiber !== null) {\n    switch (fiber.tag) {\n      case ClassComponent:\n      case ClassComponentLazy:\n        var ctor = fiber.type;\n        var instance = fiber.stateNode;\n        if (typeof ctor.getDerivedStateFromCatch === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n          var errorInfo = createCapturedValue(value, sourceFiber);\n          var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);\n          enqueueUpdate(fiber, update);\n          scheduleWork(fiber, expirationTime);\n          return;\n        }\n        break;\n      case HostRoot:\n        {\n          var _errorInfo = createCapturedValue(value, sourceFiber);\n          var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);\n          enqueueUpdate(fiber, _update);\n          scheduleWork(fiber, expirationTime);\n          return;\n        }\n    }\n    fiber = fiber.return;\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    var rootFiber = sourceFiber;\n    var _errorInfo2 = createCapturedValue(value, rootFiber);\n    var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);\n    enqueueUpdate(rootFiber, _update2);\n    scheduleWork(rootFiber, expirationTime);\n  }\n}\n\nfunction captureCommitPhaseError(fiber, error) {\n  return dispatch(fiber, error, Sync);\n}\n\nfunction computeThreadID(expirationTime, interactionThreadID) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + interactionThreadID;\n}\n\n// Creates a unique async expiration time.\nfunction computeUniqueAsyncExpiration() {\n  var currentTime = requestCurrentTime();\n  var result = computeAsyncExpiration(currentTime);\n  if (result <= lastUniqueAsyncExpiration) {\n    // Since we assume the current time monotonically increases, we only hit\n    // this branch when computeUniqueAsyncExpiration is fired multiple times\n    // within a 200ms window (or whatever the async bucket size is).\n    result = lastUniqueAsyncExpiration + 1;\n  }\n  lastUniqueAsyncExpiration = result;\n  return lastUniqueAsyncExpiration;\n}\n\nfunction computeExpirationForFiber(currentTime, fiber) {\n  var expirationTime = void 0;\n  if (expirationContext !== NoWork) {\n    // An explicit expiration context was set;\n    expirationTime = expirationContext;\n  } else if (isWorking) {\n    if (isCommitting$1) {\n      // Updates that occur during the commit phase should have sync priority\n      // by default.\n      expirationTime = Sync;\n    } else {\n      // Updates during the render phase should expire at the same time as\n      // the work that is being rendered.\n      expirationTime = nextRenderExpirationTime;\n    }\n  } else {\n    // No explicit expiration context was set, and we're not currently\n    // performing work. Calculate a new expiration time.\n    if (fiber.mode & AsyncMode) {\n      if (isBatchingInteractiveUpdates) {\n        // This is an interactive update\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n      // If we're in the middle of rendering a tree, do not update at the same\n      // expiration time that is already rendering.\n      if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {\n        expirationTime += 1;\n      }\n    } else {\n      // This is a sync update\n      expirationTime = Sync;\n    }\n  }\n  if (isBatchingInteractiveUpdates) {\n    // This is an interactive update. Keep track of the lowest pending\n    // interactive expiration time. This allows us to synchronously flush\n    // all interactive updates when needed.\n    if (lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime > lowestPriorityPendingInteractiveExpirationTime) {\n      lowestPriorityPendingInteractiveExpirationTime = expirationTime;\n    }\n  }\n  return expirationTime;\n}\n\nfunction renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {\n  // Schedule the timeout.\n  if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {\n    nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;\n  }\n}\n\nfunction renderDidError() {\n  nextRenderDidError = true;\n}\n\nfunction retrySuspendedRoot(root, fiber, suspendedTime) {\n  if (enableSuspense) {\n    var retryTime = void 0;\n\n    if (isPriorityLevelSuspended(root, suspendedTime)) {\n      // Ping at the original level\n      retryTime = suspendedTime;\n      markPingedPriorityLevel(root, retryTime);\n    } else {\n      // Placeholder already timed out. Compute a new expiration time\n      var currentTime = requestCurrentTime();\n      retryTime = computeExpirationForFiber(currentTime, fiber);\n      markPendingPriorityLevel(root, retryTime);\n    }\n\n    scheduleWorkToRoot(fiber, retryTime);\n    var rootExpirationTime = root.expirationTime;\n    if (rootExpirationTime !== NoWork) {\n      if (enableSchedulerTracking) {\n        // Restore previous interactions so that new work is associated with them.\n        var prevInteractions = tracking.__interactionsRef.current;\n        tracking.__interactionsRef.current = root.memoizedInteractions;\n        // Because suspense timeouts do not decrement the interaction count,\n        // Continued suspense work should also not increment the count.\n        storeInteractionsForExpirationTime(root, rootExpirationTime, false);\n        requestWork(root, rootExpirationTime);\n        tracking.__interactionsRef.current = prevInteractions;\n      } else {\n        requestWork(root, rootExpirationTime);\n      }\n    }\n  }\n}\n\nfunction scheduleWorkToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (fiber.expirationTime === NoWork || fiber.expirationTime > expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n  var alternate = fiber.alternate;\n  if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > expirationTime)) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  var node = fiber.return;\n  if (node === null && fiber.tag === HostRoot) {\n    return fiber.stateNode;\n  }\n  while (node !== null) {\n    alternate = node.alternate;\n    if (node.childExpirationTime === NoWork || node.childExpirationTime > expirationTime) {\n      node.childExpirationTime = expirationTime;\n      if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > expirationTime)) {\n        alternate.childExpirationTime = expirationTime;\n      }\n    } else if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > expirationTime)) {\n      alternate.childExpirationTime = expirationTime;\n    }\n    if (node.return === null && node.tag === HostRoot) {\n      return node.stateNode;\n    }\n    node = node.return;\n  }\n  return null;\n}\n\nfunction storeInteractionsForExpirationTime(root, expirationTime, updateInteractionCounts) {\n  if (!enableSchedulerTracking) {\n    return;\n  }\n\n  var interactions = tracking.__interactionsRef.current;\n  if (interactions.size > 0) {\n    var pendingInteractions = root.pendingInteractionMap.get(expirationTime);\n    if (pendingInteractions != null) {\n      interactions.forEach(function (interaction) {\n        if (updateInteractionCounts && !pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      root.pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n      // Update the pending async work count for the current interactions.\n      if (updateInteractionCounts) {\n        interactions.forEach(function (interaction) {\n          interaction.__count++;\n        });\n      }\n    }\n\n    var subscriber = tracking.__subscriberRef.current;\n    if (subscriber !== null) {\n      var threadID = computeThreadID(expirationTime, root.interactionThreadID);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction scheduleWork(fiber, expirationTime) {\n  recordScheduleUpdate();\n\n  {\n    if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {\n      var instance = fiber.stateNode;\n      warnAboutInvalidUpdates(instance);\n    }\n  }\n\n  var root = scheduleWorkToRoot(fiber, expirationTime);\n  if (root === null) {\n    if (true && (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)) {\n      warnAboutUpdateOnUnmounted(fiber);\n    }\n    return;\n  }\n\n  if (enableSchedulerTracking) {\n    storeInteractionsForExpirationTime(root, expirationTime, true);\n  }\n\n  if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime < nextRenderExpirationTime) {\n    // This is an interruption. (Used for performance tracking.)\n    interruptedBy = fiber;\n    resetStack();\n  }\n  markPendingPriorityLevel(root, expirationTime);\n  if (\n  // If we're in the render phase, we don't need to schedule this root\n  // for an update, because we'll do it before we exit...\n  !isWorking || isCommitting$1 ||\n  // ...unless this is a different root than the one we're rendering.\n  nextRoot !== root) {\n    var rootExpirationTime = root.expirationTime;\n    requestWork(root, rootExpirationTime);\n  }\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    // Reset this back to zero so subsequent updates don't throw.\n    nestedUpdateCount = 0;\n    invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n  }\n}\n\nfunction syncUpdates(fn, a, b, c, d) {\n  var previousExpirationContext = expirationContext;\n  expirationContext = Sync;\n  try {\n    return fn(a, b, c, d);\n  } finally {\n    expirationContext = previousExpirationContext;\n  }\n}\n\n// TODO: Everything below this is written as if it has been lifted to the\n// renderers. I'll do this in a follow-up.\n\n// Linked-list of roots\nvar firstScheduledRoot = null;\nvar lastScheduledRoot = null;\n\nvar callbackExpirationTime = NoWork;\nvar callbackID = void 0;\nvar isRendering = false;\nvar nextFlushedRoot = null;\nvar nextFlushedExpirationTime = NoWork;\nvar lowestPriorityPendingInteractiveExpirationTime = NoWork;\nvar deadlineDidExpire = false;\nvar hasUnhandledError = false;\nvar unhandledError = null;\nvar deadline = null;\n\nvar isBatchingUpdates = false;\nvar isUnbatchingUpdates = false;\nvar isBatchingInteractiveUpdates = false;\n\nvar completedBatches = null;\n\nvar originalStartTimeMs = schedule.unstable_now();\nvar currentRendererTime = msToExpirationTime(originalStartTimeMs);\nvar currentSchedulerTime = currentRendererTime;\n\n// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT = 50;\nvar nestedUpdateCount = 0;\nvar lastCommittedRootDuringThisBatch = null;\n\nvar timeHeuristicForUnitOfWork = 1;\n\nfunction recomputeCurrentRendererTime() {\n  var currentTimeMs = schedule.unstable_now() - originalStartTimeMs;\n  currentRendererTime = msToExpirationTime(currentTimeMs);\n}\n\nfunction scheduleCallbackWithExpirationTime(root, expirationTime) {\n  if (callbackExpirationTime !== NoWork) {\n    // A callback is already scheduled. Check its expiration time (timeout).\n    if (expirationTime > callbackExpirationTime) {\n      // Existing callback has sufficient timeout. Exit.\n      return;\n    } else {\n      if (callbackID !== null) {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        schedule.unstable_cancelScheduledWork(callbackID);\n      }\n    }\n    // The request callback timer is already running. Don't start a new one.\n  } else {\n    startRequestCallbackTimer();\n  }\n\n  callbackExpirationTime = expirationTime;\n  var currentMs = schedule.unstable_now() - originalStartTimeMs;\n  var expirationTimeMs = expirationTimeToMs(expirationTime);\n  var timeout = expirationTimeMs - currentMs;\n  callbackID = schedule.unstable_scheduleWork(performAsyncWork, { timeout: timeout });\n}\n\n// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and\n// onYield is called upon exiting. We use these in lieu of returning a tuple.\n// I've also chosen not to inline them into renderRoot because these will\n// eventually be lifted into the renderer.\nfunction onFatal(root) {\n  root.finishedWork = null;\n}\n\nfunction onComplete(root, finishedWork, expirationTime) {\n  root.pendingCommitExpirationTime = expirationTime;\n  root.finishedWork = finishedWork;\n}\n\nfunction onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {\n  root.expirationTime = rootExpirationTime;\n  if (enableSuspense && msUntilTimeout === 0 && !shouldYield()) {\n    // Don't wait an additional tick. Commit the tree immediately.\n    root.pendingCommitExpirationTime = suspendedExpirationTime;\n    root.finishedWork = finishedWork;\n  } else if (msUntilTimeout > 0) {\n    // Wait `msUntilTimeout` milliseconds before committing.\n    root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);\n  }\n}\n\nfunction onYield(root) {\n  root.finishedWork = null;\n}\n\nfunction onTimeout(root, finishedWork, suspendedExpirationTime) {\n  if (enableSuspense) {\n    // The root timed out. Commit it.\n    root.pendingCommitExpirationTime = suspendedExpirationTime;\n    root.finishedWork = finishedWork;\n    // Read the current time before entering the commit phase. We can be\n    // certain this won't cause tearing related to batching of event updates\n    // because we're at the top of a timer event.\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n\n    if (enableSchedulerTracking) {\n      // Don't update pending interaction counts for suspense timeouts,\n      // Because we know we still need to do more work in this case.\n      suspenseDidTimeout = true;\n      flushRoot(root, suspendedExpirationTime);\n      suspenseDidTimeout = false;\n    } else {\n      flushRoot(root, suspendedExpirationTime);\n    }\n  }\n}\n\nfunction onCommit(root, expirationTime) {\n  root.expirationTime = expirationTime;\n  root.finishedWork = null;\n}\n\nfunction requestCurrentTime() {\n  // requestCurrentTime is called by the scheduler to compute an expiration\n  // time.\n  //\n  // Expiration times are computed by adding to the current time (the start\n  // time). However, if two updates are scheduled within the same event, we\n  // should treat their start times as simultaneous, even if the actual clock\n  // time has advanced between the first and second call.\n\n  // In other words, because expiration times determine how updates are batched,\n  // we want all updates of like priority that occur within the same event to\n  // receive the same expiration time. Otherwise we get tearing.\n  //\n  // We keep track of two separate times: the current \"renderer\" time and the\n  // current \"scheduler\" time. The renderer time can be updated whenever; it\n  // only exists to minimize the calls performance.now.\n  //\n  // But the scheduler time can only be updated if there's no pending work, or\n  // if we know for certain that we're not in the middle of an event.\n\n  if (isRendering) {\n    // We're already rendering. Return the most recently read time.\n    return currentSchedulerTime;\n  }\n  // Check if there's pending work.\n  findHighestPriorityRoot();\n  if (nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never) {\n    // If there's no pending work, or if the pending work is offscreen, we can\n    // read the current time without risk of tearing.\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n    return currentSchedulerTime;\n  }\n  // There's already pending work. We might be in the middle of a browser\n  // event. If we were to read the current time, it could cause multiple updates\n  // within the same event to receive different expiration times, leading to\n  // tearing. Return the last read time. During the next idle callback, the\n  // time will be updated.\n  return currentSchedulerTime;\n}\n\n// requestWork is called by the scheduler whenever a root receives an update.\n// It's up to the renderer to call renderRoot at some point in the future.\nfunction requestWork(root, expirationTime) {\n  addRootToSchedule(root, expirationTime);\n  if (isRendering) {\n    // Prevent reentrancy. Remaining work will be scheduled at the end of\n    // the currently rendering batch.\n    return;\n  }\n\n  if (isBatchingUpdates) {\n    // Flush work at the end of the batch.\n    if (isUnbatchingUpdates) {\n      // ...unless we're inside unbatchedUpdates, in which case we should\n      // flush it now.\n      nextFlushedRoot = root;\n      nextFlushedExpirationTime = Sync;\n      performWorkOnRoot(root, Sync, true);\n    }\n    return;\n  }\n\n  // TODO: Get rid of Sync and use current time?\n  if (expirationTime === Sync) {\n    performSyncWork();\n  } else {\n    scheduleCallbackWithExpirationTime(root, expirationTime);\n  }\n}\n\nfunction addRootToSchedule(root, expirationTime) {\n  // Add the root to the schedule.\n  // Check if this root is already part of the schedule.\n  if (root.nextScheduledRoot === null) {\n    // This root is not already scheduled. Add it.\n    root.expirationTime = expirationTime;\n    if (lastScheduledRoot === null) {\n      firstScheduledRoot = lastScheduledRoot = root;\n      root.nextScheduledRoot = root;\n    } else {\n      lastScheduledRoot.nextScheduledRoot = root;\n      lastScheduledRoot = root;\n      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n    }\n  } else {\n    // This root is already scheduled, but its priority may have increased.\n    var remainingExpirationTime = root.expirationTime;\n    if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n      // Update the priority.\n      root.expirationTime = expirationTime;\n    }\n  }\n}\n\nfunction findHighestPriorityRoot() {\n  var highestPriorityWork = NoWork;\n  var highestPriorityRoot = null;\n  if (lastScheduledRoot !== null) {\n    var previousScheduledRoot = lastScheduledRoot;\n    var root = firstScheduledRoot;\n    while (root !== null) {\n      var remainingExpirationTime = root.expirationTime;\n      if (remainingExpirationTime === NoWork) {\n        // This root no longer has work. Remove it from the scheduler.\n\n        // TODO: This check is redudant, but Flow is confused by the branch\n        // below where we set lastScheduledRoot to null, even though we break\n        // from the loop right after.\n        !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        if (root === root.nextScheduledRoot) {\n          // This is the only root in the list.\n          root.nextScheduledRoot = null;\n          firstScheduledRoot = lastScheduledRoot = null;\n          break;\n        } else if (root === firstScheduledRoot) {\n          // This is the first root in the list.\n          var next = root.nextScheduledRoot;\n          firstScheduledRoot = next;\n          lastScheduledRoot.nextScheduledRoot = next;\n          root.nextScheduledRoot = null;\n        } else if (root === lastScheduledRoot) {\n          // This is the last root in the list.\n          lastScheduledRoot = previousScheduledRoot;\n          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          root.nextScheduledRoot = null;\n          break;\n        } else {\n          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n          root.nextScheduledRoot = null;\n        }\n        root = previousScheduledRoot.nextScheduledRoot;\n      } else {\n        if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n          // Update the priority, if it's higher\n          highestPriorityWork = remainingExpirationTime;\n          highestPriorityRoot = root;\n        }\n        if (root === lastScheduledRoot) {\n          break;\n        }\n        if (highestPriorityWork === Sync) {\n          // Sync is highest priority by definition so\n          // we can stop searching.\n          break;\n        }\n        previousScheduledRoot = root;\n        root = root.nextScheduledRoot;\n      }\n    }\n  }\n\n  nextFlushedRoot = highestPriorityRoot;\n  nextFlushedExpirationTime = highestPriorityWork;\n}\n\nfunction performAsyncWork(dl) {\n  if (dl.didTimeout) {\n    // The callback timed out. That means at least one update has expired.\n    // Iterate through the root schedule. If they contain expired work, set\n    // the next render expiration time to the current time. This has the effect\n    // of flushing all expired work in a single batch, instead of flushing each\n    // level one at a time.\n    if (firstScheduledRoot !== null) {\n      recomputeCurrentRendererTime();\n      var root = firstScheduledRoot;\n      do {\n        didExpireAtExpirationTime(root, currentRendererTime);\n        // The root schedule is circular, so this is never null.\n        root = root.nextScheduledRoot;\n      } while (root !== firstScheduledRoot);\n    }\n  }\n  performWork(NoWork, dl);\n}\n\nfunction performSyncWork() {\n  performWork(Sync, null);\n}\n\nfunction performWork(minExpirationTime, dl) {\n  deadline = dl;\n\n  // Keep working on roots until there's no more work, or until we reach\n  // the deadline.\n  findHighestPriorityRoot();\n\n  if (deadline !== null) {\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n\n    if (enableUserTimingAPI) {\n      var didExpire = nextFlushedExpirationTime < currentRendererTime;\n      var timeout = expirationTimeToMs(nextFlushedExpirationTime);\n      stopRequestCallbackTimer(didExpire, timeout);\n    }\n\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime) && (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime >= nextFlushedExpirationTime);\n      findHighestPriorityRoot();\n      recomputeCurrentRendererTime();\n      currentSchedulerTime = currentRendererTime;\n    }\n  } else {\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime)) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);\n      findHighestPriorityRoot();\n    }\n  }\n\n  // We're done flushing work. Either we ran out of time in this callback,\n  // or there's no more work left with sufficient priority.\n\n  // If we're inside a callback, set this to false since we just completed it.\n  if (deadline !== null) {\n    callbackExpirationTime = NoWork;\n    callbackID = null;\n  }\n  // If there's work left over, schedule a new callback.\n  if (nextFlushedExpirationTime !== NoWork) {\n    scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);\n  }\n\n  // Clean-up.\n  deadline = null;\n  deadlineDidExpire = false;\n\n  finishRendering();\n}\n\nfunction flushRoot(root, expirationTime) {\n  !!isRendering ? invariant(false, 'work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.') : void 0;\n  // Perform work on root as if the given expiration time is the current time.\n  // This has the effect of synchronously flushing all work up to and\n  // including the given time.\n  nextFlushedRoot = root;\n  nextFlushedExpirationTime = expirationTime;\n  performWorkOnRoot(root, expirationTime, true);\n  // Flush any sync work that was scheduled by lifecycles\n  performSyncWork();\n}\n\nfunction finishRendering() {\n  nestedUpdateCount = 0;\n  lastCommittedRootDuringThisBatch = null;\n\n  if (completedBatches !== null) {\n    var batches = completedBatches;\n    completedBatches = null;\n    for (var i = 0; i < batches.length; i++) {\n      var batch = batches[i];\n      try {\n        batch._onComplete();\n      } catch (error) {\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      }\n    }\n  }\n\n  if (hasUnhandledError) {\n    var error = unhandledError;\n    unhandledError = null;\n    hasUnhandledError = false;\n    throw error;\n  }\n}\n\nfunction performWorkOnRoot(root, expirationTime, isExpired) {\n  !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  isRendering = true;\n\n  // Check if this is async work or sync/expired work.\n  if (deadline === null || isExpired) {\n    // Flush work without yielding.\n    // TODO: Non-yieldy work does not necessarily imply expired work. A renderer\n    // may want to perform some work without yielding, but also without\n    // requiring the root to complete (by triggering placeholders).\n\n    var finishedWork = root.finishedWork;\n    if (finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      // If this root previously suspended, clear its existing timeout, since\n      // we're about to try rendering again.\n      var timeoutHandle = root.timeoutHandle;\n      if (enableSuspense && timeoutHandle !== noTimeout) {\n        root.timeoutHandle = noTimeout;\n        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n        cancelTimeout(timeoutHandle);\n      }\n      var isYieldy = false;\n      renderRoot(root, isYieldy, isExpired);\n      finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // We've completed the root. Commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      }\n    }\n  } else {\n    // Flush async work.\n    var _finishedWork = root.finishedWork;\n    if (_finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, _finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      // If this root previously suspended, clear its existing timeout, since\n      // we're about to try rendering again.\n      var _timeoutHandle = root.timeoutHandle;\n      if (enableSuspense && _timeoutHandle !== noTimeout) {\n        root.timeoutHandle = noTimeout;\n        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n        cancelTimeout(_timeoutHandle);\n      }\n      var _isYieldy = true;\n      renderRoot(root, _isYieldy, isExpired);\n      _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // We've completed the root. Check the deadline one more time\n        // before committing.\n        if (!shouldYield()) {\n          // Still time left. Commit the root.\n          completeRoot(root, _finishedWork, expirationTime);\n        } else {\n          // There's no time left. Mark this root as complete. We'll come\n          // back and commit it later.\n          root.finishedWork = _finishedWork;\n        }\n      }\n    }\n  }\n\n  isRendering = false;\n}\n\nfunction completeRoot(root, finishedWork, expirationTime) {\n  // Check if there's a batch that matches this expiration time.\n  var firstBatch = root.firstBatch;\n  if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n    if (completedBatches === null) {\n      completedBatches = [firstBatch];\n    } else {\n      completedBatches.push(firstBatch);\n    }\n    if (firstBatch._defer) {\n      // This root is blocked from committing by a batch. Unschedule it until\n      // we receive another update.\n      root.finishedWork = finishedWork;\n      root.expirationTime = NoWork;\n      return;\n    }\n  }\n\n  // Commit the root.\n  root.finishedWork = null;\n\n  // Check if this is a nested update (a sync update scheduled during the\n  // commit phase).\n  if (root === lastCommittedRootDuringThisBatch) {\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    nestedUpdateCount++;\n  } else {\n    // Reset whenever we switch roots.\n    lastCommittedRootDuringThisBatch = root;\n    nestedUpdateCount = 0;\n  }\n  commitRoot(root, finishedWork);\n}\n\n// When working on async work, the reconciler asks the renderer if it should\n// yield execution. For DOM, we implement this with requestIdleCallback.\nfunction shouldYield() {\n  if (deadlineDidExpire) {\n    return true;\n  }\n  if (deadline === null || deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n    // Disregard deadline.didTimeout. Only expired work should be flushed\n    // during a timeout. This path is only hit for non-expired work.\n    return false;\n  }\n  deadlineDidExpire = true;\n  return true;\n}\n\nfunction onUncaughtError(error) {\n  !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  // Unschedule this root so we don't work on it again until there's\n  // another update.\n  nextFlushedRoot.expirationTime = NoWork;\n  if (!hasUnhandledError) {\n    hasUnhandledError = true;\n    unhandledError = error;\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction batchedUpdates$1(fn, a) {\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return fn(a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction unbatchedUpdates(fn, a) {\n  if (isBatchingUpdates && !isUnbatchingUpdates) {\n    isUnbatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isUnbatchingUpdates = false;\n    }\n  }\n  return fn(a);\n}\n\n// TODO: Batching should be implemented at the renderer level, not within\n// the reconciler.\nfunction flushSync(fn, a) {\n  !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return syncUpdates(fn, a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    performSyncWork();\n  }\n}\n\nfunction interactiveUpdates$1(fn, a, b) {\n  if (isBatchingInteractiveUpdates) {\n    return fn(a, b);\n  }\n  // If there are any pending interactive updates, synchronously flush them.\n  // This needs to happen before we read any handlers, because the effect of\n  // the previous event may influence which handlers are called during\n  // this event.\n  if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPriorityPendingInteractiveExpirationTime, null);\n    lowestPriorityPendingInteractiveExpirationTime = NoWork;\n  }\n  var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingInteractiveUpdates = true;\n  isBatchingUpdates = true;\n  try {\n    return fn(a, b);\n  } finally {\n    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\nfunction flushInteractiveUpdates$1() {\n  if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPriorityPendingInteractiveExpirationTime, null);\n    lowestPriorityPendingInteractiveExpirationTime = NoWork;\n  }\n}\n\nfunction flushControlled(fn) {\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    syncUpdates(fn);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performWork(Sync, null);\n    }\n  }\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\n\nvar didWarnAboutNestedUpdates = void 0;\n\n{\n  didWarnAboutNestedUpdates = false;\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    var Component = fiber.type;\n    if (isContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  } else if (fiber.tag === ClassComponentLazy) {\n    var _Component = getResultFromResolvedThenable(fiber.type);\n    if (isContextProvider(_Component)) {\n      return processChildContext(fiber, _Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction scheduleRootUpdate(current$$1, element, expirationTime, callback) {\n  {\n    if (phase === 'render' && current !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n      warningWithoutStack$1(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(current.type) || 'Unknown');\n    }\n  }\n\n  var update = createUpdate(expirationTime);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: element };\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    !(typeof callback === 'function') ? warningWithoutStack$1(false, 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback) : void 0;\n    update.callback = callback;\n  }\n  enqueueUpdate(current$$1, update);\n\n  scheduleWork(current$$1, expirationTime);\n  return expirationTime;\n}\n\nfunction updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {\n  // TODO: If this is a nested container, this won't be the root.\n  var current$$1 = container.current;\n\n  {\n    if (ReactFiberInstrumentation_1.debugTool) {\n      if (current$$1.alternate === null) {\n        ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n      } else if (element === null) {\n        ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n      } else {\n        ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n      }\n    }\n  }\n\n  var context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  return scheduleRootUpdate(current$$1, element, expirationTime, callback);\n}\n\nfunction findHostInstance(component) {\n  var fiber = get(component);\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));\n    }\n  }\n  var hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction createContainer(containerInfo, isAsync, hydrate) {\n  return createFiberRoot(containerInfo, isAsync, hydrate);\n}\n\nfunction updateContainer(element, container, parentComponent, callback) {\n  var current$$1 = container.current;\n  var currentTime = requestCurrentTime();\n  var expirationTime = computeExpirationForFiber(currentTime, current$$1);\n  return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);\n}\n\nfunction getPublicRootInstance(container) {\n  var containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\n\nfunction findHostInstanceWithNoPortals(fiber) {\n  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction injectIntoDevTools(devToolsConfig) {\n  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n  return injectInternals(_assign({}, devToolsConfig, {\n    findHostInstanceByFiber: function (fiber) {\n      var hostFiber = findCurrentHostFiber(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    findFiberByHostInstance: function (instance) {\n      if (!findFiberByHostInstance) {\n        // Might not be implemented by the renderer.\n        return null;\n      }\n      return findFiberByHostInstance(instance);\n    }\n  }));\n}\n\n// This file intentionally does *not* have the Flow annotation.\n// Don't add it. See `./inline-typed.js` for an explanation.\n\nfunction createPortal$1(children, containerInfo,\n// TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.5.1';\n\n// TODO: This type is shared between the reconciler and ReactDOM, but will\n// eventually be lifted out to the renderer.\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nvar topLevelUpdateWarnings = void 0;\nvar warnOnInvalidCallback = void 0;\nvar didWarnAboutUnstableCreatePortal = false;\n\n{\n  if (typeof Map !== 'function' ||\n  // $FlowIssue Flow incorrectly thinks Map has no prototype\n  Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' ||\n  // $FlowIssue Flow incorrectly thinks Set has no prototype\n  Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n    warningWithoutStack$1(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n  }\n\n  topLevelUpdateWarnings = function (container) {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);\n      if (hostInstance) {\n        !(hostInstance.parentNode === container) ? warningWithoutStack$1(false, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.') : void 0;\n      }\n    }\n\n    var isRootRenderedBySomeReact = !!container._reactRootContainer;\n    var rootEl = getReactRootElementInContainer(container);\n    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));\n\n    !(!hasNonRootReactChild || isRootRenderedBySomeReact) ? warningWithoutStack$1(false, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;\n\n    !(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY') ? warningWithoutStack$1(false, 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;\n  };\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    !(callback === null || typeof callback === 'function') ? warningWithoutStack$1(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback) : void 0;\n  };\n}\n\nsetRestoreImplementation(restoreControlledState$1);\n\n/* eslint-disable no-use-before-define */\n\n/* eslint-enable no-use-before-define */\n\nfunction ReactBatch(root) {\n  var expirationTime = computeUniqueAsyncExpiration();\n  this._expirationTime = expirationTime;\n  this._root = root;\n  this._next = null;\n  this._callbacks = null;\n  this._didComplete = false;\n  this._hasChildren = false;\n  this._children = null;\n  this._defer = true;\n}\nReactBatch.prototype.render = function (children) {\n  !this._defer ? invariant(false, 'batch.render: Cannot render a batch that already committed.') : void 0;\n  this._hasChildren = true;\n  this._children = children;\n  var internalRoot = this._root._internalRoot;\n  var expirationTime = this._expirationTime;\n  var work = new ReactWork();\n  updateContainerAtExpirationTime(children, internalRoot, null, expirationTime, work._onCommit);\n  return work;\n};\nReactBatch.prototype.then = function (onComplete) {\n  if (this._didComplete) {\n    onComplete();\n    return;\n  }\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    callbacks = this._callbacks = [];\n  }\n  callbacks.push(onComplete);\n};\nReactBatch.prototype.commit = function () {\n  var internalRoot = this._root._internalRoot;\n  var firstBatch = internalRoot.firstBatch;\n  !(this._defer && firstBatch !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;\n\n  if (!this._hasChildren) {\n    // This batch is empty. Return.\n    this._next = null;\n    this._defer = false;\n    return;\n  }\n\n  var expirationTime = this._expirationTime;\n\n  // Ensure this is the first batch in the list.\n  if (firstBatch !== this) {\n    // This batch is not the earliest batch. We need to move it to the front.\n    // Update its expiration time to be the expiration time of the earliest\n    // batch, so that we can flush it without flushing the other batches.\n    if (this._hasChildren) {\n      expirationTime = this._expirationTime = firstBatch._expirationTime;\n      // Rendering this batch again ensures its children will be the final state\n      // when we flush (updates are processed in insertion order: last\n      // update wins).\n      // TODO: This forces a restart. Should we print a warning?\n      this.render(this._children);\n    }\n\n    // Remove the batch from the list.\n    var previous = null;\n    var batch = firstBatch;\n    while (batch !== this) {\n      previous = batch;\n      batch = batch._next;\n    }\n    !(previous !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;\n    previous._next = batch._next;\n\n    // Add it to the front.\n    this._next = firstBatch;\n    firstBatch = internalRoot.firstBatch = this;\n  }\n\n  // Synchronously flush all the work up to this batch's expiration time.\n  this._defer = false;\n  flushRoot(internalRoot, expirationTime);\n\n  // Pop the batch from the list.\n  var next = this._next;\n  this._next = null;\n  firstBatch = internalRoot.firstBatch = next;\n\n  // Append the next earliest batch's children to the update queue.\n  if (firstBatch !== null && firstBatch._hasChildren) {\n    firstBatch.render(firstBatch._children);\n  }\n};\nReactBatch.prototype._onComplete = function () {\n  if (this._didComplete) {\n    return;\n  }\n  this._didComplete = true;\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    return;\n  }\n  // TODO: Error handling.\n  for (var i = 0; i < callbacks.length; i++) {\n    var _callback = callbacks[i];\n    _callback();\n  }\n};\n\nfunction ReactWork() {\n  this._callbacks = null;\n  this._didCommit = false;\n  // TODO: Avoid need to bind by replacing callbacks in the update queue with\n  // list of Work objects.\n  this._onCommit = this._onCommit.bind(this);\n}\nReactWork.prototype.then = function (onCommit) {\n  if (this._didCommit) {\n    onCommit();\n    return;\n  }\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    callbacks = this._callbacks = [];\n  }\n  callbacks.push(onCommit);\n};\nReactWork.prototype._onCommit = function () {\n  if (this._didCommit) {\n    return;\n  }\n  this._didCommit = true;\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    return;\n  }\n  // TODO: Error handling.\n  for (var i = 0; i < callbacks.length; i++) {\n    var _callback2 = callbacks[i];\n    !(typeof _callback2 === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback2) : void 0;\n    _callback2();\n  }\n};\n\nfunction ReactRoot(container, isAsync, hydrate) {\n  var root = createContainer(container, isAsync, hydrate);\n  this._internalRoot = root;\n}\nReactRoot.prototype.render = function (children, callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  updateContainer(children, root, null, work._onCommit);\n  return work;\n};\nReactRoot.prototype.unmount = function (callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  updateContainer(null, root, null, work._onCommit);\n  return work;\n};\nReactRoot.prototype.legacy_renderSubtreeIntoContainer = function (parentComponent, children, callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  updateContainer(children, root, parentComponent, work._onCommit);\n  return work;\n};\nReactRoot.prototype.createBatch = function () {\n  var batch = new ReactBatch(this);\n  var expirationTime = batch._expirationTime;\n\n  var internalRoot = this._internalRoot;\n  var firstBatch = internalRoot.firstBatch;\n  if (firstBatch === null) {\n    internalRoot.firstBatch = batch;\n    batch._next = null;\n  } else {\n    // Insert sorted by expiration time then insertion order\n    var insertAfter = null;\n    var insertBefore = firstBatch;\n    while (insertBefore !== null && insertBefore._expirationTime <= expirationTime) {\n      insertAfter = insertBefore;\n      insertBefore = insertBefore._next;\n    }\n    batch._next = insertBefore;\n    if (insertAfter !== null) {\n      insertAfter._next = batch;\n    }\n  }\n\n  return batch;\n};\n\n/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */\nfunction isValidContainer(node) {\n  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n\nsetBatchingImplementation(batchedUpdates$1, interactiveUpdates$1, flushInteractiveUpdates$1);\n\nvar warnedAboutHydrateAPI = false;\n\nfunction legacyCreateRootFromDOMContainer(container, forceHydrate) {\n  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  if (!shouldHydrate) {\n    var warned = false;\n    var rootSibling = void 0;\n    while (rootSibling = container.lastChild) {\n      {\n        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n          warned = true;\n          warningWithoutStack$1(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n        }\n      }\n      container.removeChild(rootSibling);\n    }\n  }\n  {\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true;\n      lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n    }\n  }\n  // Legacy roots are not async by default.\n  var isAsync = false;\n  return new ReactRoot(container, isAsync, shouldHydrate);\n}\n\nfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  // TODO: Ensure all entry points contain this check\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n\n  {\n    topLevelUpdateWarnings(container);\n  }\n\n  // TODO: Without `any` type, Flow says \"Property cannot be accessed on any\n  // member of intersection type.\" Whyyyyyy.\n  var root = container._reactRootContainer;\n  if (!root) {\n    // Initial mount\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\n    if (typeof callback === 'function') {\n      var originalCallback = callback;\n      callback = function () {\n        var instance = getPublicRootInstance(root._internalRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    unbatchedUpdates(function () {\n      if (parentComponent != null) {\n        root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);\n      } else {\n        root.render(children, callback);\n      }\n    });\n  } else {\n    if (typeof callback === 'function') {\n      var _originalCallback = callback;\n      callback = function () {\n        var instance = getPublicRootInstance(root._internalRoot);\n        _originalCallback.call(instance);\n      };\n    }\n    // Update\n    if (parentComponent != null) {\n      root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);\n    } else {\n      root.render(children, callback);\n    }\n  }\n  return getPublicRootInstance(root._internalRoot);\n}\n\nfunction createPortal(children, container) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n  // TODO: pass ReactDOM portal implementation as third argument\n  return createPortal$1(children, container, null, key);\n}\n\nvar ReactDOM = {\n  createPortal: createPortal,\n\n  findDOMNode: function (componentOrElement) {\n    {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null && owner.stateNode !== null) {\n        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n        !warnedAboutRefsInRender ? warningWithoutStack$1(false, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component') : void 0;\n        owner.stateNode._warnedAboutRefsInRender = true;\n      }\n    }\n    if (componentOrElement == null) {\n      return null;\n    }\n    if (componentOrElement.nodeType === ELEMENT_NODE) {\n      return componentOrElement;\n    }\n\n    return findHostInstance(componentOrElement);\n  },\n  hydrate: function (element, container, callback) {\n    // TODO: throw or warn if we couldn't hydrate?\n    return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n  },\n  render: function (element, container, callback) {\n    return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n  },\n  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n    return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n  },\n  unmountComponentAtNode: function (container) {\n    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n    if (container._reactRootContainer) {\n      {\n        var rootEl = getReactRootElementInContainer(container);\n        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);\n        !!renderedByDifferentReact ? warningWithoutStack$1(false, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.') : void 0;\n      }\n\n      // Unmount should not be batched.\n      unbatchedUpdates(function () {\n        legacyRenderSubtreeIntoContainer(null, null, container, false, function () {\n          container._reactRootContainer = null;\n        });\n      });\n      // If you call unmountComponentAtNode twice in quick succession, you'll\n      // get `true` twice. That's probably fine?\n      return true;\n    } else {\n      {\n        var _rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));\n\n        // Check if the container itself is a React root node.\n        var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n\n        !!hasNonRootReactChild ? warningWithoutStack$1(false, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;\n      }\n\n      return false;\n    }\n  },\n\n\n  // Temporary alias since we already shipped React 16 RC with it.\n  // TODO: remove in React 17.\n  unstable_createPortal: function () {\n    if (!didWarnAboutUnstableCreatePortal) {\n      didWarnAboutUnstableCreatePortal = true;\n      lowPriorityWarning$1(false, 'The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the \"unstable_\" prefix.');\n    }\n    return createPortal.apply(undefined, arguments);\n  },\n\n\n  unstable_batchedUpdates: batchedUpdates$1,\n\n  unstable_interactiveUpdates: interactiveUpdates$1,\n\n  flushSync: flushSync,\n\n  unstable_flushControlled: flushControlled,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // Keep in sync with ReactDOMUnstableNativeDependencies.js\n    // and ReactTestUtils.js. This is an array for better minification.\n    Events: [getInstanceFromNode$1, getNodeFromInstance$1, getFiberCurrentPropsFromNode$1, injection.injectEventPluginsByName, eventNameDispatchConfigs, accumulateTwoPhaseDispatches, accumulateDirectDispatches, enqueueStateRestore, restoreStateIfNeeded, dispatchEvent, runEventsInBatch]\n  }\n};\n\nReactDOM.unstable_createRoot = function createRoot(container, options) {\n  !isValidContainer(container) ? invariant(false, 'unstable_createRoot(...): Target container is not a DOM element.') : void 0;\n  var hydrate = options != null && options.hydrate === true;\n  return new ReactRoot(container, true, hydrate);\n};\n\nvar foundDevTools = injectIntoDevTools({\n  findFiberByHostInstance: getClosestInstanceFromNode,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: 'react-dom'\n});\n\n{\n  if (!foundDevTools && canUseDOM && window.top === window.self) {\n    // If we're in Chrome or Firefox, provide a download link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n      var protocol = window.location.protocol;\n      // Don't warn in exotic cases like chrome-extension://.\n      if (/^(https?|file):$/.test(protocol)) {\n        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n      }\n    }\n  }\n}\n\n\n\nvar ReactDOM$2 = Object.freeze({\n\tdefault: ReactDOM\n});\n\nvar ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactDom = ReactDOM$3.default || ReactDOM$3;\n\nmodule.exports = reactDom;\n  })();\n}\n\n\n//# sourceURL=webpack:///./node_modules/react-dom/cjs/react-dom.development.js?");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/react-dom/index.js?");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.5.1\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.5.1';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for('react.placeholder') : 0xead1;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\n// Exports ReactDOM.createRoot\n\n\n// Experimental error-boundary API that can recover from errors within a single\n// render phase\n\n// Suspense\nvar enableSuspense = false;\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\n\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\n\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\n\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\n\n\n// Warn about legacy context API\n\n\n// Gather advanced timing metrics for Profiler subtrees.\n\n\n// Track which interactions trigger each commit.\n\n\n// Only used in www builds.\n\n\n// Only used in www builds.\n\n\n// React Fire: prevent the value and checked attributes from syncing\n// with their related DOM properties\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function () {};\n\n{\n  validateFormat = function (format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error = void 0;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\n// Relying on the `invariant()` implementation lets us\n// preserve the format and params in the www builds.\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warningWithoutStack = function () {};\n\n{\n  warningWithoutStack = function (condition, format) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (format === undefined) {\n      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (args.length > 8) {\n      // Check before the condition to catch violations early.\n      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n    }\n    if (condition) {\n      return;\n    }\n    if (typeof console !== 'undefined') {\n      var _args$map = args.map(function (item) {\n        return '' + item;\n      }),\n          a = _args$map[0],\n          b = _args$map[1],\n          c = _args$map[2],\n          d = _args$map[3],\n          e = _args$map[4],\n          f = _args$map[5],\n          g = _args$map[6],\n          h = _args$map[7];\n\n      var message = 'Warning: ' + format;\n\n      // We intentionally don't use spread (or .apply) because it breaks IE9:\n      // https://github.com/facebook/react/issues/13610\n      switch (args.length) {\n        case 0:\n          console.error(message);\n          break;\n        case 1:\n          console.error(message, a);\n          break;\n        case 2:\n          console.error(message, a, b);\n          break;\n        case 3:\n          console.error(message, a, b, c);\n          break;\n        case 4:\n          console.error(message, a, b, c, d);\n          break;\n        case 5:\n          console.error(message, a, b, c, d, e);\n          break;\n        case 6:\n          console.error(message, a, b, c, d, e, f);\n          break;\n        case 7:\n          console.error(message, a, b, c, d, e, f, g);\n          break;\n        case 8:\n          console.error(message, a, b, c, d, e, f, g, h);\n          break;\n        default:\n          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n      }\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var _message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      throw new Error(_message);\n    } catch (x) {}\n  };\n}\n\nvar warningWithoutStack$1 = warningWithoutStack;\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + '.' + callerName;\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n    warningWithoutStack$1(false, \"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar emptyObject = {};\n{\n  Object.freeze(emptyObject);\n}\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n        return undefined;\n      }\n    });\n  };\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\n_assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n  {\n    Object.seal(refObject);\n  }\n  return refObject;\n}\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null,\n  currentDispatcher: null\n};\n\nvar BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  var sourceInfo = '';\n  if (source) {\n    var path = source.fileName;\n    var fileName = path.replace(BEFORE_SLASH_RE, '');\n    {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        var match = path.match(BEFORE_SLASH_RE);\n        if (match) {\n          var pathBeforeSlash = match[1];\n          if (pathBeforeSlash) {\n            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n            fileName = folderName + '/' + fileName;\n          }\n        }\n      }\n    }\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n};\n\nvar Resolved = 1;\n\n\n\n\nfunction refineResolvedThenable(thenable) {\n  return thenable._reactStatus === Resolved ? thenable._reactResult : null;\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  {\n    if (typeof type.tag === 'number') {\n      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_ASYNC_MODE_TYPE:\n      return 'AsyncMode';\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_PLACEHOLDER_TYPE:\n      return 'Placeholder';\n  }\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return 'Context.Consumer';\n      case REACT_PROVIDER_TYPE:\n        return 'Context.Provider';\n      case REACT_FORWARD_REF_TYPE:\n        var renderFn = type.render;\n        var functionName = renderFn.displayName || renderFn.name || '';\n        return type.displayName || (functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef');\n    }\n    if (typeof type.then === 'function') {\n      var thenable = type;\n      var resolvedThenable = refineResolvedThenable(thenable);\n      if (resolvedThenable) {\n        return getComponentName(resolvedThenable);\n      }\n    }\n  }\n  return null;\n}\n\nvar ReactDebugCurrentFrame = {};\n\nvar currentlyValidatingElement = null;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    currentlyValidatingElement = element;\n  }\n}\n\n{\n  // Stack implementation injected by the current renderer.\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var stack = '';\n\n    // Add an extra top frame while an element is being validated\n    if (currentlyValidatingElement) {\n      var name = getComponentName(currentlyValidatingElement.type);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));\n    }\n\n    // Delegate to the injected renderer-specific implementation\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n    if (impl) {\n      stack += impl() || '';\n    }\n\n    return stack;\n  };\n}\n\nvar ReactSharedInternals = {\n  ReactCurrentOwner: ReactCurrentOwner,\n  // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n  assign: _assign\n};\n\n{\n  _assign(ReactSharedInternals, {\n    // These should not be included in production.\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n    // TODO: remove in React 17.0.\n    ReactComponentTreeHook: {}\n  });\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = warningWithoutStack$1;\n\n{\n  warning = function (condition, format) {\n    if (condition) {\n      return;\n    }\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n    // eslint-disable-next-line react-internal/warning-and-invariant-args\n\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));\n  };\n}\n\nvar warning$1 = warning;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\n\nvar specialPropKeyWarningShown = void 0;\nvar specialPropRefWarningShown = void 0;\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    if (!specialPropKeyWarningShown) {\n      specialPropKeyWarningShown = true;\n      warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    if (!specialPropRefWarningShown) {\n      specialPropRefWarningShown = true;\n      warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName = void 0;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\n\n\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\n  return newElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nfunction cloneElement(element, config, children) {\n  !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;\n\n  var propName = void 0;\n\n  // Original props are copied\n  var props = _assign({}, element.props);\n\n  // Reserved names are extracted\n  var key = element.key;\n  var ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  var self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  var source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    var defaultProps = void 0;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar didWarnAboutMaps = false;\n\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children,\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child = void 0;\n  var nextName = void 0;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step = void 0;\n      var ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n      var childrenString = '' + children;\n      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n\n\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {\n      return c;\n    });\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild,\n      // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children) {\n  return traverseAllChildren(children, function () {\n    return null;\n  }, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {\n    return child;\n  });\n  return result;\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;\n  return children;\n}\n\nfunction readContext(context, observedBits) {\n  var dispatcher = ReactCurrentOwner.currentDispatcher;\n  !(dispatcher !== null) ? invariant(false, 'Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps.') : void 0;\n  return dispatcher.readContext(context, observedBits);\n}\n\nfunction createContext(defaultValue, calculateChangedBits) {\n  if (calculateChangedBits === undefined) {\n    calculateChangedBits = null;\n  } else {\n    {\n      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;\n    }\n  }\n\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _calculateChangedBits: calculateChangedBits,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // These are circular\n    Provider: null,\n    Consumer: null,\n    unstable_read: null\n  };\n\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  context.Consumer = context;\n  context.unstable_read = readContext.bind(null, context);\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nfunction lazy(ctor) {\n  var thenable = null;\n  return {\n    then: function (resolve, reject) {\n      if (thenable === null) {\n        // Lazily create thenable by wrapping in an extra thenable.\n        thenable = ctor();\n        ctor = null;\n      }\n      return thenable.then(resolve, reject);\n    },\n\n    // React uses these fields to store the result.\n    _reactStatus: -1,\n    _reactResult: null\n  };\n}\n\nfunction forwardRef(render) {\n  {\n    if (typeof render !== 'function') {\n      warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n    } else {\n      !(\n      // Do not warn for 0 arguments because it could be due to usage of the 'arguments' object\n      render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.') : void 0;\n    }\n\n    if (render != null) {\n      !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;\n    }\n  }\n\n  return {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n}\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' ||\n  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_PLACEHOLDER_TYPE || typeof type === 'object' && type !== null && (typeof type.then === 'function' || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n}\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\nvar propTypesMisspellWarningShown = void 0;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current.type);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(elementProps) {\n  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n    var source = elementProps.__source;\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = '\\n\\nCheck the top-level render call using <' + parentName + '>.';\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  var childOwner = '';\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = ' It was passed a child from ' + getComponentName(element._owner.type) + '.';\n  }\n\n  setCurrentlyValidatingElement(element);\n  {\n    warning$1(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);\n  }\n  setCurrentlyValidatingElement(null);\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step = void 0;\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  var type = element.type;\n  var name = void 0,\n      propTypes = void 0;\n  if (typeof type === 'function') {\n    // Class or functional component\n    name = type.displayName || type.name;\n    propTypes = type.propTypes;\n  } else if (typeof type === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {\n    // ForwardRef\n    var functionName = type.render.displayName || type.render.name || '';\n    name = type.displayName || (functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef');\n    propTypes = type.propTypes;\n  } else {\n    return;\n  }\n  if (propTypes) {\n    setCurrentlyValidatingElement(element);\n    checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);\n    setCurrentlyValidatingElement(null);\n  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n  }\n  if (typeof type.getDefaultProps === 'function') {\n    !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  setCurrentlyValidatingElement(fragment);\n\n  var keys = Object.keys(fragment.props);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key !== 'children' && key !== 'key') {\n      warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n      break;\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type);\n\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    var info = '';\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendum(props);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString = void 0;\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = '<' + (getComponentName(type.type) || 'Unknown') + ' />';\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n  }\n\n  var element = createElement.apply(this, arguments);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n  // Legacy hook: remove it\n  {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\n\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nvar React = {\n  Children: {\n    map: mapChildren,\n    forEach: forEachChildren,\n    count: countChildren,\n    toArray: toArray,\n    only: onlyChild\n  },\n\n  createRef: createRef,\n  Component: Component,\n  PureComponent: PureComponent,\n\n  createContext: createContext,\n  forwardRef: forwardRef,\n\n  Fragment: REACT_FRAGMENT_TYPE,\n  StrictMode: REACT_STRICT_MODE_TYPE,\n  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,\n  unstable_Profiler: REACT_PROFILER_TYPE,\n\n  createElement: createElementWithValidation,\n  cloneElement: cloneElementWithValidation,\n  createFactory: createFactoryWithValidation,\n  isValidElement: isValidElement,\n\n  version: ReactVersion,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals\n};\n\nif (enableSuspense) {\n  React.Placeholder = REACT_PLACEHOLDER_TYPE;\n  React.lazy = lazy;\n}\n\n\n\nvar React$2 = Object.freeze({\n\tdefault: React\n});\n\nvar React$3 = ( React$2 && React ) || React$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar react = React$3.default || React$3;\n\nmodule.exports = react;\n  })();\n}\n\n\n//# sourceURL=webpack:///./node_modules/react/cjs/react.development.js?");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/react/index.js?");

/***/ }),

/***/ "./node_modules/schedule/cjs/schedule-tracking.development.js":
/*!********************************************************************!*\
  !*** ./node_modules/schedule/cjs/schedule-tracking.development.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.5.1\n * schedule-tracking.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// Exports ReactDOM.createRoot\n\n\n// Experimental error-boundary API that can recover from errors within a single\n// render phase\n\n// Suspense\n\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\n\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\n\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\n\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\n\n\n// Warn about legacy context API\n\n\n// Gather advanced timing metrics for Profiler subtrees.\n\n\n// Track which interactions trigger each commit.\nvar enableSchedulerTracking = true;\n\n// Only used in www builds.\n\n\n// Only used in www builds.\n\n\n// React Fire: prevent the value and checked attributes from syncing\n// with their related DOM properties\n\nvar DEFAULT_THREAD_ID = 0;\n\n// Counters used to generate unique IDs.\nvar interactionIDCounter = 0;\nvar threadIDCounter = 0;\n\n// Set of currently tracked interactions.\n// Interactions \"stack\"\n// Meaning that newly tracked interactions are appended to the previously active set.\n// When an interaction goes out of scope, the previous set (if any) is restored.\nexports.__interactionsRef = null;\n\n// Listener(s) to notify when interactions begin and end.\nexports.__subscriberRef = null;\n\nif (enableSchedulerTracking) {\n  exports.__interactionsRef = {\n    current: new Set()\n  };\n  exports.__subscriberRef = {\n    current: null\n  };\n}\n\nfunction unstable_clear(callback) {\n  if (!enableSchedulerTracking) {\n    return callback();\n  }\n\n  var prevInteractions = exports.__interactionsRef.current;\n  exports.__interactionsRef.current = new Set();\n\n  try {\n    return callback();\n  } finally {\n    exports.__interactionsRef.current = prevInteractions;\n  }\n}\n\nfunction unstable_getCurrent() {\n  if (!enableSchedulerTracking) {\n    return null;\n  } else {\n    return exports.__interactionsRef.current;\n  }\n}\n\nfunction unstable_getThreadID() {\n  return ++threadIDCounter;\n}\n\nfunction unstable_track(name, timestamp, callback) {\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n\n  if (!enableSchedulerTracking) {\n    return callback();\n  }\n\n  var interaction = {\n    __count: 1,\n    id: interactionIDCounter++,\n    name: name,\n    timestamp: timestamp\n  };\n\n  var prevInteractions = exports.__interactionsRef.current;\n\n  // Tracked interactions should stack/accumulate.\n  // To do that, clone the current interactions.\n  // The previous set will be restored upon completion.\n  var interactions = new Set(prevInteractions);\n  interactions.add(interaction);\n  exports.__interactionsRef.current = interactions;\n\n  var subscriber = exports.__subscriberRef.current;\n  var returnValue = void 0;\n\n  try {\n    if (subscriber !== null) {\n      subscriber.onInteractionTracked(interaction);\n    }\n  } finally {\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkStarted(interactions, threadID);\n      }\n    } finally {\n      try {\n        returnValue = callback();\n      } finally {\n        exports.__interactionsRef.current = prevInteractions;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(interactions, threadID);\n          }\n        } finally {\n          interaction.__count--;\n\n          // If no async work was scheduled for this interaction,\n          // Notify subscribers that it's completed.\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        }\n      }\n    }\n  }\n\n  return returnValue;\n}\n\nfunction unstable_wrap(callback) {\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n\n  if (!enableSchedulerTracking) {\n    return callback;\n  }\n\n  var wrappedInteractions = exports.__interactionsRef.current;\n\n  var subscriber = exports.__subscriberRef.current;\n  if (subscriber !== null) {\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\n  }\n\n  // Update the pending async work count for the current interactions.\n  // Update after calling subscribers in case of error.\n  wrappedInteractions.forEach(function (interaction) {\n    interaction.__count++;\n  });\n\n  var hasRun = false;\n\n  function wrapped() {\n    var prevInteractions = exports.__interactionsRef.current;\n    exports.__interactionsRef.current = wrappedInteractions;\n\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      var returnValue = void 0;\n\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\n        }\n      } finally {\n        try {\n          returnValue = callback.apply(undefined, arguments);\n        } finally {\n          exports.__interactionsRef.current = prevInteractions;\n\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\n          }\n        }\n      }\n\n      return returnValue;\n    } finally {\n      if (!hasRun) {\n        // We only expect a wrapped function to be executed once,\n        // But in the event that it's executed more than once\n        // Only decrement the outstanding interaction counts once.\n        hasRun = true;\n\n        // Update pending async counts for all wrapped interactions.\n        // If this was the last scheduled async work for any of them,\n        // Mark them as completed.\n        wrappedInteractions.forEach(function (interaction) {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        });\n      }\n    }\n  }\n\n  wrapped.cancel = function cancel() {\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\n      }\n    } finally {\n      // Update pending async counts for all wrapped interactions.\n      // If this was the last scheduled async work for any of them,\n      // Mark them as completed.\n      wrappedInteractions.forEach(function (interaction) {\n        interaction.__count--;\n\n        if (subscriber && interaction.__count === 0) {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        }\n      });\n    }\n  };\n\n  return wrapped;\n}\n\nvar subscribers = null;\nif (enableSchedulerTracking) {\n  subscribers = new Set();\n}\n\nfunction unstable_subscribe(subscriber) {\n  if (enableSchedulerTracking) {\n    subscribers.add(subscriber);\n\n    if (subscribers.size === 1) {\n      exports.__subscriberRef.current = {\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n        onInteractionTracked: onInteractionTracked,\n        onWorkCanceled: onWorkCanceled,\n        onWorkScheduled: onWorkScheduled,\n        onWorkStarted: onWorkStarted,\n        onWorkStopped: onWorkStopped\n      };\n    }\n  }\n}\n\nfunction unstable_unsubscribe(subscriber) {\n  if (enableSchedulerTracking) {\n    subscribers.delete(subscriber);\n\n    if (subscribers.size === 0) {\n      exports.__subscriberRef.current = null;\n    }\n  }\n}\n\nfunction onInteractionTracked(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionTracked(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onInteractionScheduledWorkCompleted(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkScheduled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkScheduled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStarted(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStarted(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStopped(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStopped(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkCanceled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkCanceled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nexports.unstable_clear = unstable_clear;\nexports.unstable_getCurrent = unstable_getCurrent;\nexports.unstable_getThreadID = unstable_getThreadID;\nexports.unstable_track = unstable_track;\nexports.unstable_wrap = unstable_wrap;\nexports.unstable_subscribe = unstable_subscribe;\nexports.unstable_unsubscribe = unstable_unsubscribe;\n  })();\n}\n\n\n//# sourceURL=webpack:///./node_modules/schedule/cjs/schedule-tracking.development.js?");

/***/ }),

/***/ "./node_modules/schedule/cjs/schedule.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/schedule/cjs/schedule.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.5.1\n * schedule.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * A scheduling library to allow scheduling work with more granular priority and\n * control than requestAnimationFrame and requestIdleCallback.\n * Current TODO items:\n * X- Pull out the scheduleWork polyfill built into React\n * X- Initial test coverage\n * X- Support for multiple callbacks\n * - Support for two priorities; serial and deferred\n * - Better test coverage\n * - Better docblock\n * - Polish documentation, API\n */\n\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated.\n// We want to be using a consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\n// However, we always expect them to be defined on the client.\n// https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined,\n// but we will error later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nexports.unstable_now = void 0;\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nexports.unstable_scheduleWork = void 0;\nexports.unstable_cancelScheduledWork = void 0;\n\nif (!canUseDOM) {\n  var timeoutIds = new Map();\n\n  exports.unstable_scheduleWork = function (callback, options) {\n    // keeping return type consistent\n    var callbackConfig = {\n      scheduledCallback: callback,\n      timeoutTime: 0,\n      next: null,\n      prev: null\n    };\n    var timeoutId = localSetTimeout(function () {\n      callback({\n        timeRemaining: function () {\n          return Infinity;\n        },\n\n        didTimeout: false\n      });\n    });\n    timeoutIds.set(callback, timeoutId);\n    return callbackConfig;\n  };\n  exports.unstable_cancelScheduledWork = function (callbackId) {\n    var callback = callbackId.scheduledCallback;\n    var timeoutId = timeoutIds.get(callback);\n    timeoutIds.delete(callbackId);\n    localClearTimeout(timeoutId);\n  };\n} else {\n  {\n    if (typeof console !== 'undefined') {\n      if (typeof localRequestAnimationFrame !== 'function') {\n        console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n      }\n      if (typeof localCancelAnimationFrame !== 'function') {\n        console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n      }\n    }\n  }\n\n  var headOfPendingCallbacksLinkedList = null;\n  var tailOfPendingCallbacksLinkedList = null;\n\n  // We track what the next soonest timeoutTime is, to be able to quickly tell\n  // if none of the scheduled callbacks have timed out.\n  var nextSoonestTimeoutTime = -1;\n\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n\n  // requestAnimationFrame does not run when the tab is in the background.\n  // if we're backgrounded we prefer for that work to happen so that the page\n  // continues\tto load in the background.\n  // so we also schedule a 'setTimeout' as a fallback.\n  var animationFrameTimeout = 100;\n  var rafID = void 0;\n  var timeoutID = void 0;\n  var scheduleAnimationFrameWithFallbackSupport = function (callback) {\n    // schedule rAF and also a setTimeout\n    rafID = localRequestAnimationFrame(function (timestamp) {\n      // cancel the setTimeout\n      localClearTimeout(timeoutID);\n      callback(timestamp);\n    });\n    timeoutID = localSetTimeout(function () {\n      // cancel the requestAnimationFrame\n      localCancelAnimationFrame(rafID);\n      callback(exports.unstable_now());\n    }, animationFrameTimeout);\n  };\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject = {\n    didTimeout: false,\n    timeRemaining: function () {\n      var remaining = frameDeadline - exports.unstable_now();\n      return remaining > 0 ? remaining : 0;\n    }\n  };\n\n  /**\n   * Handles the case where a callback errors:\n   * - don't catch the error, because this changes debugging behavior\n   * - do start a new postMessage callback, to call any remaining callbacks,\n   * - but only if there is an error, so there is not extra overhead.\n   */\n  var callUnsafely = function (callbackConfig, arg) {\n    var callback = callbackConfig.scheduledCallback;\n    var finishedCalling = false;\n    try {\n      callback(arg);\n      finishedCalling = true;\n    } finally {\n      // always remove it from linked list\n      exports.unstable_cancelScheduledWork(callbackConfig);\n\n      if (!finishedCalling) {\n        // an error must have been thrown\n        isIdleScheduled = true;\n        window.postMessage(messageKey, '*');\n      }\n    }\n  };\n\n  /**\n   * Checks for timed out callbacks, runs them, and then checks again to see if\n   * any more have timed out.\n   * Keeps doing this until there are none which have currently timed out.\n   */\n  var callTimedOutCallbacks = function () {\n    if (headOfPendingCallbacksLinkedList === null) {\n      return;\n    }\n\n    var currentTime = exports.unstable_now();\n    // TODO: this would be more efficient if deferred callbacks are stored in\n    // min heap.\n    // Or in a linked list with links for both timeoutTime order and insertion\n    // order.\n    // For now an easy compromise is the current approach:\n    // Keep a pointer to the soonest timeoutTime, and check that first.\n    // If it has not expired, we can skip traversing the whole list.\n    // If it has expired, then we step through all the callbacks.\n    if (nextSoonestTimeoutTime === -1 || nextSoonestTimeoutTime > currentTime) {\n      // We know that none of them have timed out yet.\n      return;\n    }\n    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n    // after successfully calling any timed out callbacks.\n    // If a timed out callback throws an error, we could get stuck in a state\n    // where the nextSoonestTimeoutTime was set wrong.\n    var updatedNextSoonestTimeoutTime = -1; // we will update nextSoonestTimeoutTime below\n    var timedOutCallbacks = [];\n\n    // iterate once to find timed out callbacks and find nextSoonestTimeoutTime\n    var currentCallbackConfig = headOfPendingCallbacksLinkedList;\n    while (currentCallbackConfig !== null) {\n      var _timeoutTime = currentCallbackConfig.timeoutTime;\n      if (_timeoutTime !== -1 && _timeoutTime <= currentTime) {\n        // it has timed out!\n        timedOutCallbacks.push(currentCallbackConfig);\n      } else {\n        if (_timeoutTime !== -1 && (updatedNextSoonestTimeoutTime === -1 || _timeoutTime < updatedNextSoonestTimeoutTime)) {\n          updatedNextSoonestTimeoutTime = _timeoutTime;\n        }\n      }\n      currentCallbackConfig = currentCallbackConfig.next;\n    }\n\n    if (timedOutCallbacks.length > 0) {\n      frameDeadlineObject.didTimeout = true;\n      for (var i = 0, len = timedOutCallbacks.length; i < len; i++) {\n        callUnsafely(timedOutCallbacks[i], frameDeadlineObject);\n      }\n    }\n\n    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n    // after successfully calling any timed out callbacks.\n    nextSoonestTimeoutTime = updatedNextSoonestTimeoutTime;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n    isIdleScheduled = false;\n\n    if (headOfPendingCallbacksLinkedList === null) {\n      return;\n    }\n\n    // First call anything which has timed out, until we have caught up.\n    callTimedOutCallbacks();\n\n    var currentTime = exports.unstable_now();\n    // Next, as long as we have idle time, try calling more callbacks.\n    while (frameDeadline - currentTime > 0 && headOfPendingCallbacksLinkedList !== null) {\n      var latestCallbackConfig = headOfPendingCallbacksLinkedList;\n      frameDeadlineObject.didTimeout = false;\n      // callUnsafely will remove it from the head of the linked list\n      callUnsafely(latestCallbackConfig, frameDeadlineObject);\n      currentTime = exports.unstable_now();\n    }\n    if (headOfPendingCallbacksLinkedList !== null) {\n      if (!isAnimationFrameScheduled) {\n        // Schedule another animation callback so we retry later.\n        isAnimationFrameScheduled = true;\n        scheduleAnimationFrameWithFallbackSupport(animationTick);\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  exports.unstable_scheduleWork = function (callback, options) /* CallbackConfigType */{\n    var timeoutTime = -1;\n    if (options != null && typeof options.timeout === 'number') {\n      timeoutTime = exports.unstable_now() + options.timeout;\n    }\n    if (nextSoonestTimeoutTime === -1 || timeoutTime !== -1 && timeoutTime < nextSoonestTimeoutTime) {\n      nextSoonestTimeoutTime = timeoutTime;\n    }\n\n    var scheduledCallbackConfig = {\n      scheduledCallback: callback,\n      timeoutTime: timeoutTime,\n      prev: null,\n      next: null\n    };\n    if (headOfPendingCallbacksLinkedList === null) {\n      // Make this callback the head and tail of our list\n      headOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n    } else {\n      // Add latest callback as the new tail of the list\n      scheduledCallbackConfig.prev = tailOfPendingCallbacksLinkedList;\n      // renaming for clarity\n      var oldTailOfPendingCallbacksLinkedList = tailOfPendingCallbacksLinkedList;\n      if (oldTailOfPendingCallbacksLinkedList !== null) {\n        oldTailOfPendingCallbacksLinkedList.next = scheduledCallbackConfig;\n      }\n      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n    }\n\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger scheduleWork as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      scheduleAnimationFrameWithFallbackSupport(animationTick);\n    }\n    return scheduledCallbackConfig;\n  };\n\n  exports.unstable_cancelScheduledWork = function (callbackConfig /* CallbackConfigType */\n  ) {\n    if (callbackConfig.prev === null && headOfPendingCallbacksLinkedList !== callbackConfig) {\n      // this callbackConfig has already been cancelled.\n      // cancelScheduledWork should be idempotent, a no-op after first call.\n      return;\n    }\n\n    /**\n     * There are four possible cases:\n     * - Head/nodeToRemove/Tail -> null\n     *   In this case we set Head and Tail to null.\n     * - Head -> ... middle nodes... -> Tail/nodeToRemove\n     *   In this case we point the middle.next to null and put middle as the new\n     *   Tail.\n     * - Head/nodeToRemove -> ...middle nodes... -> Tail\n     *   In this case we point the middle.prev at null and move the Head to\n     *   middle.\n     * - Head -> ... ?some nodes ... -> nodeToRemove -> ... ?some nodes ... -> Tail\n     *   In this case we point the Head.next to the Tail and the Tail.prev to\n     *   the Head.\n     */\n    var next = callbackConfig.next;\n    var prev = callbackConfig.prev;\n    callbackConfig.next = null;\n    callbackConfig.prev = null;\n    if (next !== null) {\n      // we have a next\n\n      if (prev !== null) {\n        // we have a prev\n\n        // callbackConfig is somewhere in the middle of a list of 3 or more nodes.\n        prev.next = next;\n        next.prev = prev;\n        return;\n      } else {\n        // there is a next but not a previous one;\n        // callbackConfig is the head of a list of 2 or more other nodes.\n        next.prev = null;\n        headOfPendingCallbacksLinkedList = next;\n        return;\n      }\n    } else {\n      // there is no next callback config; this must the tail of the list\n\n      if (prev !== null) {\n        // we have a prev\n\n        // callbackConfig is the tail of a list of 2 or more other nodes.\n        prev.next = null;\n        tailOfPendingCallbacksLinkedList = prev;\n        return;\n      } else {\n        // there is no previous callback config;\n        // callbackConfig is the only thing in the linked list,\n        // so both head and tail point to it.\n        headOfPendingCallbacksLinkedList = null;\n        tailOfPendingCallbacksLinkedList = null;\n        return;\n      }\n    }\n  };\n}\n  })();\n}\n\n\n//# sourceURL=webpack:///./node_modules/schedule/cjs/schedule.development.js?");

/***/ }),

/***/ "./node_modules/schedule/index.js":
/*!****************************************!*\
  !*** ./node_modules/schedule/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/schedule.development.js */ \"./node_modules/schedule/cjs/schedule.development.js\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/schedule/index.js?");

/***/ }),

/***/ "./node_modules/schedule/tracking.js":
/*!*******************************************!*\
  !*** ./node_modules/schedule/tracking.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/schedule-tracking.development.js */ \"./node_modules/schedule/cjs/schedule-tracking.development.js\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/schedule/tracking.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./wp-meteor-client/entry.js":
/*!***********************************!*\
  !*** ./wp-meteor-client/entry.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function requireAll(r) {\n  r.keys().forEach(r);\n}\n\nrequireAll(__webpack_require__(\"./meteor-app/client sync recursive \\\\.css$\"));\n\n__webpack_require__(/*! ../meteor-app/imports/client/start */ \"./meteor-app/imports/client/start.jsx\");\n\nif (false) {}\n\n//# sourceURL=webpack:///./wp-meteor-client/entry.js?");

/***/ })

/******/ });